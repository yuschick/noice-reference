// THIS FILE IS GENERATED BY graphql-codegen, DO NOT EDIT!
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Duration: { input: string; output: string; }
  InputTimestamp: { input: string; output: string; }
  Timestamp: { input: string; output: string; }
};

export type ApiAddressInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  zip?: InputMaybe<Scalars['String']['input']>;
};

export type ApiCursorInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ApiDateInput = {
  day?: InputMaybe<Scalars['Int']['input']>;
  month?: InputMaybe<Scalars['Int']['input']>;
  year?: InputMaybe<Scalars['Int']['input']>;
};

export type ApiPageInfo = {
  __typename?: 'APIPageInfo';
  endCursor: Scalars['String']['output'];
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  startCursor: Scalars['String']['output'];
};

export type AdsGetPlacementResponse = {
  __typename?: 'AdsGetPlacementResponse';
  placementId: Scalars['ID']['output'];
  referenceId: Scalars['ID']['output'];
  /** TODO: Kept while migrating and set to the first item in rewards */
  reward: AdsRewardDescription;
  rewards: Array<AdsRewardDescription>;
  state: AdsPlacementState;
  updatesAt: Scalars['Timestamp']['output'];
};

export enum AdsPlacementState {
  PlacementStateNotReady = 'PLACEMENT_STATE_NOT_READY',
  PlacementStateReady = 'PLACEMENT_STATE_READY',
  PlacementStateUnspecified = 'PLACEMENT_STATE_UNSPECIFIED'
}

export type AdsPlacementStateEvent = {
  __typename?: 'AdsPlacementStateEvent';
  placementId: Scalars['ID']['output'];
  referenceId: Scalars['ID']['output'];
  state: AdsPlacementState;
  userId: Scalars['ID']['output'];
};

export type AdsRewardDescription = {
  __typename?: 'AdsRewardDescription';
  prizes: Array<AdsRewardDescriptionPrizeDescription>;
  rarity: RarityRarity;
  readyAt: Scalars['Timestamp']['output'];
};

export type AdsRewardDescriptionPrizeDescription = {
  __typename?: 'AdsRewardDescriptionPrizeDescription';
  amount: Scalars['Int']['output'];
  kind: AdsRewardDescriptionPrizeDescriptionKind;
  max: Scalars['Int']['output'];
  min: Scalars['Int']['output'];
  value: Scalars['String']['output'];
};

export enum AdsRewardDescriptionPrizeDescriptionKind {
  KindCurrency = 'KIND_CURRENCY',
  KindExperiencePoints = 'KIND_EXPERIENCE_POINTS',
  KindUnspecified = 'KIND_UNSPECIFIED'
}

export type AdyenAmount = {
  __typename?: 'AdyenAmount';
  currency: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type AdyenSession = {
  __typename?: 'AdyenSession';
  amount: AdyenAmount;
  id: Scalars['ID']['output'];
  reference: Scalars['String']['output'];
  returnUrl: Scalars['String']['output'];
  sessionData: Scalars['String']['output'];
};

export type AgreementAgreementRevision = {
  __typename?: 'AgreementAgreementRevision';
  name: Scalars['String']['output'];
  revision: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type AgreementListAgreementResponse = {
  __typename?: 'AgreementListAgreementResponse';
  agreements: Array<AgreementAgreementRevision>;
};

export type AnnouncementAnnouncement = {
  __typename?: 'AnnouncementAnnouncement';
  category: AnnouncementAnnouncementCategory;
  createdAt: Scalars['Timestamp']['output'];
  creator: ProfileProfile;
  creatorId: Scalars['ID']['output'];
  endTime?: Maybe<Scalars['Timestamp']['output']>;
  id: Scalars['ID']['output'];
  image: Scalars['String']['output'];
  imageUrl: Scalars['String']['output'];
  published: Scalars['Boolean']['output'];
  startTime?: Maybe<Scalars['Timestamp']['output']>;
  status: AnnouncementAnnouncementStatus;
  targets: AnnouncementTargets;
  text: Scalars['String']['output'];
  title: Scalars['String']['output'];
};

export enum AnnouncementAnnouncementCategory {
  AnnouncementCategoryGameApexLegends = 'ANNOUNCEMENT_CATEGORY_GAME_APEX_LEGENDS',
  AnnouncementCategoryGameDbd = 'ANNOUNCEMENT_CATEGORY_GAME_DBD',
  AnnouncementCategoryGameDota2 = 'ANNOUNCEMENT_CATEGORY_GAME_DOTA2',
  AnnouncementCategoryGameFortnite = 'ANNOUNCEMENT_CATEGORY_GAME_FORTNITE',
  AnnouncementCategoryGameLeagueOfLegends = 'ANNOUNCEMENT_CATEGORY_GAME_LEAGUE_OF_LEGENDS',
  AnnouncementCategoryPlatform = 'ANNOUNCEMENT_CATEGORY_PLATFORM',
  AnnouncementCategorySystem = 'ANNOUNCEMENT_CATEGORY_SYSTEM',
  AnnouncementCategoryUnspecified = 'ANNOUNCEMENT_CATEGORY_UNSPECIFIED'
}

export type AnnouncementAnnouncementFilterInput = {
  statuses?: InputMaybe<Array<AnnouncementAnnouncementStatus>>;
  targets?: InputMaybe<Array<AnnouncementAnnouncementTarget>>;
};

export type AnnouncementAnnouncementInput = {
  category?: InputMaybe<AnnouncementAnnouncementCategory>;
  createdAt?: InputMaybe<Scalars['InputTimestamp']['input']>;
  creatorId?: InputMaybe<Scalars['ID']['input']>;
  endTime?: InputMaybe<Scalars['InputTimestamp']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  startTime?: InputMaybe<Scalars['InputTimestamp']['input']>;
  status?: InputMaybe<AnnouncementAnnouncementStatus>;
  targets?: InputMaybe<AnnouncementTargetsInput>;
  text?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export enum AnnouncementAnnouncementStatus {
  AnnouncementStatusActive = 'ANNOUNCEMENT_STATUS_ACTIVE',
  AnnouncementStatusDraft = 'ANNOUNCEMENT_STATUS_DRAFT',
  AnnouncementStatusPast = 'ANNOUNCEMENT_STATUS_PAST',
  AnnouncementStatusScheduled = 'ANNOUNCEMENT_STATUS_SCHEDULED',
  AnnouncementStatusUnspecified = 'ANNOUNCEMENT_STATUS_UNSPECIFIED'
}

export enum AnnouncementAnnouncementTarget {
  AnnouncementTargetMobile = 'ANNOUNCEMENT_TARGET_MOBILE',
  AnnouncementTargetStudio = 'ANNOUNCEMENT_TARGET_STUDIO',
  AnnouncementTargetUnspecified = 'ANNOUNCEMENT_TARGET_UNSPECIFIED',
  AnnouncementTargetWeb = 'ANNOUNCEMENT_TARGET_WEB'
}

export type AnnouncementCreateAnnouncementImageUploadTokenResponse = {
  __typename?: 'AnnouncementCreateAnnouncementImageUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type AnnouncementListAnnouncementsResponse = {
  __typename?: 'AnnouncementListAnnouncementsResponse';
  announcements: Array<AnnouncementAnnouncement>;
  pageInfo: ApiPageInfo;
  totalCount: Scalars['Int']['output'];
};

export type AnnouncementListUserAnnouncementsResponse = {
  __typename?: 'AnnouncementListUserAnnouncementsResponse';
  announcements: Array<AnnouncementAnnouncement>;
  pageInfo: ApiPageInfo;
};

export type AnnouncementTargets = {
  __typename?: 'AnnouncementTargets';
  mobile: Scalars['Boolean']['output'];
  studio: Scalars['Boolean']['output'];
  web: Scalars['Boolean']['output'];
};

export type AnnouncementTargetsInput = {
  mobile?: InputMaybe<Scalars['Boolean']['input']>;
  studio?: InputMaybe<Scalars['Boolean']['input']>;
  web?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ApiEntityState {
  EntityStateBlocked = 'ENTITY_STATE_BLOCKED',
  EntityStateDeleted = 'ENTITY_STATE_DELETED',
  EntityStateUnspecified = 'ENTITY_STATE_UNSPECIFIED'
}

export type ArenaArena = {
  __typename?: 'ArenaArena';
  config?: Maybe<ArenaArenaConfigUnion>;
  enabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  thumbnailUrl: Scalars['String']['output'];
};

export type ArenaArenaConfigUnion = ArenaServerSideArenaConfig;

export type ArenaClientSideArena = {
  __typename?: 'ArenaClientSideArena';
  enabled: Scalars['Boolean']['output'];
  environmentUrl: Scalars['String']['output'];
  glbUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lightmapUrl: Scalars['String']['output'];
  name: Scalars['String']['output'];
  thumbnailUrl: Scalars['String']['output'];
  version: Scalars['String']['output'];
};

export type ArenaListArenasResponse = {
  __typename?: 'ArenaListArenasResponse';
  arenas: Array<ArenaArena>;
  pageInfo: ApiPageInfo;
};

export type ArenaListClientSideArenasResponse = {
  __typename?: 'ArenaListClientSideArenasResponse';
  arenas: Array<ArenaClientSideArena>;
};

export type ArenaServerSideArenaConfig = {
  __typename?: 'ArenaServerSideArenaConfig';
  arenaConfigUrl: Scalars['String']['output'];
  contentCatalogUrl: Scalars['String']['output'];
  gameViewScreenshotUrl: Scalars['String']['output'];
};

export type AttributeAttribute = {
  __typename?: 'AttributeAttribute';
  value?: Maybe<AttributeAttributeValueUnion>;
};

export type AttributeAttributeBoolArray = {
  __typename?: 'AttributeAttributeBoolArray';
  value: Array<Scalars['Boolean']['output']>;
};

export type AttributeAttributeBoolArrayInput = {
  value?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

export type AttributeAttributeFloatArray = {
  __typename?: 'AttributeAttributeFloatArray';
  value: Array<Scalars['Float']['output']>;
};

export type AttributeAttributeFloatArrayInput = {
  value?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type AttributeAttributeInput = {
  boolArrayValue?: InputMaybe<AttributeAttributeBoolArrayInput>;
  boolValue?: InputMaybe<Scalars['Boolean']['input']>;
  floatArrayValue?: InputMaybe<AttributeAttributeFloatArrayInput>;
  floatValue?: InputMaybe<Scalars['Float']['input']>;
  intArrayValue?: InputMaybe<AttributeAttributeIntArrayInput>;
  intValue?: InputMaybe<Scalars['Int']['input']>;
  mapValue?: InputMaybe<AttributeAttributeMapInput>;
  stringArrayValue?: InputMaybe<AttributeAttributeStringArrayInput>;
  stringValue?: InputMaybe<Scalars['String']['input']>;
};

export type AttributeAttributeIntArray = {
  __typename?: 'AttributeAttributeIntArray';
  value: Array<Scalars['Int']['output']>;
};

export type AttributeAttributeIntArrayInput = {
  value?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type AttributeAttributeMap = {
  __typename?: 'AttributeAttributeMap';
  value: Array<AttributeAttributeMapValueEntry>;
};

export type AttributeAttributeMapInput = {
  value?: InputMaybe<Array<AttributeAttributeMapValueEntryInput>>;
};

export type AttributeAttributeMapValueEntry = {
  __typename?: 'AttributeAttributeMapValueEntry';
  key: Scalars['String']['output'];
  value: AttributeAttribute;
};

export type AttributeAttributeMapValueEntryInput = {
  key?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type AttributeAttributeStringArray = {
  __typename?: 'AttributeAttributeStringArray';
  value: Array<Scalars['String']['output']>;
};

export type AttributeAttributeStringArrayInput = {
  value?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type AttributeAttributeValueUnion = AttributeAttributeBoolArray | AttributeAttributeFloatArray | AttributeAttributeIntArray | AttributeAttributeMap | AttributeAttributeStringArray | BooleanType | FloatType | IntType | StringType;

export type AuthAccount = {
  __typename?: 'AuthAccount';
  acceptedTerms: Array<AuthTermsVersion>;
  birthday?: Maybe<AuthDate>;
  channelCreationEligibility: ChannelChannelCreationEligibility;
  createdAt: Scalars['Timestamp']['output'];
  email: Scalars['String']['output'];
  emailVerifiedAt?: Maybe<Scalars['Timestamp']['output']>;
  externalIds: Array<AuthIdentity>;
  flags: Array<AuthAccountStatusFlag>;
  isBot: Scalars['Boolean']['output'];
  labels: Array<Scalars['String']['output']>;
  marketingConsent: AuthConsentStatus;
  matureRatedContentAllowed: Scalars['Boolean']['output'];
  pendingAgreements: Array<AgreementAgreementRevision>;
  roles: Array<AuthPlatformRole>;
  signupLocation: Scalars['String']['output'];
  signupOrigin?: Maybe<AuthSignupOrigin>;
  staff: Scalars['Boolean']['output'];
  state: ApiEntityState;
  temporary: Scalars['Boolean']['output'];
  uid: Scalars['String']['output'];
};

export enum AuthAccountStatusFlag {
  StatusFlagBanned = 'STATUS_FLAG_BANNED',
  StatusFlagDeletionScheduled = 'STATUS_FLAG_DELETION_SCHEDULED',
  StatusFlagUnspecified = 'STATUS_FLAG_UNSPECIFIED',
  StatusFlagWaitlist = 'STATUS_FLAG_WAITLIST'
}

export type AuthAccountUpdateInput = {
  roles?: InputMaybe<Array<AuthPlatformRole>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export enum AuthConsentStatus {
  ConsentStatusAccepted = 'CONSENT_STATUS_ACCEPTED',
  ConsentStatusDeclined = 'CONSENT_STATUS_DECLINED',
  ConsentStatusUnspecified = 'CONSENT_STATUS_UNSPECIFIED'
}

export type AuthDate = {
  __typename?: 'AuthDate';
  day: Scalars['Int']['output'];
  month: Scalars['Int']['output'];
  year: Scalars['Int']['output'];
};

export type AuthDateInput = {
  day?: InputMaybe<Scalars['Int']['input']>;
  month?: InputMaybe<Scalars['Int']['input']>;
  year?: InputMaybe<Scalars['Int']['input']>;
};

export type AuthIdentity = {
  __typename?: 'AuthIdentity';
  id: Scalars['ID']['output'];
  type: AuthIdentityType;
};

export enum AuthIdentityType {
  IdentityTypeApple = 'IDENTITY_TYPE_APPLE',
  IdentityTypeDiscord = 'IDENTITY_TYPE_DISCORD',
  IdentityTypeEmail = 'IDENTITY_TYPE_EMAIL',
  IdentityTypeUnspecified = 'IDENTITY_TYPE_UNSPECIFIED'
}

export enum AuthPlatformRole {
  PlatformRoleAdmin = 'PLATFORM_ROLE_ADMIN',
  PlatformRoleBot = 'PLATFORM_ROLE_BOT',
  PlatformRoleFullUser = 'PLATFORM_ROLE_FULL_USER',
  PlatformRoleGuest = 'PLATFORM_ROLE_GUEST',
  PlatformRoleModerator = 'PLATFORM_ROLE_MODERATOR',
  PlatformRolePxAgent = 'PLATFORM_ROLE_PX_AGENT',
  PlatformRoleRoot = 'PLATFORM_ROLE_ROOT',
  PlatformRoleStreamerTooling = 'PLATFORM_ROLE_STREAMER_TOOLING',
  PlatformRoleUnspecified = 'PLATFORM_ROLE_UNSPECIFIED',
  PlatformRoleUser = 'PLATFORM_ROLE_USER'
}

export type AuthSignupOrigin = {
  __typename?: 'AuthSignupOrigin';
  origin?: Maybe<AuthSignupOriginOriginUnion>;
};

export type AuthSignupOriginCampaign = {
  __typename?: 'AuthSignupOriginCampaign';
  campaign: Scalars['String']['output'];
  content: Scalars['String']['output'];
  creator: Scalars['String']['output'];
  format: Scalars['String']['output'];
  medium: Scalars['String']['output'];
  source: Scalars['String']['output'];
  term: Scalars['String']['output'];
};

export type AuthSignupOriginChannel = {
  __typename?: 'AuthSignupOriginChannel';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
};

export type AuthSignupOriginOriginUnion = AuthSignupOriginCampaign | AuthSignupOriginChannel | AuthSignupOriginPage;

export type AuthSignupOriginPage = {
  __typename?: 'AuthSignupOriginPage';
  url: Scalars['String']['output'];
};

export type AuthTermsVersion = {
  __typename?: 'AuthTermsVersion';
  name: Scalars['String']['output'];
  revision: Scalars['String']['output'];
  signature: Scalars['String']['output'];
};

export type AuthTermsVersionInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
  signature?: InputMaybe<Scalars['String']['input']>;
};

export type AuthV4GetOAuth2ConsentResponse = {
  __typename?: 'AuthV4GetOAuth2ConsentResponse';
  clientId: Scalars['ID']['output'];
  clientName: Scalars['String']['output'];
  scopes: Array<Scalars['String']['output']>;
};

export type AvatarAnimation = {
  __typename?: 'AvatarAnimation';
  category: Array<AvatarAnimationCategory>;
  chatCommand: Scalars['String']['output'];
  config: AvatarAnimationConfig;
  enabled: Scalars['Boolean']['output'];
  glbUrl: Scalars['String']['output'];
  iconUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  mirroredGlbUrl: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export enum AvatarAnimationCategory {
  CategoryAngry = 'CATEGORY_ANGRY',
  CategoryBoosterReceived = 'CATEGORY_BOOSTER_RECEIVED',
  CategoryBoosterRequested = 'CATEGORY_BOOSTER_REQUESTED',
  CategoryBoosterSent = 'CATEGORY_BOOSTER_SENT',
  CategoryCameraDrive = 'CATEGORY_CAMERA_DRIVE',
  CategoryCameraDriveExcited = 'CATEGORY_CAMERA_DRIVE_EXCITED',
  CategoryCardFailure = 'CATEGORY_CARD_FAILURE',
  CategoryCardMaxedOut = 'CATEGORY_CARD_MAXED_OUT',
  CategoryCardSuccess = 'CATEGORY_CARD_SUCCESS',
  CategoryChatMessage = 'CATEGORY_CHAT_MESSAGE',
  CategoryCheer = 'CATEGORY_CHEER',
  CategoryDance = 'CATEGORY_DANCE',
  CategoryDefeat = 'CATEGORY_DEFEAT',
  CategoryEditorIdle = 'CATEGORY_EDITOR_IDLE',
  CategoryEditorPickBody = 'CATEGORY_EDITOR_PICK_BODY',
  CategoryEditorPickFace = 'CATEGORY_EDITOR_PICK_FACE',
  CategoryEditorPickGloves = 'CATEGORY_EDITOR_PICK_GLOVES',
  CategoryEditorPickHat = 'CATEGORY_EDITOR_PICK_HAT',
  CategoryEditorPickJacket = 'CATEGORY_EDITOR_PICK_JACKET',
  CategoryEditorPickPants = 'CATEGORY_EDITOR_PICK_PANTS',
  CategoryEditorPickShoes = 'CATEGORY_EDITOR_PICK_SHOES',
  CategoryEmoji = 'CATEGORY_EMOJI',
  CategoryEmote = 'CATEGORY_EMOTE',
  CategoryExcited = 'CATEGORY_EXCITED',
  CategoryFsInChat = 'CATEGORY_FS_IN_CHAT',
  CategoryIdle = 'CATEGORY_IDLE',
  CategoryMessage = 'CATEGORY_MESSAGE',
  CategoryPhotoPoses = 'CATEGORY_PHOTO_POSES',
  CategoryPlayerExit = 'CATEGORY_PLAYER_EXIT',
  CategoryPlayerJoin = 'CATEGORY_PLAYER_JOIN',
  CategoryPlayerPickCard = 'CATEGORY_PLAYER_PICK_CARD',
  CategoryPlayerSwapCard = 'CATEGORY_PLAYER_SWAP_CARD',
  CategoryPoseConfused = 'CATEGORY_POSE_CONFUSED',
  CategoryPoseCool = 'CATEGORY_POSE_COOL',
  CategoryPoseCrying = 'CATEGORY_POSE_CRYING',
  CategoryPoseDefault = 'CATEGORY_POSE_DEFAULT',
  CategoryPoseJustJoking = 'CATEGORY_POSE_JUST_JOKING',
  CategoryPoseLol = 'CATEGORY_POSE_LOL',
  CategoryPoseLove = 'CATEGORY_POSE_LOVE',
  CategoryPoseNoice = 'CATEGORY_POSE_NOICE',
  CategoryPoseOhno = 'CATEGORY_POSE_OHNO',
  CategoryPoseParty = 'CATEGORY_POSE_PARTY',
  CategoryPoseRage = 'CATEGORY_POSE_RAGE',
  CategoryPoseSad = 'CATEGORY_POSE_SAD',
  CategoryPoseShocked = 'CATEGORY_POSE_SHOCKED',
  CategoryPoseSick = 'CATEGORY_POSE_SICK',
  CategoryPoseSmile = 'CATEGORY_POSE_SMILE',
  CategoryPoseSurprised = 'CATEGORY_POSE_SURPRISED',
  CategoryPoseSweat = 'CATEGORY_POSE_SWEAT',
  CategoryPoseWhoa = 'CATEGORY_POSE_WHOA',
  CategorySad = 'CATEGORY_SAD',
  CategorySpotlightCrowd = 'CATEGORY_SPOTLIGHT_CROWD',
  CategorySpotlightPodium = 'CATEGORY_SPOTLIGHT_PODIUM',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED',
  CategoryVictory = 'CATEGORY_VICTORY',
  CategoryWsInChat = 'CATEGORY_WS_IN_CHAT'
}

export type AvatarAnimationConfig = {
  __typename?: 'AvatarAnimationConfig';
  clamp: Scalars['Boolean']['output'];
  fadeInTimeSec: Scalars['Float']['output'];
  handedness: AvatarAnimationHandedness;
  interruptible: Scalars['Boolean']['output'];
  maxLoops: Scalars['Int']['output'];
  randomizeLoops: Scalars['Boolean']['output'];
};

export enum AvatarAnimationHandedness {
  HandednessBoth = 'HANDEDNESS_BOTH',
  HandednessLeft = 'HANDEDNESS_LEFT',
  HandednessRight = 'HANDEDNESS_RIGHT',
  HandednessUnspecified = 'HANDEDNESS_UNSPECIFIED'
}

export type AvatarAvatar = {
  __typename?: 'AvatarAvatar';
  assets: AvatarAvatarAssets;
  avatar3D: Scalars['String']['output'];
  avatarComposition: AvatarAvatarComposition;
  avatarLods: Array<Scalars['String']['output']>;
  body: Scalars['String']['output'];
  face: Scalars['String']['output'];
  /** todo: remove or use Gender instead */
  gender: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** selectable is used to determine if the avatar is shown in the avatar picker */
  selectable: Scalars['Boolean']['output'];
};

export type AvatarAvatarAssets = {
  __typename?: 'AvatarAvatarAssets';
  images: Array<AvatarAvatarAssetsImage>;
  lods: Array<AvatarAvatarAssetsLod>;
};

export type AvatarAvatarAssetsImage = {
  __typename?: 'AvatarAvatarAssetsImage';
  category: AvatarAvatarAssetsImageCategory;
  url: Scalars['String']['output'];
};

export enum AvatarAvatarAssetsImageCategory {
  CategoryPoseConfused = 'CATEGORY_POSE_CONFUSED',
  CategoryPoseCool = 'CATEGORY_POSE_COOL',
  CategoryPoseCrying = 'CATEGORY_POSE_CRYING',
  CategoryPoseJustJoking = 'CATEGORY_POSE_JUST_JOKING',
  CategoryPoseLol = 'CATEGORY_POSE_LOL',
  CategoryPoseLove = 'CATEGORY_POSE_LOVE',
  CategoryPoseNoice = 'CATEGORY_POSE_NOICE',
  CategoryPoseOhno = 'CATEGORY_POSE_OHNO',
  CategoryPoseParty = 'CATEGORY_POSE_PARTY',
  CategoryPoseRage = 'CATEGORY_POSE_RAGE',
  CategoryPoseSad = 'CATEGORY_POSE_SAD',
  CategoryPoseShocked = 'CATEGORY_POSE_SHOCKED',
  CategoryPoseSick = 'CATEGORY_POSE_SICK',
  CategoryPoseSmile = 'CATEGORY_POSE_SMILE',
  CategoryPoseSurprised = 'CATEGORY_POSE_SURPRISED',
  CategoryPoseSweat = 'CATEGORY_POSE_SWEAT',
  CategoryPoseWhoa = 'CATEGORY_POSE_WHOA',
  CategoryProfileBody = 'CATEGORY_PROFILE_BODY',
  CategoryProfileFace = 'CATEGORY_PROFILE_FACE',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED'
}

export type AvatarAvatarAssetsImageInput = {
  category?: InputMaybe<AvatarAvatarAssetsImageCategory>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type AvatarAvatarAssetsInput = {
  images?: InputMaybe<Array<AvatarAvatarAssetsImageInput>>;
  lods?: InputMaybe<Array<AvatarAvatarAssetsLodInput>>;
};

export type AvatarAvatarAssetsLod = {
  __typename?: 'AvatarAvatarAssetsLod';
  glbUrl: Scalars['String']['output'];
  skeletonType: AvatarAvatarAssetsLodSkeletonType;
};

export type AvatarAvatarAssetsLodInput = {
  glbUrl?: InputMaybe<Scalars['String']['input']>;
  skeletonType?: InputMaybe<AvatarAvatarAssetsLodSkeletonType>;
};

export enum AvatarAvatarAssetsLodSkeletonType {
  SkeletonTypeComplex = 'SKELETON_TYPE_COMPLEX',
  SkeletonTypeSimple = 'SKELETON_TYPE_SIMPLE',
  SkeletonTypeUnspecified = 'SKELETON_TYPE_UNSPECIFIED'
}

export type AvatarAvatarComposition = {
  __typename?: 'AvatarAvatarComposition';
  generatorVersion: Scalars['String']['output'];
  partCustomizations: Array<AvatarAvatarPartCustomization>;
  partIds: Array<Scalars['String']['output']>;
};

export type AvatarAvatarCompositionInput = {
  generatorVersion?: InputMaybe<Scalars['String']['input']>;
  partCustomizations?: InputMaybe<Array<AvatarAvatarPartCustomizationInput>>;
  partIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type AvatarAvatarInput = {
  assets?: InputMaybe<AvatarAvatarAssetsInput>;
  avatar3D?: InputMaybe<Scalars['String']['input']>;
  avatarComposition?: InputMaybe<AvatarAvatarCompositionInput>;
  avatarLods?: InputMaybe<Array<Scalars['String']['input']>>;
  body?: InputMaybe<Scalars['String']['input']>;
  face?: InputMaybe<Scalars['String']['input']>;
  /** todo: remove or use Gender instead */
  gender?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  /** selectable is used to determine if the avatar is shown in the avatar picker */
  selectable?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AvatarAvatarPart = {
  __typename?: 'AvatarAvatarPart';
  category: AvatarAvatarPartCategory;
  categoryOverride: Array<AvatarAvatarPartCategory>;
  channelId: Scalars['ID']['output'];
  clothingSet: Scalars['String']['output'];
  color: Scalars['String']['output'];
  colorPresetOptions: Array<Scalars['String']['output']>;
  colors: Array<Scalars['String']['output']>;
  default: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
  experimental: Scalars['Boolean']['output'];
  gender: AvatarGender;
  glbUrl: Scalars['String']['output'];
  glbUrlOverride?: Maybe<AvatarAvatarPartGlbUrlOverride>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  previewImgUrl: Scalars['String']['output'];
  sellable: Scalars['Boolean']['output'];
  skinData?: Maybe<AvatarAvatarPartSkinData>;
  skinOptions: Array<Scalars['String']['output']>;
  uniqueBootstrap: Scalars['Boolean']['output'];
  url: Scalars['String']['output'];
  userDefault: Scalars['Boolean']['output'];
};

export enum AvatarAvatarPartCategory {
  CategoryBeard = 'CATEGORY_BEARD',
  CategoryBody = 'CATEGORY_BODY',
  CategoryColorPreset = 'CATEGORY_COLOR_PRESET',
  CategoryEyebrows = 'CATEGORY_EYEBROWS',
  CategoryEyebrowsColor = 'CATEGORY_EYEBROWS_COLOR',
  CategoryEyelashes = 'CATEGORY_EYELASHES',
  CategoryEyelashesColor = 'CATEGORY_EYELASHES_COLOR',
  CategoryEyes = 'CATEGORY_EYES',
  CategoryFaceItem = 'CATEGORY_FACE_ITEM',
  CategoryHair = 'CATEGORY_HAIR',
  CategoryHairColor = 'CATEGORY_HAIR_COLOR',
  CategoryHands = 'CATEGORY_HANDS',
  CategoryHead = 'CATEGORY_HEAD',
  CategoryHeadItem = 'CATEGORY_HEAD_ITEM',
  CategoryLegs = 'CATEGORY_LEGS',
  CategoryShoes = 'CATEGORY_SHOES',
  CategorySkin = 'CATEGORY_SKIN',
  CategorySkinColor = 'CATEGORY_SKIN_COLOR',
  CategoryTeeth = 'CATEGORY_TEETH',
  CategoryTorso = 'CATEGORY_TORSO',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED'
}

export type AvatarAvatarPartCustomization = {
  __typename?: 'AvatarAvatarPartCustomization';
  colorPreset: Scalars['String']['output'];
  partId: Scalars['ID']['output'];
  skin: Scalars['String']['output'];
};

export type AvatarAvatarPartCustomizationInput = {
  colorPreset?: InputMaybe<Scalars['String']['input']>;
  partId?: InputMaybe<Scalars['ID']['input']>;
  skin?: InputMaybe<Scalars['String']['input']>;
};

export type AvatarAvatarPartGlbUrlOverride = {
  __typename?: 'AvatarAvatarPartGlbURLOverride';
  category: AvatarAvatarPartCategory;
  glbUrl: Scalars['String']['output'];
};

export type AvatarAvatarPartSkinData = {
  __typename?: 'AvatarAvatarPartSkinData';
  baseMapUrl: Scalars['String']['output'];
  emissionMapUrl: Scalars['String']['output'];
  normalMapUrl: Scalars['String']['output'];
  ormMapUrl: Scalars['String']['output'];
};

export type AvatarBatchGetAnimationsResponse = {
  __typename?: 'AvatarBatchGetAnimationsResponse';
  animations: Array<AvatarAnimation>;
};

export type AvatarBatchGetAvatarPartsResponse = {
  __typename?: 'AvatarBatchGetAvatarPartsResponse';
  avatarParts: Array<AvatarAvatarPart>;
};

export type AvatarBatchGetAvatarsResponse = {
  __typename?: 'AvatarBatchGetAvatarsResponse';
  avatars: Array<AvatarAvatar>;
};

export enum AvatarGender {
  GenderFemale = 'GENDER_FEMALE',
  GenderMale = 'GENDER_MALE',
  GenderUnspecified = 'GENDER_UNSPECIFIED'
}

export type AvatarListAnimationsResponse = {
  __typename?: 'AvatarListAnimationsResponse';
  animations: Array<AvatarAnimation>;
};

export type AvatarListAvatarPartsResponse = {
  __typename?: 'AvatarListAvatarPartsResponse';
  avatarParts: Array<AvatarAvatarPart>;
};

export type AvatarListAvatarsResponse = {
  __typename?: 'AvatarListAvatarsResponse';
  avatars: Array<AvatarAvatar>;
  pageInfo: ApiPageInfo;
};

export type AvatarValidateAvatarCompositionResponse = {
  __typename?: 'AvatarValidateAvatarCompositionResponse';
  changes: Array<AvatarValidateAvatarCompositionResponseChange>;
  composition: AvatarAvatarComposition;
  /** @deprecated field is deprecated */
  duplicatePartIds: Array<Scalars['String']['output']>;
  isDefault: Scalars['Boolean']['output'];
  /** @deprecated field is deprecated */
  missingPartCategories: Array<AvatarAvatarPartCategory>;
  /** @deprecated field is deprecated */
  missingPartIds: Array<Scalars['String']['output']>;
};

export type AvatarValidateAvatarCompositionResponseChange = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChange';
  action?: Maybe<AvatarValidateAvatarCompositionResponseChangeActionUnion>;
};

export type AvatarValidateAvatarCompositionResponseChangeActionUnion = AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded | AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved | AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced;

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded';
  id: Scalars['ID']['output'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
};

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved';
  id: Scalars['ID']['output'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
};

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced';
  id: Scalars['ID']['output'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
  replacementId: Scalars['ID']['output'];
};

export enum AvatarValidateAvatarCompositionResponseChangeReason {
  ReasonAvatarPartBodyRequired = 'REASON_AVATAR_PART_BODY_REQUIRED',
  ReasonAvatarPartEyesRequired = 'REASON_AVATAR_PART_EYES_REQUIRED',
  ReasonAvatarPartHeadRequired = 'REASON_AVATAR_PART_HEAD_REQUIRED',
  ReasonAvatarPartLegsRequired = 'REASON_AVATAR_PART_LEGS_REQUIRED',
  ReasonAvatarPartTorsoRequired = 'REASON_AVATAR_PART_TORSO_REQUIRED',
  ReasonAvatarPartUnavailable = 'REASON_AVATAR_PART_UNAVAILABLE',
  ReasonAvatarPartUnknown = 'REASON_AVATAR_PART_UNKNOWN',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type BadgeBadge = {
  __typename?: 'BadgeBadge';
  level: Scalars['Int']['output'];
  nextLevelAt: Scalars['Timestamp']['output'];
  type: BadgeBadgeType;
};

export enum BadgeBadgeType {
  TypeChannelModerator = 'TYPE_CHANNEL_MODERATOR',
  TypeChannelSubscriber = 'TYPE_CHANNEL_SUBSCRIBER',
  TypeClosedBetaCreator = 'TYPE_CLOSED_BETA_CREATOR',
  TypeNoiceStaff = 'TYPE_NOICE_STAFF',
  TypeStreamer = 'TYPE_STREAMER',
  TypeSubsGifter = 'TYPE_SUBS_GIFTER',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type BadgeBatchGetUserBadgesResponse = {
  __typename?: 'BadgeBatchGetUserBadgesResponse';
  badges: Array<BadgeUserBadges>;
};

export type BadgeGetUserBadgesResponse = {
  __typename?: 'BadgeGetUserBadgesResponse';
  badges: Array<BadgeBadge>;
};

export type BadgeUserBadges = {
  __typename?: 'BadgeUserBadges';
  badges: Array<BadgeBadge>;
  userId: Scalars['ID']['output'];
};

export type BooleanType = {
  __typename?: 'BooleanType';
  /** The wrapped value of type Boolean */
  value: Scalars['Boolean']['output'];
};

export type ChallengeChallengeReward = {
  __typename?: 'ChallengeChallengeReward';
  gameId: Scalars['ID']['output'];
  maxPickRate: Scalars['Int']['output'];
  minPickRate: Scalars['Int']['output'];
  reward: RewardRewardType;
};

export type ChallengeChallengeUpdateInput = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChallengeGetChallengeRewardsResponse = {
  __typename?: 'ChallengeGetChallengeRewardsResponse';
  rewards: Array<ChallengeChallengeReward>;
};

export type ChallengeListChallengesResponse = {
  __typename?: 'ChallengeListChallengesResponse';
  challenges: Array<GameLogicChallenge>;
};

export type ChallengesessionChallenge = {
  __typename?: 'ChallengesessionChallenge';
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  sessionId: Scalars['ID']['output'];
  state: ChallengesessionChallengeChallengeState;
};

export enum ChallengesessionChallengeChallengeState {
  ChallengeStateFailed = 'CHALLENGE_STATE_FAILED',
  ChallengeStateSucceeded = 'CHALLENGE_STATE_SUCCEEDED',
  ChallengeStateUnresolved = 'CHALLENGE_STATE_UNRESOLVED',
  ChallengeStateUnspecified = 'CHALLENGE_STATE_UNSPECIFIED'
}

export type ChallengesessionChallengeInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  sessionId?: InputMaybe<Scalars['ID']['input']>;
  state?: InputMaybe<ChallengesessionChallengeChallengeState>;
};

export type ChallengesessionChallengePick = {
  __typename?: 'ChallengesessionChallengePick';
  challengeId: Scalars['ID']['output'];
  sessionId: Scalars['ID']['output'];
  stake: ChallengesessionStake;
  userId: Scalars['ID']['output'];
};

export type ChallengesessionChallengeSession = {
  __typename?: 'ChallengesessionChallengeSession';
  challenges: Array<ChallengesessionChallenge>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  phase: ChallengesessionChallengeSessionPhase;
  streamId: Scalars['ID']['output'];
  submissionDeadline: Scalars['Timestamp']['output'];
  submissionWindowLength: Scalars['Int']['output'];
};

export type ChallengesessionChallengeSessionEvent = {
  __typename?: 'ChallengesessionChallengeSessionEvent';
  event?: Maybe<ChallengesessionChallengeSessionEventEventUnion>;
  streamId: Scalars['ID']['output'];
};

export type ChallengesessionChallengeSessionEventChallengeStatusChange = {
  __typename?: 'ChallengesessionChallengeSessionEventChallengeStatusChange';
  challenge: ChallengesessionChallenge;
  sessionId: Scalars['ID']['output'];
};

export type ChallengesessionChallengeSessionEventEventUnion = ChallengesessionChallengeSessionEventChallengeStatusChange | ChallengesessionChallengeSessionEventInitial | ChallengesessionChallengeSessionEventPhaseChange | ChallengesessionChallengeSessionEventStakeChange;

export type ChallengesessionChallengeSessionEventInitial = {
  __typename?: 'ChallengesessionChallengeSessionEventInitial';
  session: ChallengesessionChallengeSession;
  stats: Array<ChallengesessionChallengeStats>;
  userPick: ChallengesessionChallengePick;
};

export type ChallengesessionChallengeSessionEventPhaseChange = {
  __typename?: 'ChallengesessionChallengeSessionEventPhaseChange';
  session: ChallengesessionChallengeSession;
};

export type ChallengesessionChallengeSessionEventStakeChange = {
  __typename?: 'ChallengesessionChallengeSessionEventStakeChange';
  sessionId: Scalars['ID']['output'];
  stats: Array<ChallengesessionChallengeStats>;
};

export enum ChallengesessionChallengeSessionPhase {
  PhaseActive = 'PHASE_ACTIVE',
  PhaseCancelled = 'PHASE_CANCELLED',
  PhaseCompleted = 'PHASE_COMPLETED',
  PhaseDraft = 'PHASE_DRAFT',
  PhaseSubmission = 'PHASE_SUBMISSION',
  PhaseUnspecified = 'PHASE_UNSPECIFIED'
}

export type ChallengesessionChallengeSessionUpdateInput = {
  challenges?: InputMaybe<Array<ChallengesessionChallengeInput>>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
  submissionWindowLength?: InputMaybe<Scalars['Int']['input']>;
};

export type ChallengesessionChallengeStats = {
  __typename?: 'ChallengesessionChallengeStats';
  challengeId: Scalars['ID']['output'];
  highestStakePick: ChallengesessionChallengePick;
  sessionId: Scalars['ID']['output'];
  totalPicks: Scalars['Int']['output'];
  totalStake: ChallengesessionStake;
};

export type ChallengesessionStake = {
  __typename?: 'ChallengesessionStake';
  currencyAmount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
};

export type ChallengesessionStakeInput = {
  currencyAmount?: InputMaybe<Scalars['Int']['input']>;
  currencyId?: InputMaybe<Scalars['ID']['input']>;
};

export enum ChannelAppealStatus {
  AppealStatusAccepted = 'APPEAL_STATUS_ACCEPTED',
  AppealStatusDeclined = 'APPEAL_STATUS_DECLINED',
  AppealStatusPending = 'APPEAL_STATUS_PENDING',
  AppealStatusUnspecified = 'APPEAL_STATUS_UNSPECIFIED'
}

export enum ChannelAssetType {
  AssetTypeBanner = 'ASSET_TYPE_BANNER',
  AssetTypeLogo = 'ASSET_TYPE_LOGO',
  AssetTypeUnspecified = 'ASSET_TYPE_UNSPECIFIED'
}

export type ChannelAutomodItemAccepted = {
  __typename?: 'ChannelAutomodItemAccepted';
  message: ChatMessageContent;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelAutomodItemRejected = {
  __typename?: 'ChannelAutomodItemRejected';
  message: ChatMessageContent;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelAutomodSettings = {
  __typename?: 'ChannelAutomodSettings';
  defaultDecision: ChatAutomodDecision;
  level: ChatAutomodLevel;
};

export type ChannelAutomodSettingsInput = {
  defaultDecision?: InputMaybe<ChatAutomodDecision>;
  level?: InputMaybe<ChatAutomodLevel>;
};

export type ChannelAvatarItemPurchase = {
  __typename?: 'ChannelAvatarItemPurchase';
  item: ItemItem;
  itemId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelBanAppeal = {
  __typename?: 'ChannelBanAppeal';
  appealText: Scalars['String']['output'];
  bannedAt: Scalars['Timestamp']['output'];
  channelId: Scalars['ID']['output'];
  createdAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  moderatorId: Scalars['ID']['output'];
  reviewerComment: Scalars['String']['output'];
  reviewerId: Scalars['ID']['output'];
  status: ChannelAppealStatus;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelBanAppealAccepted = {
  __typename?: 'ChannelBanAppealAccepted';
  comment: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelBanAppealInfo = {
  __typename?: 'ChannelBanAppealInfo';
  appealText: Scalars['String']['output'];
  channelId: Scalars['ID']['output'];
  createdAt: Scalars['Timestamp']['output'];
  reviewer: ProfileProfile;
  reviewerComment: Scalars['String']['output'];
  reviewerId: Scalars['ID']['output'];
  status: ChannelAppealStatus;
  userId: Scalars['ID']['output'];
};

export type ChannelBanAppealRejected = {
  __typename?: 'ChannelBanAppealRejected';
  comment: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelBannedUser = {
  __typename?: 'ChannelBannedUser';
  appeal?: Maybe<ChannelBanAppealInfo>;
  bannedAt: Scalars['Timestamp']['output'];
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  keepRecentMessages: Scalars['Boolean']['output'];
  moderator: ProfileProfile;
  moderatorId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelBatchGetChannelsResponse = {
  __typename?: 'ChannelBatchGetChannelsResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelBatchGetGameStatsResponse = {
  __typename?: 'ChannelBatchGetGameStatsResponse';
  gameStats: Array<ChannelGameStats>;
};

export type ChannelBatchGetStreamSummaryResponse = {
  __typename?: 'ChannelBatchGetStreamSummaryResponse';
  summaries: Array<ChannelStreamSummary>;
};

export type ChannelBatchGetUserBanStatusResponse = {
  __typename?: 'ChannelBatchGetUserBanStatusResponse';
  statuses: Array<ChannelUserBanStatus>;
};

export type ChannelBatchStreamGetChannelResponse = {
  __typename?: 'ChannelBatchStreamGetChannelResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelBundlePurchase = {
  __typename?: 'ChannelBundlePurchase';
  bundleName: Scalars['String']['output'];
  streamerCardIds: Array<Scalars['String']['output']>;
  streamerCards?: Maybe<Array<GameLogicStreamerCard>>;
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelChallengesFeatureStatus = {
  __typename?: 'ChannelChallengesFeatureStatus';
  enabled: Scalars['Boolean']['output'];
};

/** Public channel information */
export type ChannelChannel = {
  __typename?: 'ChannelChannel';
  activeStream?: Maybe<ChannelStreamSummary>;
  channelFriends: FriendsChannelFriends;
  createdAt: Scalars['Timestamp']['output'];
  currentChatId?: Maybe<Scalars['String']['output']>;
  currentStream?: Maybe<ChannelStream>;
  currentStreamId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  features: ChannelChannelFeatures;
  followerCount: Scalars['Int']['output'];
  following: Scalars['Boolean']['output'];
  game: GameGame;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  isPublic: Scalars['Boolean']['output'];
  itemStats: Array<ItemItemStat>;
  links: Array<ChannelChannelLink>;
  liveStatus: ChannelLiveStatus;
  logo: Scalars['String']['output'];
  matchOngoing: Scalars['Boolean']['output'];
  matureRatedContent: Scalars['Boolean']['output'];
  monetizationSettings: ChannelMonetizationSettings;
  name: Scalars['String']['output'];
  offlineBanner: Scalars['String']['output'];
  offlineBannerUrl: Scalars['String']['output'];
  playedGameIds: Array<Scalars['String']['output']>;
  priority: Scalars['Int']['output'];
  reportingId: Scalars['ID']['output'];
  riskTier: ChannelRiskTier;
  state: ApiEntityState;
  streamedGames?: Maybe<Array<GameGame>>;
  streamer: ProfileProfile;
  streamerId: Scalars['ID']['output'];
  subscriberCount: Scalars['Int']['output'];
  subscription?: Maybe<SubscriptionChannelSubscription>;
  subscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  suspension: ChannelSuspension;
  thumbnail: Scalars['String']['output'];
  title: Scalars['String']['output'];
  userBanStatus: ChannelUserBanStatus;
  viewerCount: Scalars['Int']['output'];
};

export type ChannelChannelCreationEligibility = {
  __typename?: 'ChannelChannelCreationEligibility';
  canCreateChannel: Scalars['Boolean']['output'];
};

export type ChannelChannelDetailsUpdateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  featureChallengesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  featureNoicePredictionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  links?: InputMaybe<Array<ChannelChannelLinkInput>>;
  matureRatedContent?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  riskTier?: InputMaybe<ChannelRiskTier>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelChannelEvent = {
  __typename?: 'ChannelChannelEvent';
  channelId: Scalars['ID']['output'];
  content: ChannelChannelEventContent;
  createdAt: Scalars['Timestamp']['output'];
  id: Scalars['ID']['output'];
};

export type ChannelChannelEventContent = {
  __typename?: 'ChannelChannelEventContent';
  content?: Maybe<ChannelChannelEventContentContentUnion>;
};

export type ChannelChannelEventContentContentUnion = ChannelAvatarItemPurchase | ChannelBundlePurchase | ChannelGiftSubscriptionPurchase | ChannelStreamerCardPurchase | ChannelSubscriptionPurchase | ChannelSubscriptionRenewal;

export enum ChannelChannelFeature {
  ChannelFeatureChallenges = 'CHANNEL_FEATURE_CHALLENGES',
  ChannelFeatureNoicePredictions = 'CHANNEL_FEATURE_NOICE_PREDICTIONS',
  ChannelFeatureStreaming = 'CHANNEL_FEATURE_STREAMING',
  ChannelFeatureUnspecified = 'CHANNEL_FEATURE_UNSPECIFIED'
}

export type ChannelChannelFeatures = {
  __typename?: 'ChannelChannelFeatures';
  challenges: ChannelChallengesFeatureStatus;
  noicePredictions: ChannelNoicePredictionsFeatureStatus;
  streaming: ChannelStreamingFeatureStatus;
};

export type ChannelChannelLink = {
  __typename?: 'ChannelChannelLink';
  name: Scalars['String']['output'];
  type: ChannelChannelLinkLinkType;
  url: Scalars['String']['output'];
};

export type ChannelChannelLinkInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ChannelChannelLinkLinkType>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export enum ChannelChannelLinkLinkType {
  LinkTypeCustom = 'LINK_TYPE_CUSTOM',
  LinkTypeDiscord = 'LINK_TYPE_DISCORD',
  LinkTypeFacebook = 'LINK_TYPE_FACEBOOK',
  LinkTypeInstagram = 'LINK_TYPE_INSTAGRAM',
  LinkTypeTiktok = 'LINK_TYPE_TIKTOK',
  LinkTypeTwitter = 'LINK_TYPE_TWITTER',
  LinkTypeUnspecified = 'LINK_TYPE_UNSPECIFIED',
  LinkTypeYoutube = 'LINK_TYPE_YOUTUBE'
}

export enum ChannelChannelRole {
  ChannelRoleModerator = 'CHANNEL_ROLE_MODERATOR',
  ChannelRolePlatformModerator = 'CHANNEL_ROLE_PLATFORM_MODERATOR',
  ChannelRoleStreamer = 'CHANNEL_ROLE_STREAMER',
  ChannelRoleUnspecified = 'CHANNEL_ROLE_UNSPECIFIED'
}

export type ChannelChannelRoles = {
  __typename?: 'ChannelChannelRoles';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  roles: Array<ChannelChannelRole>;
};

export type ChannelChannelStreamDetailEvent = {
  __typename?: 'ChannelChannelStreamDetailEvent';
  challengesEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  liveStatus: ChannelLiveStatus;
  matureRatedContent: Scalars['Boolean']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  serverRenderingEnabled: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
  transcodingEnabled: Scalars['Boolean']['output'];
};

export type ChannelContentRendererConfig = {
  __typename?: 'ChannelContentRendererConfig';
  arenaId: Scalars['ID']['output'];
  containerImage: Scalars['String']['output'];
  controllerContainerImage: Scalars['String']['output'];
};

export type ChannelContentRendererConfigInput = {
  arenaId?: InputMaybe<Scalars['ID']['input']>;
  containerImage?: InputMaybe<Scalars['String']['input']>;
  controllerContainerImage?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelCreateChannelAssetUploadTokenResponse = {
  __typename?: 'ChannelCreateChannelAssetUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type ChannelFollowerCountEvent = {
  __typename?: 'ChannelFollowerCountEvent';
  channelId: Scalars['ID']['output'];
  followerCount: Scalars['Int']['output'];
};

export type ChannelFollowerNotificationSettings = {
  __typename?: 'ChannelFollowerNotificationSettings';
  channelId: Scalars['ID']['output'];
  channelLiveNotificationEnabled: Scalars['Boolean']['output'];
  userId: Scalars['ID']['output'];
};

export type ChannelGameStats = {
  __typename?: 'ChannelGameStats';
  game: GameGame;
  gameId: Scalars['ID']['output'];
  liveStreams: Scalars['Int']['output'];
};

export enum ChannelGender {
  GenderFemale = 'GENDER_FEMALE',
  GenderMale = 'GENDER_MALE',
  GenderUnspecified = 'GENDER_UNSPECIFIED'
}

export type ChannelGetChannelFollowerStatusResponse = {
  __typename?: 'ChannelGetChannelFollowerStatusResponse';
  followedAt?: Maybe<Scalars['Timestamp']['output']>;
  following: Scalars['Boolean']['output'];
};

export type ChannelGetFollowStatusResponse = {
  __typename?: 'ChannelGetFollowStatusResponse';
  following: Array<Scalars['Boolean']['output']>;
};

export type ChannelGetUserFollowedChannelsResponse = {
  __typename?: 'ChannelGetUserFollowedChannelsResponse';
  channels: Array<ChannelChannel>;
  pageInfo: ApiPageInfo;
};

export type ChannelGiftSubscriptionPurchase = {
  __typename?: 'ChannelGiftSubscriptionPurchase';
  recipientUserIds: Array<Scalars['String']['output']>;
  recipients?: Maybe<Array<ProfileProfile>>;
  tier: Scalars['Int']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelIngestStatsEvent = {
  __typename?: 'ChannelIngestStatsEvent';
  audioChannelCnt: Scalars['Int']['output'];
  audioSampleRate: Scalars['Int']['output'];
  bSlices: Scalars['Int']['output'];
  bitrate: Scalars['Int']['output'];
  channelId: Scalars['ID']['output'];
  framerate: Scalars['Int']['output'];
  height: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  width: Scalars['Int']['output'];
};

export type ChannelListBanAppealsResponse = {
  __typename?: 'ChannelListBanAppealsResponse';
  appeals: Array<ChannelBanAppeal>;
  pageInfo: ApiPageInfo;
};

export type ChannelListBannedUsersResponse = {
  __typename?: 'ChannelListBannedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<ChannelBannedUser>;
};

export type ChannelListChannelPrivilegedUsersResponse = {
  __typename?: 'ChannelListChannelPrivilegedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<ChannelPrivilegedUser>;
};

export type ChannelListChannelsResponse = {
  __typename?: 'ChannelListChannelsResponse';
  channels: Array<ChannelChannel>;
  pageInfo: ApiPageInfo;
};

export type ChannelListGameStatsRequestFilterInput = {
  live?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelListGameStatsResponse = {
  __typename?: 'ChannelListGameStatsResponse';
  games: Array<ChannelGameStats>;
  pageInfo: ApiPageInfo;
};

export type ChannelListHighlightedChannelsResponse = {
  __typename?: 'ChannelListHighlightedChannelsResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelListModerationEventsResponse = {
  __typename?: 'ChannelListModerationEventsResponse';
  events: Array<ChannelModerationEvent>;
  pageInfo: ApiPageInfo;
};

export type ChannelListStreamBackendConfigsResponse = {
  __typename?: 'ChannelListStreamBackendConfigsResponse';
  configs: Array<ChannelStreamBackendConfig>;
};

export type ChannelListStreamsResponse = {
  __typename?: 'ChannelListStreamsResponse';
  pageInfo: ApiPageInfo;
  streams: Array<ChannelStream>;
};

export type ChannelListUserChannelBansResponse = {
  __typename?: 'ChannelListUserChannelBansResponse';
  bans: Array<ChannelBannedUser>;
  pageInfo: ApiPageInfo;
};

export type ChannelListUserChannelRolesResponse = {
  __typename?: 'ChannelListUserChannelRolesResponse';
  roles: Array<ChannelChannelRole>;
};

export type ChannelListUserPrivilegedChannelsResponse = {
  __typename?: 'ChannelListUserPrivilegedChannelsResponse';
  channels: Array<ChannelChannelRoles>;
};

export enum ChannelLiveStatus {
  LiveStatusLive = 'LIVE_STATUS_LIVE',
  LiveStatusOffline = 'LIVE_STATUS_OFFLINE',
  LiveStatusUnlisted = 'LIVE_STATUS_UNLISTED',
  LiveStatusUnspecified = 'LIVE_STATUS_UNSPECIFIED'
}

export type ChannelLiveStatusEvent = {
  __typename?: 'ChannelLiveStatusEvent';
  channelId: Scalars['ID']['output'];
  liveStatus: ChannelLiveStatus;
  streamId: Scalars['ID']['output'];
};

export type ChannelMachineLearningConfig = {
  __typename?: 'ChannelMachineLearningConfig';
  containerImage: Scalars['String']['output'];
  disabled: Scalars['Boolean']['output'];
};

export type ChannelMachineLearningConfigInput = {
  containerImage?: InputMaybe<Scalars['String']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelModerationEvent = {
  __typename?: 'ChannelModerationEvent';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  content: ChannelModerationEventContent;
  id: Scalars['ID']['output'];
  moderator?: Maybe<ProfileProfile>;
  moderatorId: Scalars['ID']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

export type ChannelModerationEventContent = {
  __typename?: 'ChannelModerationEventContent';
  content?: Maybe<ChannelModerationEventContentContentUnion>;
};

export type ChannelModerationEventContentContentUnion = ChannelAutomodItemAccepted | ChannelAutomodItemRejected | ChannelBanAppealAccepted | ChannelBanAppealRejected | ChannelUserBanned | ChannelUserMuted | ChannelUserUnbanned;

export enum ChannelModerationEventType {
  ModerationEventTypeAutomodItemAccepted = 'MODERATION_EVENT_TYPE_AUTOMOD_ITEM_ACCEPTED',
  ModerationEventTypeAutomodItemRejected = 'MODERATION_EVENT_TYPE_AUTOMOD_ITEM_REJECTED',
  ModerationEventTypeBanAppealAccepted = 'MODERATION_EVENT_TYPE_BAN_APPEAL_ACCEPTED',
  ModerationEventTypeBanAppealRejected = 'MODERATION_EVENT_TYPE_BAN_APPEAL_REJECTED',
  ModerationEventTypeUnspecified = 'MODERATION_EVENT_TYPE_UNSPECIFIED',
  ModerationEventTypeUserBanned = 'MODERATION_EVENT_TYPE_USER_BANNED',
  ModerationEventTypeUserMuted = 'MODERATION_EVENT_TYPE_USER_MUTED',
  ModerationEventTypeUserUnbanned = 'MODERATION_EVENT_TYPE_USER_UNBANNED'
}

export type ChannelModerationEventsFilterInput = {
  eventTypes?: InputMaybe<Array<ChannelModerationEventType>>;
};

export type ChannelModerationSettings = {
  __typename?: 'ChannelModerationSettings';
  automod: ChannelAutomodSettings;
  banAppealsEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
};

export type ChannelModerationSettingsInput = {
  automod?: InputMaybe<ChannelAutomodSettingsInput>;
  banAppealsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChannelMonetizationSettings = {
  __typename?: 'ChannelMonetizationSettings';
  channelId: Scalars['ID']['output'];
  eligible: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
};

export type ChannelMonetizationSettingsInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  eligible?: InputMaybe<Scalars['Boolean']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelNoicePredictionsFeatureStatus = {
  __typename?: 'ChannelNoicePredictionsFeatureStatus';
  enabled: Scalars['Boolean']['output'];
};

export type ChannelNotificationSettings = {
  __typename?: 'ChannelNotificationSettings';
  channelLiveNotification: ChannelNotificationStatus;
  userId: Scalars['ID']['output'];
};

export type ChannelNotificationStatus = {
  __typename?: 'ChannelNotificationStatus';
  emailEnabled: Scalars['Boolean']['output'];
  pushEnabled: Scalars['Boolean']['output'];
};

export type ChannelNotificationStatusInput = {
  emailEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  pushEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelPrivilegedUser = {
  __typename?: 'ChannelPrivilegedUser';
  roles: Array<ChannelChannelRole>;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelRestreamingConfig = {
  __typename?: 'ChannelRestreamingConfig';
  bitrate: Scalars['Int']['output'];
  channelId: Scalars['ID']['output'];
  enabled: Scalars['Boolean']['output'];
  rtmpEndpoint: Scalars['String']['output'];
  rtmpKey: Scalars['String']['output'];
};

export type ChannelRestreamingConfigInput = {
  bitrate?: InputMaybe<Scalars['Int']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  rtmpEndpoint?: InputMaybe<Scalars['String']['input']>;
  rtmpKey?: InputMaybe<Scalars['String']['input']>;
};

export enum ChannelRiskTier {
  RiskTier_0 = 'RISK_TIER_0',
  RiskTier_1 = 'RISK_TIER_1',
  RiskTier_2 = 'RISK_TIER_2',
  RiskTierUnspecified = 'RISK_TIER_UNSPECIFIED'
}

export type ChannelStream = {
  __typename?: 'ChannelStream';
  challengesEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
  matureRatedContent: Scalars['Boolean']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  segments: Array<ChannelStreamSegment>;
  serverRenderingEnabled: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
  transcodingEnabled: Scalars['Boolean']['output'];
};

export type ChannelStreamBackendConfig = {
  __typename?: 'ChannelStreamBackendConfig';
  channelId: Scalars['ID']['output'];
  crConfig?: Maybe<ChannelContentRendererConfig>;
  game: GameGame;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  mlConfig?: Maybe<ChannelMachineLearningConfig>;
  recConfig?: Maybe<ChannelStreamRecorderConfig>;
  transcoderConfig?: Maybe<ChannelStreamTranscoderConfig>;
};

export type ChannelStreamBackendConfigInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  crConfig?: InputMaybe<ChannelContentRendererConfigInput>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  mlConfig?: InputMaybe<ChannelMachineLearningConfigInput>;
  recConfig?: InputMaybe<ChannelStreamRecorderConfigInput>;
  transcoderConfig?: InputMaybe<ChannelStreamTranscoderConfigInput>;
};

export type ChannelStreamRecorderConfig = {
  __typename?: 'ChannelStreamRecorderConfig';
  containerImage: Scalars['String']['output'];
};

export type ChannelStreamRecorderConfigInput = {
  containerImage?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelStreamSegment = {
  __typename?: 'ChannelStreamSegment';
  crConfig: ChannelContentRendererConfig;
  endTime?: Maybe<Scalars['Timestamp']['output']>;
  gameId: Scalars['ID']['output'];
  mlConfig: ChannelMachineLearningConfig;
  segmentId: Scalars['ID']['output'];
  startTime: Scalars['Timestamp']['output'];
  title: Scalars['String']['output'];
};

export type ChannelStreamStatusEvent = {
  __typename?: 'ChannelStreamStatusEvent';
  channelId: Scalars['ID']['output'];
  crStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  egressStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  gameRunnerStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  liveStatus: ChannelLiveStatus;
  mlStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  recStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  restreamingStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  streamId: Scalars['ID']['output'];
  transcoderStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
};

export type ChannelStreamSummary = {
  __typename?: 'ChannelStreamSummary';
  challengesEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
  endTime?: Maybe<Scalars['Timestamp']['output']>;
  gameId: Scalars['ID']['output'];
  matureRatedContent: Scalars['Boolean']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  serverRenderingEnabled: Scalars['Boolean']['output'];
  startTime: Scalars['Timestamp']['output'];
  streamId: Scalars['ID']['output'];
  transcodingEnabled: Scalars['Boolean']['output'];
};

export type ChannelStreamTranscoderConfig = {
  __typename?: 'ChannelStreamTranscoderConfig';
  containerImage: Scalars['String']['output'];
};

export type ChannelStreamTranscoderConfigInput = {
  containerImage?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelStreamerCardPurchase = {
  __typename?: 'ChannelStreamerCardPurchase';
  streamerCard: GameLogicStreamerCard;
  streamerCardId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelStreamingFeatureStatus = {
  __typename?: 'ChannelStreamingFeatureStatus';
  enabled: Scalars['Boolean']['output'];
  suspension?: Maybe<ChannelSuspension>;
};

export type ChannelSubscriptionPurchase = {
  __typename?: 'ChannelSubscriptionPurchase';
  tier: Scalars['Int']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelSubscriptionRenewal = {
  __typename?: 'ChannelSubscriptionRenewal';
  tier: Scalars['Int']['output'];
  userId: Scalars['ID']['output'];
};

export type ChannelSuspension = {
  __typename?: 'ChannelSuspension';
  description: Scalars['String']['output'];
  moderator?: Maybe<ProfileProfile>;
  reason: ChannelSuspensionReason;
  suspendedAt: Scalars['Timestamp']['output'];
  suspendedBy: Scalars['String']['output'];
  until?: Maybe<Scalars['Timestamp']['output']>;
};

export enum ChannelSuspensionReason {
  ReasonChannelDeleted = 'REASON_CHANNEL_DELETED',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type ChannelUpdateFollowerNotificationSettingsParamsInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  channelLiveNotificationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChannelUpdateNotificationSettingsParamsInput = {
  channelLiveNotification?: InputMaybe<ChannelNotificationStatusInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChannelUserBanStatus = {
  __typename?: 'ChannelUserBanStatus';
  appeal?: Maybe<ChannelBanAppealInfo>;
  banned: Scalars['Boolean']['output'];
  bannedAt?: Maybe<Scalars['Timestamp']['output']>;
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  moderator?: Maybe<ProfileProfile>;
  moderatorId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelUserBanned = {
  __typename?: 'ChannelUserBanned';
  description: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelUserBannedNotification = {
  __typename?: 'ChannelUserBannedNotification';
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  moderatorId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelUserMuted = {
  __typename?: 'ChannelUserMuted';
  description: Scalars['String']['output'];
  duration: Scalars['Duration']['output'];
  reason: ChatReason;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelUserUnbanned = {
  __typename?: 'ChannelUserUnbanned';
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelViewerCountEvent = {
  __typename?: 'ChannelViewerCountEvent';
  channelId: Scalars['ID']['output'];
  viewerCount: Scalars['Int']['output'];
};

export enum ChannelViolation {
  ViolationOther = 'VIOLATION_OTHER',
  ViolationSpam = 'VIOLATION_SPAM',
  ViolationUnspecified = 'VIOLATION_UNSPECIFIED'
}

export type ChatAutoModQueueEvent = {
  __typename?: 'ChatAutoModQueueEvent';
  event?: Maybe<ChatAutoModQueueEventEventUnion>;
};

export type ChatAutoModQueueEventAdd = {
  __typename?: 'ChatAutoModQueueEventAdd';
  item: ChatModerationItem;
};

export type ChatAutoModQueueEventEventUnion = ChatAutoModQueueEventAdd | ChatAutoModQueueEventRemove | ChatAutoModQueueEventUpdate;

export type ChatAutoModQueueEventRemove = {
  __typename?: 'ChatAutoModQueueEventRemove';
  id: Scalars['ID']['output'];
};

export type ChatAutoModQueueEventUpdate = {
  __typename?: 'ChatAutoModQueueEventUpdate';
  item: ChatModerationItem;
};

export enum ChatAutomodDecision {
  AutomodDecisionAccepted = 'AUTOMOD_DECISION_ACCEPTED',
  AutomodDecisionRejected = 'AUTOMOD_DECISION_REJECTED',
  AutomodDecisionUnspecified = 'AUTOMOD_DECISION_UNSPECIFIED'
}

export enum ChatAutomodLevel {
  AutomodLevelHigh = 'AUTOMOD_LEVEL_HIGH',
  AutomodLevelLow = 'AUTOMOD_LEVEL_LOW',
  AutomodLevelUnspecified = 'AUTOMOD_LEVEL_UNSPECIFIED'
}

export type ChatChatDetails = {
  __typename?: 'ChatChatDetails';
  chatId: Scalars['ID']['output'];
  roles: Array<ChatChatRole>;
};

export type ChatChatEvent = {
  __typename?: 'ChatChatEvent';
  chatId: Scalars['ID']['output'];
  cid: Scalars['Int']['output'];
  event?: Maybe<ChatChatEventEventUnion>;
};

export type ChatChatEventEventUnion = ChatChatDetails | ChatChatMessage | ChatHideMessage | ChatMessageDenied | ChatPing | ChatUserBanned | ChatUserMuted | ChatUserUnmuted;

export type ChatChatMessage = {
  __typename?: 'ChatChatMessage';
  chatId: Scalars['ID']['output'];
  content: ChatMessageContent;
  createdAt: Scalars['Timestamp']['output'];
  messageId: Scalars['ID']['output'];
  moderationStatus: ChatModerationStatus;
  sender: ProfileProfile;
  senderId: Scalars['ID']['output'];
  senderInfo: ChatSenderInfo;
  state: ApiEntityState;
  textClassification: ClassificationTextClassification;
  username: Scalars['String']['output'];
};

export enum ChatChatRole {
  ChatRoleMember = 'CHAT_ROLE_MEMBER',
  ChatRoleModerator = 'CHAT_ROLE_MODERATOR',
  ChatRolePlatformModerator = 'CHAT_ROLE_PLATFORM_MODERATOR',
  ChatRoleStreamer = 'CHAT_ROLE_STREAMER',
  ChatRoleUnspecified = 'CHAT_ROLE_UNSPECIFIED'
}

export type ChatChatUser = {
  __typename?: 'ChatChatUser';
  label: ChatUserLabel;
  senderInfo: ChatSenderInfo;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChatGetChatUserStatusResponse = {
  __typename?: 'ChatGetChatUserStatusResponse';
  muteDuration?: Maybe<Scalars['Duration']['output']>;
  muted: Scalars['Boolean']['output'];
};

export type ChatHideMessage = {
  __typename?: 'ChatHideMessage';
  chatId: Scalars['ID']['output'];
  messageId: Scalars['ID']['output'];
};

export type ChatListChatUsersResponse = {
  __typename?: 'ChatListChatUsersResponse';
  users: Array<ChatChatUser>;
};

export type ChatListMessagesResponse = {
  __typename?: 'ChatListMessagesResponse';
  messages: Array<ChatChatMessage>;
  pageInfo: ApiPageInfo;
};

export type ChatMessageContent = {
  __typename?: 'ChatMessageContent';
  content?: Maybe<ChatMessageContentContentUnion>;
};

export type ChatMessageContentContentUnion = ChatTextMessage | ChatTombstone;

export type ChatMessageContentInput = {
  textContent?: InputMaybe<ChatTextMessageInput>;
  tombstone?: InputMaybe<ChatTombstoneInput>;
};

export type ChatMessageDenied = {
  __typename?: 'ChatMessageDenied';
  chatId: Scalars['ID']['output'];
  messageId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ChatModerationItem = {
  __typename?: 'ChatModerationItem';
  chatMessage: ChatChatMessage;
  expired: Scalars['Boolean']['output'];
  expiresAt: Scalars['Timestamp']['output'];
  id: Scalars['ID']['output'];
  reviewer?: Maybe<ProfileProfile>;
  reviewerId?: Maybe<Scalars['ID']['output']>;
  status: ChatModerationItemStatus;
};

export enum ChatModerationItemStatus {
  StatusAllowed = 'STATUS_ALLOWED',
  StatusDenied = 'STATUS_DENIED',
  StatusPending = 'STATUS_PENDING',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export enum ChatModerationStatus {
  ModerationStatusApproved = 'MODERATION_STATUS_APPROVED',
  ModerationStatusUnspecified = 'MODERATION_STATUS_UNSPECIFIED'
}

export type ChatPing = {
  __typename?: 'ChatPing';
  seq: Scalars['Int']['output'];
};

export enum ChatReason {
  ReasonOther = 'REASON_OTHER',
  ReasonSpam = 'REASON_SPAM',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type ChatSendMessageResponse = {
  __typename?: 'ChatSendMessageResponse';
  messageId: Scalars['ID']['output'];
};

export type ChatSenderInfo = {
  __typename?: 'ChatSenderInfo';
  avatar2D: Scalars['String']['output'];
  badges: Array<BadgeBadge>;
  label: ChatUserLabel;
  preferredColor: ProfileColor;
  roles: Array<ChatChatRole>;
  userId: Scalars['ID']['output'];
  username: Scalars['String']['output'];
};

export type ChatTextMessage = {
  __typename?: 'ChatTextMessage';
  attachments: Array<ChatTextMessageAttachment>;
  links: Array<ChatTextMessageLink>;
  text: Scalars['String']['output'];
};

export type ChatTextMessageAttachment = {
  __typename?: 'ChatTextMessageAttachment';
  endIndex: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
  label: Scalars['String']['output'];
  source: Scalars['String']['output'];
  startIndex: Scalars['Int']['output'];
};

export type ChatTextMessageAttachmentInput = {
  endIndex?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  startIndex?: InputMaybe<Scalars['Int']['input']>;
};

export type ChatTextMessageInput = {
  attachments?: InputMaybe<Array<ChatTextMessageAttachmentInput>>;
  links?: InputMaybe<Array<ChatTextMessageLinkInput>>;
  text?: InputMaybe<Scalars['String']['input']>;
};

export type ChatTextMessageLink = {
  __typename?: 'ChatTextMessageLink';
  endIndex: Scalars['Int']['output'];
  startIndex: Scalars['Int']['output'];
  url: Scalars['String']['output'];
};

export type ChatTextMessageLinkInput = {
  endIndex?: InputMaybe<Scalars['Int']['input']>;
  startIndex?: InputMaybe<Scalars['Int']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type ChatTombstone = {
  __typename?: 'ChatTombstone';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type ChatTombstoneInput = {
  emptyTypeWorkaround: Scalars['Boolean']['input'];
};

export type ChatUserBanned = {
  __typename?: 'ChatUserBanned';
  chatId: Scalars['ID']['output'];
  moderatorId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export enum ChatUserLabel {
  UserLabelModerator = 'USER_LABEL_MODERATOR',
  UserLabelStaff = 'USER_LABEL_STAFF',
  UserLabelStreamer = 'USER_LABEL_STREAMER',
  UserLabelUnspecified = 'USER_LABEL_UNSPECIFIED',
  UserLabelViewer = 'USER_LABEL_VIEWER'
}

export type ChatUserMuted = {
  __typename?: 'ChatUserMuted';
  chatId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  duration: Scalars['Duration']['output'];
  moderatorId: Scalars['ID']['output'];
  reason: ChatReason;
  userId: Scalars['ID']['output'];
};

export type ChatUserUnmuted = {
  __typename?: 'ChatUserUnmuted';
  chatId: Scalars['ID']['output'];
  moderatorId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ClassificationEvent = {
  __typename?: 'ClassificationEvent';
  event?: Maybe<ClassificationEventEventUnion>;
};

export type ClassificationEventCustomEvent = {
  __typename?: 'ClassificationEventCustomEvent';
  id: Scalars['ID']['output'];
  message: Scalars['String']['output'];
};

export type ClassificationEventEventFlooding = {
  __typename?: 'ClassificationEventEventFlooding';
  count: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  limit: Scalars['Int']['output'];
};

export type ClassificationEventEventTrustChanged = {
  __typename?: 'ClassificationEventEventTrustChanged';
  id: Scalars['ID']['output'];
  message: Scalars['String']['output'];
  oldTrustLevel: ClassificationTrustLevel;
  trustLevel: ClassificationTrustLevel;
};

export type ClassificationEventEventUnion = ClassificationEventCustomEvent | ClassificationEventEventFlooding | ClassificationEventEventTrustChanged;

export type ClassificationTextClassification = {
  __typename?: 'ClassificationTextClassification';
  escalations: Array<Scalars['String']['output']>;
  events: Array<ClassificationEvent>;
  hashed: Scalars['String']['output'];
  hashes: Array<Scalars['Int']['output']>;
  highRiskLanguage: Scalars['String']['output'];
  notableIndexes: Array<Scalars['Int']['output']>;
  response: Scalars['Boolean']['output'];
  risk: ClassificationTextRisk;
  topics: Array<ClassificationTextClassificationTopicTextRiskLevel>;
  trust: ClassificationTrustLevel;
};

export type ClassificationTextClassificationTopicTextRiskLevel = {
  __typename?: 'ClassificationTextClassificationTopicTextRiskLevel';
  risk: ClassificationTextRisk;
  topic: ClassificationTopic;
};

export enum ClassificationTextRisk {
  TextRiskDangerous = 'TEXT_RISK_DANGEROUS',
  TextRiskExplicit = 'TEXT_RISK_EXPLICIT',
  TextRiskLow = 'TEXT_RISK_LOW',
  TextRiskMature = 'TEXT_RISK_MATURE',
  TextRiskNotable = 'TEXT_RISK_NOTABLE',
  TextRiskQuestionable = 'TEXT_RISK_QUESTIONABLE',
  TextRiskSafe = 'TEXT_RISK_SAFE',
  TextRiskUnknown = 'TEXT_RISK_UNKNOWN',
  TextRiskUnspecified = 'TEXT_RISK_UNSPECIFIED'
}

export enum ClassificationTopic {
  TopicAlarm = 'TOPIC_ALARM',
  TopicBullying = 'TOPIC_BULLYING',
  TopicChildGrooming = 'TOPIC_CHILD_GROOMING',
  TopicDrugsAndAlcohol = 'TOPIC_DRUGS_AND_ALCOHOL',
  TopicExtremism = 'TOPIC_EXTREMISM',
  TopicFraud = 'TOPIC_FRAUD',
  TopicGeneralRisk = 'TOPIC_GENERAL_RISK',
  TopicHateSpeech = 'TOPIC_HATE_SPEECH',
  TopicInApp = 'TOPIC_IN_APP',
  TopicJunk = 'TOPIC_JUNK',
  TopicPersonalIdentifyingInfo = 'TOPIC_PERSONAL_IDENTIFYING_INFO',
  TopicPolitics = 'TOPIC_POLITICS',
  TopicPublicThreat = 'TOPIC_PUBLIC_THREAT',
  TopicRealName = 'TOPIC_REAL_NAME',
  TopicRelationshipAndSexualContent = 'TOPIC_RELATIONSHIP_AND_SEXUAL_CONTENT',
  TopicReligious = 'TOPIC_RELIGIOUS',
  TopicSentiment = 'TOPIC_SENTIMENT',
  TopicSubversive = 'TOPIC_SUBVERSIVE',
  TopicUnspecified = 'TOPIC_UNSPECIFIED',
  TopicViolence = 'TOPIC_VIOLENCE',
  TopicVulgarity = 'TOPIC_VULGARITY',
  TopicWebsite = 'TOPIC_WEBSITE'
}

export enum ClassificationTrustLevel {
  TrustLevelDefault = 'TRUST_LEVEL_DEFAULT',
  TrustLevelMute = 'TRUST_LEVEL_MUTE',
  TrustLevelNotTrusted = 'TRUST_LEVEL_NOT_TRUSTED',
  TrustLevelSuperuser = 'TRUST_LEVEL_SUPERUSER',
  TrustLevelTrusted = 'TRUST_LEVEL_TRUSTED',
  TrustLevelUnspecified = 'TRUST_LEVEL_UNSPECIFIED'
}

export type ConfigMetagameConfigInactivityTimeouts = {
  __typename?: 'ConfigMetagameConfigInactivityTimeouts';
  enabled: Scalars['Boolean']['output'];
  idleTimeoutSec: Scalars['Int']['output'];
  implicitOfflineTimeoutSec: Scalars['Int']['output'];
  offlineTimeoutSec: Scalars['Int']['output'];
};

export type ConfigMetagameConfigUiTimings = {
  __typename?: 'ConfigMetagameConfigUITimings';
  teamActionTimeout: Scalars['Int']['output'];
};

export type EmojiBatchGetEmojisResponse = {
  __typename?: 'EmojiBatchGetEmojisResponse';
  emojis: Array<EmojiEmoji>;
};

export type EmojiCreateEmojiUploadTokenResponse = {
  __typename?: 'EmojiCreateEmojiUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type EmojiEmoji = {
  __typename?: 'EmojiEmoji';
  channelId: Scalars['ID']['output'];
  disabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  image: Scalars['String']['output'];
  imageUrl: Scalars['String']['output'];
  label: Scalars['String']['output'];
  name: Scalars['String']['output'];
  prefabName: Scalars['String']['output'];
};

export type EmojiListChannelEmojisResponse = {
  __typename?: 'EmojiListChannelEmojisResponse';
  count?: Maybe<ItemItemTotalCount>;
  emojis: Array<EmojiEmoji>;
  pageInfo: ApiPageInfo;
};

export type EmojiListPlatformEmojisResponse = {
  __typename?: 'EmojiListPlatformEmojisResponse';
  count?: Maybe<ItemItemTotalCount>;
  emojis: Array<EmojiEmoji>;
  pageInfo: ApiPageInfo;
};

export type EmojiUpdateChannelEmojiParamsInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};

export type EmojiUpdatePlatformEmojiParamsInput = {
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlag = {
  __typename?: 'FlagFeatureFlag';
  description: Scalars['String']['output'];
  enabled: Scalars['Boolean']['output'];
  groups: Array<FlagFeatureFlagGroup>;
  name: Scalars['String']['output'];
};

export type FlagFeatureFlagConfig = {
  __typename?: 'FlagFeatureFlagConfig';
  channelFlags: FlagFeatureFlagList;
  createdAt: Scalars['Timestamp']['output'];
  revision: Scalars['String']['output'];
  userFlags: FlagFeatureFlagList;
};

export type FlagFeatureFlagConfigInput = {
  channelFlags?: InputMaybe<FlagFeatureFlagListInput>;
  createdAt?: InputMaybe<Scalars['InputTimestamp']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
  userFlags?: InputMaybe<FlagFeatureFlagListInput>;
};

export type FlagFeatureFlagGroup = {
  __typename?: 'FlagFeatureFlagGroup';
  conditions: Array<FlagFeatureFlagGroupCondition>;
  default: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  values: Array<FlagFeatureFlagGroupValue>;
};

export type FlagFeatureFlagGroupCondition = {
  __typename?: 'FlagFeatureFlagGroupCondition';
  rule?: Maybe<FlagFeatureFlagGroupConditionRuleUnion>;
};

export type FlagFeatureFlagGroupConditionAny = {
  __typename?: 'FlagFeatureFlagGroupConditionAny';
  field: Scalars['String']['output'];
  values: Array<Scalars['String']['output']>;
};

export type FlagFeatureFlagGroupConditionAnyInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type FlagFeatureFlagGroupConditionEq = {
  __typename?: 'FlagFeatureFlagGroupConditionEq';
  field: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagFeatureFlagGroupConditionEqInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagGroupConditionGte = {
  __typename?: 'FlagFeatureFlagGroupConditionGte';
  field: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagFeatureFlagGroupConditionGteInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagGroupConditionInput = {
  any?: InputMaybe<FlagFeatureFlagGroupConditionAnyInput>;
  eq?: InputMaybe<FlagFeatureFlagGroupConditionEqInput>;
  gte?: InputMaybe<FlagFeatureFlagGroupConditionGteInput>;
  lte?: InputMaybe<FlagFeatureFlagGroupConditionLteInput>;
};

export type FlagFeatureFlagGroupConditionLte = {
  __typename?: 'FlagFeatureFlagGroupConditionLte';
  field: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagFeatureFlagGroupConditionLteInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagGroupConditionRuleUnion = FlagFeatureFlagGroupConditionAny | FlagFeatureFlagGroupConditionEq | FlagFeatureFlagGroupConditionGte | FlagFeatureFlagGroupConditionLte;

export type FlagFeatureFlagGroupInput = {
  conditions?: InputMaybe<Array<FlagFeatureFlagGroupConditionInput>>;
  default?: InputMaybe<Scalars['Boolean']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  values?: InputMaybe<Array<FlagFeatureFlagGroupValueInput>>;
};

export type FlagFeatureFlagGroupValue = {
  __typename?: 'FlagFeatureFlagGroupValue';
  value: Scalars['String']['output'];
  weight: Scalars['Int']['output'];
};

export type FlagFeatureFlagGroupValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type FlagFeatureFlagInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  groups?: InputMaybe<Array<FlagFeatureFlagGroupInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagList = {
  __typename?: 'FlagFeatureFlagList';
  flags: Array<FlagFeatureFlag>;
};

export type FlagFeatureFlagListInput = {
  flags?: InputMaybe<Array<FlagFeatureFlagInput>>;
};

export type FlagFeatureFlagSchema = {
  __typename?: 'FlagFeatureFlagSchema';
  flags: Array<FlagFeatureFlagSchemaFlagsEntry>;
};

export type FlagFeatureFlagSchemaFlagsEntry = {
  __typename?: 'FlagFeatureFlagSchemaFlagsEntry';
  key: Scalars['String']['output'];
  value: FlagJsonSchema;
};

export type FlagFeatureFlagState = {
  __typename?: 'FlagFeatureFlagState';
  name: Scalars['String']['output'];
  revision: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagJsonSchema = {
  __typename?: 'FlagJSONSchema';
  description: Scalars['String']['output'];
  enum: Array<Scalars['String']['output']>;
  items: FlagJsonSchema;
  maximum: Scalars['Float']['output'];
  minimum: Scalars['Float']['output'];
  multipleOf: Scalars['Float']['output'];
  pattern: Scalars['String']['output'];
  patternProperties: Array<FlagJsonSchemaPatternPropertiesEntry>;
  properties: Array<FlagJsonSchemaPropertiesEntry>;
  type: Scalars['String']['output'];
};

export type FlagJsonSchemaPatternPropertiesEntry = {
  __typename?: 'FlagJSONSchemaPatternPropertiesEntry';
  key: Scalars['String']['output'];
  value: FlagJsonSchema;
};

export type FlagJsonSchemaPropertiesEntry = {
  __typename?: 'FlagJSONSchemaPropertiesEntry';
  key: Scalars['String']['output'];
  value: FlagJsonSchema;
};

export type FlagListChannelFeatureFlagsResponse = {
  __typename?: 'FlagListChannelFeatureFlagsResponse';
  flags: Array<FlagFeatureFlagState>;
};

export type FlagListUserFeatureFlagsResponse = {
  __typename?: 'FlagListUserFeatureFlagsResponse';
  flags: Array<FlagFeatureFlagState>;
};

export type FloatType = {
  __typename?: 'FloatType';
  /** The wrapped value of type Float */
  value: Scalars['Float']['output'];
};

export type FriendsAcceptFriendRequestResponse = {
  __typename?: 'FriendsAcceptFriendRequestResponse';
  friend: ProfileProfile;
  friendId: Scalars['ID']['output'];
};

export type FriendsActivity = {
  __typename?: 'FriendsActivity';
  channel?: Maybe<ChannelChannel>;
  channelId: Scalars['ID']['output'];
  isOnline: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
};

export type FriendsBlockUserResponse = {
  __typename?: 'FriendsBlockUserResponse';
  blockedUser: ProfileProfile;
  blockedUserId: Scalars['ID']['output'];
};

export type FriendsChannelFriends = {
  __typename?: 'FriendsChannelFriends';
  channelId: Scalars['ID']['output'];
  totalCount: Scalars['Int']['output'];
  users: Array<FriendsUser>;
};

export type FriendsFriendStatusUpdateEvent = {
  __typename?: 'FriendsFriendStatusUpdateEvent';
  actorProfile: ProfileProfile;
  actorUserId: Scalars['ID']['output'];
  targetProfile: ProfileProfile;
  targetUserId: Scalars['ID']['output'];
  type: FriendsFriendStatusUpdateEventUpdateType;
};

export enum FriendsFriendStatusUpdateEventUpdateType {
  UpdateTypeFriendInvitation = 'UPDATE_TYPE_FRIEND_INVITATION',
  UpdateTypeInvitationAccepted = 'UPDATE_TYPE_INVITATION_ACCEPTED',
  UpdateTypeInvitationCancelled = 'UPDATE_TYPE_INVITATION_CANCELLED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUserBlocked = 'UPDATE_TYPE_USER_BLOCKED',
  UpdateTypeUserUnblocked = 'UPDATE_TYPE_USER_UNBLOCKED',
  UpdateTypeUserUnfriended = 'UPDATE_TYPE_USER_UNFRIENDED'
}

export type FriendsFriendsSettings = {
  __typename?: 'FriendsFriendsSettings';
  disableFriendRequests: Scalars['Boolean']['output'];
};

export type FriendsFriendsSettingsInput = {
  disableFriendRequests?: InputMaybe<Scalars['Boolean']['input']>;
};

export type FriendsFriendshipStatus = {
  __typename?: 'FriendsFriendshipStatus';
  activity?: Maybe<FriendsActivity>;
  lastStatusChange: Scalars['Timestamp']['output'];
  status: FriendsFriendshipStatusStatus;
};

export enum FriendsFriendshipStatusStatus {
  StatusBlocked = 'STATUS_BLOCKED',
  StatusBlockedBy = 'STATUS_BLOCKED_BY',
  StatusFriend = 'STATUS_FRIEND',
  StatusFriendRequestReceived = 'STATUS_FRIEND_REQUEST_RECEIVED',
  StatusFriendRequestSent = 'STATUS_FRIEND_REQUEST_SENT',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export type FriendsGetChannelActiveFriendsResponse = {
  __typename?: 'FriendsGetChannelActiveFriendsResponse';
  channelFriends: Array<FriendsChannelFriends>;
};

export type FriendsGetFriendshipStatusResponse = {
  __typename?: 'FriendsGetFriendshipStatusResponse';
  statuses: Array<FriendsFriendshipStatus>;
};

export type FriendsListBlockedUsersResponse = {
  __typename?: 'FriendsListBlockedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListFriendsRequestFilterInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  isOnline?: InputMaybe<Scalars['Boolean']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};

export type FriendsListFriendsResponse = {
  __typename?: 'FriendsListFriendsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListReceivedFriendRequestsResponse = {
  __typename?: 'FriendsListReceivedFriendRequestsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListSentFriendRequestsResponse = {
  __typename?: 'FriendsListSentFriendRequestsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsSendFriendRequestResponse = {
  __typename?: 'FriendsSendFriendRequestResponse';
  friend: ProfileProfile;
  friendId: Scalars['ID']['output'];
};

export type FriendsUnblockUserResponse = {
  __typename?: 'FriendsUnblockUserResponse';
  unblockedUser: ProfileProfile;
  unblockedUserId: Scalars['ID']['output'];
};

export type FriendsUser = {
  __typename?: 'FriendsUser';
  activity?: Maybe<FriendsActivity>;
  lastStatusChange: Scalars['Timestamp']['output'];
  profile: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export enum FtueDismissalType {
  DismissalTypeActionTaken = 'DISMISSAL_TYPE_ACTION_TAKEN',
  DismissalTypeClosed = 'DISMISSAL_TYPE_CLOSED',
  DismissalTypeUnspecified = 'DISMISSAL_TYPE_UNSPECIFIED'
}

export type FtueListDismissedTooltipsResponse = {
  __typename?: 'FtueListDismissedTooltipsResponse';
  tooltipIds: Array<Scalars['String']['output']>;
};

export type GameBatchGetGamesResponse = {
  __typename?: 'GameBatchGetGamesResponse';
  games: Array<GameGame>;
};

export type GameBatchGetSeasonsResponse = {
  __typename?: 'GameBatchGetSeasonsResponse';
  seasons: Array<GameSeason>;
};

export enum GameCardAssetType {
  AssetTypeThumbnail = 'ASSET_TYPE_THUMBNAIL',
  AssetTypeUnspecified = 'ASSET_TYPE_UNSPECIFIED',
  AssetTypeVideo = 'ASSET_TYPE_VIDEO'
}

export type GameCardBatchGetGameCardsResponse = {
  __typename?: 'GameCardBatchGetGameCardsResponse';
  cards: Array<GameLogicCard>;
};

export type GameCardBatchGetStreamerCardsResponse = {
  __typename?: 'GameCardBatchGetStreamerCardsResponse';
  cards: Array<GameLogicStreamerCard>;
};

export type GameCardCreateStreamerCardAssetUploadTokenResponse = {
  __typename?: 'GameCardCreateStreamerCardAssetUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type GameCardHighScoringCardConfig = {
  __typename?: 'GameCardHighScoringCardConfig';
  cardRarity: RarityRarity;
  percentageOfMaxRequired: Scalars['Float']['output'];
  soloMultiplier: Scalars['Float']['output'];
  streamerCardPercentageOfMaxRequired: Scalars['Float']['output'];
};

export type GameCardHighScoringCardTimings = {
  __typename?: 'GameCardHighScoringCardTimings';
  cooldownBetweenCardScores: Scalars['Int']['output'];
  ghostWaitTime: Scalars['Int']['output'];
  speed: GameCardHighScoringCardTimingsSpeed;
};

export enum GameCardHighScoringCardTimingsSpeed {
  SpeedDefault = 'SPEED_DEFAULT',
  SpeedFast = 'SPEED_FAST',
  SpeedFastest = 'SPEED_FASTEST',
  SpeedSlow = 'SPEED_SLOW',
  SpeedSlowest = 'SPEED_SLOWEST',
  SpeedUnspecified = 'SPEED_UNSPECIFIED'
}

export type GameCardListBoostersResponse = {
  __typename?: 'GameCardListBoostersResponse';
  boosters: Array<GameLogicBooster>;
};

/** TODO: add game/stream based filtering */
export type GameCardListGameCardsResponse = {
  __typename?: 'GameCardListGameCardsResponse';
  cards: Array<GameLogicCard>;
};

export type GameCardListStreamerCardDraftsRequestFilterInput = {
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};

export type GameCardListStreamerCardDraftsResponse = {
  __typename?: 'GameCardListStreamerCardDraftsResponse';
  cards: Array<GameLogicStreamerCard>;
  pageInfo: ApiPageInfo;
};

export type GameCardListStreamerCardsRequestFilterInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};

export type GameCardListStreamerCardsResponse = {
  __typename?: 'GameCardListStreamerCardsResponse';
  cards: Array<GameLogicStreamerCard>;
  pageInfo: ApiPageInfo;
};

export type GameCardStreamerCardDraftUpdateInput = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type GameGame = {
  __typename?: 'GameGame';
  activeSeason: GameSeason;
  activeSeasonId: Scalars['ID']['output'];
  backdropUrl: Scalars['String']['output'];
  challengesEnabled: Scalars['Boolean']['output'];
  coverImageUrl: Scalars['String']['output'];
  gameEventsSource: GameGameEventsSource;
  iconUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  otherNames: Array<Scalars['String']['output']>;
  progression: GameUserProgression;
  publicAccess: Scalars['Boolean']['output'];
};

export enum GameGameEventsSource {
  GameEventsSourceGameIntegration = 'GAME_EVENTS_SOURCE_GAME_INTEGRATION',
  GameEventsSourceMl = 'GAME_EVENTS_SOURCE_ML',
  GameEventsSourceUnspecified = 'GAME_EVENTS_SOURCE_UNSPECIFIED'
}

export type GameListGamesResponse = {
  __typename?: 'GameListGamesResponse';
  games: Array<GameGame>;
};

export type GameListSeasonsResponse = {
  __typename?: 'GameListSeasonsResponse';
  seasons: Array<GameSeason>;
};

export type GameLogicActiveBooster = {
  __typename?: 'GameLogicActiveBooster';
  activationTime: Scalars['Int']['output'];
  activatorUserId: Scalars['ID']['output'];
  boosterId: Scalars['Int']['output'];
};

export type GameLogicActiveCard = {
  __typename?: 'GameLogicActiveCard';
  activeBoosters: Array<GameLogicActiveCardActiveBoostersEntry>;
  cardId: Scalars['ID']['output'];
  failureTargetValue: Scalars['Int']['output'];
  points: Scalars['Int']['output'];
  pointsMax: Scalars['Int']['output'];
  pointsMin: Scalars['Int']['output'];
  pointsTimeTarget: Scalars['Int']['output'];
  pointsUpdateTime: Scalars['Int']['output'];
  pointsUpdateTimer: GameLogicTimer;
  setTime: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
  targetValues: Array<GameLogicActiveCardTargetValuesEntry>;
  timerDuration: Scalars['Int']['output'];
};

export type GameLogicActiveCardActiveBoostersEntry = {
  __typename?: 'GameLogicActiveCardActiveBoostersEntry';
  key: Scalars['String']['output'];
  value: GameLogicActiveBooster;
};

export type GameLogicActiveCardSucceededMsg = {
  __typename?: 'GameLogicActiveCardSucceededMsg';
  allOrNothing: GameLogicAllOrNothing;
  bestPlay: GameLogicBestPlay;
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  card: GameLogicCard;
  cardId: Scalars['ID']['output'];
  groupId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type GameLogicActiveCardTargetValuesEntry = {
  __typename?: 'GameLogicActiveCardTargetValuesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type GameLogicAllOrNothing = {
  __typename?: 'GameLogicAllOrNothing';
  bestPlay: GameLogicBestPlay;
  cardActivations: Array<GameLogicCardActivationResult>;
  cardId: Scalars['ID']['output'];
  nextPoints: Scalars['Int']['output'];
  round: Scalars['Int']['output'];
  totalPoints: Scalars['Int']['output'];
  totalRounds: Scalars['Int']['output'];
};

export type GameLogicBestPlay = {
  __typename?: 'GameLogicBestPlay';
  activeBoosters: Array<GameLogicActiveBooster>;
  cardId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicBooster = {
  __typename?: 'GameLogicBooster';
  canTargetSelf: Scalars['Boolean']['output'];
  description: Scalars['String']['output'];
  descriptionCondition: Scalars['String']['output'];
  descriptionDefaultBenefit: Scalars['String']['output'];
  descriptionOtherBenefit: Scalars['String']['output'];
  descriptionTargetNoneBenefit: Scalars['String']['output'];
  descriptionTargetSelf: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  image: Scalars['String']['output'];
  isAvailableSolo: Scalars['Boolean']['output'];
  isSelfAndOtherEffect: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  removeOn: Array<Scalars['String']['output']>;
  timeActive: Scalars['Int']['output'];
  triggersOn: Array<Scalars['String']['output']>;
  valueOther: Scalars['Int']['output'];
  valueSelf: Scalars['Int']['output'];
};

export type GameLogicCard = {
  __typename?: 'GameLogicCard';
  activeStreamerCard?: Maybe<GameLogicStreamerCard>;
  activeStreamerCards: Array<GameLogicStreamerCard>;
  availableStreamerCards: Array<GameLogicStreamerCard>;
  backImage: Scalars['String']['output'];
  dealingModules: Array<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  failureModules: Array<Scalars['String']['output']>;
  failureTargetValue: Scalars['Int']['output'];
  familyId: Scalars['ID']['output'];
  frontImage: Scalars['String']['output'];
  gameModes: Array<Scalars['String']['output']>;
  icon: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isAllOrNothing: Scalars['Boolean']['output'];
  isDealtAtStart: Scalars['Boolean']['output'];
  isEnabled: Scalars['Boolean']['output'];
  isMatchCard: Scalars['Boolean']['output'];
  leveling: GameLogicCardLeveling;
  matchCardId: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  pointsMax: Scalars['Int']['output'];
  pointsMin: Scalars['Int']['output'];
  pointsTimeTarget: Scalars['Int']['output'];
  rarity: RarityRarity;
  roleCharacters: Array<Scalars['String']['output']>;
  scoredCounterIds: Array<Scalars['String']['output']>;
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
  sides: Array<Scalars['String']['output']>;
  successModules: Array<Scalars['String']['output']>;
  targetValue: Scalars['Int']['output'];
  targetValues: Array<GameLogicTargetValue>;
  timerDuration: Scalars['Int']['output'];
  unlockLevel: Scalars['Int']['output'];
};


export type GameLogicCardAvailableStreamerCardsArgs = {
  channel_id?: InputMaybe<Scalars['ID']['input']>;
};

export type GameLogicCardActivationResult = {
  __typename?: 'GameLogicCardActivationResult';
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  cardId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicCardDetails = {
  __typename?: 'GameLogicCardDetails';
  groupName: Scalars['String']['output'];
  succeedingCard: GameLogicActiveCardSucceededMsg;
};

export type GameLogicCardLeveling = {
  __typename?: 'GameLogicCardLeveling';
  currentLevel: Scalars['Int']['output'];
  nextLevelLimit: Scalars['Int']['output'];
  progressToNextLevel: Scalars['Int']['output'];
};

export type GameLogicChallenge = {
  __typename?: 'GameLogicChallenge';
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  disabled: Scalars['Boolean']['output'];
  failureModule: Scalars['String']['output'];
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  successModule: Scalars['String']['output'];
  targetValues: Array<GameLogicTargetValue>;
};

export enum GameLogicChallengeState {
  ChallengeStateFailure = 'CHALLENGE_STATE_FAILURE',
  ChallengeStateSuccess = 'CHALLENGE_STATE_SUCCESS',
  ChallengeStateUnresolved = 'CHALLENGE_STATE_UNRESOLVED',
  ChallengeStateUnspecified = 'CHALLENGE_STATE_UNSPECIFIED'
}

export type GameLogicChallengeStatus = {
  __typename?: 'GameLogicChallengeStatus';
  challenge: GameLogicChallenge;
  challengeId: Scalars['ID']['output'];
  challengeState: GameLogicChallengeState;
  pickRate: Scalars['Float']['output'];
  targetValues: Array<GameLogicTargetValue>;
};

export enum GameLogicContextualTeamActionStatus {
  ContextualTeamActionStatusFailed = 'CONTEXTUAL_TEAM_ACTION_STATUS_FAILED',
  ContextualTeamActionStatusOngoing = 'CONTEXTUAL_TEAM_ACTION_STATUS_ONGOING',
  ContextualTeamActionStatusSucceeded = 'CONTEXTUAL_TEAM_ACTION_STATUS_SUCCEEDED',
  ContextualTeamActionStatusUnspecified = 'CONTEXTUAL_TEAM_ACTION_STATUS_UNSPECIFIED'
}

export enum GameLogicContextualTeamActionType {
  ContextualTeamActionTypeHighScoringCardPromoted = 'CONTEXTUAL_TEAM_ACTION_TYPE_HIGH_SCORING_CARD_PROMOTED',
  ContextualTeamActionTypeStreamerActivated = 'CONTEXTUAL_TEAM_ACTION_TYPE_STREAMER_ACTIVATED',
  ContextualTeamActionTypeUnspecified = 'CONTEXTUAL_TEAM_ACTION_TYPE_UNSPECIFIED'
}

export type GameLogicGroup = {
  __typename?: 'GameLogicGroup';
  id: Scalars['ID']['output'];
  isParty: Scalars['Boolean']['output'];
  isSolo: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicGroupDetails = {
  __typename?: 'GameLogicGroupDetails';
  group: GameLogicGroup;
  players: Array<GameLogicPlayerDetails>;
  streamId: Scalars['ID']['output'];
};

export type GameLogicHand = {
  __typename?: 'GameLogicHand';
  cardIds: Array<Scalars['String']['output']>;
  matchEndCardIds: Array<Scalars['String']['output']>;
  previousCardIds: Array<Scalars['String']['output']>;
  votes: Array<GameLogicVote>;
};

export type GameLogicHighScoringCard = {
  __typename?: 'GameLogicHighScoringCard';
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  card: GameLogicCard;
  cardId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicHighScoringCardPromotedMsg = {
  __typename?: 'GameLogicHighScoringCardPromotedMsg';
  card: GameLogicHighScoringCard;
  groupId: Scalars['ID']['output'];
  groupName: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type GameLogicLastActiveCard = {
  __typename?: 'GameLogicLastActiveCard';
  activeCard: GameLogicActiveCard;
  status: GameLogicLastActiveCardStatus;
};

export enum GameLogicLastActiveCardStatus {
  StatusFailed = 'STATUS_FAILED',
  StatusSucceeded = 'STATUS_SUCCEEDED',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export enum GameLogicMatchBonusType {
  MatchBonusTypeUnspecified = 'MATCH_BONUS_TYPE_UNSPECIFIED',
  MatchBonusTypeVictoryRoyal = 'MATCH_BONUS_TYPE_VICTORY_ROYAL'
}

export type GameLogicMatchConfiguration = {
  __typename?: 'GameLogicMatchConfiguration';
  aonPointMultipliers: Array<Scalars['Float']['output']>;
  boosterCooldowns: Array<Scalars['Int']['output']>;
  cardGlobalRefs: Array<Scalars['String']['output']>;
  cardSwitchOutTimerDuration: Scalars['Int']['output'];
  freeReshuffleCount: Scalars['Int']['output'];
  gameId: Scalars['ID']['output'];
  handSize: Scalars['Int']['output'];
  matchBonusActivationRule: Scalars['String']['output'];
  matchBonusPoints: Scalars['Int']['output'];
  matchBonusType: GameLogicMatchBonusType;
  matchType: GameLogicStreamStateMatchType;
  pointsGainTime: Scalars['Int']['output'];
  reshuffleBaseCost: Scalars['Int']['output'];
  reshuffleCostMultiplier: Scalars['Float']['output'];
  seasonId: Scalars['ID']['output'];
};

export type GameLogicMatchEndedMsg = {
  __typename?: 'GameLogicMatchEndedMsg';
  bestCard?: Maybe<GameLogicCardDetails>;
  bestGroup?: Maybe<GameLogicGroupDetails>;
  bestPlayer?: Maybe<GameLogicPlayerDetails>;
  challengeStatuses: Array<GameLogicChallengeStatus>;
  channelId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  group: GameLogicGroup;
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  players: Array<GameLogicPlayer>;
  streamId: Scalars['ID']['output'];
};

export type GameLogicMatchPauseStateChangedMsg = {
  __typename?: 'GameLogicMatchPauseStateChangedMsg';
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  paused: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
};

export type GameLogicMatchStartedMsg = {
  __typename?: 'GameLogicMatchStartedMsg';
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  streamId: Scalars['ID']['output'];
};

export type GameLogicPlayer = {
  __typename?: 'GameLogicPlayer';
  activeCard: GameLogicActiveCard;
  activeChallengeId: Scalars['ID']['output'];
  allOrNothing: GameLogicAllOrNothing;
  bestPlay: GameLogicBestPlay;
  boosterCooldownTimer: GameLogicTimer;
  cardSwitchOutTimer: GameLogicTimer;
  fullUser: Scalars['Boolean']['output'];
  hand: GameLogicHand;
  heldBoosterId: Scalars['Int']['output'];
  inactivityWarningOn: Scalars['Boolean']['output'];
  isOnline: Scalars['Boolean']['output'];
  lastActiveCard: GameLogicLastActiveCard;
  name: Scalars['String']['output'];
  points: Scalars['Int']['output'];
  remainingInactiveSeconds: Scalars['Int']['output'];
  reshuffleCount: Scalars['Int']['output'];
  selfUsedBoosterCount: Scalars['Int']['output'];
  usedBoosterCount: Scalars['Int']['output'];
  usedMatchCards: Array<GameLogicPlayerUsedMatchCardsEntry>;
  userId: Scalars['ID']['output'];
  userName: Scalars['String']['output'];
};

export type GameLogicPlayerBoosterPoints = {
  __typename?: 'GameLogicPlayerBoosterPoints';
  boosterId: Scalars['Int']['output'];
  cardUserId: Scalars['ID']['output'];
  donatorUserId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
  userId: Scalars['ID']['output'];
};

export type GameLogicPlayerDetails = {
  __typename?: 'GameLogicPlayerDetails';
  groupName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
  user: ProfileProfile;
};

export type GameLogicPlayerJoinedMsg = {
  __typename?: 'GameLogicPlayerJoinedMsg';
  groupId: Scalars['ID']['output'];
  player: GameLogicPlayer;
  playerCardIds: Array<Scalars['String']['output']>;
  serverTime: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type GameLogicPlayerUsedMatchCardsEntry = {
  __typename?: 'GameLogicPlayerUsedMatchCardsEntry';
  key: Scalars['Int']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameLogicStreamState = {
  __typename?: 'GameLogicStreamState';
  matchSeqNum: Scalars['Int']['output'];
  matchState: GameLogicStreamStateMatchState;
  matchType: GameLogicStreamStateMatchType;
  roundNumber: Scalars['Int']['output'];
  roundPhase: GameLogicStreamStateRoundPhase;
  roundPhaseDeadline: Scalars['Int']['output'];
};

export enum GameLogicStreamStateMatchState {
  MatchStateActive = 'MATCH_STATE_ACTIVE',
  MatchStateEnded = 'MATCH_STATE_ENDED',
  MatchStatePaused = 'MATCH_STATE_PAUSED',
  MatchStateUnspecified = 'MATCH_STATE_UNSPECIFIED'
}

export enum GameLogicStreamStateMatchType {
  MatchTypeMultiRound = 'MATCH_TYPE_MULTI_ROUND',
  MatchTypeSingleRound = 'MATCH_TYPE_SINGLE_ROUND',
  MatchTypeUnspecified = 'MATCH_TYPE_UNSPECIFIED'
}

export enum GameLogicStreamStateRoundPhase {
  RoundPhaseCompetition = 'ROUND_PHASE_COMPETITION',
  RoundPhaseEnded = 'ROUND_PHASE_ENDED',
  RoundPhasePreparation = 'ROUND_PHASE_PREPARATION',
  RoundPhaseUnspecified = 'ROUND_PHASE_UNSPECIFIED'
}

export type GameLogicStreamerCard = {
  __typename?: 'GameLogicStreamerCard';
  baseCard: GameLogicCard;
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  draft: Scalars['Boolean']['output'];
  facecam: Scalars['String']['output'];
  facecamUrl: Scalars['String']['output'];
  familyId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  image: Scalars['String']['output'];
  imageUrl: Scalars['String']['output'];
  name: Scalars['String']['output'];
  saleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  video: Scalars['String']['output'];
  videoUrl: Scalars['String']['output'];
};


export type GameLogicStreamerCardBaseCardArgs = {
  season_id?: InputMaybe<Scalars['String']['input']>;
};

export type GameLogicTargetValue = {
  __typename?: 'GameLogicTargetValue';
  label: Scalars['String']['output'];
  selector?: Maybe<GameLogicTargetValueSelector>;
  value: Scalars['Int']['output'];
};

export type GameLogicTargetValueSelector = {
  __typename?: 'GameLogicTargetValueSelector';
  attribute: Scalars['String']['output'];
  value?: Maybe<GameLogicTargetValueSelectorValueUnion>;
};

export type GameLogicTargetValueSelectorDefaultValue = {
  __typename?: 'GameLogicTargetValueSelectorDefaultValue';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type GameLogicTargetValueSelectorValueUnion = BooleanType | GameLogicTargetValueSelectorDefaultValue | IntType | StringType;

export type GameLogicTimer = {
  __typename?: 'GameLogicTimer';
  endTime: Scalars['Int']['output'];
  startTime: Scalars['Int']['output'];
};

export type GameLogicVote = {
  __typename?: 'GameLogicVote';
  cardId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type GameSeason = {
  __typename?: 'GameSeason';
  badgeUrl: Scalars['String']['output'];
  cardBackgroundUrls: Array<GameSeasonCardBackgroundAsset>;
  endTime: Scalars['Timestamp']['output'];
  game: GameGame;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  progression: ProgressionSeasonProgression;
  progressionPauseReason: Scalars['String']['output'];
  progressionPaused: Scalars['Boolean']['output'];
  seasonBreak: Scalars['Boolean']['output'];
  seasonBreakReason: Scalars['String']['output'];
  /** @deprecated field is deprecated */
  seasonPauseReason: Scalars['String']['output'];
  /** @deprecated field is deprecated */
  seasonPaused: Scalars['Boolean']['output'];
  startTime: Scalars['Timestamp']['output'];
};


export type GameSeasonProgressionArgs = {
  user_id?: InputMaybe<Scalars['ID']['input']>;
};

export type GameSeasonCardBackgroundAsset = {
  __typename?: 'GameSeasonCardBackgroundAsset';
  rarity: RarityRarity;
  url: Scalars['String']['output'];
};

export type GameStateAttributesState = {
  __typename?: 'GameStateAttributesState';
  boolAttributes: Array<GameStateAttributesStateBoolAttributesEntry>;
  intAttributes: Array<GameStateAttributesStateIntAttributesEntry>;
  stringAttributes: Array<GameStateAttributesStateStringAttributesEntry>;
};

export type GameStateAttributesStateBoolAttributesEntry = {
  __typename?: 'GameStateAttributesStateBoolAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateAttributesStateIntAttributesEntry = {
  __typename?: 'GameStateAttributesStateIntAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type GameStateAttributesStateStringAttributesEntry = {
  __typename?: 'GameStateAttributesStateStringAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type GameStateBoosterState = {
  __typename?: 'GameStateBoosterState';
  activeBooster: GameLogicActiveBooster;
  booster: GameLogicBooster;
  sourcePlayerId: Scalars['ID']['output'];
  targetPlayerId: Scalars['ID']['output'];
};

export type GameStateCalModule = {
  __typename?: 'GameStateCALModule';
  expression: GameStateCalModuleExpression;
};

export type GameStateCalModuleBinaryExpression = {
  __typename?: 'GameStateCALModuleBinaryExpression';
  left: GameStateCalModuleExpression;
  op: GameStateCalModuleBinaryOp;
  right: GameStateCalModuleExpression;
};

export enum GameStateCalModuleBinaryOp {
  BinaryOpAnd = 'BINARY_OP_AND',
  BinaryOpOr = 'BINARY_OP_OR',
  BinaryOpUnspecified = 'BINARY_OP_UNSPECIFIED'
}

export type GameStateCalModuleBinding = {
  __typename?: 'GameStateCALModuleBinding';
  ident: Scalars['String']['output'];
  selector: GameStateCalModuleBinding;
};

export type GameStateCalModuleCheck = {
  __typename?: 'GameStateCALModuleCheck';
  check?: Maybe<GameStateCalModuleCheckCheckUnion>;
  label: Scalars['String']['output'];
};

export type GameStateCalModuleCheckCheckUnion = GameStateCalModuleCountEventIntAttributeCheck | GameStateCalModuleEventBoolAttributeCheck | GameStateCalModuleEventIntAttributeCheck | GameStateCalModuleEventStringAttributeCheck | GameStateCalModuleEventTypeCheck | GameStateCalModuleEventTypeCheckAfterEventIntAttributeCheck | GameStateCalModuleGlobalAnyBoolAttributeCheck | GameStateCalModuleGlobalBoolAttributeCheck | GameStateCalModuleGlobalIntAttributeCheck | GameStateCalModuleGlobalIntAttributeSumCheck | GameStateCalModuleGlobalStringAttributeCheck | GameStateCalModuleIs | GameStateCalModuleRepeatedEventBoolAttributeCheck | GameStateCalModuleRepeatedEventIntAttributeCheck | GameStateCalModuleRepeatedEventStringAttributeCheck | GameStateCalModuleRepeatedEventTypeCheck | GameStateCalModuleTimeoutCheck;

export type GameStateCalModuleCheckParam = {
  __typename?: 'GameStateCALModuleCheckParam';
  value?: Maybe<GameStateCalModuleCheckParamValueUnion>;
};

export type GameStateCalModuleCheckParamValueUnion = BooleanType | GameStateCalModuleBinding | IntType | StringType;

export type GameStateCalModuleCheckSequence = {
  __typename?: 'GameStateCALModuleCheckSequence';
  activationTimes: Array<Scalars['Int']['output']>;
  expressions: Array<GameStateCalModuleExpression>;
  intervals: Array<Scalars['Int']['output']>;
  label: Scalars['String']['output'];
};

export type GameStateCalModuleCountEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleCountEventIntAttributeCheck';
  attributes: Array<Scalars['String']['output']>;
  calculateNegative: Scalars['Boolean']['output'];
  eventName: Scalars['String']['output'];
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleEventBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleEventBoolAttributeCheck';
  attribute: Scalars['String']['output'];
  eventName: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateCalModuleEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleEventIntAttributeCheck';
  attribute: Scalars['String']['output'];
  eventName: Scalars['String']['output'];
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int']['output'];
};

export type GameStateCalModuleEventStringAttributeCheck = {
  __typename?: 'GameStateCALModuleEventStringAttributeCheck';
  attribute: Scalars['String']['output'];
  eventName: Scalars['String']['output'];
  operator: GameStateStringComparisonOperator;
  values: Array<Scalars['String']['output']>;
};

export type GameStateCalModuleEventTypeCheck = {
  __typename?: 'GameStateCALModuleEventTypeCheck';
  eventNames: Array<Scalars['String']['output']>;
};

export type GameStateCalModuleEventTypeCheckAfterEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleEventTypeCheckAfterEventIntAttributeCheck';
  firstCheck: GameStateCalModuleEventIntAttributeCheck;
  firstCheckSuccessTime: Scalars['Int']['output'];
  secondCheck: GameStateCalModuleEventTypeCheck;
  timerDuration: Scalars['Int']['output'];
};

export type GameStateCalModuleExpression = {
  __typename?: 'GameStateCALModuleExpression';
  expression?: Maybe<GameStateCalModuleExpressionExpressionUnion>;
};

export type GameStateCalModuleExpressionExpressionUnion = GameStateCalModuleBinaryExpression | GameStateCalModuleCheck | GameStateCalModuleCheckSequence | GameStateCalModuleForDuration | GameStateCalModuleGroup | GameStateCalModuleRepeat | GameStateCalModuleUnaryExpression | GameStateCalModuleWhen;

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type GameStateCalModuleForDuration = {
  __typename?: 'GameStateCALModuleForDuration';
  expression: GameStateCalModuleExpression;
  resetting: Scalars['Boolean']['output'];
  timeout: GameStateCalModuleExpression;
};

export type GameStateCalModuleGlobalAnyBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalAnyBoolAttributeCheck';
  attributes: Array<Scalars['String']['output']>;
  value: Scalars['Boolean']['output'];
};

export type GameStateCalModuleGlobalBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalBoolAttributeCheck';
  attribute: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateCalModuleGlobalIntAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalIntAttributeCheck';
  attribute: Scalars['String']['output'];
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int']['output'];
};

export type GameStateCalModuleGlobalIntAttributeSumCheck = {
  __typename?: 'GameStateCALModuleGlobalIntAttributeSumCheck';
  attributes: Array<Scalars['String']['output']>;
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int']['output'];
};

export type GameStateCalModuleGlobalStringAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalStringAttributeCheck';
  attribute: Scalars['String']['output'];
  operator: GameStateStringComparisonOperator;
  values: Array<Scalars['String']['output']>;
};

export type GameStateCalModuleGroup = {
  __typename?: 'GameStateCALModuleGroup';
  expression: GameStateCalModuleExpression;
};

export type GameStateCalModuleIs = {
  __typename?: 'GameStateCALModuleIs';
  checkParams: Array<GameStateCalModuleCheckParam>;
  op: GameStateComparisonOperator;
};

export type GameStateCalModuleRepeat = {
  __typename?: 'GameStateCALModuleRepeat';
  expression: GameStateCalModuleExpression;
  initialValue: Scalars['Int']['output'];
  label: Scalars['String']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventBoolAttributeCheck';
  check: GameStateCalModuleEventBoolAttributeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventIntAttributeCheck';
  check: GameStateCalModuleEventIntAttributeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventStringAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventStringAttributeCheck';
  check: GameStateCalModuleEventStringAttributeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventTypeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventTypeCheck';
  check: GameStateCalModuleEventTypeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleTimeoutCheck = {
  __typename?: 'GameStateCALModuleTimeoutCheck';
  duration: Scalars['Int']['output'];
  lastStateChangeTimestamp: Scalars['Int']['output'];
  lastTimestamp: Scalars['Int']['output'];
  timeLeft: Scalars['Int']['output'];
};

export type GameStateCalModuleUnaryExpression = {
  __typename?: 'GameStateCALModuleUnaryExpression';
  expression: GameStateCalModuleExpression;
  op: GameStateCalModuleUnaryOp;
};

export enum GameStateCalModuleUnaryOp {
  UnaryOpNot = 'UNARY_OP_NOT',
  UnaryOpUnspecified = 'UNARY_OP_UNSPECIFIED'
}

export type GameStateCalModuleWhen = {
  __typename?: 'GameStateCALModuleWhen';
  attribute: Scalars['String']['output'];
  cases: Array<GameStateCalModuleWhenCase>;
};

export type GameStateCalModuleWhenCase = {
  __typename?: 'GameStateCALModuleWhenCase';
  expression: GameStateCalModuleExpression;
  value?: Maybe<GameStateCalModuleWhenCaseValueUnion>;
};

export type GameStateCalModuleWhenCaseDefault = {
  __typename?: 'GameStateCALModuleWhenCaseDefault';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type GameStateCalModuleWhenCaseValueUnion = BooleanType | GameStateCalModuleWhenCaseDefault | IntType | StringType;

export type GameStateCardDealingState = {
  __typename?: 'GameStateCardDealingState';
  cardAvailability: Array<GameStateCardDealingStateCardAvailabilityEntry>;
  cardDealingModules: Array<GameStateCardDealingStateCardDealingModulesEntry>;
  cards: Array<GameStateCardDealingStateCardsEntry>;
};

export type GameStateCardDealingStateCalModulesList = {
  __typename?: 'GameStateCardDealingStateCALModulesList';
  modules: Array<GameStateCalModule>;
};

export type GameStateCardDealingStateCardAvailabilityEntry = {
  __typename?: 'GameStateCardDealingStateCardAvailabilityEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateCardDealingStateCardDealingModulesEntry = {
  __typename?: 'GameStateCardDealingStateCardDealingModulesEntry';
  key: Scalars['String']['output'];
  value: GameStateCardDealingStateCalModulesList;
};

export type GameStateCardDealingStateCardsEntry = {
  __typename?: 'GameStateCardDealingStateCardsEntry';
  key: Scalars['String']['output'];
  value: GameLogicCard;
};

export type GameStateCardState = {
  __typename?: 'GameStateCardState';
  failureModules: Array<GameStateCalModule>;
  successModules: Array<GameStateCalModule>;
};

export type GameStateChallengeState = {
  __typename?: 'GameStateChallengeState';
  challengeId: Scalars['ID']['output'];
  challengeState: GameLogicChallengeState;
  failureModule: GameStateCalModule;
  pickRate: Scalars['Float']['output'];
  successModule: GameStateCalModule;
  targetValues: Array<GameStateChallengeStateTargetValuesEntry>;
};

export type GameStateChallengeStateTargetValuesEntry = {
  __typename?: 'GameStateChallengeStateTargetValuesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type GameStateClientSession = {
  __typename?: 'GameStateClientSession';
  mailbox: Scalars['String']['output'];
  timestamp: Scalars['Int']['output'];
  token: Scalars['String']['output'];
};

export type GameStateClientSessionList = {
  __typename?: 'GameStateClientSessionList';
  sessions: Array<GameStateClientSession>;
};

export enum GameStateComparisonOperator {
  ComparisonOperatorEqual = 'COMPARISON_OPERATOR_EQUAL',
  ComparisonOperatorExists = 'COMPARISON_OPERATOR_EXISTS',
  ComparisonOperatorGreater = 'COMPARISON_OPERATOR_GREATER',
  ComparisonOperatorGreaterOrEqual = 'COMPARISON_OPERATOR_GREATER_OR_EQUAL',
  ComparisonOperatorIn = 'COMPARISON_OPERATOR_IN',
  ComparisonOperatorLess = 'COMPARISON_OPERATOR_LESS',
  ComparisonOperatorLessOrEqual = 'COMPARISON_OPERATOR_LESS_OR_EQUAL',
  ComparisonOperatorNotEqual = 'COMPARISON_OPERATOR_NOT_EQUAL',
  ComparisonOperatorNotExists = 'COMPARISON_OPERATOR_NOT_EXISTS',
  ComparisonOperatorNotIn = 'COMPARISON_OPERATOR_NOT_IN',
  ComparisonOperatorUnspecified = 'COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateContextualTeamActionState = {
  __typename?: 'GameStateContextualTeamActionState';
  deadlineMs: Scalars['Int']['output'];
  participants: Array<GameStateContextualTeamActionStateParticipantsEntry>;
  status: GameLogicContextualTeamActionStatus;
  type: GameLogicContextualTeamActionType;
};

export type GameStateContextualTeamActionStateParticipantsEntry = {
  __typename?: 'GameStateContextualTeamActionStateParticipantsEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateGameConfig = {
  __typename?: 'GameStateGameConfig';
  boosters: Array<GameStateGameConfigBoostersEntry>;
  challengeConfig: GameStateGameConfigChallengeConfig;
  featureFlags: Array<GameStateGameConfigFeatureFlagsEntry>;
  highScoringCardConfig: GameStateGameConfigHighScoringCardConfig;
  inactivityTimeouts: ConfigMetagameConfigInactivityTimeouts;
  matchConfiguration: GameLogicMatchConfiguration;
  uiTimings: ConfigMetagameConfigUiTimings;
};

export type GameStateGameConfigBoostersEntry = {
  __typename?: 'GameStateGameConfigBoostersEntry';
  key: Scalars['Int']['output'];
  value: GameLogicBooster;
};

export type GameStateGameConfigChallengeConfig = {
  __typename?: 'GameStateGameConfigChallengeConfig';
  availableChallengesCount: Scalars['Int']['output'];
  challenges: Array<GameStateGameConfigChallengeConfigChallengesEntry>;
  isEnabled: Scalars['Boolean']['output'];
};

export type GameStateGameConfigChallengeConfigChallengesEntry = {
  __typename?: 'GameStateGameConfigChallengeConfigChallengesEntry';
  key: Scalars['String']['output'];
  value: GameLogicChallenge;
};

export type GameStateGameConfigFeatureFlagsEntry = {
  __typename?: 'GameStateGameConfigFeatureFlagsEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type GameStateGameConfigHighScoringCardConfig = {
  __typename?: 'GameStateGameConfigHighScoringCardConfig';
  highScoringCardConfigs: Array<GameCardHighScoringCardConfig>;
  highScoringCardTimings: Array<GameCardHighScoringCardTimings>;
};

export type GameStateGroupRunnerState = {
  __typename?: 'GameStateGroupRunnerState';
  gameConfig: GameStateGameConfig;
  groupStartTime: Scalars['Int']['output'];
  groupState: GameStateGroupState;
  matchEndTime: Scalars['Int']['output'];
  matchPauseStartTime: Scalars['Int']['output'];
  matchPauseTimeTotal: Scalars['Int']['output'];
  matchTimeTrackerState: GameStateMatchTimeTrackerState;
  players: Array<GameStateGroupRunnerStatePlayersEntry>;
  randomState: GameStateRandomState;
  sessionTrackerState: GameStateSessionTrackerState;
  started: Scalars['Boolean']['output'];
  stepTimestamp: Scalars['Int']['output'];
  streamTrackerState: GameStateStreamTrackerState;
  timeOffset: Scalars['Int']['output'];
  timer: GameStateTimerState;
};

export type GameStateGroupRunnerStatePlayersEntry = {
  __typename?: 'GameStateGroupRunnerStatePlayersEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateGroupState = {
  __typename?: 'GameStateGroupState';
  activeChallenges: Array<GameStateChallengeState>;
  addedPlayers: Array<GameStateGroupStateAddedPlayersEntry>;
  boosterUsages: Array<GameStateGroupStateBoosterUsage>;
  contextualTeamActionState: GameStateContextualTeamActionState;
  group: GameLogicGroup;
  matchBonusActivationRule: GameStateCalModule;
  players: Array<GameStateGroupStatePlayersEntry>;
  removedPlayers: Array<GameStatePlayerState>;
  streamInfo: StreamInfoStreamInfo;
  timeTrackerState: GameStateTimeTrackerState;
};

export type GameStateGroupStateAddedPlayersEntry = {
  __typename?: 'GameStateGroupStateAddedPlayersEntry';
  key: Scalars['String']['output'];
  value: GameStatePlayerState;
};

export type GameStateGroupStateBoosterUsage = {
  __typename?: 'GameStateGroupStateBoosterUsage';
  boosterState: GameStateBoosterState;
  sourcePlayerId: Scalars['ID']['output'];
  targetPlayerId: Scalars['ID']['output'];
};

export type GameStateGroupStatePlayersEntry = {
  __typename?: 'GameStateGroupStatePlayersEntry';
  key: Scalars['String']['output'];
  value: GameStatePlayerState;
};

export type GameStateHighScoringCardState = {
  __typename?: 'GameStateHighScoringCardState';
  activeGroups: Array<GameStateHighScoringCardStateActiveGroupsEntry>;
  card: GameLogicHighScoringCard;
  deadline: Scalars['Int']['output'];
  groupId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type GameStateHighScoringCardStateActiveGroupsEntry = {
  __typename?: 'GameStateHighScoringCardStateActiveGroupsEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export enum GameStateIntComparisonOperator {
  IntComparisonOperatorEqual = 'INT_COMPARISON_OPERATOR_EQUAL',
  IntComparisonOperatorGreater = 'INT_COMPARISON_OPERATOR_GREATER',
  IntComparisonOperatorGreaterOrEqual = 'INT_COMPARISON_OPERATOR_GREATER_OR_EQUAL',
  IntComparisonOperatorLess = 'INT_COMPARISON_OPERATOR_LESS',
  IntComparisonOperatorLessOrEqual = 'INT_COMPARISON_OPERATOR_LESS_OR_EQUAL',
  IntComparisonOperatorNotEqual = 'INT_COMPARISON_OPERATOR_NOT_EQUAL',
  IntComparisonOperatorUnspecified = 'INT_COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateMatchTimeTrackerState = {
  __typename?: 'GameStateMatchTimeTrackerState';
  time: Scalars['Int']['output'];
  timeOffset: Scalars['Int']['output'];
  timer: GameStateTimerState;
};

export type GameStatePlayerState = {
  __typename?: 'GameStatePlayerState';
  cardDealingState: GameStateCardDealingState;
  cardState: GameStateCardState;
  debugEvents: Scalars['Boolean']['output'];
  groupId: Scalars['ID']['output'];
  lastHeldBoosterId: Scalars['Int']['output'];
  player: GameLogicPlayer;
  streamId: Scalars['ID']['output'];
};

export type GameStateRandomState = {
  __typename?: 'GameStateRandomState';
  seed: Scalars['Int']['output'];
};

export type GameStateSessionTrackerState = {
  __typename?: 'GameStateSessionTrackerState';
  playerSessions: Array<GameStateSessionTrackerStatePlayerSessionsEntry>;
  spectatorSessions: Array<GameStateSessionTrackerStateSpectatorSessionsEntry>;
};

export type GameStateSessionTrackerStatePlayerSessionsEntry = {
  __typename?: 'GameStateSessionTrackerStatePlayerSessionsEntry';
  key: Scalars['String']['output'];
  value: GameStateClientSessionList;
};

export type GameStateSessionTrackerStateSpectatorSessionsEntry = {
  __typename?: 'GameStateSessionTrackerStateSpectatorSessionsEntry';
  key: Scalars['String']['output'];
  value: GameStateClientSessionList;
};

export type GameStateStreamGroupsTrackerState = {
  __typename?: 'GameStateStreamGroupsTrackerState';
  bestCard: GameLogicCardDetails;
  bestGroup: GameLogicGroupDetails;
  bestPlayer: GameLogicPlayerDetails;
};

export type GameStateStreamState = {
  __typename?: 'GameStateStreamState';
  groups: Array<Scalars['String']['output']>;
  streamGroupsTracker: GameStateStreamGroupsTrackerState;
  streamInfo: StreamInfoStreamInfo;
  streamTracker: GameStateStreamTrackerState;
};

export type GameStateStreamTrackerState = {
  __typename?: 'GameStateStreamTrackerState';
  globalAttributes: GameStateAttributesState;
  globalAttributesHash: Scalars['Int']['output'];
  globalsChanged: Scalars['Boolean']['output'];
  matchEndTime: Scalars['Int']['output'];
  matchPauseStartTime: Scalars['Int']['output'];
  matchPauseTimeTotal: Scalars['Int']['output'];
  matchStartTime: Scalars['Int']['output'];
  matchStateChanged: Scalars['Boolean']['output'];
  previousMatchState: GameLogicStreamStateMatchState;
  roundPhaseChanged: Scalars['Boolean']['output'];
  streamState: GameLogicStreamState;
};

export enum GameStateStringComparisonOperator {
  StringComparisonOperatorEqual = 'STRING_COMPARISON_OPERATOR_EQUAL',
  StringComparisonOperatorIn = 'STRING_COMPARISON_OPERATOR_IN',
  StringComparisonOperatorNotEqual = 'STRING_COMPARISON_OPERATOR_NOT_EQUAL',
  StringComparisonOperatorNotIn = 'STRING_COMPARISON_OPERATOR_NOT_IN',
  StringComparisonOperatorUnspecified = 'STRING_COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateTimeTrackerState = {
  __typename?: 'GameStateTimeTrackerState';
  entries: Array<GameStateTimeTrackerStateEntriesEntry>;
  matchActive: Scalars['Boolean']['output'];
};

export type GameStateTimeTrackerStateEntriesEntry = {
  __typename?: 'GameStateTimeTrackerStateEntriesEntry';
  key: Scalars['String']['output'];
  value: GameStateTimeTrackerStateTimeTrackerEntry;
};

export type GameStateTimeTrackerStateTimeTrackerEntry = {
  __typename?: 'GameStateTimeTrackerStateTimeTrackerEntry';
  disconnectedTimestamp: Scalars['Int']['output'];
  idle: Scalars['Boolean']['output'];
  idleTimestamp: Scalars['Int']['output'];
  lastOnlineTimestamp: Scalars['Int']['output'];
  online: Scalars['Boolean']['output'];
  totalIdleTime: Scalars['Int']['output'];
  totalTime: Scalars['Int']['output'];
};

export type GameStateTimerState = {
  __typename?: 'GameStateTimerState';
  activeTimeout: GameStateTimerStateTimeout;
  /** @deprecated field is deprecated */
  activeTimerDeadline: Scalars['Int']['output'];
  /** @deprecated field is deprecated */
  timeouts: Array<Scalars['Int']['output']>;
  timeoutsWithMetadata: Array<GameStateTimerStateTimeout>;
};

export type GameStateTimerStateMetadata = {
  __typename?: 'GameStateTimerStateMetadata';
  source: Scalars['String']['output'];
};

export type GameStateTimerStateTimeout = {
  __typename?: 'GameStateTimerStateTimeout';
  expirationTimestamp: Scalars['Int']['output'];
  metadata: GameStateTimerStateMetadata;
};

export type GameUserProgression = {
  __typename?: 'GameUserProgression';
  experiencePoints: Scalars['Int']['output'];
  level: Scalars['Int']['output'];
  userId: Scalars['ID']['output'];
};

export type GoalCardBatchGetGoalCardsResponse = {
  __typename?: 'GoalCardBatchGetGoalCardsResponse';
  goalCards: Array<GoalCardGoalCard>;
};

export type GoalCardGetSlotOptionsResponse = {
  __typename?: 'GoalCardGetSlotOptionsResponse';
  cardOptions: Array<GoalCardGoalCard>;
};

export type GoalCardGoalCard = {
  __typename?: 'GoalCardGoalCard';
  cardGoalGroup: Scalars['String']['output'];
  /** counter_config_ids defines which counters the goal card is tracking */
  counterConfigIds: Array<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  disabled: Scalars['Boolean']['output'];
  game?: Maybe<GameGame>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  rarity: RarityRarity;
  requiredItemIds: Array<Scalars['String']['output']>;
  requiresTeam: Scalars['Boolean']['output'];
  reward: RewardRewardType;
  /**
   * target is the target value for the counter where an award is awarded to
   *  the user
   */
  target: Scalars['Float']['output'];
  targetType: GoalCardGoalCardTargetType;
};

export type GoalCardGoalCardSlot = {
  __typename?: 'GoalCardGoalCardSlot';
  cardOptions?: Maybe<Array<GoalCardGoalCard>>;
  goalCard?: Maybe<GoalCardGoalCard>;
  goalCardId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  progress?: Maybe<GoalCardGoalCardSlotProgress>;
  resetTime?: Maybe<Scalars['Timestamp']['output']>;
  reward?: Maybe<RewardReward>;
};

export type GoalCardGoalCardSlotProgress = {
  __typename?: 'GoalCardGoalCardSlotProgress';
  completed: Scalars['Boolean']['output'];
  percentage: Scalars['Float']['output'];
  value: Scalars['Float']['output'];
};

export enum GoalCardGoalCardTargetType {
  TargetTypeSingleUpdate = 'TARGET_TYPE_SINGLE_UPDATE',
  TargetTypeTotal = 'TARGET_TYPE_TOTAL',
  TargetTypeUnspecified = 'TARGET_TYPE_UNSPECIFIED',
  TargetTypeUpdateCount = 'TARGET_TYPE_UPDATE_COUNT'
}

export type GoalCardListGoalCardSlotsResponse = {
  __typename?: 'GoalCardListGoalCardSlotsResponse';
  slots: Array<GoalCardGoalCardSlot>;
};

export type GoalCardReshuffleSlotResponse = {
  __typename?: 'GoalCardReshuffleSlotResponse';
  cardOptions: Array<GoalCardGoalCard>;
};

export type GoalCardSetGoalCardSlotResponse = {
  __typename?: 'GoalCardSetGoalCardSlotResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

/**
 * A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *
 *      service Foo {
 *        rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *      }
 *
 *  The JSON representation for `Empty` is empty JSON object `{}`.
 */
export type GoogleProtobufEmpty = {
  __typename?: 'GoogleProtobufEmpty';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

/**
 * `FieldMask` represents a set of symbolic field paths, for example:
 *
 *      paths: "f.a"
 *      paths: "f.b.d"
 *
 *  Here `f` represents a field in some root message, `a` and `b`
 *  fields in the message found in `f`, and `d` a field found in the
 *  message in `f.b`.
 *
 *  Field masks are used to specify a subset of fields that should be
 *  returned by a get operation or modified by an update operation.
 *  Field masks also have a custom JSON encoding (see below).
 *
 *  # Field Masks in Projections
 *
 *  When used in the context of a projection, a response message or
 *  sub-message is filtered by the API to only contain those fields as
 *  specified in the mask. For example, if the mask in the previous
 *  example is applied to a response message as follows:
 *
 *      f {
 *        a : 22
 *        b {
 *          d : 1
 *          x : 2
 *        }
 *        y : 13
 *      }
 *      z: 8
 *
 *  The result will not contain specific values for fields x,y and z
 *  (their value will be set to the default, and omitted in proto text
 *  output):
 *
 *
 *      f {
 *        a : 22
 *        b {
 *          d : 1
 *        }
 *      }
 *
 *  A repeated field is not allowed except at the last position of a
 *  paths string.
 *
 *  If a FieldMask object is not present in a get operation, the
 *  operation applies to all fields (as if a FieldMask of all fields
 *  had been specified).
 *
 *  Note that a field mask does not necessarily apply to the
 *  top-level response message. In case of a REST get operation, the
 *  field mask applies directly to the response, but in case of a REST
 *  list operation, the mask instead applies to each individual message
 *  in the returned resource list. In case of a REST custom method,
 *  other definitions may be used. Where the mask applies will be
 *  clearly documented together with its declaration in the API.  In
 *  any case, the effect on the returned resource/resources is required
 *  behavior for APIs.
 *
 *  # Field Masks in Update Operations
 *
 *  A field mask in update operations specifies which fields of the
 *  targeted resource are going to be updated. The API is required
 *  to only change the values of the fields as specified in the mask
 *  and leave the others untouched. If a resource is passed in to
 *  describe the updated values, the API ignores the values of all
 *  fields not covered by the mask.
 *
 *  If a repeated field is specified for an update operation, new values will
 *  be appended to the existing repeated field in the target resource. Note that
 *  a repeated field is only allowed in the last position of a `paths` string.
 *
 *  If a sub-message is specified in the last position of the field mask for an
 *  update operation, then new value will be merged into the existing sub-message
 *  in the target resource.
 *
 *  For example, given the target message:
 *
 *      f {
 *        b {
 *          d: 1
 *          x: 2
 *        }
 *        c: [1]
 *      }
 *
 *  And an update message:
 *
 *      f {
 *        b {
 *          d: 10
 *        }
 *        c: [2]
 *      }
 *
 *  then if the field mask is:
 *
 *   paths: ["f.b", "f.c"]
 *
 *  then the result will be:
 *
 *      f {
 *        b {
 *          d: 10
 *          x: 2
 *        }
 *        c: [1, 2]
 *      }
 *
 *  An implementation may provide options to override this default behavior for
 *  repeated and message fields.
 *
 *  In order to reset a field's value to the default, the field must
 *  be in the mask and set to the default value in the provided resource.
 *  Hence, in order to reset all fields of a resource, provide a default
 *  instance of the resource and set all fields in the mask, or do
 *  not provide a mask as described below.
 *
 *  If a field mask is not present on update, the operation applies to
 *  all fields (as if a field mask of all fields has been specified).
 *  Note that in the presence of schema evolution, this may mean that
 *  fields the client does not know and has therefore not filled into
 *  the request will be reset to their default. If this is unwanted
 *  behavior, a specific service may require a client to always specify
 *  a field mask, producing an error if not.
 *
 *  As with get operations, the location of the resource which
 *  describes the updated values in the request message depends on the
 *  operation kind. In any case, the effect of the field mask is
 *  required to be honored by the API.
 *
 *  ## Considerations for HTTP REST
 *
 *  The HTTP kind of an update operation which uses a field mask must
 *  be set to PATCH instead of PUT in order to satisfy HTTP semantics
 *  (PUT must only be used for full updates).
 *
 *  # JSON Encoding of Field Masks
 *
 *  In JSON, a field mask is encoded as a single string where paths are
 *  separated by a comma. Fields name in each path are converted
 *  to/from lower-camel naming conventions.
 *
 *  As an example, consider the following message declarations:
 *
 *      message Profile {
 *        User user = 1;
 *        Photo photo = 2;
 *      }
 *      message User {
 *        string display_name = 1;
 *        string address = 2;
 *      }
 *
 *  In proto a field mask for `Profile` may look as such:
 *
 *      mask {
 *        paths: "user.display_name"
 *        paths: "photo"
 *      }
 *
 *  In JSON, the same mask is represented as below:
 *
 *      {
 *        mask: "user.displayName,photo"
 *      }
 *
 *  # Field Masks and Oneof Fields
 *
 *  Field masks treat fields in oneofs just as regular fields. Consider the
 *  following message:
 *
 *      message SampleMessage {
 *        oneof test_oneof {
 *          string name = 4;
 *          SubMessage sub_message = 9;
 *        }
 *      }
 *
 *  The field mask can be:
 *
 *      mask {
 *        paths: "name"
 *      }
 *
 *  Or:
 *
 *      mask {
 *        paths: "sub_message"
 *      }
 *
 *  Note that oneof type names ("test_oneof" in this case) cannot be used in
 *  paths.
 *
 *  ## Field Mask Verification
 *
 *  The implementation of any API method which has a FieldMask type field in the
 *  request should verify the included field paths, and return an
 *  `INVALID_ARGUMENT` error if any path is unmappable.
 */
export type GoogleProtobufFieldMaskInput = {
  /** The set of field mask paths. */
  paths?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type IntType = {
  __typename?: 'IntType';
  /** The wrapped value of type Int */
  value: Scalars['Int']['output'];
};

export type InventoryAddEntitlementsResponse = {
  __typename?: 'InventoryAddEntitlementsResponse';
  items: Array<InventoryInventoryItem>;
};

export type InventoryConsumeItemResponse = {
  __typename?: 'InventoryConsumeItemResponse';
  items: Array<InventoryInventoryItem>;
};

export type InventoryInventoryEvent = {
  __typename?: 'InventoryInventoryEvent';
  event?: Maybe<InventoryInventoryEventEventUnion>;
  id: Scalars['ID']['output'];
  reason: ReasonReason;
  userId: Scalars['ID']['output'];
};

export type InventoryInventoryEventEventUnion = InventoryItemConsumption | InventoryItemEntitlement;

export type InventoryInventoryItem = {
  __typename?: 'InventoryInventoryItem';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type InventoryInventoryUpdateEvent = {
  __typename?: 'InventoryInventoryUpdateEvent';
  events: Array<InventoryInventoryEvent>;
};

export type InventoryItemConsumption = {
  __typename?: 'InventoryItemConsumption';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type InventoryItemConsumptionInput = {
  itemCount?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
};

export type InventoryItemEntitlement = {
  __typename?: 'InventoryItemEntitlement';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type InventoryItemEntitlementInput = {
  itemCount?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
};

export type InventoryListUserInventoryRequestFilterAttributeFilterInput = {
  key?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type InventoryListUserInventoryRequestFilterInput = {
  /** attribute optional attribute filter */
  attribute?: InputMaybe<InventoryListUserInventoryRequestFilterAttributeFilterInput>;
  /** game_id optional game filter */
  gameId?: InputMaybe<Scalars['ID']['input']>;
  /** item_type optional item type filter */
  itemType?: InputMaybe<ItemItemType>;
  /** season_id optional season filter */
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

export type InventoryListUserInventoryResponse = {
  __typename?: 'InventoryListUserInventoryResponse';
  items: Array<InventoryInventoryItem>;
  pageInfo: ApiPageInfo;
};

export type InvitationCreateInvitationCodesResponse = {
  __typename?: 'InvitationCreateInvitationCodesResponse';
  codes: Array<InvitationInvitationCode>;
};

export type InvitationInvitationCode = {
  __typename?: 'InvitationInvitationCode';
  code: Scalars['String']['output'];
  createdAt: Scalars['Timestamp']['output'];
  ownerId: Scalars['ID']['output'];
  usedAt?: Maybe<Scalars['Timestamp']['output']>;
  usedBy?: Maybe<ProfileProfile>;
  usedById?: Maybe<Scalars['ID']['output']>;
};

export type InvitationInvitationCodeUpdateEvent = {
  __typename?: 'InvitationInvitationCodeUpdateEvent';
  codes: Array<InvitationInvitationCode>;
  updateType: InvitationInvitationCodeUpdateEventUpdateType;
  updatedAt: Scalars['Timestamp']['output'];
};

export enum InvitationInvitationCodeUpdateEventUpdateType {
  UpdateTypeCreated = 'UPDATE_TYPE_CREATED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUsed = 'UPDATE_TYPE_USED'
}

export type InvitationListInvitationCodesResponse = {
  __typename?: 'InvitationListInvitationCodesResponse';
  codes: Array<InvitationInvitationCode>;
};

export type ItemBatchExpandItemsResponse = {
  __typename?: 'ItemBatchExpandItemsResponse';
  items: Array<ItemItem>;
};

export type ItemBatchGetItemsResponse = {
  __typename?: 'ItemBatchGetItemsResponse';
  items: Array<ItemItem>;
};

export type ItemExpandItemResponse = {
  __typename?: 'ItemExpandItemResponse';
  items: Array<ItemItem>;
};

export type ItemGetItemResponse = {
  __typename?: 'ItemGetItemResponse';
  item: ItemItem;
};

export type ItemItem = {
  __typename?: 'ItemItem';
  attributes: AttributeAttributeMap;
  bootstraps?: Maybe<Array<ItemItemBootstrap>>;
  channel?: Maybe<ChannelChannel>;
  channelId: Scalars['ID']['output'];
  children?: Maybe<Array<ItemItem>>;
  consumable: Scalars['Boolean']['output'];
  details?: Maybe<ItemItemDetailsUnion>;
  disabled: Scalars['Boolean']['output'];
  game?: Maybe<GameGame>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  inventoryItem: InventoryInventoryItem;
  name: Scalars['String']['output'];
  /** if the parent item is owned, this item is owned as well */
  parentItemId: Scalars['ID']['output'];
  season?: Maybe<GameSeason>;
  seasonId: Scalars['ID']['output'];
  type: ItemItemType;
  /** unlock_item_id what if any item is required to unlock this item for bundles and other consumption */
  unlockItemId: Scalars['ID']['output'];
  updatedAt: Scalars['Timestamp']['output'];
};


export type ItemItemInventoryItemArgs = {
  user_id: Scalars['ID']['input'];
};

export type ItemItemBootstrap = {
  __typename?: 'ItemItemBootstrap';
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
  revision: Scalars['String']['output'];
};

export type ItemItemBootstrapInput = {
  itemCount?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
};

export type ItemItemCount = {
  __typename?: 'ItemItemCount';
  count: Scalars['Int']['output'];
  type: ItemItemType;
};

export type ItemItemDetailsUnion = AvatarAnimation | AvatarAvatarPart | EmojiEmoji | GameLogicCard | GameLogicStreamerCard;

export type ItemItemStat = {
  __typename?: 'ItemItemStat';
  counts: Array<ItemItemCount>;
  gameId: Scalars['ID']['output'];
};

export type ItemItemTotalCount = {
  __typename?: 'ItemItemTotalCount';
  disabled: Scalars['Int']['output'];
  total: Scalars['Int']['output'];
};

export enum ItemItemType {
  TypeAvatarItem = 'TYPE_AVATAR_ITEM',
  TypeBootstrap = 'TYPE_BOOTSTRAP',
  TypeDailyGoalCardSlot = 'TYPE_DAILY_GOAL_CARD_SLOT',
  TypeEmoji = 'TYPE_EMOJI',
  TypeEmote = 'TYPE_EMOTE',
  TypeGameCard = 'TYPE_GAME_CARD',
  TypeStreamerCard = 'TYPE_STREAMER_CARD',
  TypeSubscription = 'TYPE_SUBSCRIPTION',
  TypeUnlock = 'TYPE_UNLOCK',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type ItemListItemsRequestFilterAttributeInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type ItemListItemsRequestFilterInput = {
  attribute?: InputMaybe<ItemListItemsRequestFilterAttributeInput>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<ItemItemType>;
  parentId?: InputMaybe<Scalars['ID']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

export type ItemListItemsResponse = {
  __typename?: 'ItemListItemsResponse';
  count?: Maybe<ItemItemTotalCount>;
  items: Array<ItemItem>;
  pageInfo: ApiPageInfo;
};

export type MatchCardCount = {
  __typename?: 'MatchCardCount';
  card: GameLogicCard;
  cardId: Scalars['ID']['output'];
  count: Scalars['Int']['output'];
};

export type MatchChallengeUpdate = {
  __typename?: 'MatchChallengeUpdate';
  content?: Maybe<MatchChallengeUpdateContentUnion>;
};

export type MatchChallengeUpdateContentUnion = MatchChallengeUpdateReset | MatchChallengeUpdateStatusUpdate;

export type MatchChallengeUpdateReset = {
  __typename?: 'MatchChallengeUpdateReset';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type MatchChallengeUpdateStatusUpdate = {
  __typename?: 'MatchChallengeUpdateStatusUpdate';
  challenges: Array<GameLogicChallengeStatus>;
};

export type MatchGetGroupChatIdResponse = {
  __typename?: 'MatchGetGroupChatIDResponse';
  chatId: Scalars['ID']['output'];
};

export type MatchGetGroupStateResponse = {
  __typename?: 'MatchGetGroupStateResponse';
  runnerState: GameStateGroupRunnerState;
  /** @deprecated field is deprecated */
  state: GameStateGroupState;
};

export type MatchGetMatchStateResponse = {
  __typename?: 'MatchGetMatchStateResponse';
  matchState: GameLogicStreamStateMatchState;
};

export type MatchGetStreamStateResponse = {
  __typename?: 'MatchGetStreamStateResponse';
  gameConfig: GameStateGameConfig;
  groups: Array<Scalars['String']['output']>;
  highScoringCard: GameStateHighScoringCardState;
  started: Scalars['Boolean']['output'];
  streamGroupsTracker: GameStateStreamGroupsTrackerState;
  streamInfo: StreamInfoStreamInfo;
  streamTracker: GameStateStreamTrackerState;
};

export type MatchGetTopActiveCardsResponse = {
  __typename?: 'MatchGetTopActiveCardsResponse';
  topCards: Array<MatchCardCount>;
};

export type MatchStreamSpectatorChangeGroupEvent = {
  __typename?: 'MatchStreamSpectatorChangeGroupEvent';
  groupId: Scalars['ID']['output'];
};

export type MatchStreamSpectatorCoordinationEvent = {
  __typename?: 'MatchStreamSpectatorCoordinationEvent';
  event?: Maybe<MatchStreamSpectatorCoordinationEventEventUnion>;
};

export type MatchStreamSpectatorCoordinationEventEventUnion = MatchStreamSpectatorChangeGroupEvent;

export type MatchTopCardsUpdate = {
  __typename?: 'MatchTopCardsUpdate';
  content?: Maybe<MatchTopCardsUpdateContentUnion>;
};

export type MatchTopCardsUpdateCardCountUpdate = {
  __typename?: 'MatchTopCardsUpdateCardCountUpdate';
  cards: Array<MatchCardCount>;
};

export type MatchTopCardsUpdateContentUnion = MatchTopCardsUpdateCardCountUpdate | MatchTopCardsUpdateReset;

export type MatchTopCardsUpdateReset = {
  __typename?: 'MatchTopCardsUpdateReset';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type MediaBatchGetMediaUrlResponse = {
  __typename?: 'MediaBatchGetMediaURLResponse';
  urls: Array<Scalars['String']['output']>;
};

export type MediaMediaOptionsInput = {
  height?: InputMaybe<Scalars['Int']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

export type MlControllerGetHudScaleResponse = {
  __typename?: 'MlControllerGetHUDScaleResponse';
  estimatedScale: Scalars['Int']['output'];
  isScaleSufficient: Scalars['Boolean']['output'];
  mlDisabled: Scalars['Boolean']['output'];
  suggestedMinimumScale: Scalars['Int']['output'];
};

export enum ModerationAppealStatus {
  AppealStatusAccepted = 'APPEAL_STATUS_ACCEPTED',
  AppealStatusDeclined = 'APPEAL_STATUS_DECLINED',
  AppealStatusPending = 'APPEAL_STATUS_PENDING',
  AppealStatusUnspecified = 'APPEAL_STATUS_UNSPECIFIED'
}

export enum ModerationBanStatus {
  BanStatusActive = 'BAN_STATUS_ACTIVE',
  BanStatusInactive = 'BAN_STATUS_INACTIVE',
  BanStatusUnspecified = 'BAN_STATUS_UNSPECIFIED'
}

export type ModerationListPlatformBanAppealsResponse = {
  __typename?: 'ModerationListPlatformBanAppealsResponse';
  appeals: Array<ModerationPlatformBanAppeal>;
  pageInfo: ApiPageInfo;
};

export type ModerationPlatformBan = {
  __typename?: 'ModerationPlatformBan';
  appeal?: Maybe<ModerationPlatformBanAppeal>;
  appealApproved: Scalars['Boolean']['output'];
  banId: Scalars['ID']['output'];
  bannedAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  moderator: ProfileProfile;
  moderatorId: Scalars['ID']['output'];
  status: ModerationBanStatus;
  unbannedAt?: Maybe<Scalars['Timestamp']['output']>;
  unbannedBy: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
  violation: ModerationViolation;
};

export type ModerationPlatformBanAppeal = {
  __typename?: 'ModerationPlatformBanAppeal';
  appealText: Scalars['String']['output'];
  ban: ModerationPlatformBan;
  banId: Scalars['ID']['output'];
  closedAt?: Maybe<Scalars['Timestamp']['output']>;
  createdAt: Scalars['Timestamp']['output'];
  reviewer?: Maybe<ProfileProfile>;
  reviewerComment: Scalars['String']['output'];
  reviewerId: Scalars['ID']['output'];
  status: ModerationAppealStatus;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ModerationPlatformUserBannedNotification = {
  __typename?: 'ModerationPlatformUserBannedNotification';
  bannedAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  userId: Scalars['ID']['output'];
  violation: ModerationViolation;
};

export enum ModerationViolation {
  ViolationChildSafety = 'VIOLATION_CHILD_SAFETY',
  ViolationCircumventionEvasion = 'VIOLATION_CIRCUMVENTION_EVASION',
  ViolationExtremism = 'VIOLATION_EXTREMISM',
  ViolationGraphicRealWorldMedia = 'VIOLATION_GRAPHIC_REAL_WORLD_MEDIA',
  ViolationHarassmentTargetedAbuse = 'VIOLATION_HARASSMENT_TARGETED_ABUSE',
  ViolationHatefulBehavior = 'VIOLATION_HATEFUL_BEHAVIOR',
  ViolationIllegalHarmfulAndRestrictedActivity = 'VIOLATION_ILLEGAL_HARMFUL_AND_RESTRICTED_ACTIVITY',
  ViolationOffPlatformBehavior = 'VIOLATION_OFF_PLATFORM_BEHAVIOR',
  ViolationOther = 'VIOLATION_OTHER',
  ViolationPlatformManipulation = 'VIOLATION_PLATFORM_MANIPULATION',
  ViolationRepeatedCopyrightInfringement = 'VIOLATION_REPEATED_COPYRIGHT_INFRINGEMENT',
  ViolationResponsibleStreaming = 'VIOLATION_RESPONSIBLE_STREAMING',
  ViolationRestrictedGamesAndGamesWithGraphicFootage = 'VIOLATION_RESTRICTED_GAMES_AND_GAMES_WITH_GRAPHIC_FOOTAGE',
  ViolationSelfHarm = 'VIOLATION_SELF_HARM',
  ViolationSexualBehavior = 'VIOLATION_SEXUAL_BEHAVIOR',
  ViolationSpam = 'VIOLATION_SPAM',
  ViolationUnspecified = 'VIOLATION_UNSPECIFIED',
  ViolationViolence = 'VIOLATION_VIOLENCE'
}

export type Mutation = {
  __typename?: 'Mutation';
  /** FriendsService.AcceptFriendRequest */
  acceptFriendRequest?: Maybe<FriendsAcceptFriendRequestResponse>;
  /** ChannelService.AcceptMonetizationTerms */
  acceptMonetizationTerms?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.AddOAuth2Consent */
  addOAuth2Consent?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.CreatePushNotificationToken */
  addPushNotificationToken?: Maybe<GoogleProtobufEmpty>;
  /** ReactionService.AddReaction */
  addReaction?: Maybe<ReactionReactionState>;
  /** UserInventoryAdminService.AddEntitlements */
  addUserEntitlements?: Maybe<InventoryAddEntitlementsResponse>;
  /** WalletAdminService.AddCurrencies */
  addWalletCurrencies?: Maybe<WalletAddCurrenciesResponse>;
  /** ChatModerationService.AllowModerationItem */
  allowChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.BanUser */
  banChannelUser?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.BanUser */
  banPlatformUser?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.BatchDeleteNotifications */
  batchDeleteNotifications?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.BatchMarkNotificationsRead */
  batchMarkNotificationsRead?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.BlockUser */
  blockUser?: Maybe<FriendsBlockUserResponse>;
  /** StoreServiceV2.BuyWithInGameCurrency */
  buyWithInGameCurrency?: Maybe<StoreV2BuyWithInGameCurrencyResponse>;
  /** StoreServiceV2.BuyWithPayment */
  buyWithPayment?: Maybe<StoreV2BuyWithPaymentResponse>;
  /** ChannelSubscriptionService.CancelSubscription */
  cancelChannelSubscription?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.CancelDeletion */
  cancelDataDeletion?: Maybe<GoogleProtobufEmpty>;
  /** StoreServiceV2.CancelOrder */
  cancelOrder?: Maybe<GoogleProtobufEmpty>;
  /** ChannelSubscriptionService.CheckoutExistingSubscription */
  checkoutExistingChannelSubscription?: Maybe<SubscriptionCheckoutExistingSubscriptionResponse>;
  /** ChannelSubscriptionService.CheckoutNewSubscription */
  checkoutNewChannelSubscription?: Maybe<SubscriptionCheckoutNewSubscriptionResponse>;
  /** RewardService.ClaimReward */
  claimReward?: Maybe<RewardClaimRewardResponse>;
  /** ChatModerationService.ClearModerationItem */
  clearChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.ClearPushNotifications */
  clearPushNotifications?: Maybe<GoogleProtobufEmpty>;
  /** UserInventoryAdminService.ConsumeItem */
  consumeUserItem?: Maybe<InventoryConsumeItemResponse>;
  /** AuthAdminService.CreateAccount */
  createAccount?: Maybe<AuthAccount>;
  /** AnnouncementService.CreateAnnouncement */
  createAnnouncement?: Maybe<AnnouncementAnnouncement>;
  /** AnnouncementService.CreateAnnouncementImageUploadToken */
  createAnnouncementImageUploadToken?: Maybe<AnnouncementCreateAnnouncementImageUploadTokenResponse>;
  /** ChallengeService.CreateChallenge */
  createChallenge?: Maybe<GameLogicChallenge>;
  /** ChallengeSessionService.CreateChallengeSession */
  createChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelService.CreateChannel */
  createChannel?: Maybe<ChannelChannel>;
  /** ChannelService.CreateChannelAssetUploadToken */
  createChannelAssetUploadToken?: Maybe<ChannelCreateChannelAssetUploadTokenResponse>;
  /** ChannelModerationService.CreateBanAppeal */
  createChannelBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** ChannelEmojiService.CreateChannelEmoji */
  createChannelEmoji?: Maybe<EmojiEmoji>;
  /** EmojiService.CreateEmojiUploadToken */
  createEmojiUploadToken?: Maybe<EmojiCreateEmojiUploadTokenResponse>;
  /** StreamIngestConfigService.CreateIngestConfigs */
  createIngestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** InvitationService.CreateInvitationCodes */
  createInvitationCodes?: Maybe<InvitationCreateInvitationCodesResponse>;
  /** ItemService.CreateItemBootstrap */
  createItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.CreateParty */
  createParty?: Maybe<PartyParty>;
  /** PartyService.CreatePartyInvitation */
  createPartyInvitation?: Maybe<PartyPartyInvitation>;
  /** PartyService.CreatePartyMember */
  createPartyMember?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.CreateUserPlatformBanAppeal */
  createPlatformBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.CreatePlatformEmoji */
  createPlatformEmoji?: Maybe<EmojiEmoji>;
  /** SupportService.CreateReport */
  createReport?: Maybe<SupportReport>;
  /** ChannelConfigService.CreateStreamBackendConfig */
  createStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StreamerCardService.CreateStreamerCardAssetUploadToken */
  createStreamerCardAssetUploadToken?: Maybe<GameCardCreateStreamerCardAssetUploadTokenResponse>;
  /** StreamerCardService.CreateStreamerCardDraft */
  createStreamerCardDraft?: Maybe<GameLogicStreamerCard>;
  /** StoreServiceV2.CreateStreamerCardSaleConfig */
  createStreamerCardSaleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  /** SupportService.CreateTicket */
  createSupportTicket?: Maybe<GoogleProtobufEmpty>;
  /** AnnouncementService.DeleteAnnouncement */
  deleteAnnouncement?: Maybe<GoogleProtobufEmpty>;
  /** AnnouncementService.DeleteAnnouncementImage */
  deleteAnnouncementImage?: Maybe<GoogleProtobufEmpty>;
  /** ChallengeService.DeleteChallenge */
  deleteChallenge?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.DeleteChannel */
  deleteChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.DeleteChannelAsset */
  deleteChannelAsset?: Maybe<GoogleProtobufEmpty>;
  /** ChannelEmojiService.DeleteChannelEmoji */
  deleteChannelEmoji?: Maybe<GoogleProtobufEmpty>;
  /** FTUEService.DeleteDismissedTooltip */
  deleteDismissedTooltip?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.DeleteExternalAccount */
  deleteExternalAccount?: Maybe<GoogleProtobufEmpty>;
  /** StreamIngestConfigService.DeleteIngestConfigs */
  deleteIngestConfigs?: Maybe<GoogleProtobufEmpty>;
  /** ItemService.DeleteItemBootstrap */
  deleteItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.DeleteNotification */
  deleteNotification?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.DeleteOAuth2Consent */
  deleteOAuth2Consent?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.DeletePartyInvitation */
  deletePartyInvitation?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.DeletePartyMember */
  deletePartyMember?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.DeletePlatformEmoji */
  deletePlatformEmoji?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.DeletePushNotificationToken */
  deletePushNotificationToken?: Maybe<GoogleProtobufEmpty>;
  /** ChannelConfigService.DeleteStreamBackendConfig */
  deleteStreamBackendConfig?: Maybe<GoogleProtobufEmpty>;
  /** StreamerCardService.DeleteStreamerCardDraft */
  deleteStreamerCardDraft?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.DeleteUserData */
  deleteUserData?: Maybe<PrivacyDeleteUserDataResponse>;
  /** ChatModerationService.DenyModerationItem */
  denyChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** FTUEService.DismissTooltip */
  dismissTooltip?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.ExportUserData */
  exportUserData?: Maybe<PrivacyExportUserDataResponse>;
  /** ChannelService.FollowChannel - Following APIs */
  followChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.HideChatMessage */
  hideChatMessage?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.MarkNotificationRead */
  markNotificationRead?: Maybe<NotificationNotification>;
  /** MLControllerService.TriggerMatchEnd */
  mlTriggerMatchEnd?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.MuteChatUser */
  muteChatUser?: Maybe<GoogleProtobufEmpty>;
  /** ChallengeSessionService.PickChallenge */
  pickChallenge?: Maybe<ChallengesessionChallengePick>;
  /** ChallengeSessionService.ProgressChallengeSession */
  progressChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** StreamerCardService.PublishStreamerCardDraft */
  publishStreamerCardDraft?: Maybe<GoogleProtobufEmpty>;
  /** ChannelSubscriptionService.ReactivateSubscription */
  reactivateChannelSubscription?: Maybe<GoogleProtobufEmpty>;
  /** StreamIngestConfigService.RefreshIngestConfigs */
  refreshIngestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** ProfileService.RejectUsername */
  rejectUsername?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.DeleteFriend */
  removeFriend?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.DeleteFriendRequest */
  removeFriendRequest?: Maybe<GoogleProtobufEmpty>;
  /** ReactionService.RemoveReaction */
  removeReaction?: Maybe<ReactionReactionState>;
  /** GoalCardService.ReshuffleSlot */
  reshuffleGoalCardSlot?: Maybe<GoalCardReshuffleSlotResponse>;
  /** ChallengeSessionService.ResolveChallenge */
  resolveChallenge?: Maybe<ChallengesessionChallengeSession>;
  /** PlacementsService.RewardPlacement */
  rewardPlacement?: Maybe<GoogleProtobufEmpty>;
  /** ChannelConfigService.SelectStreamBackendConfig */
  selectStreamBackendConfig?: Maybe<GoogleProtobufEmpty>;
  /** ChatService.SendChatMessage */
  sendChatMessage?: Maybe<ChatSendMessageResponse>;
  /** FriendsService.SendFriendRequest */
  sendFriendRequest?: Maybe<FriendsSendFriendRequestResponse>;
  /** PushNotificationService.SendPushNotification */
  sendPushNotification?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.SetBirthday */
  setBirthday?: Maybe<GoogleProtobufEmpty>;
  /** FeatureFlagService.SetFeatureFlagConfig */
  setFeatureFlagConfig?: Maybe<FlagFeatureFlagConfig>;
  /** GoalCardService.SetGoalCardSlot */
  setGoalCardSlot?: Maybe<GoalCardSetGoalCardSlotResponse>;
  /** ChannelService.SetUserChannelRoles */
  setUserChannelRoles?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.SignAgreements */
  signAgreements?: Maybe<GoogleProtobufEmpty>;
  /** StreamerService.ActivateContextualTeamAction */
  streamerActivateContextualTeamAction?: Maybe<StreamerActivateContextualTeamActionResponse>;
  /** StreamerService.TriggerCameraTransition */
  streamerTriggerCameraTransition?: Maybe<StreamerTriggerCameraTransitionResponse>;
  /** WalletAdminService.SubtractCurrencies */
  subtractWalletCurrencies?: Maybe<WalletSubtractCurrenciesResponse>;
  /** ChannelModerationService.SuspendChannelFeature */
  suspendChannelFeature?: Maybe<GoogleProtobufEmpty>;
  /** UserActionService.TriggerEmoji */
  triggerEmoji?: Maybe<GoogleProtobufEmpty>;
  /** UserActionService.TriggerEmote */
  triggerEmote?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.UnbanUser */
  unbanChannelUser?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.UnbanUser */
  unbanPlatformUser?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.UnblockUser */
  unblockUser?: Maybe<FriendsUnblockUserResponse>;
  /** ChannelService.UnfollowChannel */
  unfollowChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.UnmuteChatUser */
  unmuteChatUser?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.UnsuspendChannelFeature */
  unsuspendChannelFeature?: Maybe<GoogleProtobufEmpty>;
  /** AuthAdminService.UpdateAccount */
  updateAccount?: Maybe<AuthAccount>;
  /** AnnouncementService.UpdateAnnouncement */
  updateAnnouncement?: Maybe<AnnouncementAnnouncement>;
  /** AvatarService.UpdateAvatar */
  updateAvatar?: Maybe<AvatarAvatar>;
  /** ChallengeService.UpdateChallenge */
  updateChallenge?: Maybe<GameLogicChallenge>;
  /** ChallengeSessionService.UpdateChallengeSession */
  updateChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelModerationService.UpdateBanAppeal */
  updateChannelBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.UpdateChannelDetails */
  updateChannelDetails?: Maybe<ChannelChannel>;
  /** ChannelEmojiService.UpdateChannelEmoji */
  updateChannelEmoji?: Maybe<EmojiEmoji>;
  /** ChannelModerationService.UpdateModerationSettings */
  updateChannelModerationSettings?: Maybe<ChannelModerationSettings>;
  /** ChannelService.UpdateMonetizationSettings */
  updateChannelMonetizationSettings?: Maybe<ChannelMonetizationSettings>;
  /** ChannelNotificationService.UpdateNotificationSettings */
  updateChannelNotificationSettings?: Maybe<ChannelNotificationSettings>;
  /** ChannelSubscriptionService.UpdateChannelSubscriptionConfig */
  updateChannelSubscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  /** ChannelNotificationService.UpdateFollowerNotificationSettings */
  updateFollowerNotificationSettings?: Maybe<ChannelFollowerNotificationSettings>;
  /** FriendsService.UpdateFriendsSettings */
  updateFriendsSettings?: Maybe<FriendsFriendsSettings>;
  /** ItemService.UpdateItemBootstrap */
  updateItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.UpdateMarketingConsent */
  updateMarketingConsent?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.UpdatePlatformBanAppeal */
  updatePlatformBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.UpdatePlatformEmoji */
  updatePlatformEmoji?: Maybe<EmojiEmoji>;
  /** ProfileService.UpdatePrivacySettings */
  updatePrivacySettings?: Maybe<ProfilePrivacySettings>;
  /** ProfileService.UpdateProfile */
  updateProfile?: Maybe<ProfileProfile>;
  /** ProfileService.UpdateProfileAvatar */
  updateProfileAvatar?: Maybe<GoogleProtobufEmpty>;
  /** ProfileService.UpdateProfileAvatarV2 */
  updateProfileAvatarV2?: Maybe<AvatarAvatar>;
  /** ChannelConfigService.UpdateRestreamingConfig */
  updateRestreamingConfig?: Maybe<ChannelRestreamingConfig>;
  /** ChannelConfigService.UpdateStreamBackendConfig */
  updateStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StreamerCardService.UpdateStreamerCardDraft */
  updateStreamerCardDraft?: Maybe<GameLogicStreamerCard>;
  /** StoreServiceV2.UpdateStreamerCardSaleConfig */
  updateStreamerCardSaleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  /** ChannelSubscriptionService.UpdateSubscriptionPaymentMethod - protolint:disable:next MAX_LINE_LENGTH */
  updateSubscriptionPaymentMethod?: Maybe<SubscriptionUpdateSubscriptionPaymentMethodResponse>;
  /** InvitationService.UseInvitationCode */
  useInvitationCode?: Maybe<GoogleProtobufEmpty>;
  /** AvatarService.ValidateAvatarComposition */
  validateAvatarComposition?: Maybe<AvatarValidateAvatarCompositionResponse>;
};


export type MutationAcceptFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAcceptMonetizationTermsArgs = {
  address?: InputMaybe<ApiAddressInput>;
  birthday?: InputMaybe<ApiDateInput>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<ChannelGender>;
  lastName?: InputMaybe<Scalars['String']['input']>;
};


export type MutationAddOAuth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']['input']>;
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAddPushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']['input']>;
  tokenType?: InputMaybe<NotificationPushNotificationTokenType>;
};


export type MutationAddReactionArgs = {
  parentId?: InputMaybe<Scalars['ID']['input']>;
  parentType?: InputMaybe<Scalars['String']['input']>;
  reactionType?: InputMaybe<ReactionReactionType>;
  resourceId?: InputMaybe<Scalars['ID']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
};


export type MutationAddUserEntitlementsArgs = {
  entitlements?: InputMaybe<Array<InventoryItemEntitlementInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAddWalletCurrenciesArgs = {
  currencies?: InputMaybe<Array<WalletWalletCurrencyInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAllowChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  moderationItemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationBanChannelUserArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  keepRecentMessages?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
  violation?: InputMaybe<ChannelViolation>;
};


export type MutationBanPlatformUserArgs = {
  description?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Duration']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
  violation?: InputMaybe<ModerationViolation>;
};


export type MutationBatchDeleteNotificationsArgs = {
  notificationIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type MutationBatchMarkNotificationsReadArgs = {
  notificationIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type MutationBlockUserArgs = {
  blockedUserId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationBuyWithInGameCurrencyArgs = {
  currencyId?: InputMaybe<Scalars['ID']['input']>;
  giftOptions?: InputMaybe<StoreV2GiftOptionsInput>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  signature?: InputMaybe<Scalars['String']['input']>;
};


export type MutationBuyWithPaymentArgs = {
  giftOptions?: InputMaybe<StoreV2GiftOptionsInput>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  paymentMethod?: InputMaybe<StoreV2PaymentMethod>;
  signature?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCancelChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCancelDataDeletionArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCancelOrderArgs = {
  orderId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCheckoutExistingChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCheckoutNewChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  tier?: InputMaybe<Scalars['Int']['input']>;
};


export type MutationClaimRewardArgs = {
  rewardId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationClearChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  moderationItemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationConsumeUserItemArgs = {
  consumptions?: InputMaybe<Array<InventoryItemConsumptionInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateAccountArgs = {
  displayName?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  isBot?: InputMaybe<Scalars['Boolean']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateAnnouncementArgs = {
  category?: InputMaybe<AnnouncementAnnouncementCategory>;
  endTime?: InputMaybe<Scalars['Timestamp']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  startTime?: InputMaybe<Scalars['Timestamp']['input']>;
  targets?: InputMaybe<AnnouncementTargetsInput>;
  text?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateAnnouncementImageUploadTokenArgs = {
  announcementId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChallengeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChallengeSessionArgs = {
  challenges?: InputMaybe<Array<ChallengesessionChallengeInput>>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
  submissionWindowLength?: InputMaybe<Scalars['Int']['input']>;
};


export type MutationCreateChannelArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
  streamerId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChannelAssetUploadTokenArgs = {
  assetType?: InputMaybe<ChannelAssetType>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChannelBanAppealArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateChannelEmojiArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateEmojiUploadTokenArgs = {
  itemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateInvitationCodesArgs = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateItemBootstrapArgs = {
  bootstrap?: InputMaybe<ItemItemBootstrapInput>;
};


export type MutationCreatePartyArgs = {
  inviteeIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type MutationCreatePartyInvitationArgs = {
  inviteeId?: InputMaybe<Scalars['ID']['input']>;
  inviterId?: InputMaybe<Scalars['ID']['input']>;
  partyId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreatePartyMemberArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreatePlatformBanAppealArgs = {
  appealText?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreatePlatformEmojiArgs = {
  label?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateReportArgs = {
  context?: InputMaybe<SupportReportContextInput>;
  description?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<SupportReportReason>;
};


export type MutationCreateStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  crConfig?: InputMaybe<ChannelContentRendererConfigInput>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  mlConfig?: InputMaybe<ChannelMachineLearningConfigInput>;
  recConfig?: InputMaybe<ChannelStreamRecorderConfigInput>;
  transcoderConfig?: InputMaybe<ChannelStreamTranscoderConfigInput>;
};


export type MutationCreateStreamerCardAssetUploadTokenArgs = {
  assetType?: InputMaybe<GameCardAssetType>;
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateStreamerCardDraftArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateStreamerCardSaleConfigArgs = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  excludeFromBundles?: InputMaybe<Scalars['Boolean']['input']>;
  period?: InputMaybe<StoreV2PeriodInput>;
};


export type MutationCreateSupportTicketArgs = {
  description?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDeleteAnnouncementArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteAnnouncementImageArgs = {
  announcementId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChannelArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChannelAssetArgs = {
  assetType?: InputMaybe<ChannelAssetType>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChannelEmojiArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteDismissedTooltipArgs = {
  tooltipId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteExternalAccountArgs = {
  idType?: InputMaybe<AuthIdentityType>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteItemBootstrapArgs = {
  itemId?: InputMaybe<Scalars['ID']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDeleteNotificationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteOAuth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePartyInvitationArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePartyMemberArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePlatformEmojiArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDeleteStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteStreamerCardDraftArgs = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteUserDataArgs = {
  gracePeriod?: InputMaybe<Scalars['Duration']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDenyChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  moderationItemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDismissTooltipArgs = {
  dismissalType?: InputMaybe<FtueDismissalType>;
  tooltipId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationFollowChannelArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationHideChatMessageArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  messageId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationMarkNotificationReadArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationMlTriggerMatchEndArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationMuteChatUserArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Duration']['input']>;
  reason?: InputMaybe<ChatReason>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationPickChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
  stake?: InputMaybe<ChallengesessionStakeInput>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationProgressChallengeSessionArgs = {
  phase?: InputMaybe<ChallengesessionChallengeSessionPhase>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationPublishStreamerCardDraftArgs = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationReactivateChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRefreshIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRejectUsernameArgs = {
  currentUsername?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<ModerationViolation>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRemoveFriendArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRemoveFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRemoveReactionArgs = {
  parentId?: InputMaybe<Scalars['ID']['input']>;
  parentType?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['ID']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
};


export type MutationReshuffleGoalCardSlotArgs = {
  slotId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationResolveChallengeArgs = {
  challenge?: InputMaybe<ChallengesessionChallengeInput>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRewardPlacementArgs = {
  placementId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSelectStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  configId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSendChatMessageArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  consentToModeration?: InputMaybe<Scalars['Boolean']['input']>;
  content?: InputMaybe<ChatMessageContentInput>;
};


export type MutationSendFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSendPushNotificationArgs = {
  body?: InputMaybe<Scalars['String']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  link?: InputMaybe<Scalars['String']['input']>;
  payload?: InputMaybe<NotificationPushNotificationPayloadInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  topic?: InputMaybe<Scalars['String']['input']>;
};


export type MutationSetBirthdayArgs = {
  birthday?: InputMaybe<AuthDateInput>;
};


export type MutationSetFeatureFlagConfigArgs = {
  config?: InputMaybe<FlagFeatureFlagConfigInput>;
  previousRevision?: InputMaybe<Scalars['String']['input']>;
  validateSchema?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationSetGoalCardSlotArgs = {
  goalCardId?: InputMaybe<Scalars['ID']['input']>;
  goalCardSlotId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSetUserChannelRolesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  roles?: InputMaybe<Array<ChannelChannelRole>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSignAgreementsArgs = {
  agreements?: InputMaybe<Array<AuthTermsVersionInput>>;
};


export type MutationStreamerActivateContextualTeamActionArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationStreamerTriggerCameraTransitionArgs = {
  cameraTransitionTarget?: InputMaybe<RenderingCameraTransitionRequestTransitionTarget>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSubtractWalletCurrenciesArgs = {
  currencies?: InputMaybe<Array<WalletWalletCurrencyInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSuspendChannelFeatureArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Duration']['input']>;
  feature?: InputMaybe<ChannelChannelFeature>;
  reason?: InputMaybe<ChannelSuspensionReason>;
};


export type MutationTriggerEmojiArgs = {
  emojiId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationTriggerEmoteArgs = {
  emoteId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnbanChannelUserArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnbanPlatformUserArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnblockUserArgs = {
  blockedUserId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnfollowChannelArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnmuteChatUserArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnsuspendChannelFeatureArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  feature?: InputMaybe<ChannelChannelFeature>;
};


export type MutationUpdateAccountArgs = {
  body?: InputMaybe<AuthAccountUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateAnnouncementArgs = {
  body?: InputMaybe<AnnouncementAnnouncementInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateAvatarArgs = {
  body?: InputMaybe<AvatarAvatarInput>;
};


export type MutationUpdateChallengeArgs = {
  body?: InputMaybe<ChallengeChallengeUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChallengeSessionArgs = {
  body?: InputMaybe<ChallengesessionChallengeSessionUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelBanAppealArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<ChannelAppealStatus>;
  text?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateChannelDetailsArgs = {
  body?: InputMaybe<ChannelChannelDetailsUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelEmojiArgs = {
  body?: InputMaybe<EmojiUpdateChannelEmojiParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelModerationSettingsArgs = {
  body?: InputMaybe<ChannelModerationSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelMonetizationSettingsArgs = {
  body?: InputMaybe<ChannelMonetizationSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelNotificationSettingsArgs = {
  body?: InputMaybe<ChannelUpdateNotificationSettingsParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelSubscriptionConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  subscriptionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationUpdateFollowerNotificationSettingsArgs = {
  body?: InputMaybe<ChannelUpdateFollowerNotificationSettingsParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateFriendsSettingsArgs = {
  body?: InputMaybe<FriendsFriendsSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateItemBootstrapArgs = {
  body?: InputMaybe<ItemItemBootstrapInput>;
};


export type MutationUpdateMarketingConsentArgs = {
  marketingConsent?: InputMaybe<AuthConsentStatus>;
};


export type MutationUpdatePlatformBanAppealArgs = {
  banId?: InputMaybe<Scalars['ID']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ModerationAppealStatus>;
};


export type MutationUpdatePlatformEmojiArgs = {
  body?: InputMaybe<EmojiUpdatePlatformEmojiParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdatePrivacySettingsArgs = {
  body?: InputMaybe<ProfilePrivacySettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateProfileArgs = {
  body?: InputMaybe<ProfileProfileUpdateInput>;
  options?: InputMaybe<ProfileUpdateProfileRequestOptionsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateProfileAvatarArgs = {
  modelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateProfileAvatarV2Args = {
  modelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateRestreamingConfigArgs = {
  body?: InputMaybe<ChannelRestreamingConfigInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamBackendConfigArgs = {
  body?: InputMaybe<ChannelStreamBackendConfigInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamerCardDraftArgs = {
  body?: InputMaybe<GameCardStreamerCardDraftUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamerCardSaleConfigArgs = {
  body?: InputMaybe<StoreV2StreamerCardSaleConfigUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUseInvitationCodeArgs = {
  code?: InputMaybe<Scalars['String']['input']>;
};


export type MutationValidateAvatarCompositionArgs = {
  composition?: InputMaybe<AvatarAvatarCompositionInput>;
};

export type NotificationForcedSignoutEvent = {
  __typename?: 'NotificationForcedSignoutEvent';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type NotificationGiftSubscription = {
  __typename?: 'NotificationGiftSubscription';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  giver?: Maybe<ProfileProfile>;
  giverId: Scalars['ID']['output'];
  tier: Scalars['Int']['output'];
};

export type NotificationListNotificationsResponse = {
  __typename?: 'NotificationListNotificationsResponse';
  notifications: Array<NotificationNotification>;
};

export type NotificationNotification = {
  __typename?: 'NotificationNotification';
  content: NotificationNotificationContent;
  createdAt: Scalars['Timestamp']['output'];
  id: Scalars['ID']['output'];
  new: Scalars['Boolean']['output'];
  persisted: Scalars['Boolean']['output'];
};

export type NotificationNotificationContent = {
  __typename?: 'NotificationNotificationContent';
  content?: Maybe<NotificationNotificationContentContentUnion>;
};

export type NotificationNotificationContentContentUnion = AdsPlacementStateEvent | ChannelUserBannedNotification | FriendsFriendStatusUpdateEvent | GoalCardGoalCardSlot | IntType | InventoryInventoryUpdateEvent | InvitationInvitationCodeUpdateEvent | ModerationPlatformUserBannedNotification | NotificationForcedSignoutEvent | NotificationGiftSubscription | PartyPartyInvitationUpdateEvent | PrivacyUserDataExportCompleteEvent | ProfileUsernameChange | ProgressionProgressionUpdateEvent | RewardReward | SubscriptionChannelSubscriptionUpdateEvent | WalletTransactionEvent;

export type NotificationPushNotificationPayloadChannelLiveInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  channelName?: InputMaybe<Scalars['String']['input']>;
};

export type NotificationPushNotificationPayloadInput = {
  channelLive?: InputMaybe<NotificationPushNotificationPayloadChannelLiveInput>;
};

export type NotificationPushNotificationToken = {
  __typename?: 'NotificationPushNotificationToken';
  token: Scalars['String']['output'];
  tokenType: NotificationPushNotificationTokenType;
  userId: Scalars['ID']['output'];
};

export enum NotificationPushNotificationTokenType {
  PushNotificationTokenTypeFirebase = 'PUSH_NOTIFICATION_TOKEN_TYPE_FIREBASE',
  PushNotificationTokenTypeUnspecified = 'PUSH_NOTIFICATION_TOKEN_TYPE_UNSPECIFIED'
}

export type PartyParty = {
  __typename?: 'PartyParty';
  channel?: Maybe<ChannelChannel>;
  id: Scalars['ID']['output'];
  leaderId: Scalars['ID']['output'];
  members: Array<PartyPartyMember>;
  name: Scalars['String']['output'];
  public: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
};

export type PartyPartyInvitation = {
  __typename?: 'PartyPartyInvitation';
  inviteeId: Scalars['ID']['output'];
  inviterId: Scalars['ID']['output'];
  partyId: Scalars['ID']['output'];
};

export type PartyPartyInvitationUpdateEvent = {
  __typename?: 'PartyPartyInvitationUpdateEvent';
  partyInvitation: PartyPartyInvitation;
  type: PartyPartyInvitationUpdateEventUpdateType;
};

export enum PartyPartyInvitationUpdateEventUpdateType {
  UpdateTypeInvitationAccepted = 'UPDATE_TYPE_INVITATION_ACCEPTED',
  UpdateTypeInvitationCreated = 'UPDATE_TYPE_INVITATION_CREATED',
  UpdateTypeInvitationDeclined = 'UPDATE_TYPE_INVITATION_DECLINED',
  UpdateTypeInvitationDeleted = 'UPDATE_TYPE_INVITATION_DELETED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED'
}

export type PartyPartyMember = {
  __typename?: 'PartyPartyMember';
  profile: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type PartyPartyUpdateEvent = {
  __typename?: 'PartyPartyUpdateEvent';
  party: PartyParty;
};

export type PaymentAmount = {
  __typename?: 'PaymentAmount';
  currency: PaymentCurrency;
  value: Scalars['Int']['output'];
};

export type PaymentAmountInput = {
  currency?: InputMaybe<PaymentCurrency>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentAppStoreSession = {
  __typename?: 'PaymentAppStoreSession';
  paymentId: Scalars['ID']['output'];
  productId: Scalars['ID']['output'];
};

export enum PaymentCurrency {
  CurrencyAed = 'CURRENCY_AED',
  CurrencyAfn = 'CURRENCY_AFN',
  CurrencyAll = 'CURRENCY_ALL',
  CurrencyAmd = 'CURRENCY_AMD',
  CurrencyAng = 'CURRENCY_ANG',
  CurrencyAoa = 'CURRENCY_AOA',
  CurrencyArs = 'CURRENCY_ARS',
  CurrencyAud = 'CURRENCY_AUD',
  CurrencyAwg = 'CURRENCY_AWG',
  CurrencyAzn = 'CURRENCY_AZN',
  CurrencyBam = 'CURRENCY_BAM',
  CurrencyBbd = 'CURRENCY_BBD',
  CurrencyBdt = 'CURRENCY_BDT',
  CurrencyBgn = 'CURRENCY_BGN',
  CurrencyBhd = 'CURRENCY_BHD',
  CurrencyBif = 'CURRENCY_BIF',
  CurrencyBmd = 'CURRENCY_BMD',
  CurrencyBnd = 'CURRENCY_BND',
  CurrencyBob = 'CURRENCY_BOB',
  CurrencyBov = 'CURRENCY_BOV',
  CurrencyBrl = 'CURRENCY_BRL',
  CurrencyBsd = 'CURRENCY_BSD',
  CurrencyBtn = 'CURRENCY_BTN',
  CurrencyBwp = 'CURRENCY_BWP',
  CurrencyByn = 'CURRENCY_BYN',
  CurrencyBzd = 'CURRENCY_BZD',
  CurrencyCad = 'CURRENCY_CAD',
  CurrencyCdf = 'CURRENCY_CDF',
  CurrencyChe = 'CURRENCY_CHE',
  CurrencyChf = 'CURRENCY_CHF',
  CurrencyChw = 'CURRENCY_CHW',
  CurrencyClf = 'CURRENCY_CLF',
  CurrencyClp = 'CURRENCY_CLP',
  CurrencyCny = 'CURRENCY_CNY',
  CurrencyCop = 'CURRENCY_COP',
  CurrencyCou = 'CURRENCY_COU',
  CurrencyCrc = 'CURRENCY_CRC',
  CurrencyCuc = 'CURRENCY_CUC',
  CurrencyCup = 'CURRENCY_CUP',
  CurrencyCve = 'CURRENCY_CVE',
  CurrencyCzk = 'CURRENCY_CZK',
  CurrencyDjf = 'CURRENCY_DJF',
  CurrencyDkk = 'CURRENCY_DKK',
  CurrencyDop = 'CURRENCY_DOP',
  CurrencyDzd = 'CURRENCY_DZD',
  CurrencyEgp = 'CURRENCY_EGP',
  CurrencyErn = 'CURRENCY_ERN',
  CurrencyEtb = 'CURRENCY_ETB',
  CurrencyEur = 'CURRENCY_EUR',
  CurrencyFjd = 'CURRENCY_FJD',
  CurrencyFkp = 'CURRENCY_FKP',
  CurrencyGbp = 'CURRENCY_GBP',
  CurrencyGel = 'CURRENCY_GEL',
  CurrencyGhs = 'CURRENCY_GHS',
  CurrencyGip = 'CURRENCY_GIP',
  CurrencyGmd = 'CURRENCY_GMD',
  CurrencyGnf = 'CURRENCY_GNF',
  CurrencyGtq = 'CURRENCY_GTQ',
  CurrencyGyd = 'CURRENCY_GYD',
  CurrencyHkd = 'CURRENCY_HKD',
  CurrencyHnl = 'CURRENCY_HNL',
  CurrencyHtg = 'CURRENCY_HTG',
  CurrencyHuf = 'CURRENCY_HUF',
  CurrencyIdr = 'CURRENCY_IDR',
  CurrencyIls = 'CURRENCY_ILS',
  CurrencyInr = 'CURRENCY_INR',
  CurrencyIqd = 'CURRENCY_IQD',
  CurrencyIrr = 'CURRENCY_IRR',
  CurrencyIsk = 'CURRENCY_ISK',
  CurrencyJmd = 'CURRENCY_JMD',
  CurrencyJod = 'CURRENCY_JOD',
  CurrencyJpy = 'CURRENCY_JPY',
  CurrencyKes = 'CURRENCY_KES',
  CurrencyKgs = 'CURRENCY_KGS',
  CurrencyKhr = 'CURRENCY_KHR',
  CurrencyKmf = 'CURRENCY_KMF',
  CurrencyKpw = 'CURRENCY_KPW',
  CurrencyKrw = 'CURRENCY_KRW',
  CurrencyKwd = 'CURRENCY_KWD',
  CurrencyKyd = 'CURRENCY_KYD',
  CurrencyKzt = 'CURRENCY_KZT',
  CurrencyLak = 'CURRENCY_LAK',
  CurrencyLbp = 'CURRENCY_LBP',
  CurrencyLkr = 'CURRENCY_LKR',
  CurrencyLrd = 'CURRENCY_LRD',
  CurrencyLsl = 'CURRENCY_LSL',
  CurrencyLyd = 'CURRENCY_LYD',
  CurrencyMad = 'CURRENCY_MAD',
  CurrencyMdl = 'CURRENCY_MDL',
  CurrencyMga = 'CURRENCY_MGA',
  CurrencyMkd = 'CURRENCY_MKD',
  CurrencyMmk = 'CURRENCY_MMK',
  CurrencyMnt = 'CURRENCY_MNT',
  CurrencyMop = 'CURRENCY_MOP',
  CurrencyMru = 'CURRENCY_MRU',
  CurrencyMur = 'CURRENCY_MUR',
  CurrencyMvr = 'CURRENCY_MVR',
  CurrencyMwk = 'CURRENCY_MWK',
  CurrencyMxn = 'CURRENCY_MXN',
  CurrencyMxv = 'CURRENCY_MXV',
  CurrencyMyr = 'CURRENCY_MYR',
  CurrencyMzn = 'CURRENCY_MZN',
  CurrencyNad = 'CURRENCY_NAD',
  CurrencyNgn = 'CURRENCY_NGN',
  CurrencyNio = 'CURRENCY_NIO',
  CurrencyNok = 'CURRENCY_NOK',
  CurrencyNpr = 'CURRENCY_NPR',
  CurrencyNzd = 'CURRENCY_NZD',
  CurrencyOmr = 'CURRENCY_OMR',
  CurrencyPab = 'CURRENCY_PAB',
  CurrencyPen = 'CURRENCY_PEN',
  CurrencyPgk = 'CURRENCY_PGK',
  CurrencyPhp = 'CURRENCY_PHP',
  CurrencyPkr = 'CURRENCY_PKR',
  CurrencyPln = 'CURRENCY_PLN',
  CurrencyPyg = 'CURRENCY_PYG',
  CurrencyQar = 'CURRENCY_QAR',
  CurrencyRon = 'CURRENCY_RON',
  CurrencyRsd = 'CURRENCY_RSD',
  CurrencyRub = 'CURRENCY_RUB',
  CurrencyRwf = 'CURRENCY_RWF',
  CurrencySar = 'CURRENCY_SAR',
  CurrencySbd = 'CURRENCY_SBD',
  CurrencyScr = 'CURRENCY_SCR',
  CurrencySdg = 'CURRENCY_SDG',
  CurrencySek = 'CURRENCY_SEK',
  CurrencySgd = 'CURRENCY_SGD',
  CurrencyShp = 'CURRENCY_SHP',
  CurrencySle = 'CURRENCY_SLE',
  CurrencySos = 'CURRENCY_SOS',
  CurrencySrd = 'CURRENCY_SRD',
  CurrencySsp = 'CURRENCY_SSP',
  CurrencyStn = 'CURRENCY_STN',
  CurrencySvc = 'CURRENCY_SVC',
  CurrencySyp = 'CURRENCY_SYP',
  CurrencySzl = 'CURRENCY_SZL',
  CurrencyThb = 'CURRENCY_THB',
  CurrencyTjs = 'CURRENCY_TJS',
  CurrencyTmt = 'CURRENCY_TMT',
  CurrencyTnd = 'CURRENCY_TND',
  CurrencyTop = 'CURRENCY_TOP',
  CurrencyTry = 'CURRENCY_TRY',
  CurrencyTtd = 'CURRENCY_TTD',
  CurrencyTwd = 'CURRENCY_TWD',
  CurrencyTzs = 'CURRENCY_TZS',
  CurrencyUah = 'CURRENCY_UAH',
  CurrencyUgx = 'CURRENCY_UGX',
  CurrencyUnspecified = 'CURRENCY_UNSPECIFIED',
  CurrencyUsd = 'CURRENCY_USD',
  CurrencyUsn = 'CURRENCY_USN',
  CurrencyUyi = 'CURRENCY_UYI',
  CurrencyUyu = 'CURRENCY_UYU',
  CurrencyUyw = 'CURRENCY_UYW',
  CurrencyUzs = 'CURRENCY_UZS',
  CurrencyVed = 'CURRENCY_VED',
  CurrencyVes = 'CURRENCY_VES',
  CurrencyVnd = 'CURRENCY_VND',
  CurrencyVuv = 'CURRENCY_VUV',
  CurrencyWst = 'CURRENCY_WST',
  CurrencyXaf = 'CURRENCY_XAF',
  CurrencyXag = 'CURRENCY_XAG',
  CurrencyXau = 'CURRENCY_XAU',
  CurrencyXba = 'CURRENCY_XBA',
  CurrencyXbb = 'CURRENCY_XBB',
  CurrencyXbc = 'CURRENCY_XBC',
  CurrencyXbd = 'CURRENCY_XBD',
  CurrencyXcd = 'CURRENCY_XCD',
  CurrencyXdr = 'CURRENCY_XDR',
  CurrencyXof = 'CURRENCY_XOF',
  CurrencyXpd = 'CURRENCY_XPD',
  CurrencyXpf = 'CURRENCY_XPF',
  CurrencyXpt = 'CURRENCY_XPT',
  CurrencyXsu = 'CURRENCY_XSU',
  CurrencyXts = 'CURRENCY_XTS',
  CurrencyXua = 'CURRENCY_XUA',
  CurrencyXxx = 'CURRENCY_XXX',
  CurrencyYer = 'CURRENCY_YER',
  CurrencyZar = 'CURRENCY_ZAR',
  CurrencyZmw = 'CURRENCY_ZMW',
  CurrencyZwl = 'CURRENCY_ZWL'
}

export type PaymentLineItem = {
  __typename?: 'PaymentLineItem';
  currency: PaymentCurrency;
  description: Scalars['String']['output'];
  price: Scalars['Int']['output'];
  quantity: Scalars['Int']['output'];
};

export type PaymentListPaymentsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  statuses?: InputMaybe<Array<PaymentPaymentStatus>>;
  to?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type PaymentListPaymentsResponse = {
  __typename?: 'PaymentListPaymentsResponse';
  pageInfo: ApiPageInfo;
  payments: Array<PaymentPayment>;
};

export type PaymentListSuccessfulPaymentsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  to?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type PaymentListSuccessfulPaymentsResponse = {
  __typename?: 'PaymentListSuccessfulPaymentsResponse';
  pageInfo: ApiPageInfo;
  payments: Array<PaymentPayment>;
};

export type PaymentPayment = {
  __typename?: 'PaymentPayment';
  amount: PaymentAmount;
  externalReference: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  info: PaymentPaymentInfo;
  items: Array<PaymentLineItem>;
  meta: PaymentSessionMeta;
  provider: PaymentPaymentProvider;
  status: PaymentPaymentStatus;
  tax: PaymentTax;
  timestamp: Scalars['Timestamp']['output'];
  userId: Scalars['ID']['output'];
};

export type PaymentPaymentInfo = {
  __typename?: 'PaymentPaymentInfo';
  cardHolderName: Scalars['String']['output'];
  cardIssuingCountry: Scalars['String']['output'];
  cardSummary: Scalars['String']['output'];
};

export enum PaymentPaymentProvider {
  PaymentProviderAdyen = 'PAYMENT_PROVIDER_ADYEN',
  PaymentProviderAppstore = 'PAYMENT_PROVIDER_APPSTORE',
  PaymentProviderUnspecified = 'PAYMENT_PROVIDER_UNSPECIFIED'
}

export enum PaymentPaymentStatus {
  PaymentStatusExpired = 'PAYMENT_STATUS_EXPIRED',
  PaymentStatusFailed = 'PAYMENT_STATUS_FAILED',
  PaymentStatusPending = 'PAYMENT_STATUS_PENDING',
  PaymentStatusReversed = 'PAYMENT_STATUS_REVERSED',
  PaymentStatusSuccess = 'PAYMENT_STATUS_SUCCESS',
  PaymentStatusUnspecified = 'PAYMENT_STATUS_UNSPECIFIED'
}

export type PaymentSession = {
  __typename?: 'PaymentSession';
  session?: Maybe<PaymentSessionSessionUnion>;
};

export type PaymentSessionMeta = {
  __typename?: 'PaymentSessionMeta';
  attributes: Array<PaymentSessionMetaAttributesEntry>;
  namespace: Scalars['String']['output'];
};

export type PaymentSessionMetaAttributesEntry = {
  __typename?: 'PaymentSessionMetaAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type PaymentSessionSessionUnion = AdyenSession | PaymentAppStoreSession;

export type PaymentTax = {
  __typename?: 'PaymentTax';
  amount?: Maybe<PaymentAmount>;
  rate: Scalars['Int']['output'];
  rateInBasisPoints: Scalars['Int']['output'];
};

export type PlayerStatsPlayerStats = {
  __typename?: 'PlayerStatsPlayerStats';
  adsWatched: Scalars['Int']['output'];
  boosterUsage?: Maybe<PlayerStatsPlayerStatsBoosterUsage>;
  cardBundlesPurchased: Scalars['Int']['output'];
  cardLevelUps: Scalars['Int']['output'];
  cardsPlayed: Scalars['Int']['output'];
  cardsSucceeded: Scalars['Int']['output'];
  currencySpending?: Maybe<PlayerStatsPlayerStatsCurrencySpending>;
  dailyGoalCardsCompleted: Scalars['Int']['output'];
  dailyGoalCardsSet: Scalars['Int']['output'];
  matchesPlayed: Scalars['Int']['output'];
  partyMatchesPlayed: Scalars['Int']['output'];
  shufflesUsed: Scalars['Int']['output'];
  soloMatchesPlayed: Scalars['Int']['output'];
  timePlayed?: Maybe<Scalars['Duration']['output']>;
};

export type PlayerStatsPlayerStatsBoosterUsage = {
  __typename?: 'PlayerStatsPlayerStatsBoosterUsage';
  doubt: Scalars['Int']['output'];
  goodCall: Scalars['Int']['output'];
  letsGo: Scalars['Int']['output'];
  nextUp: Scalars['Int']['output'];
  scavenge: Scalars['Int']['output'];
  speedUp: Scalars['Int']['output'];
  total: Scalars['Int']['output'];
};

export type PlayerStatsPlayerStatsCurrencySpending = {
  __typename?: 'PlayerStatsPlayerStatsCurrencySpending';
  channelCurrency: Scalars['Int']['output'];
  hardCurrency: Scalars['Int']['output'];
  softCurrency: Scalars['Int']['output'];
};

export type PrivacyDeleteUserDataResponse = {
  __typename?: 'PrivacyDeleteUserDataResponse';
  taskId: Scalars['ID']['output'];
};

export type PrivacyExportUserDataResponse = {
  __typename?: 'PrivacyExportUserDataResponse';
  taskId: Scalars['ID']['output'];
};

export type PrivacyUserDataExportCompleteEvent = {
  __typename?: 'PrivacyUserDataExportCompleteEvent';
  dataUrl: Scalars['String']['output'];
  taskId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ProfileBatchGetProfilesResponse = {
  __typename?: 'ProfileBatchGetProfilesResponse';
  profiles: Array<ProfileProfile>;
};

export enum ProfileColor {
  Color_6Ec9F7 = 'COLOR_6EC9F7',
  Color_56F6C0 = 'COLOR_56F6C0',
  Color_63F655 = 'COLOR_63F655',
  Color_8686F9 = 'COLOR_8686F9',
  ColorB26Afb = 'COLOR_B26AFB',
  ColorC0F656 = 'COLOR_C0F656',
  ColorF6Ce56 = 'COLOR_F6CE56',
  ColorF6F656 = 'COLOR_F6F656',
  ColorF76Ef7 = 'COLOR_F76EF7',
  ColorF69856 = 'COLOR_F69856',
  ColorUnspecified = 'COLOR_UNSPECIFIED'
}

export type ProfileGetUsernameHistoryResponse = {
  __typename?: 'ProfileGetUsernameHistoryResponse';
  changes: Array<ProfileUsernameChange>;
};

export type ProfileListPlayedGamesResponse = {
  __typename?: 'ProfileListPlayedGamesResponse';
  games: Array<ProfilePlayedGame>;
  pageInfo: ApiPageInfo;
};

export type ProfileListProfilesResponse = {
  __typename?: 'ProfileListProfilesResponse';
  pageInfo: ApiPageInfo;
  profiles: Array<ProfileProfile>;
};

export type ProfilePlayedGame = {
  __typename?: 'ProfilePlayedGame';
  game: GameGame;
  id: Scalars['ID']['output'];
  lastPlayedAt: Scalars['Timestamp']['output'];
  progression: GameUserProgression;
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export enum ProfilePresenceStatus {
  PresenceStatusOffline = 'PRESENCE_STATUS_OFFLINE',
  PresenceStatusOnline = 'PRESENCE_STATUS_ONLINE',
  PresenceStatusUnspecified = 'PRESENCE_STATUS_UNSPECIFIED'
}

export type ProfilePrivacySettings = {
  __typename?: 'ProfilePrivacySettings';
  anonymisePurchaseHighlights: Scalars['Boolean']['output'];
  discordUsernameVisibility: ProfilePrivacySettingsVisibility;
  hideOnlineStatus: Scalars['Boolean']['output'];
  showMatureContentWarning: Scalars['Boolean']['output'];
  visibility: ProfilePrivacySettingsVisibility;
};

export type ProfilePrivacySettingsInput = {
  anonymisePurchaseHighlights?: InputMaybe<Scalars['Boolean']['input']>;
  discordUsernameVisibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
  hideOnlineStatus?: InputMaybe<Scalars['Boolean']['input']>;
  showMatureContentWarning?: InputMaybe<Scalars['Boolean']['input']>;
  visibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
};

export enum ProfilePrivacySettingsVisibility {
  VisibilityAll = 'VISIBILITY_ALL',
  VisibilityFriends = 'VISIBILITY_FRIENDS',
  VisibilityOnlyMe = 'VISIBILITY_ONLY_ME',
  VisibilityUnspecified = 'VISIBILITY_UNSPECIFIED'
}

/** Profile message contains user profile information */
export type ProfileProfile = {
  __typename?: 'ProfileProfile';
  account?: Maybe<AuthAccount>;
  avatarConfig?: Maybe<ProfileProfileAvatarConfig>;
  /**
   * contains a concatenated list of different avatar urls (use avatars object instead)
   * @deprecated field is deprecated
   */
  avatarUrl: Scalars['String']['output'];
  avatars?: Maybe<ProfileProfileAvatars>;
  badges: Array<BadgeBadge>;
  bio: Scalars['String']['output'];
  canChangeUsernameAt?: Maybe<Scalars['Timestamp']['output']>;
  channel?: Maybe<ChannelChannel>;
  discordUsername?: Maybe<Scalars['String']['output']>;
  /** @deprecated field is deprecated */
  displayName: Scalars['String']['output'];
  friends: Array<ProfileProfile>;
  friendshipStatus: FriendsFriendshipStatus;
  isNewUsername: Scalars['Boolean']['output'];
  lastSeen?: Maybe<Scalars['Timestamp']['output']>;
  onlineStatus: ProfilePresenceStatus;
  playedGames: Array<ProfilePlayedGame>;
  preferredColor: ProfileColor;
  settings?: Maybe<ProfileProfileSettings>;
  state: ApiEntityState;
  stats: PlayerStatsPlayerStats;
  temporary: Scalars['Boolean']['output'];
  userId: Scalars['ID']['output'];
  userTag: Scalars['String']['output'];
  usernameHistory?: Maybe<Array<ProfileUsernameChange>>;
  visibility: ProfileProfileVisibility;
};


/** Profile message contains user profile information */
export type ProfileProfileBadgesArgs = {
  channel_id?: InputMaybe<Scalars['ID']['input']>;
};


/** Profile message contains user profile information */
export type ProfileProfileStatsArgs = {
  season_id?: InputMaybe<Scalars['String']['input']>;
};


/** Profile message contains user profile information */
export type ProfileProfileUsernameHistoryArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type ProfileProfileAvatarConfig = {
  __typename?: 'ProfileProfileAvatarConfig';
  model: AvatarAvatar;
  modelId: Scalars['ID']['output'];
};

export type ProfileProfileAvatars = {
  __typename?: 'ProfileProfileAvatars';
  avatar2D: Scalars['String']['output'];
  avatar3D: Scalars['String']['output'];
  avatarFullbody: Scalars['String']['output'];
  avatarGender: Scalars['String']['output'];
};

export type ProfileProfileSettings = {
  __typename?: 'ProfileProfileSettings';
  friends: FriendsFriendsSettings;
  privacy: ProfilePrivacySettings;
};

export type ProfileProfileUpdateInput = {
  bio?: InputMaybe<Scalars['String']['input']>;
  discordUsername?: InputMaybe<Scalars['String']['input']>;
  /** @deprecated field is deprecated */
  displayName?: InputMaybe<Scalars['String']['input']>;
  preferredColor?: InputMaybe<ProfileColor>;
  userId?: InputMaybe<Scalars['ID']['input']>;
  userTag?: InputMaybe<Scalars['String']['input']>;
};

export enum ProfileProfileVisibility {
  ProfileVisibilityPrivate = 'PROFILE_VISIBILITY_PRIVATE',
  ProfileVisibilityPublic = 'PROFILE_VISIBILITY_PUBLIC',
  ProfileVisibilityUnspecified = 'PROFILE_VISIBILITY_UNSPECIFIED'
}

export type ProfileResolveUserTagsResponse = {
  __typename?: 'ProfileResolveUserTagsResponse';
  profiles: Array<ProfileProfile>;
  userIds: Array<ProfileResolveUserTagsResponseUserIdsEntry>;
};

export type ProfileResolveUserTagsResponseUserIdsEntry = {
  __typename?: 'ProfileResolveUserTagsResponseUserIdsEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type ProfileUpdateProfileRequestOptionsInput = {
  omitNameValidation?: InputMaybe<Scalars['Boolean']['input']>;
  omitRankValidation?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProfileUsernameChange = {
  __typename?: 'ProfileUsernameChange';
  changedAt: Scalars['Timestamp']['output'];
  changedBy: Scalars['String']['output'];
  changer?: Maybe<ProfileProfile>;
  newUsername: Scalars['String']['output'];
  oldUsername: Scalars['String']['output'];
  reason: ModerationViolation;
};

export type ProgressionBatchGetSeasonProgressionRequestQueryInput = {
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ProgressionBatchGetSeasonProgressionResponse = {
  __typename?: 'ProgressionBatchGetSeasonProgressionResponse';
  progression: Array<ProgressionSeasonProgression>;
};

export type ProgressionChannel = {
  __typename?: 'ProgressionChannel';
  channelId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ProgressionExperiencePoints = {
  __typename?: 'ProgressionExperiencePoints';
  amount: Scalars['Int']['output'];
  target?: Maybe<ProgressionExperiencePointsTargetUnion>;
};

export type ProgressionExperiencePointsTargetUnion = ProgressionChannel | ProgressionFan | ProgressionSeason;

export type ProgressionFan = {
  __typename?: 'ProgressionFan';
  userId: Scalars['ID']['output'];
};

export type ProgressionGetDailyParticipationLimitResponse = {
  __typename?: 'ProgressionGetDailyParticipationLimitResponse';
  remainingDailyParticipationMinutes: Scalars['Int']['output'];
};

export type ProgressionGetDailyXpBoostLimitResponse = {
  __typename?: 'ProgressionGetDailyXPBoostLimitResponse';
  remainingDailyXpBoost: Scalars['Int']['output'];
};

export type ProgressionGetDailyXpEarningsLimitResponse = {
  __typename?: 'ProgressionGetDailyXPEarningsLimitResponse';
  remainingDailyXpEarningsMinutes: Scalars['Int']['output'];
};

export type ProgressionLevel = {
  __typename?: 'ProgressionLevel';
  number: Scalars['Int']['output'];
  target?: Maybe<ProgressionLevelTargetUnion>;
};

export type ProgressionLevelConfig = {
  __typename?: 'ProgressionLevelConfig';
  /**
   * channel_id is an optional configuration for channel loyalty related level
   *  configs
   */
  channelId: Scalars['ID']['output'];
  number: Scalars['Int']['output'];
  rewards: Array<RewardRewardType>;
  /** season_id is an optional configuration for season related level configs */
  seasonId: Scalars['ID']['output'];
  threshold: Scalars['Int']['output'];
};

export type ProgressionLevelTargetUnion = ProgressionChannel | ProgressionFan | ProgressionSeason;

export type ProgressionListLevelConfigsResponse = {
  __typename?: 'ProgressionListLevelConfigsResponse';
  levelConfigs: Array<ProgressionLevelConfig>;
};

export type ProgressionListSeasonProgressionResponse = {
  __typename?: 'ProgressionListSeasonProgressionResponse';
  progression: Array<ProgressionSeasonProgression>;
};

export type ProgressionProgressionUpdateEvent = {
  __typename?: 'ProgressionProgressionUpdateEvent';
  reason: ReasonReason;
  updates: Array<ProgressionProgressionUpdateEventUpdate>;
};

export type ProgressionProgressionUpdateEventUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdate';
  update?: Maybe<ProgressionProgressionUpdateEventUpdateUpdateUnion>;
};

export type ProgressionProgressionUpdateEventUpdateExperiencePointUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdateExperiencePointUpdate';
  newPoints: ProgressionExperiencePoints;
  oldPoints: ProgressionExperiencePoints;
};

export type ProgressionProgressionUpdateEventUpdateLevelUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdateLevelUpdate';
  newLevel: ProgressionLevel;
  oldLevel: ProgressionLevel;
};

export type ProgressionProgressionUpdateEventUpdateUpdateUnion = ProgressionProgressionUpdateEventUpdateExperiencePointUpdate | ProgressionProgressionUpdateEventUpdateLevelUpdate;

export type ProgressionSeason = {
  __typename?: 'ProgressionSeason';
  seasonId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ProgressionSeasonProgression = {
  __typename?: 'ProgressionSeasonProgression';
  level: Scalars['Int']['output'];
  nextLevel: Scalars['Int']['output'];
  nextLevelThreshold: Scalars['Int']['output'];
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
  xpAmount: Scalars['Int']['output'];
};

export type Query = {
  __typename?: 'Query';
  /** AuthServiceV4.GetAccount */
  account?: Maybe<AuthAccount>;
  /** AgreementService.ListAgreements */
  agreements?: Maybe<AgreementListAgreementResponse>;
  /** AnnouncementService.ListAnnouncements */
  announcements?: Maybe<AnnouncementListAnnouncementsResponse>;
  /** ArenaService.GetArena */
  arena?: Maybe<ArenaArena>;
  /** ArenaService.ListArenas */
  arenas?: Maybe<ArenaListArenasResponse>;
  /** AvatarService.GetAvatar */
  avatar?: Maybe<AvatarAvatar>;
  /** AvatarAnimationService.GetAnimation */
  avatarAnimation?: Maybe<AvatarAnimation>;
  /** AvatarAnimationService.BatchGetAnimations */
  avatarAnimationBatch?: Maybe<AvatarBatchGetAnimationsResponse>;
  /** AvatarAnimationService.ListAnimations */
  avatarAnimations?: Maybe<AvatarListAnimationsResponse>;
  /** StoreServiceV2.GetAvatarEditorStoreFront */
  avatarEditorStoreFront?: Maybe<StoreV2StoreFront>;
  /** AvatarService.GetAvatarPart */
  avatarPart?: Maybe<AvatarAvatarPart>;
  /** AvatarService.ListAvatarParts */
  avatarParts?: Maybe<AvatarListAvatarPartsResponse>;
  /** AvatarService.BatchGetAvatarParts */
  avatarPartsBatch?: Maybe<AvatarBatchGetAvatarPartsResponse>;
  /** AvatarService.ListAvatars */
  avatars?: Maybe<AvatarListAvatarsResponse>;
  /** AvatarService.BatchGetAvatars */
  avatarsBatch?: Maybe<AvatarBatchGetAvatarsResponse>;
  /** ProgressionService.BatchGetSeasonProgression */
  batchGetSeasonProgression?: Maybe<ProgressionBatchGetSeasonProgressionResponse>;
  /** BadgeService.BatchGetUserBadges */
  batchGetUserBadges?: Maybe<BadgeBatchGetUserBadgesResponse>;
  /** FriendsService.ListBlockedUsers */
  blockedUsers?: Maybe<FriendsListBlockedUsersResponse>;
  /** BoosterService.GetBooster */
  booster?: Maybe<GameLogicBooster>;
  /** BoosterService.ListBoosters */
  boosters?: Maybe<GameCardListBoostersResponse>;
  /** ChallengeService.GetChallenge */
  challenge?: Maybe<GameLogicChallenge>;
  /** ChallengeService.GetChallengeRewards */
  challengeRewards?: Maybe<ChallengeGetChallengeRewardsResponse>;
  /** ChallengeService.BatchGetChallenges */
  challengesBatch?: Maybe<ChallengeListChallengesResponse>;
  /** ChannelService.GetChannel */
  channel?: Maybe<ChannelChannel>;
  /** FriendsService.GetChannelActiveFriends */
  channelActiveFriends?: Maybe<FriendsGetChannelActiveFriendsResponse>;
  /** StreamerService.ListChannelActivityEvents */
  channelActivityEvents?: Maybe<StreamerListChannelActivityEventsResponse>;
  /** ChannelModerationService.ListBanAppeals */
  channelBanAppeals?: Maybe<ChannelListBanAppealsResponse>;
  /** ChannelModerationService.GetUserBanStatus */
  channelBanUserStatus?: Maybe<ChannelUserBanStatus>;
  /** ChannelModerationService.BatchGetUserBanStatus */
  channelBanUserStatuses?: Maybe<ChannelBatchGetUserBanStatusResponse>;
  /** ChannelModerationService.ListBannedUsers */
  channelBannedUsers?: Maybe<ChannelListBannedUsersResponse>;
  /** ChannelService.GetChannelByName */
  channelByName?: Maybe<ChannelChannel>;
  /** ChannelEmojiService.ListChannelEmojis */
  channelEmojis?: Maybe<EmojiListChannelEmojisResponse>;
  /** FeatureFlagService.GetChannelFeatureFlag */
  channelFeatureFlag?: Maybe<FlagFeatureFlagState>;
  /** FeatureFlagService.ListChannelFeatureFlags */
  channelFeatureFlags?: Maybe<FlagListChannelFeatureFlagsResponse>;
  /** ChannelNotificationService.GetFollowerNotificationSettings */
  channelFollowerNotificationSettings?: Maybe<ChannelFollowerNotificationSettings>;
  /** ChannelService.GetChannelFollowerStatus */
  channelFollowerStatus?: Maybe<ChannelGetChannelFollowerStatusResponse>;
  /** ChannelService.ListGameStats */
  channelGameStats?: Maybe<ChannelListGameStatsResponse>;
  /** ChannelService.BatchGetGameStats */
  channelGameStatsBatch?: Maybe<ChannelBatchGetGameStatsResponse>;
  /** ChannelModerationService.GetModerationSettings */
  channelModerationSettings?: Maybe<ChannelModerationSettings>;
  /** ChannelNotificationService.GetNotificationSettings */
  channelNotificationSettings?: Maybe<ChannelNotificationSettings>;
  /** ChannelService.ListChannelPrivilegedUsers */
  channelPrivilegedUsers?: Maybe<ChannelListChannelPrivilegedUsersResponse>;
  /** StoreServiceV2.GetChannelStoreFront */
  channelStoreFront?: Maybe<StoreV2StoreFront>;
  /** ChannelSubscriptionService.GetChannelSubscriptionConfig */
  channelSubscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  /** ChannelSubscriptionService.ListChannelSubscriptionTiers */
  channelSubscriptionTiers?: Maybe<SubscriptionListChannelSubscriptionTiersResponse>;
  /** ChannelSubscriptionService.ListChannelSubscriptions */
  channelSubscriptions?: Maybe<SubscriptionListChannelSubscriptionsResponse>;
  /** ChannelService.ListChannels */
  channels?: Maybe<ChannelListChannelsResponse>;
  /** ChatService.ListMessages */
  chatMessages?: Maybe<ChatListMessagesResponse>;
  /** ChatModerationService.GetChatUserStatus */
  chatUserStatus?: Maybe<ChatGetChatUserStatusResponse>;
  /** ChatService.ListChatUsers */
  chatUsers?: Maybe<ChatListChatUsersResponse>;
  /** ArenaService.GetClientSideArena */
  clientSideArena?: Maybe<ArenaClientSideArena>;
  /** ArenaService.ListClientSideArenas */
  clientSideArenas?: Maybe<ArenaListClientSideArenasResponse>;
  /** ProgressionService.GetDailyParticipationLimit */
  dailyParticipationLimit?: Maybe<ProgressionGetDailyParticipationLimitResponse>;
  /** ProgressionService.GetDailyXPBoostLimit */
  dailyXPBoostLimit?: Maybe<ProgressionGetDailyXpBoostLimitResponse>;
  /** ProgressionService.GetDailyXPEarningsLimit */
  dailyXPEarningsLimit?: Maybe<ProgressionGetDailyXpEarningsLimitResponse>;
  /** FTUEService.ListDismissedTooltips */
  dismissedTooltips?: Maybe<FtueListDismissedTooltipsResponse>;
  /** EmojiService.GetEmoji */
  emoji?: Maybe<EmojiEmoji>;
  /** EmojiService.BatchGetEmojis */
  emojisBatch?: Maybe<EmojiBatchGetEmojisResponse>;
  /** FeatureFlagService.GetFeatureFlagConfig */
  featureFlagConfig?: Maybe<FlagFeatureFlagConfig>;
  /** FeatureFlagService.GetFeatureFlagSchema */
  featureFlagSchema?: Maybe<FlagFeatureFlagSchema>;
  /** ChannelService.GetFollowStatus */
  followStatuses?: Maybe<ChannelGetFollowStatusResponse>;
  /** ChannelService.GetUserFollowedChannels */
  followedChannels?: Maybe<ChannelGetUserFollowedChannelsResponse>;
  /** FriendsService.ListFriends */
  friends?: Maybe<FriendsListFriendsResponse>;
  /** FriendsService.GetFriendshipStatus */
  friendshipStatuses?: Maybe<FriendsGetFriendshipStatusResponse>;
  /** GameService.GetGame */
  game?: Maybe<GameGame>;
  /** GameCardService.BatchGetGameCards */
  gameCards?: Maybe<GameCardBatchGetGameCardsResponse>;
  /** GameService.BatchGetGames */
  games?: Maybe<GameBatchGetGamesResponse>;
  /** ChallengeSessionService.GetChallengeSession */
  getChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelService.BatchGetChannels */
  getChannels?: Maybe<ChannelBatchGetChannelsResponse>;
  /** ChannelService.BatchStreamGetChannel */
  getStreamChannels?: Maybe<ChannelBatchStreamGetChannelResponse>;
  /** StoreServiceV2.ListGiftSellableItems */
  giftSellableItems?: Maybe<StoreV2ListGiftSellableItemsResponse>;
  /** GoalCardService.GetGoalCard */
  goalCard?: Maybe<GoalCardGoalCard>;
  /** GoalCardService.GetSlotOptions */
  goalCardSlotOptions?: Maybe<GoalCardGetSlotOptionsResponse>;
  /** GoalCardService.ListGoalCardSlots */
  goalCardSlots?: Maybe<GoalCardListGoalCardSlotsResponse>;
  /** GoalCardService.BatchGetGoalCards */
  goalCards?: Maybe<GoalCardBatchGetGoalCardsResponse>;
  /** ChannelService.ListHighlightedChannels */
  highlightedChannels?: Maybe<ChannelListHighlightedChannelsResponse>;
  /** StreamIngestConfigService.GetIngestConfig */
  ingestConfig?: Maybe<StreamIngestConfigChannelIngestConfig>;
  /** StreamIngestConfigService.ListIngestConfigs */
  ingestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** UserInventoryService.ListUserInventory */
  inventory?: Maybe<InventoryListUserInventoryResponse>;
  /** InvitationService.ListInvitationCodes */
  invitationCodes?: Maybe<InvitationListInvitationCodesResponse>;
  /** ItemService.GetItem */
  item?: Maybe<ItemGetItemResponse>;
  /** ItemService.ExpandItem */
  itemExpand?: Maybe<ItemExpandItemResponse>;
  /** ItemService.ListItems */
  items?: Maybe<ItemListItemsResponse>;
  /** ItemService.BatchGetItems */
  itemsBatch?: Maybe<ItemBatchGetItemsResponse>;
  /** ItemService.BatchExpandItems */
  itemsBatchExpand?: Maybe<ItemBatchExpandItemsResponse>;
  /** ChallengeService.ListChallenges */
  listChallenges?: Maybe<ChallengeListChallengesResponse>;
  /** GameCardService.ListGameCards */
  listGameCards?: Maybe<GameCardListGameCardsResponse>;
  /** GameService.ListGames */
  listGames?: Maybe<GameListGamesResponse>;
  /** ProgressionService.ListLevelConfigs */
  listLevelConfigs?: Maybe<ProgressionListLevelConfigsResponse>;
  /** ProgressionService.ListSeasonProgression */
  listSeasonProgression?: Maybe<ProgressionListSeasonProgressionResponse>;
  /** GameService.ListSeasons */
  listSeasons?: Maybe<GameListSeasonsResponse>;
  /** MatchServiceV2.GetGroupChatID */
  matchGroupChatID?: Maybe<MatchGetGroupChatIdResponse>;
  /** MatchAdminService.GetGroupState */
  matchGroupState?: Maybe<MatchGetGroupStateResponse>;
  /** MatchServiceV2.GetMatchState */
  matchState?: Maybe<MatchGetMatchStateResponse>;
  /** MatchAdminService.GetStreamState */
  matchStreamState?: Maybe<MatchGetStreamStateResponse>;
  /** MediaService.BatchGetMediaUrl */
  mediaUrlsBatch?: Maybe<MediaBatchGetMediaUrlResponse>;
  /** MLControllerService.GetHUDScale */
  mlHUDScale?: Maybe<MlControllerGetHudScaleResponse>;
  /** ChannelModerationService.ListModerationEvents */
  moderationEvents?: Maybe<ChannelListModerationEventsResponse>;
  /** NotificationService.ListNotifications */
  notifications?: Maybe<NotificationListNotificationsResponse>;
  /** AuthServiceV4.GetOAuth2Consent */
  oauth2Consent?: Maybe<AuthV4GetOAuth2ConsentResponse>;
  /** PartyService.GetParty */
  party?: Maybe<PartyParty>;
  /** PaymentService.GetPayment */
  payment?: Maybe<PaymentPayment>;
  /** PaymentService.ListPayments */
  payments?: Maybe<PaymentListPaymentsResponse>;
  /** PlacementsService.GetPlacement */
  placement?: Maybe<AdsGetPlacementResponse>;
  /** PlatformModerationService.GetUserPlatformBan */
  platformBan?: Maybe<ModerationPlatformBan>;
  /** PlatformModerationService.ListPlatformBanAppeals */
  platformBanAppeals?: Maybe<ModerationListPlatformBanAppealsResponse>;
  /** PlatformEmojiService.ListPlatformEmojis */
  platformEmojis?: Maybe<EmojiListPlatformEmojisResponse>;
  /** StoreServiceV2.GetPlatformStoreFront */
  platformStoreFront?: Maybe<StoreV2StoreFront>;
  /** ProfileService.ListPlayedGames */
  playedGames?: Maybe<ProfileListPlayedGamesResponse>;
  /** ProfileService.GetProfile - Returns user profiles based on a given userID */
  profile?: Maybe<ProfileProfile>;
  /** ProfileService.BatchGetProfiles */
  profileBatch?: Maybe<ProfileBatchGetProfilesResponse>;
  /** ProfileService.ListProfiles */
  profiles?: Maybe<ProfileListProfilesResponse>;
  /** SearchService.PublicSearch */
  publicSearch?: Maybe<SearchSearchResponse>;
  /** PushNotificationService.GetNotificationToken */
  pushNotificationToken?: Maybe<NotificationPushNotificationToken>;
  /** FriendsService.ListReceivedFriendRequests */
  receivedFriendRequests?: Maybe<FriendsListReceivedFriendRequestsResponse>;
  /** SupportService.GetReportCase */
  reportCase?: Maybe<SupportReportCase>;
  /** SupportService.ListReports */
  reports?: Maybe<SupportListReportsResponse>;
  /** ProfileService.ResolveUserTags */
  resolveUserTags?: Maybe<ProfileResolveUserTagsResponse>;
  /** ChannelConfigService.GetRestreamingConfig */
  restreamingConfig?: Maybe<ChannelRestreamingConfig>;
  /** RewardService.ListRewards */
  rewards?: Maybe<RewardListRewardsResponse>;
  /** SearchService.Search */
  search?: Maybe<SearchSearchResponse>;
  /** GameService.GetSeason */
  season?: Maybe<GameSeason>;
  /** ProgressionService.GetSeasonProgression */
  seasonProgression?: Maybe<ProgressionSeasonProgression>;
  /** GameService.BatchGetSeasons */
  seasons?: Maybe<GameBatchGetSeasonsResponse>;
  /** ChannelConfigService.GetSelectedStreamBackendConfig */
  selectedStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StoreServiceV2.GetSellableItem */
  sellableItem?: Maybe<StoreV2SellableItem>;
  /** StoreServiceV2.ListSellableItems */
  sellableItems?: Maybe<StoreV2ListSellableItemsResponse>;
  /** FriendsService.ListSentFriendRequests */
  sentFriendRequests?: Maybe<FriendsListSentFriendRequestsResponse>;
  /** ChannelService.GetStream */
  stream?: Maybe<ChannelStream>;
  /** StreamerService.GetStreamAudienceInsights */
  streamAudienceInsights?: Maybe<StreamerStreamAudienceInsights>;
  /** ChannelConfigService.GetStreamBackendConfig */
  streamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** ChannelConfigService.ListStreamBackendConfigs */
  streamBackendConfigs?: Maybe<ChannelListStreamBackendConfigsResponse>;
  /** ChannelService.GetStreamSummary */
  streamSummary?: Maybe<ChannelStreamSummary>;
  /** ChannelService.BatchGetStreamSummary */
  streamSummaryBatch?: Maybe<ChannelBatchGetStreamSummaryResponse>;
  /** MatchServiceV2.GetTopActiveCards */
  streamTopActiveCards?: Maybe<MatchGetTopActiveCardsResponse>;
  /** StreamerCardService.GetStreamerCard */
  streamerCard?: Maybe<GameLogicStreamerCard>;
  /** StreamerCardService.ListStreamerCardDrafts */
  streamerCardDrafts?: Maybe<GameCardListStreamerCardDraftsResponse>;
  /** StoreServiceV2.ListStreamerCardSaleConfigs */
  streamerCardSaleConfigs?: Maybe<StoreV2ListStreamerCardSaleConfigsResponse>;
  /** StreamerCardService.ListStreamerCards */
  streamerCards?: Maybe<GameCardListStreamerCardsResponse>;
  /** StreamerCardService.BatchGetStreamerCards */
  streamerCardsBatch?: Maybe<GameCardBatchGetStreamerCardsResponse>;
  /** ChannelService.ListStreams */
  streams?: Maybe<ChannelListStreamsResponse>;
  /** PaymentService.ListSuccessfulPayments */
  successfulPayments?: Maybe<PaymentListSuccessfulPaymentsResponse>;
  /** SupportService.GetArticle */
  supportArticle?: Maybe<SupportArticle>;
  /** StoreServiceV2.ListTopUpSellableItems */
  topUpSellableItems?: Maybe<StoreV2ListTopUpSellableItemsResponse>;
  /** AnnouncementService.ListUserAnnouncements */
  userAnnouncements?: Maybe<AnnouncementListUserAnnouncementsResponse>;
  /** BadgeService.GetUserBadges */
  userBadges?: Maybe<BadgeGetUserBadgesResponse>;
  /** ChannelService.GetUserChannel */
  userChannel?: Maybe<ChannelChannel>;
  /** ChannelModerationService.ListUserChannelBans */
  userChannelBans?: Maybe<ChannelListUserChannelBansResponse>;
  /** ChannelService.ListUserChannelRoles */
  userChannelRoles?: Maybe<ChannelListUserChannelRolesResponse>;
  /** ChannelSubscriptionService.GetUserChannelSubscription */
  userChannelSubscription?: Maybe<SubscriptionChannelSubscription>;
  /** ChannelSubscriptionService.ListUserChannelSubscriptions */
  userChannelSubscriptions?: Maybe<SubscriptionListUserChannelSubscriptionsResponse>;
  /** FeatureFlagService.GetUserFeatureFlag */
  userFeatureFlag?: Maybe<FlagFeatureFlagState>;
  /** FeatureFlagService.ListUserFeatureFlags */
  userFeatureFlags?: Maybe<FlagListUserFeatureFlagsResponse>;
  /** PartyService.GetUserParty */
  userParty?: Maybe<PartyParty>;
  /** ChannelService.ListUserPrivilegedChannels */
  userPrivilegedChannels?: Maybe<ChannelListUserPrivilegedChannelsResponse>;
  /** ProfileService.GetUsernameHistory */
  usernameHistory?: Maybe<ProfileGetUsernameHistoryResponse>;
  /** WalletService.GetWallet */
  wallet?: Maybe<WalletGetWalletResponse>;
  /** WalletService.ListWalletTransactions */
  walletTransactions?: Maybe<WalletListWalletTransactionsResponse>;
};


export type QueryAccountArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAgreementsArgs = {
  includeOldRevisions?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAnnouncementsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<AnnouncementAnnouncementFilterInput>;
};


export type QueryArenaArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryArenasArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryAvatarArgs = {
  avatarId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAvatarAnimationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAvatarAnimationBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryAvatarPartArgs = {
  avatarPartId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAvatarPartsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryAvatarsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  listAll?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAvatarsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryBatchGetSeasonProgressionArgs = {
  queries?: InputMaybe<Array<ProgressionBatchGetSeasonProgressionRequestQueryInput>>;
};


export type QueryBatchGetUserBadgesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type QueryBlockedUsersArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryBoosterArgs = {
  id?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChallengeRewardsArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChallengesBatchArgs = {
  challengeIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryChannelArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelActiveFriendsArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelActivityEventsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<StreamerChannelActivityEventFilterInput>;
};


export type QueryChannelBanAppealsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelBanUserStatusArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelBanUserStatusesArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelBannedUsersArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelByNameArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
};


export type QueryChannelEmojisArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  includeCount?: InputMaybe<Scalars['Boolean']['input']>;
  includeDisabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryChannelFeatureFlagArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  flagName?: InputMaybe<Scalars['String']['input']>;
};


export type QueryChannelFeatureFlagsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelFollowerNotificationSettingsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelFollowerStatusArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelGameStatsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<ChannelListGameStatsRequestFilterInput>>;
};


export type QueryChannelGameStatsBatchArgs = {
  gameIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryChannelModerationSettingsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelNotificationSettingsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelPrivilegedUsersArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelStoreFrontArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelSubscriptionConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelSubscriptionTiersArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelSubscriptionsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<SubscriptionListChannelSubscriptionsRequestFilterInput>>;
};


export type QueryChannelsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  liveStatus?: InputMaybe<ChannelLiveStatus>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type QueryChatMessagesArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChatUserStatusArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChatUsersArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<Scalars['String']['input']>;
  userLabel?: InputMaybe<ChatUserLabel>;
};


export type QueryClientSideArenaArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryClientSideArenasArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryDismissedTooltipsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryEmojiArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryEmojisBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryFeatureFlagConfigArgs = {
  revision?: InputMaybe<Scalars['String']['input']>;
};


export type QueryFollowStatusesArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryFollowedChannelsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  liveStatus?: InputMaybe<ChannelLiveStatus>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryFriendsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<FriendsListFriendsRequestFilterInput>>;
  priorityOrder?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryFriendshipStatusesArgs = {
  friendIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGameArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGameCardsArgs = {
  cardIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGamesArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGetChallengeSessionArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGetChannelsArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGetStreamChannelsArgs = {
  streamIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGiftSellableItemsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};


export type QueryGoalCardArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGoalCardSlotOptionsArgs = {
  slotId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGoalCardsArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryHighlightedChannelsArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIngestConfigArgs = {
  ftlId?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryInventoryArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<InventoryListUserInventoryRequestFilterInput>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryInvitationCodesArgs = {
  includeUsed?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryItemArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryItemExpandArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryItemsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<ItemListItemsRequestFilterInput>>;
};


export type QueryItemsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryItemsBatchExpandArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryListChallengesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListGameCardsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListGamesArgs = {
  gameName?: InputMaybe<Scalars['String']['input']>;
};


export type QueryListLevelConfigsArgs = {
  maxLevel?: InputMaybe<Scalars['Int']['input']>;
  minLevel?: InputMaybe<Scalars['Int']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListSeasonProgressionArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListSeasonsArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchGroupChatIdArgs = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchGroupStateArgs = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchStateArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchStreamStateArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMediaUrlsBatchArgs = {
  options?: InputMaybe<MediaMediaOptionsInput>;
  urls?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryMlHudScaleArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryModerationEventsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<ChannelModerationEventsFilterInput>;
};


export type QueryNotificationsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};


export type QueryOauth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']['input']>;
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPartyArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPaymentArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPaymentsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<PaymentListPaymentsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlacementArgs = {
  placementId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlatformBanArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlatformBanAppealsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  status?: InputMaybe<ModerationAppealStatus>;
};


export type QueryPlatformEmojisArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  includeCount?: InputMaybe<Scalars['Boolean']['input']>;
  includeDisabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryPlatformStoreFrontArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlayedGamesArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryProfileArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryProfileBatchArgs = {
  userIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryProfilesArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryPublicSearchArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  entityTypes?: InputMaybe<Array<SearchEntityType>>;
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QueryPushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']['input']>;
};


export type QueryReceivedFriendRequestsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryReportCaseArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryReportsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<SupportReportsFilterInput>;
};


export type QueryResolveUserTagsArgs = {
  userTags?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryRestreamingConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRewardsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySearchArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  entityTypes?: InputMaybe<Array<SearchEntityType>>;
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySeasonArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySeasonProgressionArgs = {
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySeasonsArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QuerySelectedStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySellableItemArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySellableItemsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<StoreV2ListSellableItemsRequestFilterInput>;
};


export type QuerySentFriendRequestsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamAudienceInsightsArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamBackendConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamSummaryArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamSummaryBatchArgs = {
  streamIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryStreamTopActiveCardsArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamerCardArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamerCardDraftsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<GameCardListStreamerCardDraftsRequestFilterInput>>;
};


export type QueryStreamerCardSaleConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryStreamerCardsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<GameCardListStreamerCardsRequestFilterInput>>;
};


export type QueryStreamerCardsBatchArgs = {
  streamerCardIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryStreamsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QuerySuccessfulPaymentsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<PaymentListSuccessfulPaymentsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySupportArticleArgs = {
  attachmentBaseUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTopUpSellableItemsArgs = {
  currencyId?: InputMaybe<Scalars['ID']['input']>;
  minAmount?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryUserAnnouncementsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  target?: InputMaybe<AnnouncementAnnouncementTarget>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserBadgesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelBansArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelRolesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelSubscriptionsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<SubscriptionListUserChannelSubscriptionsRequestFilterInput>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserFeatureFlagArgs = {
  flagName?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserFeatureFlagsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserPartyArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserPrivilegedChannelsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUsernameHistoryArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryWalletArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryWalletTransactionsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<WalletListWalletTransactionsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export enum RarityRarity {
  RarityCommon = 'RARITY_COMMON',
  RarityEpic = 'RARITY_EPIC',
  RarityLegendary = 'RARITY_LEGENDARY',
  RarityRare = 'RARITY_RARE',
  RarityUncommon = 'RARITY_UNCOMMON',
  RarityUnspecified = 'RARITY_UNSPECIFIED'
}

export type ReactionReactionEvent = {
  __typename?: 'ReactionReactionEvent';
  event?: Maybe<ReactionReactionEventEventUnion>;
  parentId: Scalars['ID']['output'];
  parentType: Scalars['String']['output'];
};

export type ReactionReactionEventAdd = {
  __typename?: 'ReactionReactionEventAdd';
  reactionType: ReactionReactionType;
  resourceId: Scalars['ID']['output'];
  resourceType: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
};

export type ReactionReactionEventEventUnion = ReactionReactionEventAdd | ReactionReactionEventInitial | ReactionReactionEventRemove;

export type ReactionReactionEventInitial = {
  __typename?: 'ReactionReactionEventInitial';
  states: Array<ReactionReactionState>;
};

export type ReactionReactionEventRemove = {
  __typename?: 'ReactionReactionEventRemove';
  reactionType: ReactionReactionType;
  resourceId: Scalars['ID']['output'];
  resourceType: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
};

export type ReactionReactionState = {
  __typename?: 'ReactionReactionState';
  /** reactions is a map of reaction type (enum string) to count */
  reactions: Array<ReactionReactionStateReactionsEntry>;
  resourceId: Scalars['ID']['output'];
  resourceType: Scalars['String']['output'];
  userHasReacted: Scalars['Boolean']['output'];
};

export type ReactionReactionStateReactionsEntry = {
  __typename?: 'ReactionReactionStateReactionsEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export enum ReactionReactionType {
  ReactionTypeLike = 'REACTION_TYPE_LIKE',
  ReactionTypeUnspecified = 'REACTION_TYPE_UNSPECIFIED'
}

export type ReasonReason = {
  __typename?: 'ReasonReason';
  metadata?: Maybe<AttributeAttributeMap>;
  reason?: Maybe<ReasonReasonReasonUnion>;
};

export type ReasonReasonAdWatched = {
  __typename?: 'ReasonReasonAdWatched';
  placementId: Scalars['ID']['output'];
};

export type ReasonReasonAdWatchedInput = {
  placementId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonAdministrative = {
  __typename?: 'ReasonReasonAdministrative';
  reason: Scalars['String']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ReasonReasonAdministrativeInput = {
  reason?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonChallengeSuccessful = {
  __typename?: 'ReasonReasonChallengeSuccessful';
  challengeId: Scalars['ID']['output'];
};

export type ReasonReasonChallengeSuccessfulInput = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonChannelOwner = {
  __typename?: 'ReasonReasonChannelOwner';
  channelId: Scalars['ID']['output'];
};

export type ReasonReasonChannelOwnerInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonChannelSubscription = {
  __typename?: 'ReasonReasonChannelSubscription';
  channelId: Scalars['ID']['output'];
};

export type ReasonReasonChannelSubscriptionInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithInGameCurrency = {
  __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID']['output'];
  revenueShares: Array<ReasonRevenueShare>;
  senderId: Scalars['ID']['output'];
  sku: Scalars['String']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithInGameCurrencyInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  senderId?: InputMaybe<Scalars['ID']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithPayment = {
  __typename?: 'ReasonReasonGiftPurchaseWithPayment';
  cardIssuingCountry: Scalars['String']['output'];
  orderId: Scalars['ID']['output'];
  price: PaymentAmount;
  reference: Scalars['String']['output'];
  senderId: Scalars['ID']['output'];
  sku: Scalars['String']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithPaymentInput = {
  cardIssuingCountry?: InputMaybe<Scalars['String']['input']>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  price?: InputMaybe<PaymentAmountInput>;
  reference?: InputMaybe<Scalars['String']['input']>;
  senderId?: InputMaybe<Scalars['ID']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type ReasonReasonGoalCardComplete = {
  __typename?: 'ReasonReasonGoalCardComplete';
  goalCard: GoalCardGoalCard;
  goalCardId: Scalars['ID']['output'];
  goalCardSlotId: Scalars['ID']['output'];
};

export type ReasonReasonGoalCardCompleteInput = {
  goalCardId?: InputMaybe<Scalars['ID']['input']>;
  goalCardSlotId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonGoalCardSlotReshuffle = {
  __typename?: 'ReasonReasonGoalCardSlotReshuffle';
  goalCardSlotId: Scalars['ID']['output'];
};

export type ReasonReasonGoalCardSlotReshuffleInput = {
  goalCardSlotId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonInput = {
  adWatched?: InputMaybe<ReasonReasonAdWatchedInput>;
  administrative?: InputMaybe<ReasonReasonAdministrativeInput>;
  challengeSuccessful?: InputMaybe<ReasonReasonChallengeSuccessfulInput>;
  channelOwner?: InputMaybe<ReasonReasonChannelOwnerInput>;
  channelSubscription?: InputMaybe<ReasonReasonChannelSubscriptionInput>;
  giftPurchaseWithInGameCurrency?: InputMaybe<ReasonReasonGiftPurchaseWithInGameCurrencyInput>;
  giftPurchaseWithPayment?: InputMaybe<ReasonReasonGiftPurchaseWithPaymentInput>;
  goalCardComplete?: InputMaybe<ReasonReasonGoalCardCompleteInput>;
  goalCardSlotReshuffle?: InputMaybe<ReasonReasonGoalCardSlotReshuffleInput>;
  levelUp?: InputMaybe<ReasonReasonLevelUpInput>;
  matchEnd?: InputMaybe<ReasonReasonMatchEndInput>;
  metadata?: InputMaybe<AttributeAttributeMapInput>;
  provision?: InputMaybe<ReasonReasonProvisionInput>;
  purchaseWithInGameCurrency?: InputMaybe<ReasonReasonPurchaseWithInGameCurrencyInput>;
  purchaseWithPayment?: InputMaybe<ReasonReasonPurchaseWithPaymentInput>;
  reshuffle?: InputMaybe<ReasonReasonReshuffleInput>;
  rewardClaimed?: InputMaybe<ReasonReasonRewardClaimedInput>;
  storeOrderPayment?: InputMaybe<ReasonReasonStoreOrderPaymentInput>;
};

export type ReasonReasonLevelUp = {
  __typename?: 'ReasonReasonLevelUp';
  level: Scalars['Int']['output'];
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
};

export type ReasonReasonLevelUpInput = {
  level?: InputMaybe<Scalars['Int']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonMatchEnd = {
  __typename?: 'ReasonReasonMatchEnd';
  groupId: Scalars['ID']['output'];
};

export type ReasonReasonMatchEndInput = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonProvision = {
  __typename?: 'ReasonReasonProvision';
  rev: Scalars['String']['output'];
  seasonId: Scalars['ID']['output'];
};

export type ReasonReasonProvisionInput = {
  rev?: InputMaybe<Scalars['String']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithInGameCurrency = {
  __typename?: 'ReasonReasonPurchaseWithInGameCurrency';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID']['output'];
  revenueShares: Array<ReasonRevenueShare>;
  sku: Scalars['String']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithInGameCurrencyInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithPayment = {
  __typename?: 'ReasonReasonPurchaseWithPayment';
  cardIssuingCountry: Scalars['String']['output'];
  orderId: Scalars['ID']['output'];
  price: PaymentAmount;
  reference: Scalars['String']['output'];
  sku: Scalars['String']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithPaymentInput = {
  cardIssuingCountry?: InputMaybe<Scalars['String']['input']>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  price?: InputMaybe<PaymentAmountInput>;
  reference?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type ReasonReasonReasonUnion = ReasonReasonAdWatched | ReasonReasonAdministrative | ReasonReasonChallengeSuccessful | ReasonReasonChannelOwner | ReasonReasonChannelSubscription | ReasonReasonGiftPurchaseWithInGameCurrency | ReasonReasonGiftPurchaseWithPayment | ReasonReasonGoalCardComplete | ReasonReasonGoalCardSlotReshuffle | ReasonReasonLevelUp | ReasonReasonMatchEnd | ReasonReasonProvision | ReasonReasonPurchaseWithInGameCurrency | ReasonReasonPurchaseWithPayment | ReasonReasonReshuffle | ReasonReasonRewardClaimed | ReasonReasonStoreOrderPayment;

export type ReasonReasonReshuffle = {
  __typename?: 'ReasonReasonReshuffle';
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  streamId: Scalars['ID']['output'];
};

export type ReasonReasonReshuffleInput = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
  matchId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonRewardClaimed = {
  __typename?: 'ReasonReasonRewardClaimed';
  rewardId: Scalars['ID']['output'];
  rewardReason: ReasonReason;
};

export type ReasonReasonRewardClaimedInput = {
  rewardId?: InputMaybe<Scalars['ID']['input']>;
  rewardReason?: InputMaybe<ReasonReasonInput>;
};

export type ReasonReasonStoreOrderPayment = {
  __typename?: 'ReasonReasonStoreOrderPayment';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID']['output'];
  revenueShares: Array<ReasonRevenueShare>;
  sku: Scalars['String']['output'];
};

export type ReasonReasonStoreOrderPaymentInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

export type ReasonRevenueRecipient = {
  __typename?: 'ReasonRevenueRecipient';
  kind: ReasonRevenueRecipientKind;
  recipientId: Scalars['ID']['output'];
};

export type ReasonRevenueRecipientInput = {
  kind?: InputMaybe<ReasonRevenueRecipientKind>;
  recipientId?: InputMaybe<Scalars['ID']['input']>;
};

export enum ReasonRevenueRecipientKind {
  KindChannel = 'KIND_CHANNEL',
  KindPlatform = 'KIND_PLATFORM',
  KindUnspecified = 'KIND_UNSPECIFIED'
}

export type ReasonRevenueShare = {
  __typename?: 'ReasonRevenueShare';
  percent: Scalars['Int']['output'];
  recipient: ReasonRevenueRecipient;
};

export type ReasonRevenueShareInput = {
  percent?: InputMaybe<Scalars['Int']['input']>;
  recipient?: InputMaybe<ReasonRevenueRecipientInput>;
};

export enum RenderingCameraTransitionRequestTransitionTarget {
  TransitionTargetArena = 'TRANSITION_TARGET_ARENA',
  TransitionTargetCameraDrive1 = 'TRANSITION_TARGET_CAMERA_DRIVE1',
  TransitionTargetSpotlight = 'TRANSITION_TARGET_SPOTLIGHT',
  TransitionTargetUnspecified = 'TRANSITION_TARGET_UNSPECIFIED'
}

export type RewardClaimRewardResponse = {
  __typename?: 'RewardClaimRewardResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type RewardListRewardsResponse = {
  __typename?: 'RewardListRewardsResponse';
  rewards: Array<RewardReward>;
};

export type RewardReward = {
  __typename?: 'RewardReward';
  id: Scalars['ID']['output'];
  reason: ReasonReason;
  rewardedAt: Scalars['Timestamp']['output'];
  type: RewardRewardType;
  userId: Scalars['ID']['output'];
};

export type RewardRewardType = {
  __typename?: 'RewardRewardType';
  reward?: Maybe<RewardRewardTypeRewardUnion>;
};

export type RewardRewardTypeCurrency = {
  __typename?: 'RewardRewardTypeCurrency';
  currencyAmount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
};

export type RewardRewardTypeItem = {
  __typename?: 'RewardRewardTypeItem';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type RewardRewardTypeRewardUnion = RewardRewardTypeCurrency | RewardRewardTypeItem;

export enum SearchEntityType {
  EntityTypeChannel = 'ENTITY_TYPE_CHANNEL',
  EntityTypeGame = 'ENTITY_TYPE_GAME',
  EntityTypeUnspecified = 'ENTITY_TYPE_UNSPECIFIED',
  EntityTypeUser = 'ENTITY_TYPE_USER'
}

export type SearchResultItem = {
  __typename?: 'SearchResultItem';
  entity?: Maybe<SearchResultItemEntityUnion>;
  entityId: Scalars['ID']['output'];
  entityType: SearchEntityType;
  matchedProperties: Array<Scalars['String']['output']>;
  score: Scalars['Float']['output'];
};

export type SearchResultItemEntityUnion = ChannelChannel | ChannelGameStats | ProfileProfile;

export type SearchSearchResponse = {
  __typename?: 'SearchSearchResponse';
  pageInfo: ApiPageInfo;
  resultItems: Array<SearchResultItem>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2BuyWithInGameCurrencyResponse = {
  __typename?: 'StoreV2BuyWithInGameCurrencyResponse';
  orderId: Scalars['ID']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2BuyWithPaymentResponse = {
  __typename?: 'StoreV2BuyWithPaymentResponse';
  orderId: Scalars['ID']['output'];
  session: PaymentSession;
};

export type StoreV2Content = {
  __typename?: 'StoreV2Content';
  value?: Maybe<StoreV2ContentValueUnion>;
};

export type StoreV2ContentValueUnion = StoreV2CurrencyRef | StoreV2ItemRef | StoreV2SubscriptionRef;

export type StoreV2CurrencyRef = {
  __typename?: 'StoreV2CurrencyRef';
  amount: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
};

export type StoreV2GiftOptionsInput = {
  giftAnonymously?: InputMaybe<Scalars['Boolean']['input']>;
  recipientIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2InGameCurrencyPrice = {
  __typename?: 'StoreV2InGameCurrencyPrice';
  amount: Scalars['Int']['output'];
  amountWithoutDiscount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
  default: Scalars['Boolean']['output'];
};

export type StoreV2ItemRef = {
  __typename?: 'StoreV2ItemRef';
  count: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  inventoryState?: Maybe<InventoryInventoryItem>;
  item: ItemItem;
};

export enum StoreV2ItemType {
  ItemTypeAvatarPart = 'ITEM_TYPE_AVATAR_PART',
  ItemTypeCurrencyPack = 'ITEM_TYPE_CURRENCY_PACK',
  ItemTypeGiftSubscription = 'ITEM_TYPE_GIFT_SUBSCRIPTION',
  ItemTypePremiumCardBundle = 'ITEM_TYPE_PREMIUM_CARD_BUNDLE',
  ItemTypeStandardCardBundle = 'ITEM_TYPE_STANDARD_CARD_BUNDLE',
  ItemTypeStreamerCard = 'ITEM_TYPE_STREAMER_CARD',
  ItemTypeUnspecified = 'ITEM_TYPE_UNSPECIFIED'
}

export type StoreV2ListGiftSellableItemsResponse = {
  __typename?: 'StoreV2ListGiftSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
};

export type StoreV2ListSellableItemsRequestChannelStoreFilterInput = {
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};

export type StoreV2ListSellableItemsRequestFilterInput = {
  channel?: InputMaybe<StoreV2ListSellableItemsRequestChannelStoreFilterInput>;
  platform?: InputMaybe<StoreV2ListSellableItemsRequestPlatformStoreFilterInput>;
};

export type StoreV2ListSellableItemsRequestPlatformStoreFilterInput = {
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};

export type StoreV2ListSellableItemsResponse = {
  __typename?: 'StoreV2ListSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
  pageInfo: ApiPageInfo;
};

export type StoreV2ListStreamerCardSaleConfigsResponse = {
  __typename?: 'StoreV2ListStreamerCardSaleConfigsResponse';
  configs: Array<StoreV2StreamerCardSaleConfig>;
  pageInfo: ApiPageInfo;
};

export type StoreV2ListTopUpSellableItemsResponse = {
  __typename?: 'StoreV2ListTopUpSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
};

export enum StoreV2PaymentMethod {
  PaymentMethodAdyen = 'PAYMENT_METHOD_ADYEN',
  PaymentMethodAppstore = 'PAYMENT_METHOD_APPSTORE',
  PaymentMethodUnspecified = 'PAYMENT_METHOD_UNSPECIFIED'
}

export type StoreV2Period = {
  __typename?: 'StoreV2Period';
  from: Scalars['Timestamp']['output'];
  until: Scalars['Timestamp']['output'];
};

export type StoreV2PeriodInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  until?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type StoreV2Price = {
  __typename?: 'StoreV2Price';
  amount: Scalars['Int']['output'];
  amountWithoutDiscount: Scalars['Int']['output'];
  currency: PaymentCurrency;
};

export type StoreV2PurchaseLimits = {
  __typename?: 'StoreV2PurchaseLimits';
  perItem: Scalars['Int']['output'];
  perUser: Scalars['Int']['output'];
};

export enum StoreV2RecipientRestriction {
  RecipientRestrictionGiftOnly = 'RECIPIENT_RESTRICTION_GIFT_ONLY',
  RecipientRestrictionSelfOnly = 'RECIPIENT_RESTRICTION_SELF_ONLY',
  RecipientRestrictionUnspecified = 'RECIPIENT_RESTRICTION_UNSPECIFIED'
}

export type StoreV2SellableItem = {
  __typename?: 'StoreV2SellableItem';
  availableUntil?: Maybe<Scalars['Timestamp']['output']>;
  content: Array<StoreV2Content>;
  discountPercent: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  igcPrices?: Maybe<Array<StoreV2InGameCurrencyPrice>>;
  meta: StoreV2SellableItemMeta;
  name: Scalars['String']['output'];
  price?: Maybe<StoreV2Price>;
  promotionName: Scalars['String']['output'];
  purchaseLimits: StoreV2PurchaseLimits;
  recipientRestriction: StoreV2RecipientRestriction;
  signature: Scalars['String']['output'];
  sku: Scalars['String']['output'];
  type: StoreV2ItemType;
};

export type StoreV2SellableItemMeta = {
  __typename?: 'StoreV2SellableItemMeta';
  channelId: Scalars['ID']['output'];
  configId: Scalars['ID']['output'];
  itemType: StoreV2ItemType;
  promotionId: Scalars['ID']['output'];
  storeFrontId: Scalars['ID']['output'];
  storeType: StoreV2StoreType;
};

export type StoreV2StoreFront = {
  __typename?: 'StoreV2StoreFront';
  categories?: Maybe<Array<StoreV2StoreFrontCategory>>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  type: StoreV2StoreType;
};

export type StoreV2StoreFrontCategory = {
  __typename?: 'StoreV2StoreFrontCategory';
  id: Scalars['ID']['output'];
  itemType: StoreV2ItemType;
  sellableItems: Array<StoreV2SellableItem>;
};

export enum StoreV2StoreType {
  StoreTypeAvatarEditor = 'STORE_TYPE_AVATAR_EDITOR',
  StoreTypeChannel = 'STORE_TYPE_CHANNEL',
  StoreTypePlatform = 'STORE_TYPE_PLATFORM',
  StoreTypeUnspecified = 'STORE_TYPE_UNSPECIFIED'
}

export type StoreV2StreamerCardSaleConfig = {
  __typename?: 'StoreV2StreamerCardSaleConfig';
  cardId: Scalars['ID']['output'];
  channelId: Scalars['ID']['output'];
  enabled: Scalars['Boolean']['output'];
  excludeFromBundles: Scalars['Boolean']['output'];
  period?: Maybe<StoreV2Period>;
};

export type StoreV2StreamerCardSaleConfigUpdateInput = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  excludeFromBundles?: InputMaybe<Scalars['Boolean']['input']>;
  period?: InputMaybe<StoreV2PeriodInput>;
  unsetPeriod?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StoreV2SubscriptionRef = {
  __typename?: 'StoreV2SubscriptionRef';
  amount: Scalars['Int']['output'];
  channelId: Scalars['ID']['output'];
  /** this is not used */
  id: Scalars['ID']['output'];
  tier: Scalars['Int']['output'];
};

export enum StreamDeploymentStreamDeploymentStatusComponentStatus {
  ComponentStatusContainersUnready = 'COMPONENT_STATUS_CONTAINERS_UNREADY',
  ComponentStatusDeployingContainers = 'COMPONENT_STATUS_DEPLOYING_CONTAINERS',
  ComponentStatusDeployingPod = 'COMPONENT_STATUS_DEPLOYING_POD',
  ComponentStatusDeploymentStarted = 'COMPONENT_STATUS_DEPLOYMENT_STARTED',
  ComponentStatusDisabled = 'COMPONENT_STATUS_DISABLED',
  ComponentStatusOffline = 'COMPONENT_STATUS_OFFLINE',
  ComponentStatusProvisioningNode = 'COMPONENT_STATUS_PROVISIONING_NODE',
  ComponentStatusReady = 'COMPONENT_STATUS_READY',
  ComponentStatusUnspecified = 'COMPONENT_STATUS_UNSPECIFIED'
}

export type StreamInfoStreamInfo = {
  __typename?: 'StreamInfoStreamInfo';
  channelId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  seasonId: Scalars['ID']['output'];
  streamId: Scalars['ID']['output'];
};

export type StreamIngestConfigChannelIngestConfig = {
  __typename?: 'StreamIngestConfigChannelIngestConfig';
  channelId: Scalars['ID']['output'];
  config: StreamIngestConfigIngestConfig;
  streamingStatus: StreamIngestConfigStreamingStatus;
};

export type StreamIngestConfigChannelIngestConfigs = {
  __typename?: 'StreamIngestConfigChannelIngestConfigs';
  channelId: Scalars['ID']['output'];
  configs: Array<StreamIngestConfigIngestConfig>;
};

export type StreamIngestConfigIngestConfig = {
  __typename?: 'StreamIngestConfigIngestConfig';
  ingest?: Maybe<StreamIngestConfigIngestConfigIngestUnion>;
};

export type StreamIngestConfigIngestConfigFtlConfig = {
  __typename?: 'StreamIngestConfigIngestConfigFTLConfig';
  sharedKey: Scalars['String']['output'];
  streamId: Scalars['Int']['output'];
  streamKey: Scalars['String']['output'];
};

export type StreamIngestConfigIngestConfigIngestUnion = StreamIngestConfigIngestConfigFtlConfig;

export enum StreamIngestConfigStreamingStatus {
  StreamingStatusStreamingDisabled = 'STREAMING_STATUS_STREAMING_DISABLED',
  StreamingStatusUnspecified = 'STREAMING_STATUS_UNSPECIFIED',
  StreamingStatusUserSuspended = 'STREAMING_STATUS_USER_SUSPENDED'
}

export type StreamerActivateContextualTeamActionResponse = {
  __typename?: 'StreamerActivateContextualTeamActionResponse';
  activated: Scalars['Boolean']['output'];
  cooldown: Scalars['Duration']['output'];
};

export type StreamerAvatarItemPurchased = {
  __typename?: 'StreamerAvatarItemPurchased';
  item: ItemItem;
  itemId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerBundlePurchased = {
  __typename?: 'StreamerBundlePurchased';
  bundleName: Scalars['String']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerChannelActivityEvent = {
  __typename?: 'StreamerChannelActivityEvent';
  content?: Maybe<StreamerChannelActivityEventContentUnion>;
  id: Scalars['ID']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

export type StreamerChannelActivityEventContentUnion = GameLogicHighScoringCardPromotedMsg | StreamerAvatarItemPurchased | StreamerBundlePurchased | StreamerChannelFollowed | StreamerChannelSubscribed | StreamerMatchEnded | StreamerMatchStarted | StreamerPlayerJoined | StreamerStreamEnded | StreamerStreamStarted | StreamerStreamTitleChanged | StreamerStreamerCardPurchased | StreamerSubscriptionGifted | StreamerSubscriptionRenewed;

export enum StreamerChannelActivityEventFilterEventType {
  EventTypeAvatarItemPurchased = 'EVENT_TYPE_AVATAR_ITEM_PURCHASED',
  EventTypeBundlePurchased = 'EVENT_TYPE_BUNDLE_PURCHASED',
  EventTypeChannelFollowed = 'EVENT_TYPE_CHANNEL_FOLLOWED',
  EventTypeChannelSubscribed = 'EVENT_TYPE_CHANNEL_SUBSCRIBED',
  EventTypeChannelSubscriptionGifted = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_GIFTED',
  EventTypeChannelSubscriptionRenewed = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_RENEWED',
  EventTypeHighScoringCardPromoted = 'EVENT_TYPE_HIGH_SCORING_CARD_PROMOTED',
  EventTypeMatchEnded = 'EVENT_TYPE_MATCH_ENDED',
  EventTypeMatchStarted = 'EVENT_TYPE_MATCH_STARTED',
  EventTypePlayerJoined = 'EVENT_TYPE_PLAYER_JOINED',
  EventTypeStreamerCardPurchased = 'EVENT_TYPE_STREAMER_CARD_PURCHASED',
  EventTypeStreamEnded = 'EVENT_TYPE_STREAM_ENDED',
  EventTypeStreamStarted = 'EVENT_TYPE_STREAM_STARTED',
  EventTypeStreamTitleChanged = 'EVENT_TYPE_STREAM_TITLE_CHANGED',
  EventTypeUnspecified = 'EVENT_TYPE_UNSPECIFIED'
}

export type StreamerChannelActivityEventFilterInput = {
  eventTypes?: InputMaybe<Array<StreamerChannelActivityEventFilterEventType>>;
};

export type StreamerChannelFollowed = {
  __typename?: 'StreamerChannelFollowed';
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type StreamerChannelSubscribed = {
  __typename?: 'StreamerChannelSubscribed';
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerListChannelActivityEventsResponse = {
  __typename?: 'StreamerListChannelActivityEventsResponse';
  events: Array<StreamerChannelActivityEvent>;
  pageInfo: ApiPageInfo;
};

export type StreamerMatchEnded = {
  __typename?: 'StreamerMatchEnded';
  bestCard?: Maybe<GameLogicCardDetails>;
  bestGroup?: Maybe<GameLogicGroupDetails>;
  bestPlayer?: Maybe<GameLogicPlayerDetails>;
  challengeStatuses?: Maybe<Array<GameLogicChallengeStatus>>;
  streamId: Scalars['ID']['output'];
};

export type StreamerMatchStarted = {
  __typename?: 'StreamerMatchStarted';
  streamId: Scalars['ID']['output'];
};

export type StreamerPlayerJoined = {
  __typename?: 'StreamerPlayerJoined';
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type StreamerStreamAudienceInsights = {
  __typename?: 'StreamerStreamAudienceInsights';
  chatters: Scalars['Int']['output'];
  followers: Scalars['Int']['output'];
  players: Scalars['Int']['output'];
  subscribers: Scalars['Int']['output'];
  viewers: Scalars['Int']['output'];
};

export type StreamerStreamDiagnosticsEvent = {
  __typename?: 'StreamerStreamDiagnosticsEvent';
  channelId: Scalars['ID']['output'];
  obsNoiceValidator: StreamerStreamDiagnosticsEventObsNoiceValidator;
  obsPluginInfo: StreamerStreamDiagnosticsEventObsPluginInfo;
  streamId: Scalars['ID']['output'];
};

export type StreamerStreamDiagnosticsEventObsNoiceValidator = {
  __typename?: 'StreamerStreamDiagnosticsEventObsNoiceValidator';
  missingValidator: Scalars['Boolean']['output'];
  occludingSourceNames: Array<Scalars['String']['output']>;
};

export type StreamerStreamDiagnosticsEventObsPluginInfo = {
  __typename?: 'StreamerStreamDiagnosticsEventObsPluginInfo';
  obsVersion: Scalars['String']['output'];
  pluginVersion: Scalars['String']['output'];
};

export type StreamerStreamDiagnosticsUpdate = {
  __typename?: 'StreamerStreamDiagnosticsUpdate';
  content?: Maybe<StreamerStreamDiagnosticsUpdateContentUnion>;
};

export type StreamerStreamDiagnosticsUpdateContentUnion = IntType | StreamerStreamDiagnosticsEvent;

export type StreamerStreamEnded = {
  __typename?: 'StreamerStreamEnded';
  streamId: Scalars['ID']['output'];
};

export type StreamerStreamEvent = {
  __typename?: 'StreamerStreamEvent';
  content?: Maybe<StreamerStreamEventContentUnion>;
  timestamp: Scalars['Timestamp']['output'];
};

export type StreamerStreamEventContentUnion = GameLogicActiveCardSucceededMsg | GameLogicHighScoringCardPromotedMsg | GameLogicMatchEndedMsg | GameLogicMatchPauseStateChangedMsg | GameLogicMatchStartedMsg | GameLogicPlayerJoinedMsg | GameStateStreamState | IntType | StreamerChannelFollowed | StreamerChannelSubscribed | StreamerSubscriptionGifted;

export enum StreamerStreamEventFilterEventType {
  EventTypeActiveCardSucceeded = 'EVENT_TYPE_ACTIVE_CARD_SUCCEEDED',
  EventTypeChannelFollowed = 'EVENT_TYPE_CHANNEL_FOLLOWED',
  EventTypeChannelSubscribed = 'EVENT_TYPE_CHANNEL_SUBSCRIBED',
  EventTypeChannelSubscriptionGifted = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_GIFTED',
  EventTypeHighScoringCardPromoted = 'EVENT_TYPE_HIGH_SCORING_CARD_PROMOTED',
  EventTypePlayerJoined = 'EVENT_TYPE_PLAYER_JOINED',
  EventTypeUnspecified = 'EVENT_TYPE_UNSPECIFIED'
}

export type StreamerStreamEventFilterInput = {
  eventTypes?: InputMaybe<Array<StreamerStreamEventFilterEventType>>;
};

export type StreamerStreamStarted = {
  __typename?: 'StreamerStreamStarted';
  streamId: Scalars['ID']['output'];
};

export type StreamerStreamTitleChanged = {
  __typename?: 'StreamerStreamTitleChanged';
  title: Scalars['String']['output'];
};

export type StreamerStreamerCardPurchased = {
  __typename?: 'StreamerStreamerCardPurchased';
  streamerCard: GameLogicStreamerCard;
  streamerCardId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerSubscriptionGifted = {
  __typename?: 'StreamerSubscriptionGifted';
  recipientUserIds: Array<Scalars['String']['output']>;
  recipients?: Maybe<Array<ProfileProfile>>;
  tier: Scalars['Int']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerSubscriptionRenewed = {
  __typename?: 'StreamerSubscriptionRenewed';
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerTriggerCameraTransitionResponse = {
  __typename?: 'StreamerTriggerCameraTransitionResponse';
  success: Scalars['Boolean']['output'];
};

export type StringType = {
  __typename?: 'StringType';
  /** The wrapped value of type String */
  value: Scalars['String']['output'];
};

export type Subscription = {
  __typename?: 'Subscription';
  /** StreamerService.ChannelActivityEvents */
  channelActivityEventsSubscribe?: Maybe<StreamerChannelActivityEvent>;
  /** ChannelService.ChannelEventStream */
  channelEventsSubscribe?: Maybe<ChannelChannelEvent>;
  /** ChannelService.FollowerCountUpdates */
  channelFollowerCountSubscribe?: Maybe<ChannelFollowerCountEvent>;
  /** ChannelService.LiveStatusUpdates - Subscription APIs */
  channelLiveStatusSubscribe?: Maybe<ChannelLiveStatusEvent>;
  /** ChannelService.ChannelStreamDetailUpdates */
  channelStreamDetailSubscribe?: Maybe<ChannelChannelStreamDetailEvent>;
  /** ChannelService.ViewerCountUpdates */
  channelViewerCountSubscribe?: Maybe<ChannelViewerCountEvent>;
  /** ChatModerationService.StreamAutoModQueue */
  chatAutoModQueueSubscribe?: Maybe<ChatAutoModQueueEvent>;
  /** ChatService.ChatMessageStream */
  chatMessageSubscribe?: Maybe<ChatChatEvent>;
  /** ChannelConfigService.IngestStatsUpdates */
  ingestStatsSubscribe?: Maybe<ChannelIngestStatsEvent>;
  /** MLControllerService.StreamHUDScaleUpdates */
  mlHUDScaleUpdatesSubscribe?: Maybe<MlControllerGetHudScaleResponse>;
  /** ChannelModerationService.ModerationEventsStream */
  moderationEventsSubscribe?: Maybe<ChannelModerationEvent>;
  /** NotificationService.Notifications */
  notificationSubscribe?: Maybe<NotificationNotification>;
  /** PartyService.StreamPartyUpdates */
  partyUpdateSubscribe?: Maybe<PartyPartyUpdateEvent>;
  /** ReactionService.StreamReactions */
  reactionsSubscription?: Maybe<ReactionReactionEvent>;
  /** ChallengeSessionService.ChallengeSessionEvents */
  streamChallengeSessionEvents?: Maybe<ChallengesessionChallengeSessionEvent>;
  /** MatchServiceV2.ChallengeUpdates */
  streamChallengeUpdatesSubscribe?: Maybe<MatchChallengeUpdate>;
  /** StreamerService.StreamDiagnosticsUpdates */
  streamDiagnosticsSubscribe?: Maybe<StreamerStreamDiagnosticsUpdate>;
  /** StreamerService.StreamEvents */
  streamEventsSubscribe?: Maybe<StreamerStreamEvent>;
  /** MatchServiceV2.StreamSpectatorCoordinationEvents */
  streamSpectatorCoordinationEventsSubscribe?: Maybe<MatchStreamSpectatorCoordinationEvent>;
  /** ChannelConfigService.StreamStatusUpdates */
  streamStatusSubscribe?: Maybe<ChannelStreamStatusEvent>;
  /** MatchServiceV2.TopCardUpdates */
  streamTopActiveCardsSubscribe?: Maybe<MatchTopCardsUpdate>;
  /** FeatureFlagService.StreamConfigUpdates */
  subscribeFeatureFlagConfigUpdates?: Maybe<FlagFeatureFlagConfig>;
};


export type SubscriptionChannelActivityEventsSubscribeArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<StreamerChannelActivityEventFilterInput>;
};


export type SubscriptionChannelEventsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelFollowerCountSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelLiveStatusSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelStreamDetailSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelViewerCountSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChatAutoModQueueSubscribeArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChatMessageSubscribeArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionIngestStatsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionMlHudScaleUpdatesSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionModerationEventsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ChannelModerationEventsFilterInput>;
};


export type SubscriptionNotificationSubscribeArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};


export type SubscriptionPartyUpdateSubscribeArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionReactionsSubscriptionArgs = {
  parentId?: InputMaybe<Scalars['ID']['input']>;
  parentType?: InputMaybe<Scalars['String']['input']>;
};


export type SubscriptionStreamChallengeSessionEventsArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamChallengeUpdatesSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamDiagnosticsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamEventsSubscribeArgs = {
  filter?: InputMaybe<StreamerStreamEventFilterInput>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamSpectatorCoordinationEventsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamStatusSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamTopActiveCardsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionSubscribeFeatureFlagConfigUpdatesArgs = {
  revision?: InputMaybe<Scalars['String']['input']>;
};

export type SubscriptionChannelSubscription = {
  __typename?: 'SubscriptionChannelSubscription';
  activatedAt?: Maybe<Scalars['Timestamp']['output']>;
  cancelReason: SubscriptionChannelSubscriptionCancelReason;
  cancelledAt?: Maybe<Scalars['Timestamp']['output']>;
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  createdAt: Scalars['Timestamp']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  externalReference: Scalars['String']['output'];
  giverId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  paymentFailedAt?: Maybe<Scalars['Timestamp']['output']>;
  paymentSucceededAt?: Maybe<Scalars['Timestamp']['output']>;
  provider: SubscriptionChannelSubscriptionProvider;
  renewedAt?: Maybe<Scalars['Timestamp']['output']>;
  state: SubscriptionChannelSubscriptionState;
  terminatedAt?: Maybe<Scalars['Timestamp']['output']>;
  tier: Scalars['Int']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export enum SubscriptionChannelSubscriptionCancelReason {
  CancelReasonCurrencyIncompatibleWithGateway = 'CANCEL_REASON_CURRENCY_INCOMPATIBLE_WITH_GATEWAY',
  CancelReasonFraudReviewFailed = 'CANCEL_REASON_FRAUD_REVIEW_FAILED',
  CancelReasonNonCompliantCustomer = 'CANCEL_REASON_NON_COMPLIANT_CUSTOMER',
  CancelReasonNonCompliantEuCustomer = 'CANCEL_REASON_NON_COMPLIANT_EU_CUSTOMER',
  CancelReasonNotPaid = 'CANCEL_REASON_NOT_PAID',
  CancelReasonNoCard = 'CANCEL_REASON_NO_CARD',
  CancelReasonTaxCalculationFailed = 'CANCEL_REASON_TAX_CALCULATION_FAILED',
  CancelReasonUnspecified = 'CANCEL_REASON_UNSPECIFIED'
}

export type SubscriptionChannelSubscriptionConfig = {
  __typename?: 'SubscriptionChannelSubscriptionConfig';
  channelId: Scalars['ID']['output'];
  subscriptionsEnabled: Scalars['Boolean']['output'];
  tiers: Array<SubscriptionChannelSubscriptionTier>;
};

export type SubscriptionChannelSubscriptionEntitlement = {
  __typename?: 'SubscriptionChannelSubscriptionEntitlement';
  amount: Scalars['Int']['output'];
  item: ItemItem;
  itemId: Scalars['ID']['output'];
};

export enum SubscriptionChannelSubscriptionProvider {
  ProviderApple = 'PROVIDER_APPLE',
  ProviderChargebee = 'PROVIDER_CHARGEBEE',
  ProviderUnspecified = 'PROVIDER_UNSPECIFIED'
}

export enum SubscriptionChannelSubscriptionState {
  StateActive = 'STATE_ACTIVE',
  StateCancelled = 'STATE_CANCELLED',
  StateExpired = 'STATE_EXPIRED',
  StateLocked = 'STATE_LOCKED',
  StatePending = 'STATE_PENDING',
  StateTerminated = 'STATE_TERMINATED',
  StateUnspecified = 'STATE_UNSPECIFIED'
}

export type SubscriptionChannelSubscriptionTier = {
  __typename?: 'SubscriptionChannelSubscriptionTier';
  description: Scalars['String']['output'];
  entitlements: Array<SubscriptionChannelSubscriptionEntitlement>;
  level: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  prices: Array<SubscriptionSubscriptionPrice>;
};

export type SubscriptionChannelSubscriptionUpdateEvent = {
  __typename?: 'SubscriptionChannelSubscriptionUpdateEvent';
  meta: SubscriptionSubscriptionUpdateMeta;
  subscription: SubscriptionChannelSubscription;
  updateType: SubscriptionChannelSubscriptionUpdateEventUpdateType;
  updatedAt: Scalars['Timestamp']['output'];
};

export enum SubscriptionChannelSubscriptionUpdateEventUpdateType {
  UpdateTypeActivated = 'UPDATE_TYPE_ACTIVATED',
  UpdateTypeCancellationRemoved = 'UPDATE_TYPE_CANCELLATION_REMOVED',
  UpdateTypeCancellationRequested = 'UPDATE_TYPE_CANCELLATION_REQUESTED',
  UpdateTypeCancelled = 'UPDATE_TYPE_CANCELLED',
  UpdateTypeCreated = 'UPDATE_TYPE_CREATED',
  UpdateTypeExpired = 'UPDATE_TYPE_EXPIRED',
  UpdateTypePaymentFailed = 'UPDATE_TYPE_PAYMENT_FAILED',
  UpdateTypePaymentSucceeded = 'UPDATE_TYPE_PAYMENT_SUCCEEDED',
  UpdateTypeRenewed = 'UPDATE_TYPE_RENEWED',
  UpdateTypeTerminated = 'UPDATE_TYPE_TERMINATED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUpgraded = 'UPDATE_TYPE_UPGRADED'
}

export type SubscriptionCheckoutExistingSubscriptionResponse = {
  __typename?: 'SubscriptionCheckoutExistingSubscriptionResponse';
  sessionData: Scalars['String']['output'];
};

export type SubscriptionCheckoutNewSubscriptionResponse = {
  __typename?: 'SubscriptionCheckoutNewSubscriptionResponse';
  sessionData: Scalars['String']['output'];
};

export type SubscriptionListChannelSubscriptionTiersResponse = {
  __typename?: 'SubscriptionListChannelSubscriptionTiersResponse';
  tiers: Array<SubscriptionChannelSubscriptionTier>;
};

export type SubscriptionListChannelSubscriptionsRequestFilterInput = {
  state?: InputMaybe<SubscriptionChannelSubscriptionState>;
};

export type SubscriptionListChannelSubscriptionsResponse = {
  __typename?: 'SubscriptionListChannelSubscriptionsResponse';
  pageInfo: ApiPageInfo;
  subscriptions: Array<SubscriptionChannelSubscription>;
};

export type SubscriptionListUserChannelSubscriptionsRequestFilterInput = {
  paymentFailed?: InputMaybe<Scalars['Boolean']['input']>;
  state?: InputMaybe<SubscriptionChannelSubscriptionState>;
};

export type SubscriptionListUserChannelSubscriptionsResponse = {
  __typename?: 'SubscriptionListUserChannelSubscriptionsResponse';
  pageInfo: ApiPageInfo;
  subscriptions: Array<SubscriptionChannelSubscription>;
};

export type SubscriptionSubscriptionPrice = {
  __typename?: 'SubscriptionSubscriptionPrice';
  currency: PaymentCurrency;
  period: SubscriptionSubscriptionPricePeriod;
  price: Scalars['Int']['output'];
};

export enum SubscriptionSubscriptionPricePeriod {
  PeriodMonth = 'PERIOD_MONTH',
  PeriodUnspecified = 'PERIOD_UNSPECIFIED',
  PeriodYear = 'PERIOD_YEAR'
}

export type SubscriptionSubscriptionUpdateMeta = {
  __typename?: 'SubscriptionSubscriptionUpdateMeta';
  giverId: Scalars['ID']['output'];
};

export type SubscriptionUpdateSubscriptionPaymentMethodResponse = {
  __typename?: 'SubscriptionUpdateSubscriptionPaymentMethodResponse';
  sessionData: Scalars['String']['output'];
};

export type SupportArticle = {
  __typename?: 'SupportArticle';
  body: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  locale: Scalars['String']['output'];
  title: Scalars['String']['output'];
};

export type SupportListReportsResponse = {
  __typename?: 'SupportListReportsResponse';
  pageInfo: ApiPageInfo;
  reports: Array<SupportReport>;
};

export type SupportReport = {
  __typename?: 'SupportReport';
  caseId: Scalars['ID']['output'];
  context: SupportReportContext;
  createdAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  reason: SupportReportReason;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type SupportReportCase = {
  __typename?: 'SupportReportCase';
  closedAt: Scalars['Timestamp']['output'];
  closedBy: Scalars['String']['output'];
  context: SupportReportContext;
  createdAt: Scalars['Timestamp']['output'];
  firstDescription: Scalars['String']['output'];
  firstReason: SupportReportReason;
  firstReporterId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  moderatorComment: Scalars['String']['output'];
  resolution: SupportReportCaseResolution;
  status: SupportReportCaseStatus;
};

export enum SupportReportCaseResolution {
  ReportCaseResolutionAllowContent = 'REPORT_CASE_RESOLUTION_ALLOW_CONTENT',
  ReportCaseResolutionRemoveContent = 'REPORT_CASE_RESOLUTION_REMOVE_CONTENT',
  ReportCaseResolutionUnspecified = 'REPORT_CASE_RESOLUTION_UNSPECIFIED'
}

export enum SupportReportCaseStatus {
  ReportCaseStatusClosed = 'REPORT_CASE_STATUS_CLOSED',
  ReportCaseStatusOpen = 'REPORT_CASE_STATUS_OPEN',
  ReportCaseStatusUnspecified = 'REPORT_CASE_STATUS_UNSPECIFIED'
}

export type SupportReportContext = {
  __typename?: 'SupportReportContext';
  value?: Maybe<SupportReportContextValueUnion>;
};

export type SupportReportContextChannel = {
  __typename?: 'SupportReportContextChannel';
  channelId: Scalars['ID']['output'];
  target: SupportReportContextChannelTarget;
};

export type SupportReportContextChannelInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  target?: InputMaybe<SupportReportContextChannelTarget>;
};

export enum SupportReportContextChannelTarget {
  TargetDescription = 'TARGET_DESCRIPTION',
  TargetName = 'TARGET_NAME',
  TargetUnspecified = 'TARGET_UNSPECIFIED'
}

export type SupportReportContextChatMessage = {
  __typename?: 'SupportReportContextChatMessage';
  channelId: Scalars['ID']['output'];
  chatId: Scalars['ID']['output'];
  messageId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type SupportReportContextChatMessageInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  chatId?: InputMaybe<Scalars['ID']['input']>;
  messageId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type SupportReportContextInput = {
  channel?: InputMaybe<SupportReportContextChannelInput>;
  chatMessage?: InputMaybe<SupportReportContextChatMessageInput>;
  stream?: InputMaybe<SupportReportContextStreamInput>;
  user?: InputMaybe<SupportReportContextUserInput>;
};

export type SupportReportContextStream = {
  __typename?: 'SupportReportContextStream';
  channelId: Scalars['ID']['output'];
  startAt: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type SupportReportContextStreamInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  startAt?: InputMaybe<Scalars['Int']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type SupportReportContextUser = {
  __typename?: 'SupportReportContextUser';
  target: SupportReportContextUserTarget;
  userId: Scalars['ID']['output'];
};

export type SupportReportContextUserInput = {
  target?: InputMaybe<SupportReportContextUserTarget>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export enum SupportReportContextUserTarget {
  TargetName = 'TARGET_NAME',
  TargetUnspecified = 'TARGET_UNSPECIFIED'
}

export type SupportReportContextValueUnion = SupportReportContextChannel | SupportReportContextChatMessage | SupportReportContextStream | SupportReportContextUser;

export enum SupportReportReason {
  ReportReasonChildSafetyChildAbuse = 'REPORT_REASON_CHILD_SAFETY_CHILD_ABUSE',
  ReportReasonChildSafetyCse = 'REPORT_REASON_CHILD_SAFETY_CSE',
  ReportReasonChildSafetyDangerous = 'REPORT_REASON_CHILD_SAFETY_DANGEROUS',
  ReportReasonChildSafetyUnderageUser = 'REPORT_REASON_CHILD_SAFETY_UNDERAGE_USER',
  ReportReasonGraphicMediaAnimalAbuse = 'REPORT_REASON_GRAPHIC_MEDIA_ANIMAL_ABUSE',
  ReportReasonGraphicMediaGore = 'REPORT_REASON_GRAPHIC_MEDIA_GORE',
  ReportReasonGraphicMediaViolence = 'REPORT_REASON_GRAPHIC_MEDIA_VIOLENCE',
  ReportReasonHarassment = 'REPORT_REASON_HARASSMENT',
  ReportReasonHarassmentBlackmail = 'REPORT_REASON_HARASSMENT_BLACKMAIL',
  ReportReasonHarassmentIncitement = 'REPORT_REASON_HARASSMENT_INCITEMENT',
  ReportReasonHarassmentNonConsensualIntimateImages = 'REPORT_REASON_HARASSMENT_NON_CONSENSUAL_INTIMATE_IMAGES',
  ReportReasonHarassmentSexualNonConsensual = 'REPORT_REASON_HARASSMENT_SEXUAL_NON_CONSENSUAL',
  ReportReasonHarassmentStalking = 'REPORT_REASON_HARASSMENT_STALKING',
  ReportReasonHatefulBehavior = 'REPORT_REASON_HATEFUL_BEHAVIOR',
  ReportReasonIllegalActivitySale = 'REPORT_REASON_ILLEGAL_ACTIVITY_SALE',
  ReportReasonIllegalActivityWeapons = 'REPORT_REASON_ILLEGAL_ACTIVITY_WEAPONS',
  ReportReasonIllegalAlcoholNicotine = 'REPORT_REASON_ILLEGAL_ALCOHOL_NICOTINE',
  ReportReasonIllegalDrugs = 'REPORT_REASON_ILLEGAL_DRUGS',
  ReportReasonIllegalManipulation = 'REPORT_REASON_ILLEGAL_MANIPULATION',
  ReportReasonIllegalSpam = 'REPORT_REASON_ILLEGAL_SPAM',
  ReportReasonImpersonation = 'REPORT_REASON_IMPERSONATION',
  ReportReasonInauthenticGameplay = 'REPORT_REASON_INAUTHENTIC_GAMEPLAY',
  ReportReasonOffPlatform = 'REPORT_REASON_OFF_PLATFORM',
  ReportReasonPlatformRulesViolation = 'REPORT_REASON_PLATFORM_RULES_VIOLATION',
  ReportReasonPossibleIllegalActivity = 'REPORT_REASON_POSSIBLE_ILLEGAL_ACTIVITY',
  ReportReasonRestrictedGamesInherentlyViolative = 'REPORT_REASON_RESTRICTED_GAMES_INHERENTLY_VIOLATIVE',
  ReportReasonRestrictedGamesMature = 'REPORT_REASON_RESTRICTED_GAMES_MATURE',
  ReportReasonSelfHarm = 'REPORT_REASON_SELF_HARM',
  ReportReasonSexualBehaviorExplicit = 'REPORT_REASON_SEXUAL_BEHAVIOR_EXPLICIT',
  ReportReasonSexualBehaviorSuggestive = 'REPORT_REASON_SEXUAL_BEHAVIOR_SUGGESTIVE',
  ReportReasonSpam = 'REPORT_REASON_SPAM',
  ReportReasonSpamSuspensionEvasion = 'REPORT_REASON_SPAM_SUSPENSION_EVASION',
  ReportReasonUnknown = 'REPORT_REASON_UNKNOWN',
  ReportReasonUnspecified = 'REPORT_REASON_UNSPECIFIED',
  ReportReasonViolenceExtremism = 'REPORT_REASON_VIOLENCE_EXTREMISM'
}

export type SupportReportsFilterInput = {
  caseId?: InputMaybe<Scalars['ID']['input']>;
};

export type WalletAddCurrenciesResponse = {
  __typename?: 'WalletAddCurrenciesResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type WalletGetWalletResponse = {
  __typename?: 'WalletGetWalletResponse';
  wallet: WalletWallet;
};

export type WalletListWalletTransactionsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  reasons?: InputMaybe<Array<WalletTransactionReason>>;
  to?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type WalletListWalletTransactionsResponse = {
  __typename?: 'WalletListWalletTransactionsResponse';
  pageInfo: ApiPageInfo;
  transactions: Array<WalletTransaction>;
};

export type WalletOperation = {
  __typename?: 'WalletOperation';
  currencyAmount: Scalars['Int']['output'];
  currencyBalance: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
  type: WalletOperationType;
};

export enum WalletOperationType {
  TypeAdd = 'TYPE_ADD',
  TypeSubtract = 'TYPE_SUBTRACT',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type WalletSubtractCurrenciesResponse = {
  __typename?: 'WalletSubtractCurrenciesResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type WalletTransaction = {
  __typename?: 'WalletTransaction';
  createdAt: Scalars['Timestamp']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  id: Scalars['ID']['output'];
  operations: Array<WalletOperation>;
  reason: ReasonReason;
  state: WalletTransactionState;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type WalletTransactionEvent = {
  __typename?: 'WalletTransactionEvent';
  transaction: WalletTransaction;
};

export enum WalletTransactionReason {
  TransactionReasonAdministrative = 'TRANSACTION_REASON_ADMINISTRATIVE',
  TransactionReasonAdWatched = 'TRANSACTION_REASON_AD_WATCHED',
  TransactionReasonChannelSubscription = 'TRANSACTION_REASON_CHANNEL_SUBSCRIPTION',
  TransactionReasonGoalCardComplete = 'TRANSACTION_REASON_GOAL_CARD_COMPLETE',
  TransactionReasonGoalCardSlotReshuffle = 'TRANSACTION_REASON_GOAL_CARD_SLOT_RESHUFFLE',
  TransactionReasonLevelUp = 'TRANSACTION_REASON_LEVEL_UP',
  TransactionReasonMatchEnd = 'TRANSACTION_REASON_MATCH_END',
  TransactionReasonProvision = 'TRANSACTION_REASON_PROVISION',
  TransactionReasonPurchaseWithInGameCurrency = 'TRANSACTION_REASON_PURCHASE_WITH_IN_GAME_CURRENCY',
  TransactionReasonPurchaseWithPayment = 'TRANSACTION_REASON_PURCHASE_WITH_PAYMENT',
  TransactionReasonReshuffle = 'TRANSACTION_REASON_RESHUFFLE',
  TransactionReasonRewardClaimed = 'TRANSACTION_REASON_REWARD_CLAIMED',
  TransactionReasonStoreOrderPayment = 'TRANSACTION_REASON_STORE_ORDER_PAYMENT',
  TransactionReasonUnspecified = 'TRANSACTION_REASON_UNSPECIFIED'
}

export enum WalletTransactionState {
  TransactionStateCancelled = 'TRANSACTION_STATE_CANCELLED',
  TransactionStateCommitted = 'TRANSACTION_STATE_COMMITTED',
  TransactionStatePending = 'TRANSACTION_STATE_PENDING',
  TransactionStateUnspecified = 'TRANSACTION_STATE_UNSPECIFIED'
}

export type WalletWallet = {
  __typename?: 'WalletWallet';
  currencies: Array<WalletWalletCurrency>;
  userId: Scalars['ID']['output'];
};

export type WalletWalletCurrency = {
  __typename?: 'WalletWalletCurrency';
  currencyAmount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
};

export type WalletWalletCurrencyInput = {
  currencyAmount?: InputMaybe<Scalars['Int']['input']>;
  currencyId?: InputMaybe<Scalars['ID']['input']>;
};

export type FtueDismissComponentsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FtueDismissComponentsQuery = { __typename?: 'Query', dismissedTooltips?: { __typename?: 'FtueListDismissedTooltipsResponse', tooltipIds: Array<string> } | null };

export type FtueCurrentStreamChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type FtueCurrentStreamChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null };

export type FtuePlayerDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FtuePlayerDataQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, stats: { __typename?: 'PlayerStatsPlayerStats', adsWatched: number, matchesPlayed: number, soloMatchesPlayed: number, partyMatchesPlayed: number, timePlayed?: string | null, dailyGoalCardsCompleted: number, cardsPlayed: number, shufflesUsed: number, cardBundlesPurchased: number, cardsSucceeded: number, dailyGoalCardsSet: number, cardLevelUps: number, boosterUsage?: { __typename?: 'PlayerStatsPlayerStatsBoosterUsage', total: number, doubt: number, goodCall: number, letsGo: number, nextUp: number, scavenge: number, speedUp: number } | null, currencySpending?: { __typename?: 'PlayerStatsPlayerStatsCurrencySpending', hardCurrency: number, softCurrency: number, channelCurrency: number } | null }, avatarConfig?: { __typename?: 'ProfileProfileAvatarConfig', modelId: string, model: { __typename?: 'AvatarAvatar', id: string, selectable: boolean } } | null, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, progression: { __typename?: 'GameUserProgression', level: number } }> } | null };

export type FtuePlayerDataMatchProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FtuePlayerDataMatchProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, stats: { __typename?: 'PlayerStatsPlayerStats', matchesPlayed: number, soloMatchesPlayed: number, partyMatchesPlayed: number, timePlayed?: string | null } } | null };

export type FtuePlayerDataBoosterProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FtuePlayerDataBoosterProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, stats: { __typename?: 'PlayerStatsPlayerStats', boosterUsage?: { __typename?: 'PlayerStatsPlayerStatsBoosterUsage', total: number, doubt: number, goodCall: number, letsGo: number, nextUp: number, scavenge: number, speedUp: number } | null } } | null };

export type FtueCriteriaDataCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type FtueCriteriaDataCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, isMatchCard: boolean, isAllOrNothing: boolean }> } | null };

export type CardSucceededStatsUpdateProfileFragment = { __typename?: 'ProfileProfile', stats: { __typename?: 'PlayerStatsPlayerStats', cardsPlayed: number, cardsSucceeded: number } };

export type CardFailedStatsUpdateProfileFragment = { __typename?: 'ProfileProfile', stats: { __typename?: 'PlayerStatsPlayerStats', cardsPlayed: number } };

export type FtueDismissComponentMutationVariables = Exact<{
  tooltipId: Scalars['ID']['input'];
  type?: InputMaybe<FtueDismissalType>;
}>;


export type FtueDismissComponentMutation = { __typename?: 'Mutation', dismissTooltip?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type PlatformAppDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type PlatformAppDataQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, account?: { __typename?: 'AuthAccount', email: string } | null, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string } }>, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', reason: ModerationViolation, changedAt: string }> | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type CompleteAccountCheckProfileFragment = { __typename?: 'ProfileProfile', avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, account?: { __typename?: 'AuthAccount', uid: string, birthday?: { __typename?: 'AuthDate', day: number, month: number, year: number } | null } | null };

export type UserAnnouncementsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type UserAnnouncementsQuery = { __typename?: 'Query', userAnnouncements?: { __typename?: 'AnnouncementListUserAnnouncementsResponse', announcements: Array<{ __typename?: 'AnnouncementAnnouncement', id: string, title: string, text: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, image: string }> } | null };

export type AppRouteRedirectsProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type AppRouteRedirectsProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', flags: Array<AuthAccountStatusFlag>, state: ApiEntityState, uid: string, birthday?: { __typename?: 'AuthDate', day: number, month: number, year: number } | null } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, platformBan?: { __typename?: 'ModerationPlatformBan', banId: string } | null };

export type UserPendingAgreementsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type UserPendingAgreementsQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', uid: string, marketingConsent: AuthConsentStatus, pendingAgreements: Array<{ __typename?: 'AgreementAgreementRevision', name: string, revision: string, url: string }> } | null } | null };

export type AvatarPartChannelLogoChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type AvatarPartChannelLogoChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, logo: string, name: string } | null };

export type AvatarPartChannelQueryVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type AvatarPartChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } | null };

export type AvatarEditorAvatarPartFragment = { __typename?: 'AvatarAvatarPart', id: string, color: string, url: string, colors: Array<string>, experimental: boolean, colorPresetOptions: Array<string>, userDefault: boolean, uniqueBootstrap: boolean, skinOptions: Array<string>, enabled: boolean, channelId: string, sellable: boolean, glbUrlOverride?: { __typename?: 'AvatarAvatarPartGlbURLOverride', category: AvatarAvatarPartCategory, glbUrl: string } | null, skinData?: { __typename?: 'AvatarAvatarPartSkinData', baseMapUrl: string, normalMapUrl: string, ormMapUrl: string, emissionMapUrl: string } | null };

export type AvatarEditorSellableItemFragment = { __typename?: 'StoreV2SellableItem', id: string, sku: string, signature: string, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, amount: number, amountWithoutDiscount: number }> | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef' } | { __typename: 'StoreV2ItemRef', count: number, item: { __typename?: 'ItemItem', id: string, gameId: string, type: ItemItemType, attributes: { __typename?: 'AttributeAttributeMap', value: Array<{ __typename?: 'AttributeAttributeMapValueEntry', key: string, value: { __typename?: 'AttributeAttribute', value?: { __typename?: 'AttributeAttributeBoolArray' } | { __typename?: 'AttributeAttributeFloatArray' } | { __typename?: 'AttributeAttributeIntArray' } | { __typename?: 'AttributeAttributeMap' } | { __typename?: 'AttributeAttributeStringArray' } | { __typename?: 'BooleanType' } | { __typename?: 'FloatType' } | { __typename?: 'IntType' } | { __typename?: 'StringType', value: string } | null } }> } } } | { __typename?: 'StoreV2SubscriptionRef' } | null }> };

export type AvatarEditorAvatarPartsQueryVariables = Exact<{ [key: string]: never; }>;


export type AvatarEditorAvatarPartsQuery = { __typename?: 'Query', avatarEditorStoreFront?: { __typename?: 'StoreV2StoreFront', id: string, gameId: string, categories?: Array<{ __typename?: 'StoreV2StoreFrontCategory', id: string, itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, sku: string, signature: string, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, amount: number, amountWithoutDiscount: number }> | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef' } | { __typename: 'StoreV2ItemRef', count: number, item: { __typename?: 'ItemItem', id: string, gameId: string, type: ItemItemType, attributes: { __typename?: 'AttributeAttributeMap', value: Array<{ __typename?: 'AttributeAttributeMapValueEntry', key: string, value: { __typename?: 'AttributeAttribute', value?: { __typename?: 'AttributeAttributeBoolArray' } | { __typename?: 'AttributeAttributeFloatArray' } | { __typename?: 'AttributeAttributeIntArray' } | { __typename?: 'AttributeAttributeMap' } | { __typename?: 'AttributeAttributeStringArray' } | { __typename?: 'BooleanType' } | { __typename?: 'FloatType' } | { __typename?: 'IntType' } | { __typename?: 'StringType', value: string } | null } }> } } } | { __typename?: 'StoreV2SubscriptionRef' } | null }> }> }> | null } | null };

export type CardStackCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type CategoryLinkGameStatsFragment = { __typename?: 'ChannelGameStats', gameId: string, liveStreams: number, game: { __typename?: 'GameGame', id: string, name: string, coverImageUrl: string } };

export type ChannelActionButtonsChannelFragment = { __typename?: 'ChannelChannel', id: string, streamerId: string, name: string, following: boolean, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null, monetizationSettings?: { __typename?: 'ChannelMonetizationSettings', enabled: boolean } };

export type FollowButtonChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, following: boolean };

export type ChannelFollowerNotificationSettingsQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type ChannelFollowerNotificationSettingsQuery = { __typename?: 'Query', channelFollowerNotificationSettings?: { __typename?: 'ChannelFollowerNotificationSettings', userId: string, channelId: string, channelLiveNotificationEnabled: boolean } | null, channelNotificationSettings?: { __typename?: 'ChannelNotificationSettings', userId: string, channelLiveNotification: { __typename?: 'ChannelNotificationStatus', emailEnabled: boolean } } | null };

export type SubscriptionButtonChannelFragment = { __typename?: 'ChannelChannel', id: string, following: boolean, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null, monetizationSettings?: { __typename?: 'ChannelMonetizationSettings', enabled: boolean } };

export type ChannelTagsChannelFragment = { __typename?: 'ChannelChannel', matureRatedContent: boolean };

export type LiveChannelProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type LiveChannelProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, badges: Array<{ __typename?: 'BadgeBadge', level: number, type: BadgeBadgeType }> } | null };

export type LiveChannelPreviewChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, title: string, following: boolean, matureRatedContent: boolean, viewerCount: number, thumbnail: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason?: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }, channelFriends?: { __typename?: 'FriendsChannelFriends', totalCount: number, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null };

export type OfflineChannelLinkChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, offlineBanner: string, following: boolean, followerCount: number, liveStatus: ChannelLiveStatus, logo: string };

export type MatureRatedContentDialogProviderProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type MatureRatedContentDialogProviderProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', uid: string, matureRatedContentAllowed: boolean } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', showMatureContentWarning: boolean } } | null } | null };

export type MatureRatedContentDialogProviderChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type MatureRatedContentDialogProviderChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, game: { __typename?: 'GameGame', id: string, activeSeason: { __typename?: 'GameSeason', id: string, seasonBreak: boolean } }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null } | null };

export type MatureRatedContentDialogChannelFragment = { __typename?: 'ChannelChannel', id: string, matureRatedContent: boolean };

export type ChannelAutoJoinLinkPropsChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, matureRatedContent: boolean };

export type ChannelFollowChannelMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type ChannelFollowChannelMutation = { __typename?: 'Mutation', followChannel?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type FollowChannelChannelFragment = { __typename?: 'ChannelChannel', id: string, followerCount: number, following: boolean };

export type UseLocalPlayerChannelIdsQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UseLocalPlayerChannelIdsQuery = { __typename?: 'Query', followedChannels?: { __typename?: 'ChannelGetUserFollowedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string }> } | null };

export type ChannelUnfollowChannelMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type ChannelUnfollowChannelMutation = { __typename?: 'Mutation', unfollowChannel?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type UpdateChannelFollowerNotificationSettingsMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
  enabled: Scalars['Boolean']['input'];
}>;


export type UpdateChannelFollowerNotificationSettingsMutation = { __typename?: 'Mutation', updateFollowerNotificationSettings?: { __typename?: 'ChannelFollowerNotificationSettings', userId: string, channelId: string, channelLiveNotificationEnabled: boolean } | null };

export type IsGamePredictionsEnabledChannelFragment = { __typename?: 'ChannelChannel', game: { __typename?: 'GameGame', id: string, activeSeason: { __typename?: 'GameSeason', id: string, seasonBreak: boolean } }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null };

export type ChannelListPageChannelsChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, title: string, following: boolean, matureRatedContent: boolean, viewerCount: number, thumbnail: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason?: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }, channelFriends?: { __typename?: 'FriendsChannelFriends', totalCount: number, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null };

export type ChannelListPageChannelsOfflineChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, offlineBanner: string, following: boolean, followerCount: number, liveStatus: ChannelLiveStatus, logo: string };

export type GameProgressionGameFragment = { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', name: string, id: string, progression: { __typename?: 'ProgressionSeasonProgression', seasonId: string, xpAmount: number, level: number, nextLevelThreshold: number, nextLevel: number } } };

export type GameProgressionLevelConfigsQueryVariables = Exact<{
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  minLevel?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GameProgressionLevelConfigsQuery = { __typename?: 'Query', listLevelConfigs?: { __typename?: 'ProgressionListLevelConfigsResponse', levelConfigs: Array<{ __typename?: 'ProgressionLevelConfig', threshold: number }> } | null };

export type UseAvatarEmotesQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UseAvatarEmotesQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename: 'AvatarAnimation', name: string, chatCommand: string, iconUrl: string, id: string } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji', id: string, label: string, image: string } | { __typename: 'GameLogicCard' } | { __typename: 'GameLogicStreamerCard' } | null } }> } | null };

export type ChannelSectionSmChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  skipAuthFields?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type ChannelSectionSmChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string, streamerId: string, following: boolean, matureRatedContent: boolean, game: { __typename?: 'GameGame', id: string, name: string }, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null, monetizationSettings?: { __typename?: 'ChannelMonetizationSettings', enabled: boolean } } | null };

export type ChannelSectionViewerCountQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelSectionViewerCountQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, viewerCount: number } | null };

export type ChannelSectionSmTagsChannelFragment = { __typename?: 'ChannelChannel', id: string, matureRatedContent: boolean, game: { __typename?: 'GameGame', id: string, name: string } };

export type GameSidebarChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  skipAuthFields?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GameSidebarChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus, viewerCount: number, followerCount: number, name: string, logo: string, title: string, streamerId: string, following: boolean, matureRatedContent: boolean, game: { __typename?: 'GameGame', id: string, name: string }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, startTime: string } | null, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean }, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null } | null };

export type ChannelSectionChannelViewerCountSubscriptionVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelSectionChannelViewerCountSubscription = { __typename?: 'Subscription', channelViewerCountSubscribe?: { __typename?: 'ChannelViewerCountEvent', viewerCount: number } | null };

export type ChannelSectionChannelFragment = { __typename?: 'ChannelChannel', viewerCount: number, followerCount: number, name: string, logo: string, title: string, liveStatus: ChannelLiveStatus, id: string, streamerId: string, following: boolean, matureRatedContent: boolean, game: { __typename?: 'GameGame', id: string, name: string }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, startTime: string } | null, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean }, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null };

export type ChannelViewCountUpdateFragment = { __typename?: 'ChannelChannel', id: string, viewerCount: number };

export type GameSidebarExpandedChannelFragment = { __typename?: 'ChannelChannel', id: string, viewerCount: number, followerCount: number, name: string, logo: string, title: string, liveStatus: ChannelLiveStatus, streamerId: string, following: boolean, matureRatedContent: boolean, game: { __typename?: 'GameGame', id: string, name: string }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, startTime: string } | null, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean }, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null };

export type AonDoubleDownCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type AonDoubleDownCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type BoosterScoredCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type BoosterScoredCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type CardFailedBoostersQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type CardFailedBoostersQuery = { __typename?: 'Query', boosters?: { __typename?: 'GameCardListBoostersResponse', boosters: Array<{ __typename?: 'GameLogicBooster', id: number, name: string }> } | null, gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type CardScavengeDataQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type CardScavengeDataQuery = { __typename?: 'Query', boosters?: { __typename?: 'GameCardListBoostersResponse', boosters: Array<{ __typename?: 'GameLogicBooster', id: number, name: string }> } | null, gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type CardSuccessDataQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type CardSuccessDataQuery = { __typename?: 'Query', boosters?: { __typename?: 'GameCardListBoostersResponse', boosters: Array<{ __typename?: 'GameLogicBooster', id: number, name: string }> } | null, gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus, streamer: { __typename?: 'ProfileProfile', userId: string } } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type UseGroupEventsBoosterDataQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type UseGroupEventsBoosterDataQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string } | null };

export type UseGroupEventsPlayerProfileQueryVariables = Exact<{
  playerId: Scalars['ID']['input'];
}>;


export type UseGroupEventsPlayerProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type GameSidebarMinimizedChannelFragment = { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, logo: string, name: string };

export type SidebarChannelLogoFragment = { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, logo: string, name: string };

export type ImplicitAccountGameBannerRankQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ImplicitAccountGameBannerRankQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, playedGames: Array<{ __typename?: 'ProfilePlayedGame', userId: string, id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', name: string, id: string, progression: { __typename?: 'ProgressionSeasonProgression', seasonId: string, xpAmount: number, level: number, nextLevelThreshold: number, nextLevel: number } } } }> } | null };

export type PipChannelInfoFragment = { __typename?: 'ChannelChannel', name: string, title: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string } };

export type SeasonBreakBottomBarSeasonFragment = { __typename?: 'GameSeason', seasonBreak: boolean, seasonBreakReason: string };

export type StreamComponentDataQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StreamComponentDataQuery = { __typename?: 'Query', streamSummary?: { __typename?: 'ChannelStreamSummary', serverRenderingEnabled: boolean } | null };

export type PartyInvitationAcceptedPartyQueryVariables = Exact<{
  partyId: Scalars['ID']['input'];
}>;


export type PartyInvitationAcceptedPartyQuery = { __typename?: 'Query', party?: { __typename?: 'PartyParty', streamId: string, channel?: { __typename?: 'ChannelChannel', name: string } | null } | null };

export type GuideToMetaGameDataQueryVariables = Exact<{
  placementId: Scalars['ID']['input'];
}>;


export type GuideToMetaGameDataQuery = { __typename?: 'Query', placement?: { __typename?: 'AdsGetPlacementResponse', placementId: string, rewards: Array<{ __typename?: 'AdsRewardDescription', readyAt: string }> } | null, goalCardSlots?: { __typename?: 'GoalCardListGoalCardSlotsResponse', slots: Array<{ __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', completed: boolean } | null, reward?: { __typename?: 'RewardReward', id: string } | null }> } | null };

export type MatchGroupChatIdQueryVariables = Exact<{
  streamId: Scalars['ID']['input'];
  groupId: Scalars['ID']['input'];
}>;


export type MatchGroupChatIdQuery = { __typename?: 'Query', matchGroupChatID?: { __typename?: 'MatchGetGroupChatIDResponse', chatId: string } | null };

export type StreamChannelFragment = { __typename?: 'ChannelChannel', id: string, currentChatId?: string | null, name: string, title: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, noicePredictionsEnabled: boolean, activeSeason: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } } };

export type StreamChannelQueryVariables = Exact<{
  streamId: Scalars['String']['input'];
}>;


export type StreamChannelQuery = { __typename?: 'Query', getStreamChannels?: { __typename?: 'ChannelBatchStreamGetChannelResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, currentChatId?: string | null, name: string, title: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, noicePredictionsEnabled: boolean, activeSeason: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } } }> } | null };

export type RestreamingHudChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type RestreamingHudChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, viewerCount: number } | null };

export type RestreamingHudChannelFragment = { __typename?: 'ChannelChannel', name: string, id: string };

export type SpectatorChannelQueryVariables = Exact<{
  streamId: Scalars['String']['input'];
}>;


export type SpectatorChannelQuery = { __typename?: 'Query', getStreamChannels?: { __typename?: 'ChannelBatchStreamGetChannelResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, currentChatId?: string | null, name: string }> } | null };

export type SpectatorChannelFragment = { __typename?: 'ChannelChannel', id: string, currentChatId?: string | null, name: string };

export type UseDefaultGameIdProfileGameFragment = { __typename?: 'ProfilePlayedGame', id: string, lastPlayedAt: string };

export type UseDefaultGameIdProfileQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UseDefaultGameIdProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, playedGames: Array<{ __typename?: 'ProfilePlayedGame', userId: string, id: string, lastPlayedAt: string }> } | null };

export type UsePlayedGameIdsQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UsePlayedGameIdsQuery = { __typename?: 'Query', playedGames?: { __typename?: 'ProfileListPlayedGamesResponse', games: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string }> } | null };

export type GoalCardSlotStateGoalCardSlotFragment = { __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', completed: boolean } | null, reward?: { __typename?: 'RewardReward', id: string } | null };

export type GoalCardSlotResetTimePastGoalCardSlotFragment = { __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null };

export type GoalCardSlotReadyForPickGoalCardCardSlotFragment = { __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', completed: boolean } | null, reward?: { __typename?: 'RewardReward', id: string } | null };

export type GameSelectorGameFragment = { __typename?: 'GameGame', id: string, name: string };

export type UseGameSelectorQueryVariables = Exact<{
  gameIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type UseGameSelectorQuery = { __typename?: 'Query', games?: { __typename?: 'GameBatchGetGamesResponse', games: Array<{ __typename?: 'GameGame', id: string, name: string }> } | null };

export type FriendRequestAcceptedNotificationContentProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type FriendRequestNotificationContentProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type GoalCardNotificationContentGoalCardSlotFragment = { __typename?: 'GoalCardGoalCardSlot', id: string, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', percentage: number, value: number, completed: boolean } | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string, description: string, target: number } | null };

export type GoalCardNotificationContentGoalCardFragment = { __typename?: 'GoalCardGoalCard', id: string, description: string, target: number };

export type PartyInviteNotificationContentPartyFragment = { __typename?: 'PartyParty', id: string, streamId: string, channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type PartyInviteNotificationContentLeaderProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type SeasonNotificationContentSeasonFragment = { __typename?: 'GameSeason', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string }, progression: { __typename?: 'ProgressionSeasonProgression', level: number } };

export type StoreItemNotificationContentStoreV2SellableItemFragment = { __typename?: 'StoreV2SellableItem', name: string, type: StoreV2ItemType };

export type ChannelSubscriptionUpdateNotificationChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelSubscriptionUpdateNotificationChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type NotificationFriendRequestProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type NotificationFriendRequestProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type NotificationGoalCardQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type NotificationGoalCardQuery = { __typename?: 'Query', goalCard?: { __typename?: 'GoalCardGoalCard', id: string, description: string, target: number } | null };

export type PartyInviterNotificationProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type PartyInviterNotificationProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type PartyInviterNotificationPartyQueryVariables = Exact<{
  partyId: Scalars['ID']['input'];
}>;


export type PartyInviterNotificationPartyQuery = { __typename?: 'Query', party?: { __typename?: 'PartyParty', id: string, streamId: string, channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null } | null };

export type UsePartyLeaderStreamChangedPartyQueryVariables = Exact<{
  partyId: Scalars['ID']['input'];
}>;


export type UsePartyLeaderStreamChangedPartyQuery = { __typename?: 'Query', party?: { __typename?: 'PartyParty', id: string, leaderId: string, streamId: string, channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null, members: Array<{ __typename?: 'PartyPartyMember', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string } }> } | null };

export type NotificationReceivedSubscriptionGiftQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  channelId: Scalars['ID']['input'];
  skipProfile?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type NotificationReceivedSubscriptionGiftQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null, channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type NotificationSeasonQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type NotificationSeasonQuery = { __typename?: 'Query', season?: { __typename?: 'GameSeason', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string }, progression: { __typename?: 'ProgressionSeasonProgression', level: number } } | null };

export type NotificationsStoreFrontQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type NotificationsStoreFrontQuery = { __typename?: 'Query', platformStoreFront?: { __typename?: 'StoreV2StoreFront', id: string, gameId: string, categories?: Array<{ __typename?: 'StoreV2StoreFrontCategory', id: string, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, name: string, type: StoreV2ItemType, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, amount: number }> | null }> }> | null } | null };

export type TimedAdsVideoRewardFragment = { __typename?: 'AdsRewardDescription', rarity: RarityRarity, prizes: Array<{ __typename?: 'AdsRewardDescriptionPrizeDescription', value: string, min: number, max: number }> };

export type TimedAdsContentRewardFragment = { __typename?: 'AdsRewardDescription', rarity: RarityRarity, readyAt: string, prizes: Array<{ __typename?: 'AdsRewardDescriptionPrizeDescription', min: number, max: number, value: string }> };

export type TimedAdsContentFragment = { __typename?: 'AdsGetPlacementResponse', rewards: Array<{ __typename?: 'AdsRewardDescription', rarity: RarityRarity, readyAt: string, prizes: Array<{ __typename?: 'AdsRewardDescriptionPrizeDescription', min: number, max: number, value: string }> }> };

export type TimedAdsLegendPrizeFragment = { __typename?: 'AdsRewardDescriptionPrizeDescription', value: string, min: number, max: number };

export type TimedAdsRewardRowRewardFragment = { __typename?: 'AdsRewardDescription', rarity: RarityRarity, readyAt: string, prizes: Array<{ __typename?: 'AdsRewardDescriptionPrizeDescription', min: number, max: number, value: string }> };

export type TimedAdsSelectionRewardsFragment = { __typename?: 'AdsRewardDescription', rarity: RarityRarity, readyAt: string, prizes: Array<{ __typename?: 'AdsRewardDescriptionPrizeDescription', min: number, max: number, value: string }> };

export type TimedAdsHeaderRewardsFragment = { __typename?: 'AdsRewardDescription', readyAt: string };

export type TimedAdsHeaderFragment = { __typename?: 'AdsGetPlacementResponse', placementId: string };

export type TimedAdsModalAdRewardFragment = { __typename?: 'AdsRewardDescription', readyAt: string, rarity: RarityRarity, prizes: Array<{ __typename?: 'AdsRewardDescriptionPrizeDescription', min: number, max: number, value: string }> };

export type TimedAdsModalAdFragment = { __typename?: 'AdsGetPlacementResponse', placementId: string, rewards: Array<{ __typename?: 'AdsRewardDescription', readyAt: string, rarity: RarityRarity, prizes: Array<{ __typename?: 'AdsRewardDescriptionPrizeDescription', min: number, max: number, value: string }> }> };

export type TimedAdsPlacementQueryVariables = Exact<{
  placementId: Scalars['ID']['input'];
}>;


export type TimedAdsPlacementQuery = { __typename?: 'Query', placement?: { __typename?: 'AdsGetPlacementResponse', placementId: string, rewards: Array<{ __typename?: 'AdsRewardDescription', readyAt: string, rarity: RarityRarity, prizes: Array<{ __typename?: 'AdsRewardDescriptionPrizeDescription', min: number, max: number, value: string }> }> } | null };

export type TimedAdsRewardPlacementMutationVariables = Exact<{
  placementId: Scalars['ID']['input'];
}>;


export type TimedAdsRewardPlacementMutation = { __typename?: 'Mutation', rewardPlacement?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type InitialRewardsQueryVariables = Exact<{
  placementId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type InitialRewardsQuery = { __typename?: 'Query', placement?: { __typename?: 'AdsGetPlacementResponse', placementId: string, rewards: Array<{ __typename?: 'AdsRewardDescription', readyAt: string }> } | null };

export type AvailableRewardsRewardFragment = { __typename?: 'AdsRewardDescription', readyAt: string };

export type UpdateProfileOnUsernameChangeNotificationFragment = { __typename?: 'ProfileProfile', userTag: string, canChangeUsernameAt?: string | null, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', reason: ModerationViolation }> | null };

export type AdyenContentCancelOrderMutationVariables = Exact<{
  orderId: Scalars['ID']['input'];
}>;


export type AdyenContentCancelOrderMutation = { __typename?: 'Mutation', cancelOrder?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type CancelAdyenOrderMutationVariables = Exact<{
  orderId: Scalars['ID']['input'];
}>;


export type CancelAdyenOrderMutation = { __typename?: 'Mutation', cancelOrder?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SearchMatchResultChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string };

export type SearchMatchResultCategoryFragment = { __typename?: 'ChannelGameStats', gameId: string, game: { __typename?: 'GameGame', id: string, name: string, coverImageUrl: string } };

export type SearchInputCategoryLinkGameFragment = { __typename?: 'GameGame', id: string, name: string, coverImageUrl: string };

export type SearchInputChannelLinkChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string };

export type SearchInputChannelSearchQueryVariables = Exact<{
  query?: InputMaybe<Scalars['String']['input']>;
  amount: Scalars['Int']['input'];
  skipCategories: Scalars['Boolean']['input'];
}>;


export type SearchInputChannelSearchQuery = { __typename?: 'Query', searchChannels?: { __typename?: 'SearchSearchResponse', resultItems: Array<{ __typename?: 'SearchResultItem', entityId: string, entity?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile' } | null }> } | null, searchCategories?: { __typename?: 'SearchSearchResponse', resultItems: Array<{ __typename?: 'SearchResultItem', entityId: string, entity?: { __typename?: 'ChannelChannel' } | { __typename?: 'ChannelGameStats', gameId: string, game: { __typename?: 'GameGame', id: string, name: string, coverImageUrl: string } } | { __typename?: 'ProfileProfile' } | null }> } | null };

export type SeasonBreakInfoGameQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type SeasonBreakInfoGameQuery = { __typename?: 'Query', game?: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } } | null };

export type SeasonCardRewardsDialogFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', rarity: RarityRarity, url: string }>, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type SeasonDialogBaseSeasonFragment = { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', rarity: RarityRarity, url: string }>, game: { __typename?: 'GameGame', id: string, name: string } };

export type SeasonDialogCardFanCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type SeasonEndDialogSeasonFragment = { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, progression: { __typename?: 'ProgressionSeasonProgression', seasonId: string, level: number, xpAmount: number }, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', rarity: RarityRarity, url: string }>, game: { __typename?: 'GameGame', id: string, name: string } };

export type SeasonEndDialogProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null };

export type SeasonEndDialogProfileStatsFragment = { __typename?: 'PlayerStatsPlayerStats', matchesPlayed: number };

export type SeasonEndDialogInventoryFragment = { __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType } };

export type SeasonEndDialogWrapperProfileFragment = { __typename?: 'ProfileProfile', playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string } }> };

export type UseSeasonEndDialogWrapperProfileQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  seasonId?: InputMaybe<Scalars['String']['input']>;
}>;


export type UseSeasonEndDialogWrapperProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, stats: { __typename?: 'PlayerStatsPlayerStats', matchesPlayed: number }, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null } | null };

export type UseSeasonEndDialogWrapperMutatingQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UseSeasonEndDialogWrapperMutatingQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType } }> } | null, season?: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, progression: { __typename?: 'ProgressionSeasonProgression', seasonId: string, level: number, xpAmount: number }, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', rarity: RarityRarity, url: string }>, game: { __typename?: 'GameGame', id: string, name: string } } | null };

export type UseSeasonEndDialogsSeasonsQueryVariables = Exact<{
  seasonIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type UseSeasonEndDialogsSeasonsQuery = { __typename?: 'Query', seasons?: { __typename?: 'GameBatchGetSeasonsResponse', seasons: Array<{ __typename?: 'GameSeason', id: string, gameId: string }> } | null };

export type UseEndSeasonEndDialogsProfileFragment = { __typename?: 'ProfileProfile', playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string } }> };

export type UseSeasonEndDialogsSeasonFragment = { __typename?: 'GameSeason', id: string, gameId: string };

export type SeasonRankUpDialogClaimRewardMutationVariables = Exact<{
  rewardId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type SeasonRankUpDialogClaimRewardMutation = { __typename?: 'Mutation', claimReward?: { __typename?: 'RewardClaimRewardResponse', emptyTypeWorkaround: boolean } | null };

export type UnclaimedSeasonRewardFragment = { __typename?: 'RewardReward', id: string, rewardedAt: string, reason: { __typename?: 'ReasonReason', reason?: { __typename?: 'ReasonReasonAdWatched' } | { __typename?: 'ReasonReasonAdministrative' } | { __typename?: 'ReasonReasonChallengeSuccessful' } | { __typename?: 'ReasonReasonChannelOwner' } | { __typename?: 'ReasonReasonChannelSubscription' } | { __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonGiftPurchaseWithPayment' } | { __typename?: 'ReasonReasonGoalCardComplete' } | { __typename?: 'ReasonReasonGoalCardSlotReshuffle' } | { __typename?: 'ReasonReasonLevelUp', level: number, season: { __typename?: 'GameSeason', id: string, name: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', rarity: RarityRarity, url: string }>, game: { __typename?: 'GameGame', id: string, name: string } } } | { __typename?: 'ReasonReasonMatchEnd' } | { __typename?: 'ReasonReasonProvision' } | { __typename?: 'ReasonReasonPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonPurchaseWithPayment' } | { __typename?: 'ReasonReasonReshuffle' } | { __typename?: 'ReasonReasonRewardClaimed' } | { __typename?: 'ReasonReasonStoreOrderPayment' } | null }, type: { __typename?: 'RewardRewardType', reward?: { __typename: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename: 'RewardRewardTypeItem', item: { __typename?: 'ItemItem', gameId: string, seasonId: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, seasonId: string, name: string, rarity: RarityRarity, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number }, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard' } | null } } | null } };

export type UnclaimedSeasonRewardsQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UnclaimedSeasonRewardsQuery = { __typename?: 'Query', rewards?: { __typename?: 'RewardListRewardsResponse', rewards: Array<{ __typename?: 'RewardReward', id: string, rewardedAt: string, reason: { __typename?: 'ReasonReason', reason?: { __typename?: 'ReasonReasonAdWatched' } | { __typename?: 'ReasonReasonAdministrative' } | { __typename?: 'ReasonReasonChallengeSuccessful' } | { __typename?: 'ReasonReasonChannelOwner' } | { __typename?: 'ReasonReasonChannelSubscription' } | { __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonGiftPurchaseWithPayment' } | { __typename?: 'ReasonReasonGoalCardComplete' } | { __typename?: 'ReasonReasonGoalCardSlotReshuffle' } | { __typename?: 'ReasonReasonLevelUp', level: number, season: { __typename?: 'GameSeason', id: string, name: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', rarity: RarityRarity, url: string }>, game: { __typename?: 'GameGame', id: string, name: string } } } | { __typename?: 'ReasonReasonMatchEnd' } | { __typename?: 'ReasonReasonProvision' } | { __typename?: 'ReasonReasonPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonPurchaseWithPayment' } | { __typename?: 'ReasonReasonReshuffle' } | { __typename?: 'ReasonReasonRewardClaimed' } | { __typename?: 'ReasonReasonStoreOrderPayment' } | null }, type: { __typename?: 'RewardRewardType', reward?: { __typename: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename: 'RewardRewardTypeItem', item: { __typename?: 'ItemItem', gameId: string, seasonId: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, seasonId: string, name: string, rarity: RarityRarity, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number }, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard' } | null } } | null } }> } | null };

export type GameSeasonSelectorSeasonFragment = { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, gameId: string, startTime: string, endTime: string };

export type GameSeasonSelectorProgressionQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  gameId: Scalars['ID']['input'];
}>;


export type GameSeasonSelectorProgressionQuery = { __typename?: 'Query', listSeasonProgression?: { __typename?: 'ProgressionListSeasonProgressionResponse', progression: Array<{ __typename?: 'ProgressionSeasonProgression', season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, gameId: string, startTime: string, endTime: string, game: { __typename?: 'GameGame', id: string, activeSeason: { __typename?: 'GameSeason', id: string } } } }> } | null, game?: { __typename?: 'GameGame', id: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, gameId: string, startTime: string, endTime: string } } | null };

export type SeasonStartDialogCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', rarity: RarityRarity, url: string }>, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type UseDefaultSeasonIdGameQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type UseDefaultSeasonIdGameQuery = { __typename?: 'Query', game?: { __typename?: 'GameGame', id: string, activeSeasonId: string } | null };

export type HasUnclaimedSeasonRewardsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type HasUnclaimedSeasonRewardsQuery = { __typename?: 'Query', rewards?: { __typename?: 'RewardListRewardsResponse', rewards: Array<{ __typename?: 'RewardReward', id: string, rewardedAt: string, reason: { __typename?: 'ReasonReason', reason?: { __typename?: 'ReasonReasonAdWatched' } | { __typename?: 'ReasonReasonAdministrative' } | { __typename?: 'ReasonReasonChallengeSuccessful' } | { __typename?: 'ReasonReasonChannelOwner' } | { __typename?: 'ReasonReasonChannelSubscription' } | { __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonGiftPurchaseWithPayment' } | { __typename?: 'ReasonReasonGoalCardComplete' } | { __typename?: 'ReasonReasonGoalCardSlotReshuffle' } | { __typename?: 'ReasonReasonLevelUp', season: { __typename?: 'GameSeason', id: string, game: { __typename?: 'GameGame', id: string } } } | { __typename?: 'ReasonReasonMatchEnd' } | { __typename?: 'ReasonReasonProvision' } | { __typename?: 'ReasonReasonPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonPurchaseWithPayment' } | { __typename?: 'ReasonReasonReshuffle' } | { __typename?: 'ReasonReasonRewardClaimed' } | { __typename?: 'ReasonReasonStoreOrderPayment' } | null } }> } | null };

export type UseSeasonStartDialogCardsQueryVariables = Exact<{
  ids: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type UseSeasonStartDialogCardsQuery = { __typename?: 'Query', itemsBatchExpand?: { __typename?: 'ItemBatchExpandItemsResponse', items: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', rarity: RarityRarity, url: string }>, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard' } | null }> } | null };

export type CardBundlePurchaseButtonCurrencyPriceFragment = { __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, amount: number, default: boolean };

export type StoreItemContentCardItemRefFragment = { __typename?: 'StoreV2ItemRef', id: string, count: number, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', progressToNextLevel: number, nextLevelLimit: number, currentLevel: number }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, baseCard: { __typename?: 'GameLogicCard', leveling: { __typename?: 'GameLogicCardLeveling', progressToNextLevel: number, nextLevelLimit: number } } } | null } } | null };

export type CardBundlePurchaseSuccessItemRefFragment = { __typename?: 'StoreV2ItemRef', id: string, count: number, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard', id: string, familyId: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard', id: string, familyId: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null } } | null };

export type CardBundleTitleGameFragment = { __typename?: 'GameGame', name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string, endTime: string } };

export type StoreItemPageQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  gameId: Scalars['ID']['input'];
}>;


export type StoreItemPageQuery = { __typename?: 'Query', sellableItem?: { __typename?: 'StoreV2SellableItem', id: string, name: string, type: StoreV2ItemType, sku: string, signature: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number }> | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', id: string } | { __typename: 'StoreV2ItemRef', id: string, count: number, item: { __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity, familyId: string, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, familyId: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, familyId: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, familyId: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', progressToNextLevel: number, nextLevelLimit: number, currentLevel: number }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, familyId: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', progressToNextLevel: number, nextLevelLimit: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null } } | null } | { __typename: 'StoreV2SubscriptionRef', id: string } | null }> } | null, game?: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string, endTime: string } } | null };

export type StoreItemItemRefFragment = { __typename?: 'StoreV2ItemRef', id: string, count: number, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard', id: string, familyId: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard', id: string, familyId: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null } } | null };

export type StoreItemPageChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string };

export type StoreItemSuccessCardItemRefFragment = { __typename?: 'StoreV2ItemRef', count: number, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard', id: string, familyId: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard', id: string, familyId: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null } } | null };

export type StoreSuccessCardItemItemFragment = { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard', id: string, familyId: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null };

export type StoreSuccessCardGameLogicCardFragment = { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type StoreSuccessCardStreamerLogicCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, familyId: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } };

export type StoreSuccessCardBaseCardFragment = { __typename?: 'GameLogicCard', id: string, familyId: string, name: string, pointsMin: number, pointsMax: number, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number } };

export type PurchaseStoreItemMutationVariables = Exact<{
  itemId: Scalars['ID']['input'];
  signature: Scalars['String']['input'];
  currencyId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type PurchaseStoreItemMutation = { __typename?: 'Mutation', buyWithInGameCurrency?: { __typename?: 'StoreV2BuyWithInGameCurrencyResponse', orderId: string } | null };

export type PurchaseStoreItemSellableItemFragment = { __typename?: 'StoreV2SellableItem', id: string, type: StoreV2ItemType, signature: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean }> | null };

export type StoreItemRevealedItemsFragment = { __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', id: string } | { __typename: 'StoreV2ItemRef', id: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity } | { __typename: 'GameLogicStreamerCard' } | null } } | { __typename: 'StoreV2SubscriptionRef', id: string } | null }>, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number }> | null };

export type StoreItemPlatformNavigationQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type StoreItemPlatformNavigationQuery = { __typename?: 'Query', platformStoreFront?: { __typename?: 'StoreV2StoreFront', id: string, gameId: string, categories?: Array<{ __typename?: 'StoreV2StoreFrontCategory', id: string, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string }> }> | null } | null };

export type StoreItemChannelNavigationQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type StoreItemChannelNavigationQuery = { __typename?: 'Query', channelStoreFront?: { __typename?: 'StoreV2StoreFront', id: string, gameId: string, categories?: Array<{ __typename?: 'StoreV2StoreFrontCategory', id: string, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string }> }> | null } | null };

export type StoreItemNavigationChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string };

export type StoreItemRevealedAnalyticsSellableItemFragment = { __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef', id: string } | { __typename?: 'StoreV2ItemRef', id: string } | { __typename?: 'StoreV2SubscriptionRef', id: string } | null }>, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number }> | null };

export type StoreItemRevealedAnalyticsIgcPriceFragment = { __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number };

export type UpgradedCardLevelDetailsFragment = { __typename?: 'GameLogicCard', pointsMin: number, pointsMax: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } };

export type SellableItemContentTextFragment = { __typename?: 'StoreV2SellableItem', content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef' } | null }> };

export type SendGiftDialogOverviewContentSellableItemFragment = { __typename?: 'StoreV2SellableItem', type: StoreV2ItemType, name: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef', channelId: string, amount: number } | null }>, price?: { __typename?: 'StoreV2Price', amount: number, amountWithoutDiscount: number, currency: PaymentCurrency } | null };

export type SendGiftToCommunityDialogOverviewContentChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type SendGiftToCommunityDialogOverviewContentChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, followerCount: number, liveStatus: ChannelLiveStatus } | null };

export type SendGiftToUserDialogOverviewContentChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type SendGiftToUserDialogOverviewContentChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type SendGiftToUserProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type SendGiftDialogOverviewActionsSellableItemFragment = { __typename?: 'StoreV2SellableItem', content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef' } | { __typename?: 'StoreV2ItemRef' } | { __typename?: 'StoreV2SubscriptionRef', amount: number } | null }>, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number } | null };

export type OverviewCurrencyContentSellableItemFragment = { __typename?: 'StoreV2SellableItem', name: string, price?: { __typename?: 'StoreV2Price', amount: number, amountWithoutDiscount: number, currency: PaymentCurrency } | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef' } | null }> };

export type OverviewSubscriptionContentSellableItemFragment = { __typename?: 'StoreV2SellableItem', content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef' } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef', channelId: string } | null }> };

export type OverviewSubscriptionContentChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type OverviewSubscriptionContentChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type SendGiftToUserDialogPaymentSellableItemFragment = { __typename?: 'StoreV2SellableItem', type: StoreV2ItemType, name: string, price?: { __typename?: 'StoreV2Price', amount: number, amountWithoutDiscount: number, currency: PaymentCurrency } | null };

export type SendGiftDialogPaymentContentChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type SendGiftDialogPaymentContentChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, followerCount: number, liveStatus: ChannelLiveStatus } | null };

export type GiftSubscriptionGetChannelIdSellableItemFragment = { __typename?: 'StoreV2SellableItem', content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef' } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef', channelId: string } | null }> };

export type SendGiftDialogSellableItemFragment = { __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, name: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef', channelId: string, amount: number } | null }>, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null };

export type SendGiftToUserDialogProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type GiftableItemFragment = { __typename?: 'StoreV2SellableItem', id: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef' } | { __typename?: 'StoreV2ItemRef' } | { __typename?: 'StoreV2SubscriptionRef', amount: number } | null }> };

export type SendGiftToUserDialogDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type SendGiftToUserDialogDataQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, userChannelSubscription?: { __typename?: 'SubscriptionChannelSubscription', state: SubscriptionChannelSubscriptionState } | null };

export type SendGiftGiftItemsQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type SendGiftGiftItemsQuery = { __typename?: 'Query', giftSellableItems?: { __typename?: 'StoreV2ListGiftSellableItemsResponse', items: Array<{ __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, name: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef', amount: number, channelId: string } | null }>, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null }> } | null };

export type SendGiftToUserIsTemporaryQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type SendGiftToUserIsTemporaryQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, temporary: boolean } | null };

export type SendGiftToUserSubscriptionStateQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type SendGiftToUserSubscriptionStateQuery = { __typename?: 'Query', userChannelSubscription?: { __typename?: 'SubscriptionChannelSubscription', state: SubscriptionChannelSubscriptionState } | null };

export type GiftPaymentSessionFragment = { __typename?: 'StoreV2BuyWithPaymentResponse', orderId: string, session: { __typename?: 'PaymentSession', session?: { __typename?: 'AdyenSession', id: string, reference: string, returnUrl: string, sessionData: string, amount: { __typename?: 'AdyenAmount', value: number, currency: string } } | { __typename?: 'PaymentAppStoreSession' } | null } };

export type SendGiftToUserWithPaymentMutationVariables = Exact<{
  itemId: Scalars['ID']['input'];
  signature: Scalars['String']['input'];
  giftedUserId: Scalars['String']['input'];
  giftAnonymously: Scalars['Boolean']['input'];
}>;


export type SendGiftToUserWithPaymentMutation = { __typename?: 'Mutation', buyWithPayment?: { __typename?: 'StoreV2BuyWithPaymentResponse', orderId: string, session: { __typename?: 'PaymentSession', session?: { __typename?: 'AdyenSession', id: string, reference: string, returnUrl: string, sessionData: string, amount: { __typename?: 'AdyenAmount', value: number, currency: string } } | { __typename?: 'PaymentAppStoreSession' } | null } } | null };

export type SendGiftToCommunityWithPaymentMutationVariables = Exact<{
  itemId: Scalars['ID']['input'];
  signature: Scalars['String']['input'];
  giftAnonymously: Scalars['Boolean']['input'];
}>;


export type SendGiftToCommunityWithPaymentMutation = { __typename?: 'Mutation', buyWithPayment?: { __typename?: 'StoreV2BuyWithPaymentResponse', orderId: string, session: { __typename?: 'PaymentSession', session?: { __typename?: 'AdyenSession', id: string, reference: string, returnUrl: string, sessionData: string, amount: { __typename?: 'AdyenAmount', value: number, currency: string } } | { __typename?: 'PaymentAppStoreSession' } | null } } | null };

export type UpdateSubscriptionOnGiftChannelFragment = { __typename?: 'ChannelChannel', subscription?: { __typename?: 'SubscriptionChannelSubscription', state: SubscriptionChannelSubscriptionState } | null };

export type StoreHasBundlesToBuyStoreFrontQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type StoreHasBundlesToBuyStoreFrontQuery = { __typename?: 'Query', platformStoreFront?: { __typename?: 'StoreV2StoreFront', id: string, gameId: string, categories?: Array<{ __typename?: 'StoreV2StoreFrontCategory', id: string, itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, name: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, amount: number }> | null }> }> | null } | null };

export type CardBundleSellableItemFragment = { __typename?: 'StoreV2SellableItem', type: StoreV2ItemType, name: string, discountPercent: number, promotionName: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef' } | { __typename: 'StoreV2ItemRef', count: number, id: string, item: { __typename?: 'ItemItem', id: string, season?: { __typename?: 'GameSeason', id: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', url: string, rarity: RarityRarity }> } | null, game?: { __typename?: 'GameGame', id: string, name: string } | null, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null } } | { __typename?: 'StoreV2SubscriptionRef' } | null }> };

export type CardBundleSellableItemPriceFragment = { __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number };

export type CardBundleCardAssetImageSellableItemFragment = { __typename?: 'StoreV2SellableItem', type: StoreV2ItemType, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef' } | { __typename: 'StoreV2ItemRef', id: string, count: number, item: { __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null } } | { __typename?: 'StoreV2SubscriptionRef' } | null }> };

export type CardBundleAssetGameLogicCardFragment = { __typename?: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type CardBundleAssetGameLogicStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } };

export type CardBundleCardContentSellableItemFragment = { __typename?: 'StoreV2SellableItem', name: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef' } | { __typename: 'StoreV2ItemRef', count: number, item: { __typename?: 'ItemItem', id: string, game?: { __typename?: 'GameGame', id: string, name: string } | null, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity } | { __typename: 'GameLogicStreamerCard' } | null } } | { __typename?: 'StoreV2SubscriptionRef' } | null }> };

export type StoreCardBundleCategoryFragment = { __typename?: 'StoreV2StoreFrontCategory', itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, name: string, discountPercent: number, promotionName: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef', id: string } | { __typename: 'StoreV2ItemRef', count: number, id: string, item: { __typename?: 'ItemItem', id: string, season?: { __typename?: 'GameSeason', id: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', url: string, rarity: RarityRarity }> } | null, game?: { __typename?: 'GameGame', id: string, name: string } | null, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null } } | { __typename?: 'StoreV2SubscriptionRef', id: string } | null }> }> };

export type StoreCardBundleAnalyticsSellableItemFragment = { __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef', id: string } | { __typename?: 'StoreV2ItemRef', id: string } | { __typename?: 'StoreV2SubscriptionRef', id: string } | null }>, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number }> | null };

export type StoreCardBundleAnalyticsIgcPriceFragment = { __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number };

export type StoreCardDiscountLabelSellableItemFragment = { __typename?: 'StoreV2SellableItem', discountPercent: number, promotionName: string };

export type AdyenOverlaySellableItemFragment = { __typename?: 'StoreV2SellableItem', name: string, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number } | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef' } | null }> };

export type CurrencyCardSellableItemFragment = { __typename?: 'StoreV2SellableItem', discountPercent: number, promotionName: string, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, amount: number, amountWithoutDiscount: number }> | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef' } | null }> };

export type CurrencyCardImageCurrencyPriceFragment = { __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, amount: number, amountWithoutDiscount: number };

export type CurrencyListStoreFrontCategoryFragment = { __typename?: 'StoreV2StoreFrontCategory', id: string, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, signature: string, sku: string, name: string, discountPercent: number, promotionName: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef' } | null }> }> };

export type StoreBuyCurrencyBundleWithInGameCurrencyMutationVariables = Exact<{
  itemId: Scalars['ID']['input'];
  signature: Scalars['String']['input'];
  currencyId: Scalars['ID']['input'];
}>;


export type StoreBuyCurrencyBundleWithInGameCurrencyMutation = { __typename?: 'Mutation', buyWithInGameCurrency?: { __typename?: 'StoreV2BuyWithInGameCurrencyResponse', orderId: string } | null };

export type InGameCurrencyBuyCurrencyCardSellableItemFragment = { __typename?: 'StoreV2SellableItem', id: string, signature: string, sku: string, discountPercent: number, promotionName: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef' } | null }> };

export type InGameCurrencyBuyCurrencyCardIgcPriceFragment = { __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number };

export type InGameCurrencyBuyOverlaySellableItemFragment = { __typename?: 'StoreV2SellableItem', igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef' } | null }> };

export type InGameCurrencyBuyOverlayItemPriceFragment = { __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number };

export type StoreBuyCurrencyBundleWithPaymentMutationVariables = Exact<{
  itemId: Scalars['ID']['input'];
  signature: Scalars['String']['input'];
}>;


export type StoreBuyCurrencyBundleWithPaymentMutation = { __typename?: 'Mutation', buyWithPayment?: { __typename?: 'StoreV2BuyWithPaymentResponse', orderId: string, session: { __typename?: 'PaymentSession', session?: { __typename?: 'AdyenSession', id: string, reference: string, returnUrl: string, sessionData: string, amount: { __typename?: 'AdyenAmount', value: number, currency: string } } | { __typename?: 'PaymentAppStoreSession' } | null } } | null };

export type PaymentBuyCurrencyCardSellableItemFragment = { __typename?: 'StoreV2SellableItem', id: string, signature: string, name: string, discountPercent: number, promotionName: string, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, amount: number, amountWithoutDiscount: number }> | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef' } | null }> };

export type StoreCurrencyPackCategoryFragment = { __typename?: 'StoreV2StoreFrontCategory', itemType: StoreV2ItemType, id: string, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, signature: string, sku: string, name: string, discountPercent: number, promotionName: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', amount: number, id: string } | { __typename: 'StoreV2ItemRef' } | { __typename: 'StoreV2SubscriptionRef' } | null }> }> };

export type ChannelStoreFrontCategoriesCategoryFragment = { __typename?: 'StoreV2StoreFrontCategory', itemType: StoreV2ItemType, id: string, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, discountPercent: number, availableUntil?: string | null, name: string, promotionName: string, sku: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef', id: string } | { __typename: 'StoreV2ItemRef', count: number, id: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart', previewImgUrl: string } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, channelId: string, gameId: string, familyId: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus }, baseCard: { __typename?: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } | null, season?: { __typename?: 'GameSeason', id: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', url: string, rarity: RarityRarity }> } | null, game?: { __typename?: 'GameGame', id: string, name: string } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemCount: number } | null } | { __typename?: 'StoreV2SubscriptionRef', id: string } | null }>, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null }> };

export type ChannelStoreFrontChannelFragment = { __typename?: 'ChannelChannel', logo: string, offlineBanner: string, name: string, streamedGames?: Array<{ __typename?: 'GameGame', id: string, noicePredictionsEnabled: boolean, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } }> | null };

export type ChannelStoreFrontProfileFragment = { __typename?: 'ProfileProfile', playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string } }> };

export type ChannelStoreFrontCategoriesContentCategoryFragment = { __typename?: 'StoreV2StoreFrontCategory', itemType: StoreV2ItemType, id: string, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, discountPercent: number, availableUntil?: string | null, name: string, promotionName: string, sku: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef', id: string } | { __typename: 'StoreV2ItemRef', count: number, id: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart', previewImgUrl: string } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, channelId: string, gameId: string, familyId: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus }, baseCard: { __typename?: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } | null, season?: { __typename?: 'GameSeason', id: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', url: string, rarity: RarityRarity }> } | null, game?: { __typename?: 'GameGame', id: string, name: string } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemCount: number } | null } | { __typename?: 'StoreV2SubscriptionRef', id: string } | null }>, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null }> };

export type ChannelStoreFrontCategoriesContentChannelFragment = { __typename?: 'ChannelChannel', name: string, streamedGames?: Array<{ __typename?: 'GameGame', id: string, noicePredictionsEnabled: boolean, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } }> | null };

export type ChannelStoreFrontCategoriesContentProfileFragment = { __typename?: 'ProfileProfile', playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string } }> };

export type StoreChannelStoreAvatarPartFragment = { __typename?: 'StoreV2StoreFrontCategory', itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef' } | { __typename?: 'StoreV2ItemRef', item: { __typename?: 'ItemItem', details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart', previewImgUrl: string } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } } | { __typename?: 'StoreV2SubscriptionRef' } | null }> }> };

export type ChannelStorePremiumBundlePrefixChannelFragment = { __typename?: 'ChannelChannel', name: string };

export type PlatformStoreFrontCategoriesCategoryFragment = { __typename?: 'StoreV2StoreFrontCategory', id: string, itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, sku: string, name: string, discountPercent: number, promotionName: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', id: string, amount: number } | { __typename: 'StoreV2ItemRef', count: number, id: string, item: { __typename?: 'ItemItem', id: string, season?: { __typename?: 'GameSeason', id: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', url: string, rarity: RarityRarity }> } | null, game?: { __typename?: 'GameGame', id: string, name: string } | null, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null } } | { __typename: 'StoreV2SubscriptionRef', id: string } | null }>, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null }> };

export type PlatformStoreFrontCategoriesProfileFragment = { __typename?: 'ProfileProfile', userId: string, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }> };

export type StoreFrontCategoriesCategoryFragment = { __typename?: 'StoreV2StoreFrontCategory', id: string, itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, sku: string, discountPercent: number, availableUntil?: string | null, name: string, promotionName: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', id: string, amount: number } | { __typename: 'StoreV2ItemRef', id: string, count: number, item: { __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart', previewImgUrl: string } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, channelId: string, gameId: string, familyId: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus }, baseCard: { __typename?: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } | null, season?: { __typename?: 'GameSeason', id: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', url: string, rarity: RarityRarity }> } | null, game?: { __typename?: 'GameGame', id: string, name: string } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemCount: number } | null } | { __typename: 'StoreV2SubscriptionRef', id: string } | null }>, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null }> };

export type StoreFrontCategoriesChannelFragment = { __typename?: 'ChannelChannel', id: string, logo: string, offlineBanner: string, name: string, streamedGames?: Array<{ __typename?: 'GameGame', id: string, noicePredictionsEnabled: boolean, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } }> | null };

export type StoreFrontCategoryProfileFragment = { __typename?: 'ProfileProfile', userId: string, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }> };

export type StoreFrontCategoriesAnalyticsCategoryFragment = { __typename?: 'StoreV2StoreFrontCategory', itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, signature: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef', id: string } | { __typename?: 'StoreV2ItemRef', id: string } | { __typename?: 'StoreV2SubscriptionRef', id: string } | null }> }> };

export type ShowNewSeasonBannerForUserProfileFragment = { __typename?: 'ProfileProfile', playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string } }> };

export type ShowNewSeasonBannerForUserCategoryFragment = { __typename?: 'StoreV2StoreFrontCategory', itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string }> };

export type StoreGameSelectorGameFragment = { __typename?: 'GameGame', id: string, name: string };

export type StoreNewSeasonBannerGameFragment = { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } };

export type StoreNewSeasonBannerChannelFragment = { __typename?: 'ChannelChannel', name: string };

export type StoreStreamerCardCategoryFragment = { __typename?: 'StoreV2StoreFrontCategory', id: string, itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, discountPercent: number, availableUntil?: string | null, sku: string, type: StoreV2ItemType, signature: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef' } | { __typename?: 'StoreV2ItemRef', id: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard', id: string, channelId: string, gameId: string, familyId: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus }, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemCount: number } | null } | { __typename?: 'StoreV2SubscriptionRef' } | null }>, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number }> | null }> };

export type StreamerCardPurchaseCardButtonPriceFragment = { __typename?: 'StoreV2InGameCurrencyPrice', amount: number, currencyId: string };

export type StreamerCardPurchaseCardButtonSellableItemFragment = { __typename?: 'StoreV2SellableItem', sku: string, id: string, type: StoreV2ItemType, signature: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean }> | null };

export type StreamerCardPurchaseCardButtonStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', channelId: string, gameId: string, familyId: string, id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', name: string, id: string, logo: string, liveStatus: ChannelLiveStatus }, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } };

export type StreamerCardPurchaseDialogSellableItemFragment = { __typename?: 'StoreV2SellableItem', id: string, type: StoreV2ItemType, signature: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean }> | null };

export type StreamerCardPurchaseDialogStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', name: string, id: string, logo: string, liveStatus: ChannelLiveStatus }, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } };

export type StreamerCardPurchaseDescriptionChannelFragment = { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, logo: string };

export type StreamerCardPurchaseSuccessModalStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus }, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } };

export type SellableCreatorCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus }, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } };

export type StoreStreamerCardSellableItemFragment = { __typename?: 'StoreV2SellableItem', id: string, discountPercent: number, availableUntil?: string | null, sku: string, type: StoreV2ItemType, signature: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename?: 'StoreV2CurrencyRef' } | { __typename?: 'StoreV2ItemRef', id: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard', id: string, channelId: string, gameId: string, familyId: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus }, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemCount: number } | null } | { __typename?: 'StoreV2SubscriptionRef' } | null }>, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number }> | null };

export type StreamGameProxyStreamFragment = { __typename?: 'ChannelStreamSummary', streamId: string, channelId: string, noicePredictionsEnabled: boolean };

export type StreamGameProxyChannelQueryVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type StreamGameProxyChannelQuery = { __typename?: 'Query', streamSummary?: { __typename?: 'ChannelStreamSummary', streamId: string, channelId: string, noicePredictionsEnabled: boolean } | null };

export type StreamStateChannelLiveStateSubscriptionVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type StreamStateChannelLiveStateSubscription = { __typename?: 'Subscription', channelStreamDetailSubscribe?: { __typename?: 'ChannelChannelStreamDetailEvent', channelId: string, liveStatus: ChannelLiveStatus, streamId: string, matureRatedContent: boolean, serverRenderingEnabled: boolean } | null };

export type StreamStateProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type StreamStateProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', uid: string, matureRatedContentAllowed: boolean } | null } | null };

export type ActiveChannelLiveStatusFragment = { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, currentStreamId: string, id: string, matureRatedContent: boolean };

export type ActiveStreamLiveStatusFragment = { __typename?: 'ChannelStream', streamId: string, serverRenderingEnabled: boolean };

export type ActiveChannelSummaryLiveStatusFragment = { __typename?: 'ChannelStreamSummary', streamId: string, matureRatedContent: boolean, serverRenderingEnabled: boolean, channelId: string };

export type ActiveSubscriptionMenuCancelMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ActiveSubscriptionMenuCancelMutation = { __typename?: 'Mutation', cancelChannelSubscription?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ActiveSubscriptionMenuUserBadgeQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type ActiveSubscriptionMenuUserBadgeQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null };

export type SubscriptionCancellationModalChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type SubscriptionCancellationModalChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, followerCount: number, liveStatus: ChannelLiveStatus, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, provider: SubscriptionChannelSubscriptionProvider, expiresAt?: string | null } | null, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> }> } | null } | null };

export type ChargebeeSubscriptionCancellationModalActionsChannelFragment = { __typename?: 'ChannelChannel', id: string };

export type ChargebeeSubscriptionCancellationModalActionsSubscriptionFragment = { __typename?: 'SubscriptionChannelSubscription', id: string };

export type ActiveMenuCancelUpdateSubscriptionFragment = { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState };

export type SubscriptionCancellationModalActionsSubscriptionFragment = { __typename?: 'SubscriptionChannelSubscription', id: string, provider: SubscriptionChannelSubscriptionProvider };

export type SubscriptionCancellationModalActionsChannelFragment = { __typename?: 'ChannelChannel', id: string };

export type ChargebeeSubscriptionCancellationModalContentChannelFragment = { __typename?: 'ChannelChannel', id: string, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> }> } | null };

export type ChargebeeSubscriptionCancellationModalContentSubscriptionFragment = { __typename?: 'SubscriptionChannelSubscription', expiresAt?: string | null };

export type SubscriptionCancellationModalContentSubscriptionFragment = { __typename?: 'SubscriptionChannelSubscription', id: string, provider: SubscriptionChannelSubscriptionProvider, expiresAt?: string | null };

export type SubscriptionCancellationModalContentChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, logo: string, followerCount: number, liveStatus: ChannelLiveStatus, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> }> } | null };

export type SubscriptionDialogChannelContentChannelFragment = { __typename?: 'ChannelChannel', name: string, logo: string, followerCount: number, liveStatus: ChannelLiveStatus };

export type ChargebeeSubscriptionModelChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChargebeeSubscriptionModelChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, followerCount: number, liveStatus: ChannelLiveStatus, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, prices: Array<{ __typename?: 'SubscriptionSubscriptionPrice', period: SubscriptionSubscriptionPricePeriod, price: number, currency: PaymentCurrency }>, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> }> } | null, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState, cancelReason: SubscriptionChannelSubscriptionCancelReason } | null } | null };

export type SubscriptionModalCompleteStageChannelFragment = { __typename?: 'ChannelChannel', name: string };

export type SubscriptionModalOverviewStageChannelFragment = { __typename?: 'ChannelChannel', name: string, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> }> } | null };

export type SubscriptionModalActionsChannelFragment = { __typename?: 'ChannelChannel', id: string, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null };

export type ReactiveChannelSubscriptionMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ReactiveChannelSubscriptionMutation = { __typename?: 'Mutation', reactivateChannelSubscription?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SubscriptionModalStageFlowsSubscriptionFragment = { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState, cancelReason: SubscriptionChannelSubscriptionCancelReason };

export type ReactiveSubscriptionChannelFragment = { __typename?: 'ChannelChannel', id: string, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null };

export type ReactiveSubscriptionChannelSubscriptionFragment = { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState };

export type CheckoutExistingChannelSubscriptionMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type CheckoutExistingChannelSubscriptionMutation = { __typename?: 'Mutation', checkoutExistingChannelSubscription?: { __typename?: 'SubscriptionCheckoutExistingSubscriptionResponse', sessionData: string } | null };

export type CheckoutNewChannelSubscriptionMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  tier?: InputMaybe<Scalars['Int']['input']>;
}>;


export type CheckoutNewChannelSubscriptionMutation = { __typename?: 'Mutation', checkoutNewChannelSubscription?: { __typename?: 'SubscriptionCheckoutNewSubscriptionResponse', sessionData: string } | null };

export type SubscriptionCheckoutCacheUpdateProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type SubscriptionCheckoutCacheUpdateProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', anonymisePurchaseHighlights: boolean } } | null } | null };

export type SubscriptionCheckoutModalOnClickUpdateChannelFragment = { __typename?: 'ChannelChannel', id: string, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null };

export type SubscriptionBadgeProfileFragment = { __typename?: 'ProfileProfile', badges: Array<{ __typename: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type SubscriptionPaymentMethodSessionMutationVariables = Exact<{ [key: string]: never; }>;


export type SubscriptionPaymentMethodSessionMutation = { __typename?: 'Mutation', updateSubscriptionPaymentMethod?: { __typename?: 'SubscriptionUpdateSubscriptionPaymentMethodResponse', sessionData: string } | null };

export type UpdateConsentWarningSettingMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  showMatureContentWarning: Scalars['Boolean']['input'];
}>;


export type UpdateConsentWarningSettingMutation = { __typename?: 'Mutation', updatePrivacySettings?: { __typename?: 'ProfilePrivacySettings', showMatureContentWarning: boolean } | null };

export type ConsentWarningSettingUpdateProfileFragment = { __typename?: 'ProfileProfile', settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', showMatureContentWarning: boolean } } | null };

export type UpdateHideOnlineStatusMutationVariables = Exact<{
  hideOnlineStatus: Scalars['Boolean']['input'];
}>;


export type UpdateHideOnlineStatusMutation = { __typename?: 'Mutation', updatePrivacySettings?: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } | null };

export type OnlineVisibilityUpdateProfileFragment = { __typename?: 'ProfileProfile', userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null };

export type UpdateMarketingConsentMutationVariables = Exact<{
  consent: AuthConsentStatus;
}>;


export type UpdateMarketingConsentMutation = { __typename?: 'Mutation', updateMarketingConsent?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type MarketingConsentUpdateProfileFragment = { __typename?: 'ProfileProfile', account?: { __typename?: 'AuthAccount', marketingConsent: AuthConsentStatus } | null };

export type GetPushNotificationTokenQueryVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type GetPushNotificationTokenQuery = { __typename?: 'Query', pushNotificationToken?: { __typename?: 'NotificationPushNotificationToken', token: string } | null };

export type AddPushNotificationTokenMutationVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type AddPushNotificationTokenMutation = { __typename?: 'Mutation', addPushNotificationToken?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type DeletePushNotificationTokenMutationVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type DeletePushNotificationTokenMutation = { __typename?: 'Mutation', deletePushNotificationToken?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type MicroSurveyPlayerTraitsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type MicroSurveyPlayerTraitsQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, stats: { __typename?: 'PlayerStatsPlayerStats', adsWatched: number, matchesPlayed: number, timePlayed?: string | null, cardsPlayed: number, cardsSucceeded: number }, account?: { __typename?: 'AuthAccount', createdAt: string, email: string } | null } | null };

export type UseSelectedGameIdWithDefaultQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type UseSelectedGameIdWithDefaultQuery = { __typename?: 'Query', playedGames?: { __typename?: 'ProfileListPlayedGamesResponse', games: Array<{ __typename?: 'ProfilePlayedGame', userId: string, id: string, game: { __typename?: 'GameGame', id: string } }> } | null };

export type SelectedSeasonsSeasonFragment = { __typename?: 'GameSeason', id: string, gameId: string };

export type SelectedSeasonSeasonsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  gameId: Scalars['ID']['input'];
}>;


export type SelectedSeasonSeasonsQuery = { __typename?: 'Query', listSeasonProgression?: { __typename?: 'ProgressionListSeasonProgressionResponse', progression: Array<{ __typename?: 'ProgressionSeasonProgression', season: { __typename?: 'GameSeason', id: string, gameId: string } }> } | null, playedGames?: { __typename?: 'ProfileListPlayedGamesResponse', games: Array<{ __typename?: 'ProfilePlayedGame', userId: string, id: string, game: { __typename?: 'GameGame', id: string, activeSeason: { __typename?: 'GameSeason', id: string, gameId: string } } }> } | null, game?: { __typename?: 'GameGame', id: string, activeSeasonId: string } | null };

export type PageLayoutProfileFragment = { __typename?: 'ProfileProfile', onlineStatus: ProfilePresenceStatus, userTag: string, userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', reason: ModerationViolation, changedAt: string }> | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type CreateChannelMutationVariables = Exact<{
  channelName: Scalars['String']['input'];
}>;


export type CreateChannelMutation = { __typename?: 'Mutation', createChannel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type DebugMenuProfileFragment = { __typename?: 'ProfileProfile', userTag: string };

export type DebugMenuMatchInfoProfileFragment = { __typename?: 'ProfileProfile', userTag: string };

export type MenuButtonsProfileFragment = { __typename?: 'ProfileProfile', userTag: string, userId: string, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', reason: ModerationViolation, changedAt: string }> | null };

export type NotificationAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', id: string, title: string, text: string, category: AnnouncementAnnouncementCategory, startTime?: string | null };

export type NotificationsTabFriendRequestFriendsUserFragment = { __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } };

export type NotificationsTabRewardRewardFragment = { __typename?: 'RewardReward', id: string, rewardedAt: string, reason: { __typename?: 'ReasonReason', reason?: { __typename?: 'ReasonReasonAdWatched' } | { __typename?: 'ReasonReasonAdministrative' } | { __typename?: 'ReasonReasonChallengeSuccessful' } | { __typename?: 'ReasonReasonChannelOwner' } | { __typename?: 'ReasonReasonChannelSubscription' } | { __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonGiftPurchaseWithPayment' } | { __typename?: 'ReasonReasonGoalCardComplete', goalCardSlotId: string, goalCardId: string, goalCard: { __typename?: 'GoalCardGoalCard', id: string, description: string, target: number } } | { __typename?: 'ReasonReasonGoalCardSlotReshuffle' } | { __typename?: 'ReasonReasonLevelUp', seasonId: string, season: { __typename?: 'GameSeason', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string }, progression: { __typename?: 'ProgressionSeasonProgression', level: number } } } | { __typename?: 'ReasonReasonMatchEnd' } | { __typename?: 'ReasonReasonProvision' } | { __typename?: 'ReasonReasonPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonPurchaseWithPayment' } | { __typename?: 'ReasonReasonReshuffle' } | { __typename?: 'ReasonReasonRewardClaimed' } | { __typename?: 'ReasonReasonStoreOrderPayment' } | null } };

export type NotificationsTabSubscriptionPaymentFailedSubscriptionFragment = { __typename?: 'SubscriptionChannelSubscription', id: string, paymentFailedAt?: string | null, channel: { __typename?: 'ChannelChannel', id: string, name: string } };

export type NotificationsTabUsernameRejectedProfileFragment = { __typename?: 'ProfileProfile', userId: string, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', reason: ModerationViolation, changedAt: string }> | null };

export type NotificationAnnouncementsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type NotificationAnnouncementsQuery = { __typename?: 'Query', userAnnouncements?: { __typename?: 'AnnouncementListUserAnnouncementsResponse', announcements: Array<{ __typename?: 'AnnouncementAnnouncement', id: string, title: string, text: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, image: string }> } | null };

export type NotificationReceivedFriendRequestsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type NotificationReceivedFriendRequestsQuery = { __typename?: 'Query', receivedFriendRequests?: { __typename?: 'FriendsListReceivedFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> } | null };

export type NotificationPaymentFailedSubscriptionsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type NotificationPaymentFailedSubscriptionsQuery = { __typename?: 'Query', userChannelSubscriptions?: { __typename?: 'SubscriptionListUserChannelSubscriptionsResponse', subscriptions: Array<{ __typename?: 'SubscriptionChannelSubscription', id: string, paymentFailedAt?: string | null, channel: { __typename?: 'ChannelChannel', id: string, name: string } }> } | null };

export type NotificationRewardsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type NotificationRewardsQuery = { __typename?: 'Query', rewards?: { __typename?: 'RewardListRewardsResponse', rewards: Array<{ __typename?: 'RewardReward', id: string, rewardedAt: string, reason: { __typename?: 'ReasonReason', reason?: { __typename?: 'ReasonReasonAdWatched' } | { __typename?: 'ReasonReasonAdministrative' } | { __typename?: 'ReasonReasonChallengeSuccessful' } | { __typename?: 'ReasonReasonChannelOwner' } | { __typename?: 'ReasonReasonChannelSubscription' } | { __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonGiftPurchaseWithPayment' } | { __typename?: 'ReasonReasonGoalCardComplete', goalCardSlotId: string, goalCardId: string, goalCard: { __typename?: 'GoalCardGoalCard', id: string, description: string, target: number } } | { __typename?: 'ReasonReasonGoalCardSlotReshuffle' } | { __typename?: 'ReasonReasonLevelUp', seasonId: string, season: { __typename?: 'GameSeason', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string }, progression: { __typename?: 'ProgressionSeasonProgression', level: number } } } | { __typename?: 'ReasonReasonMatchEnd' } | { __typename?: 'ReasonReasonProvision' } | { __typename?: 'ReasonReasonPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonPurchaseWithPayment' } | { __typename?: 'ReasonReasonReshuffle' } | { __typename?: 'ReasonReasonRewardClaimed' } | { __typename?: 'ReasonReasonStoreOrderPayment' } | null } }> } | null };

export type NotificationRewardFragment = { __typename?: 'RewardReward', id: string, rewardedAt: string, reason: { __typename?: 'ReasonReason', reason?: { __typename?: 'ReasonReasonAdWatched' } | { __typename?: 'ReasonReasonAdministrative' } | { __typename?: 'ReasonReasonChallengeSuccessful' } | { __typename?: 'ReasonReasonChannelOwner' } | { __typename?: 'ReasonReasonChannelSubscription' } | { __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonGiftPurchaseWithPayment' } | { __typename?: 'ReasonReasonGoalCardComplete', goalCardSlotId: string, goalCardId: string, goalCard: { __typename?: 'GoalCardGoalCard', id: string, description: string, target: number } } | { __typename?: 'ReasonReasonGoalCardSlotReshuffle' } | { __typename?: 'ReasonReasonLevelUp', seasonId: string, season: { __typename?: 'GameSeason', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string }, progression: { __typename?: 'ProgressionSeasonProgression', level: number } } } | { __typename?: 'ReasonReasonMatchEnd' } | { __typename?: 'ReasonReasonProvision' } | { __typename?: 'ReasonReasonPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonPurchaseWithPayment' } | { __typename?: 'ReasonReasonReshuffle' } | { __typename?: 'ReasonReasonRewardClaimed' } | { __typename?: 'ReasonReasonStoreOrderPayment' } | null } };

export type NotificationProfileFragment = { __typename?: 'ProfileProfile', userId: string, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', reason: ModerationViolation, changedAt: string }> | null };

export type PageLayoutHeaderProfileFragment = { __typename?: 'ProfileProfile', onlineStatus: ProfilePresenceStatus, userTag: string, userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', reason: ModerationViolation, changedAt: string }> | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ChannelButtonOwnChannelFragment = { __typename?: 'ChannelChannel', name: string };

export type ChannelButtonProfileFragment = { __typename?: 'ProfileProfile', temporary: boolean, account?: { __typename?: 'AuthAccount', uid: string, channelCreationEligibility: { __typename?: 'ChannelChannelCreationEligibility', canCreateChannel: boolean } } | null };

export type HideOnlineStatusSettingSectionProfileFragment = { __typename?: 'ProfileProfile', settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null };

export type ProfileMenuQueryQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  isImplicitAccount: Scalars['Boolean']['input'];
}>;


export type ProfileMenuQueryQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, temporary: boolean, onlineStatus: ProfilePresenceStatus, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, account?: { __typename?: 'AuthAccount', uid: string, channelCreationEligibility: { __typename?: 'ChannelChannelCreationEligibility', canCreateChannel: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, userPrivilegedChannels?: { __typename?: 'ChannelListUserPrivilegedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannelRoles', channelId: string, roles: Array<ChannelChannelRole>, channel: { __typename?: 'ChannelChannel', id: string, name: string } }> } | null };

export type ProfileMenuProfileFragment = { __typename?: 'ProfileProfile', onlineStatus: ProfilePresenceStatus, userTag: string, userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', reason: ModerationViolation, changedAt: string }> | null };

export type ProfileMenuLinksSectionProfileFragment = { __typename?: 'ProfileProfile', userTag: string };

export type ProfileMenuProfileSectionProfileFragment = { __typename?: 'ProfileProfile', userTag: string, onlineStatus: ProfilePresenceStatus, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ProfileMenuImplicitAccountProfileSectionProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type TimeAdsRewardsQueryVariables = Exact<{
  placementId: Scalars['ID']['input'];
}>;


export type TimeAdsRewardsQuery = { __typename?: 'Query', placement?: { __typename?: 'AdsGetPlacementResponse', placementId: string, rewards: Array<{ __typename?: 'AdsRewardDescription', readyAt: string }> } | null };

export type DailyGoalTooltipContentGoalCardSlotFragment = { __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null, reward?: { __typename: 'RewardReward', id: string } | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string, description: string, target: number } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', value: number, completed: boolean } | null };

export type UseDailyGoalsTooltipDataQueryVariables = Exact<{ [key: string]: never; }>;


export type UseDailyGoalsTooltipDataQuery = { __typename?: 'Query', goalCardSlots?: { __typename?: 'GoalCardListGoalCardSlotsResponse', slots: Array<{ __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null, reward?: { __typename: 'RewardReward', id: string } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', completed: boolean, value: number } | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string, description: string, target: number } | null }> } | null };

export type UseDailyGoalsTooltipDataSlotFragment = { __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null, reward?: { __typename: 'RewardReward', id: string } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', completed: boolean, value: number } | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string, description: string, target: number } | null };

export type StoreTooltipStoreFrontQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type StoreTooltipStoreFrontQuery = { __typename?: 'Query', platformStoreFront?: { __typename?: 'StoreV2StoreFront', id: string, gameId: string, categories?: Array<{ __typename?: 'StoreV2StoreFrontCategory', id: string, itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, name: string, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number }> | null }> }> | null } | null };

export type StoreTooltipSellableItemPriceFragment = { __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number };

export type UseShouldVisitDailyGoalsGoalCardSlotsQueryVariables = Exact<{ [key: string]: never; }>;


export type UseShouldVisitDailyGoalsGoalCardSlotsQuery = { __typename?: 'Query', goalCardSlots?: { __typename?: 'GoalCardListGoalCardSlotsResponse', slots: Array<{ __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', completed: boolean } | null, reward?: { __typename?: 'RewardReward', id: string } | null }> } | null };

export type SidebarChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, viewerCount: number, logo: string, game: { __typename?: 'GameGame', id: string, name: string } };

export type SidebarFollowedChannelsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
}>;


export type SidebarFollowedChannelsQuery = { __typename?: 'Query', followedChannels?: { __typename?: 'ChannelGetUserFollowedChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, viewerCount: number, logo: string, game: { __typename?: 'GameGame', id: string, name: string } }> } | null };

export type SidebarRecommendedChannelsQueryVariables = Exact<{ [key: string]: never; }>;


export type SidebarRecommendedChannelsQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, viewerCount: number, logo: string, game: { __typename?: 'GameGame', id: string, name: string } }> } | null };

export type AccountStateQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type AccountStateQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', uid: string, state: ApiEntityState, flags: Array<AuthAccountStatusFlag> } | null } | null };

export type CancelUserDeletionMutationVariables = Exact<{ [key: string]: never; }>;


export type CancelUserDeletionMutation = { __typename?: 'Mutation', cancelDataDeletion?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type AvatarSetupProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type AvatarSetupProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type AvatarSelectorGridAvatarFragment = { __typename?: 'AvatarAvatar', id: string, body: string };

export type UseAvatarSelectorAvatarFragment = { __typename?: 'AvatarAvatar', id: string, gender: string, avatar3D: string, body: string };

export type UseAvatarSelectorAvatarsQueryVariables = Exact<{ [key: string]: never; }>;


export type UseAvatarSelectorAvatarsQuery = { __typename?: 'Query', avatars?: { __typename?: 'AvatarListAvatarsResponse', avatars: Array<{ __typename?: 'AvatarAvatar', id: string, gender: string, avatar3D: string, body: string }> } | null };

export type SetBirthdayProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type SetBirthdayProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', uid: string, birthday?: { __typename?: 'AuthDate', day: number, month: number, year: number } | null } | null } | null };

export type SetBirthdayMutationVariables = Exact<{
  day: Scalars['Int']['input'];
  month: Scalars['Int']['input'];
  year: Scalars['Int']['input'];
}>;


export type SetBirthdayMutation = { __typename?: 'Mutation', setBirthday?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type AvatarEditorProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type AvatarEditorProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, avatarConfig?: { __typename?: 'ProfileProfileAvatarConfig', modelId: string } | null } | null };

export type BrowseCategoriesQueryVariables = Exact<{
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type BrowseCategoriesQuery = { __typename?: 'Query', channelGameStats?: { __typename?: 'ChannelListGameStatsResponse', pageInfo: { __typename?: 'APIPageInfo', hasNextPage: boolean, endCursor: string }, games: Array<{ __typename?: 'ChannelGameStats', gameId: string, liveStreams: number, game: { __typename?: 'GameGame', id: string, name: string, coverImageUrl: string } }> } | null };

export type BrowseCategoryQueryVariables = Exact<{
  categoryId: Scalars['ID']['input'];
}>;


export type BrowseCategoryQuery = { __typename?: 'Query', game?: { __typename?: 'GameGame', id: string, name: string } | null };

export type BrowseCategoryChannelsQueryVariables = Exact<{
  categoryId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  skipUserFields?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type BrowseCategoryChannelsQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, title: string, following: boolean, matureRatedContent: boolean, viewerCount: number, thumbnail: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason?: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }, channelFriends?: { __typename?: 'FriendsChannelFriends', totalCount: number, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null }> } | null };

export type BrowseCategoryOfflineChannelsQueryVariables = Exact<{
  categoryId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type BrowseCategoryOfflineChannelsQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, offlineBanner: string, following: boolean, followerCount: number, liveStatus: ChannelLiveStatus, logo: string }> } | null };

export type BrowseChannelsHighlightedChannelsQueryVariables = Exact<{
  skipUserFields?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type BrowseChannelsHighlightedChannelsQuery = { __typename?: 'Query', highlightedChannels?: { __typename?: 'ChannelListHighlightedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, title: string, following: boolean, matureRatedContent: boolean, viewerCount: number, thumbnail: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason?: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }, channelFriends?: { __typename?: 'FriendsChannelFriends', totalCount: number, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null }> } | null };

export type BrowseChannelsLiveChannelsQueryVariables = Exact<{
  cursor?: InputMaybe<Scalars['String']['input']>;
  skipUserFields?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type BrowseChannelsLiveChannelsQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, title: string, following: boolean, matureRatedContent: boolean, viewerCount: number, thumbnail: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason?: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }, channelFriends?: { __typename?: 'FriendsChannelFriends', totalCount: number, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null }> } | null };

export type BrowseChannelsGameSelectorQueryVariables = Exact<{ [key: string]: never; }>;


export type BrowseChannelsGameSelectorQuery = { __typename?: 'Query', listGames?: { __typename?: 'GameListGamesResponse', games: Array<{ __typename?: 'GameGame', id: string, name: string }> } | null };

export type BrowseChannelsGameFragment = { __typename?: 'GameGame', id: string, name: string };

export type BrowseHighlightedChannelsQueryVariables = Exact<{
  gameId?: InputMaybe<Scalars['ID']['input']>;
  skipUserFields?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type BrowseHighlightedChannelsQuery = { __typename?: 'Query', highlightedChannels?: { __typename?: 'ChannelListHighlightedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, title: string, following: boolean, matureRatedContent: boolean, viewerCount: number, thumbnail: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason?: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }, channelFriends?: { __typename?: 'FriendsChannelFriends', totalCount: number, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null }> } | null };

export type BrowseLiveChannelsQueryVariables = Exact<{
  cursor?: InputMaybe<Scalars['String']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  skipUserFields?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type BrowseLiveChannelsQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, title: string, following: boolean, matureRatedContent: boolean, viewerCount: number, thumbnail: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason?: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }, channelFriends?: { __typename?: 'FriendsChannelFriends', totalCount: number, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null }> } | null };

export type BrowseOfflineChannelsQueryVariables = Exact<{
  cursor?: InputMaybe<Scalars['String']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type BrowseOfflineChannelsQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, offlineBanner: string, following: boolean, followerCount: number, liveStatus: ChannelLiveStatus, logo: string }> } | null };

export type ChannelPageEntryChannelQueryVariables = Exact<{
  channelName: Scalars['String']['input'];
  skipAuthFields: Scalars['Boolean']['input'];
}>;


export type ChannelPageEntryChannelQuery = { __typename?: 'Query', channelByName?: { __typename?: 'ChannelChannel', id: string, name: string, currentStreamId: string, liveStatus: ChannelLiveStatus, matureRatedContent: boolean, userBanStatus?: { __typename?: 'ChannelUserBanStatus', banned: boolean } } | null };

export type ChannelPageChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  skipAuthFields: Scalars['Boolean']['input'];
}>;


export type ChannelPageChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, currentStreamId: string, name: string, liveStatus: ChannelLiveStatus, followerCount: number, streamerId: string, description: string, logo: string, following: boolean, offlineBanner: string, monetizationSettings?: { __typename?: 'ChannelMonetizationSettings', enabled: boolean }, links: Array<{ __typename?: 'ChannelChannelLink', type: ChannelChannelLinkLinkType, name: string, url: string }>, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null, streamedGames?: Array<{ __typename?: 'GameGame', id: string, noicePredictionsEnabled: boolean, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } }> | null } | null };

export type ChannelPageContentChannelFragment = { __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus, name: string, followerCount: number, streamerId: string, currentStreamId: string, description: string, logo: string, following: boolean, offlineBanner: string, monetizationSettings?: { __typename?: 'ChannelMonetizationSettings', enabled: boolean }, links: Array<{ __typename?: 'ChannelChannelLink', type: ChannelChannelLinkLinkType, name: string, url: string }>, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null, streamedGames?: Array<{ __typename?: 'GameGame', id: string, noicePredictionsEnabled: boolean, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } }> | null };

export type ChannelPageContentRolesQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type ChannelPageContentRolesQuery = { __typename?: 'Query', userChannelRoles?: { __typename?: 'ChannelListUserChannelRolesResponse', roles: Array<ChannelChannelRole> } | null };

export type ChannelPageChannelHeaderQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  isLive: Scalars['Boolean']['input'];
}>;


export type ChannelPageChannelHeaderQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, offlineBanner: string, name: string, streamerId: string, currentStreamId: string, thumbnail: string, matureRatedContent: boolean, following: boolean, title: string, viewerCount: number, liveStatus: ChannelLiveStatus, logo: string, channelFriends: { __typename?: 'FriendsChannelFriends', totalCount: number }, game: { __typename?: 'GameGame', id: string, name: string } } | null };

export type ChannelPageHeaderOfflineChannelFragment = { __typename?: 'ChannelChannel', id: string, offlineBanner: string, name: string, streamerId: string, following: boolean };

export type ChannelPageHeaderLiveChannelFragment = { __typename?: 'ChannelChannel', id: string, currentStreamId: string, thumbnail: string, matureRatedContent: boolean, title: string, viewerCount: number, name: string, liveStatus: ChannelLiveStatus, logo: string, channelFriends: { __typename?: 'FriendsChannelFriends', totalCount: number }, game: { __typename?: 'GameGame', id: string, name: string } };

export type ChannelPageHeaderChannelFragment = { __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus };

export type ChannelActiveFriendsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type ChannelActiveFriendsQuery = { __typename?: 'Query', friends?: { __typename?: 'FriendsListFriendsResponse', pageInfo: { __typename?: 'APIPageInfo', startCursor: string, endCursor: string, hasNextPage: boolean, hasPreviousPage: boolean }, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> } | null };

export type ChannelFriendsListChannelFragment = { __typename?: 'ChannelChannel', id: string, channelFriends: { __typename?: 'FriendsChannelFriends', totalCount: number } };

export type LiveChannelButtonWrapperChannelFragment = { __typename?: 'ChannelChannel', name: string, id: string, matureRatedContent: boolean };

export type JoinGameClickChannelFragment = { __typename?: 'ChannelChannel', id: string, matureRatedContent: boolean };

export type LiveChannelHeaderChannelFragment = { __typename?: 'ChannelChannel', currentStreamId: string, thumbnail: string, matureRatedContent: boolean, id: string, title: string, viewerCount: number, name: string, liveStatus: ChannelLiveStatus, logo: string, channelFriends: { __typename?: 'FriendsChannelFriends', totalCount: number }, game: { __typename?: 'GameGame', id: string, name: string } };

export type LiveChannelHeaderProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type LiveChannelHeaderProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', uid: string, matureRatedContentAllowed: boolean } | null } | null };

export type LiveChannelHeaderStreamInfoChannelFragment = { __typename?: 'ChannelChannel', title: string, viewerCount: number, liveStatus: ChannelLiveStatus, logo: string, name: string, matureRatedContent: boolean, game: { __typename?: 'GameGame', id: string, name: string } };

export type ChannelPageInfoSectionChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, followerCount: number, liveStatus: ChannelLiveStatus, streamerId: string, currentStreamId: string, description: string, logo: string, following: boolean, links: Array<{ __typename?: 'ChannelChannelLink', type: ChannelChannelLinkLinkType, name: string, url: string }>, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null, subscription?: { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState } | null, monetizationSettings?: { __typename?: 'ChannelMonetizationSettings', enabled: boolean } };

export type ChannelPageLinksChannelFragment = { __typename?: 'ChannelChannel', links: Array<{ __typename?: 'ChannelChannelLink', type: ChannelChannelLinkLinkType, name: string, url: string }> };

export type ChannelPageStoreSectionChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, logo: string, offlineBanner: string, monetizationSettings?: { __typename?: 'ChannelMonetizationSettings', enabled: boolean }, streamedGames?: Array<{ __typename?: 'GameGame', id: string, noicePredictionsEnabled: boolean, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } }> | null };

export type ChannelStoreStoreFrontQueryVariables = Exact<{
  gameID?: InputMaybe<Scalars['ID']['input']>;
  channelId: Scalars['ID']['input'];
}>;


export type ChannelStoreStoreFrontQuery = { __typename?: 'Query', channelStoreFront?: { __typename?: 'StoreV2StoreFront', id: string, gameId: string, categories?: Array<{ __typename?: 'StoreV2StoreFrontCategory', id: string, itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, sku: string, discountPercent: number, availableUntil?: string | null, name: string, promotionName: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', id: string, amount: number } | { __typename: 'StoreV2ItemRef', id: string, count: number, item: { __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart', previewImgUrl: string } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, channelId: string, gameId: string, familyId: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus }, baseCard: { __typename?: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } | null, season?: { __typename?: 'GameSeason', id: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', url: string, rarity: RarityRarity }> } | null, game?: { __typename?: 'GameGame', id: string, name: string } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemCount: number } | null } | { __typename: 'StoreV2SubscriptionRef', id: string } | null }>, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null }> }> | null } | null };

export type ChannelStoreProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ChannelStoreProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }> } | null };

export type ChannelStoreRedirectChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelStoreRedirectChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, streamedGames?: Array<{ __typename?: 'GameGame', id: string, noicePredictionsEnabled: boolean }> | null } | null };

export type ChannelStoreRedirectChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, monetizationSettings?: { __typename?: 'ChannelMonetizationSettings', enabled: boolean } };

export type OfflineChannelIndicatorChannelNotificationSettingsQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type OfflineChannelIndicatorChannelNotificationSettingsQuery = { __typename?: 'Query', channelFollowerNotificationSettings?: { __typename?: 'ChannelFollowerNotificationSettings', userId: string, channelId: string, channelLiveNotificationEnabled: boolean } | null };

export type OfflineChannelIndicatorChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, following: boolean };

export type OfflineChannelIndicatorFollowerNotificationSettingFragment = { __typename?: 'ChannelFollowerNotificationSettings', channelId: string, channelLiveNotificationEnabled: boolean };

export type OfflineChannelIndicatorButtonChannelFragment = { __typename?: 'ChannelChannel', id: string, following: boolean };

export type ChannelStreamContextChannelFragment = { __typename?: 'ChannelChannel', currentStreamId: string, name: string };

export type ChannelStreamAutoJoinChannelFragment = { __typename?: 'ChannelChannel', id: string, currentStreamId: string, liveStatus: ChannelLiveStatus, name: string, matureRatedContent: boolean };

export type ChannelStreamStateChannelFragment = { __typename?: 'ChannelChannel', id: string, currentStreamId: string, name: string };

export type ChannelSubscribeSubscriptionVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ChannelSubscribeSubscription = { __typename?: 'Subscription', channelStreamDetailSubscribe?: { __typename?: 'ChannelChannelStreamDetailEvent', channelId: string, liveStatus: ChannelLiveStatus, noicePredictionsEnabled: boolean, streamId: string, gameId: string, matureRatedContent: boolean } | null };

export type ChannelLiveStatusFragment = { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, currentStreamId: string, matureRatedContent: boolean, game: { __typename?: 'GameGame', id: string } };

export type ChannelStoreItemChannelQueryVariables = Exact<{
  channelName: Scalars['String']['input'];
}>;


export type ChannelStoreItemChannelQuery = { __typename?: 'Query', channelByName?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type ChannelBanQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelBanQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, logo: string, userBanStatus: { __typename?: 'ChannelUserBanStatus', banned: boolean, violation: ChannelViolation, description: string, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus, appealText: string } | null } } | null, channelModerationSettings?: { __typename?: 'ChannelModerationSettings', channelId: string, banAppealsEnabled: boolean } | null };

export type ChannelBanAppealFormMutationVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
}>;


export type ChannelBanAppealFormMutation = { __typename?: 'Mutation', createChannelBanAppeal?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChannelBanFormBanAppealInfoFragment = { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus, appealText: string };

export type CardGridGameCardFragment = { __typename?: 'GameLogicCard', id: string, seasonId: string, name: string, rarity: RarityRarity, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type LockedCardGameCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type UncollectedCardGameCardFragment = { __typename?: 'GameLogicCard', id: string, seasonId: string, name: string, rarity: RarityRarity, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type UnlockedCardGameCardFragment = { __typename?: 'GameLogicCard', id: string, seasonId: string, name: string, rarity: RarityRarity, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type CardModalChannelSelectorChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string };

export type CollectionCardsUnlockedCountProfileQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type CollectionCardsUnlockedCountProfileQuery = { __typename?: 'Query', seasonProgression?: { __typename?: 'ProgressionSeasonProgression', seasonId: string, level: number } | null };

export type CollectionCardsUnlockedCountCardsQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  inventoryFilters?: InputMaybe<Array<InventoryListUserInventoryRequestFilterInput> | InventoryListUserInventoryRequestFilterInput>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  minLevel: Scalars['Int']['input'];
}>;


export type CollectionCardsUnlockedCountCardsQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, itemCount: number, item: { __typename?: 'ItemItem', id: string } }> } | null, listLevelConfigs?: { __typename?: 'ProgressionListLevelConfigsResponse', levelConfigs: Array<{ __typename?: 'ProgressionLevelConfig', number: number, rewards: Array<{ __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency' } | { __typename?: 'RewardRewardTypeItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard' } | { __typename: 'GameLogicStreamerCard' } | null } } | null }> }> } | null, rewards?: { __typename?: 'RewardListRewardsResponse', rewards: Array<{ __typename?: 'RewardReward', type: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency' } | { __typename?: 'RewardRewardTypeItem', itemId: string, item: { __typename?: 'ItemItem', gameId: string, seasonId: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, seasonId: string, name: string, rarity: RarityRarity, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number }, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard' } | null } } | null } }> } | null };

export type UseBaseCardsGameCardFragment = { __typename?: 'GameLogicCard', id: string, seasonId: string, name: string, rarity: RarityRarity, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number }, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type UseBaseCardsSeasonProgressionQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UseBaseCardsSeasonProgressionQuery = { __typename?: 'Query', seasonProgression?: { __typename?: 'ProgressionSeasonProgression', seasonId: string, level: number } | null };

export type UseBaseCardsQueryVariables = Exact<{
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  minLevel: Scalars['Int']['input'];
  userId: Scalars['ID']['input'];
  inventoryFilters?: InputMaybe<Array<InventoryListUserInventoryRequestFilterInput> | InventoryListUserInventoryRequestFilterInput>;
}>;


export type UseBaseCardsQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, seasonId: string, name: string, rarity: RarityRarity, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number }, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard' } | null } }> } | null, listLevelConfigs?: { __typename?: 'ProgressionListLevelConfigsResponse', levelConfigs: Array<{ __typename?: 'ProgressionLevelConfig', number: number, rewards: Array<{ __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency' } | { __typename?: 'RewardRewardTypeItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, seasonId: string, name: string, rarity: RarityRarity, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number }, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard' } | null } } | null }> }> } | null, rewards?: { __typename?: 'RewardListRewardsResponse', rewards: Array<{ __typename?: 'RewardReward', type: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency' } | { __typename?: 'RewardRewardTypeItem', itemId: string, item: { __typename?: 'ItemItem', gameId: string, seasonId: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, seasonId: string, name: string, rarity: RarityRarity, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number }, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard' } | null } } | null } }> } | null };

export type CardProgressFragment = { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number };

export type CardProgressCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number } };

export type CollectionChannelSelectorInventoryQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  filters?: InputMaybe<Array<InventoryListUserInventoryRequestFilterInput> | InventoryListUserInventoryRequestFilterInput>;
}>;


export type CollectionChannelSelectorInventoryQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, channelId: string } }> } | null };

export type CollectionChannelSelectorChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string };

export type CollectionChannelSelectorChannelsQueryVariables = Exact<{
  channelIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type CollectionChannelSelectorChannelsQuery = { __typename?: 'Query', getChannels?: { __typename?: 'ChannelBatchGetChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string }> } | null };

export type CollectionPageDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  inventoryFilters?: InputMaybe<Array<InventoryListUserInventoryRequestFilterInput> | InventoryListUserInventoryRequestFilterInput>;
}>;


export type CollectionPageDataQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, itemCount: number, item: { __typename?: 'ItemItem', id: string } }> } | null, profile?: { __typename?: 'ProfileProfile', userId: string, playedGames: Array<{ __typename?: 'ProfilePlayedGame', userId: string, id: string, game: { __typename?: 'GameGame', id: string } }> } | null };

export type CardDetailLevelCardLevelingFragment = { __typename?: 'GameLogicCard', id: string, name: string, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number } };

export type CollectionItemModalBaseCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type CollectionItemModalStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } };

export type CreatorCardGridStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } };

export type CreatorCardModalCreatorCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number }, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus }, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, channelId: string, enabled: boolean, period?: { __typename?: 'StoreV2Period', from: string, until: string } | null } | null };

export type CreatorCardModalItemQueryVariables = Exact<{
  filters?: InputMaybe<Array<ItemListItemsRequestFilterInput> | ItemListItemsRequestFilterInput>;
  seasonId?: InputMaybe<Scalars['String']['input']>;
}>;


export type CreatorCardModalItemQuery = { __typename?: 'Query', items?: { __typename?: 'ItemListItemsResponse', items: Array<{ __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number, progressToNextLevel: number, nextLevelLimit: number }, season: { __typename?: 'GameSeason', id: string, name: string, badgeUrl: string, game: { __typename?: 'GameGame', id: string, name: string } }, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus }, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, channelId: string, enabled: boolean, period?: { __typename?: 'StoreV2Period', from: string, until: string } | null } | null } | null }> } | null };

export type CreatorCardsChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type CreatorCardsChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string } | null };

export type CollectionChannelCardGridGameQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type CollectionChannelCardGridGameQuery = { __typename?: 'Query', game?: { __typename?: 'GameGame', id: string, activeSeason: { __typename?: 'GameSeason', id: string } } | null };

export type UseCreatorCardsItemsQueryVariables = Exact<{
  filters?: InputMaybe<Array<ItemListItemsRequestFilterInput> | ItemListItemsRequestFilterInput>;
  seasonId: Scalars['String']['input'];
  userId: Scalars['ID']['input'];
}>;


export type UseCreatorCardsItemsQuery = { __typename?: 'Query', items?: { __typename?: 'ItemListItemsResponse', items: Array<{ __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard' } | { __typename: 'GameLogicStreamerCard', id: string, image: string, video: string, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, channelId: string, enabled: boolean, period?: { __typename?: 'StoreV2Period', from: string, until: string } | null } | null, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }>, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, inventoryItem: { __typename?: 'InventoryInventoryItem', itemId: string, itemCount: number, item: { __typename?: 'ItemItem', id: string } } }> } | null };

export type CollectionGameSelectorProfileQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type CollectionGameSelectorProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, playedGames: Array<{ __typename?: 'ProfilePlayedGame', userId: string, id: string, game: { __typename?: 'GameGame', id: string, name: string } }> } | null };

export type UseCollectionSeasonIdGameQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type UseCollectionSeasonIdGameQuery = { __typename?: 'Query', game?: { __typename?: 'GameGame', id: string, activeSeasonId: string } | null };

export type DailyGoalSwitchOutConfirmationCardQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DailyGoalSwitchOutConfirmationCardQuery = { __typename?: 'Query', goalCard?: { __typename?: 'GoalCardGoalCard', id: string, description: string, gameId: string, rarity: RarityRarity, target: number, requiresTeam: boolean, game?: { __typename?: 'GameGame', id: string, name: string } | null, reward: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem' } | null } } | null };

export type DailyGoalSelectModalGoalCardOptionsQueryVariables = Exact<{
  slotId: Scalars['ID']['input'];
}>;


export type DailyGoalSelectModalGoalCardOptionsQuery = { __typename?: 'Query', goalCardSlotOptions?: { __typename?: 'GoalCardGetSlotOptionsResponse', cardOptions: Array<{ __typename?: 'GoalCardGoalCard', id: string, description: string, gameId: string, rarity: RarityRarity, target: number, requiresTeam: boolean, game?: { __typename?: 'GameGame', id: string, name: string } | null, reward: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem' } | null } }> } | null };

export type DailyGoalsPageDataQueryVariables = Exact<{ [key: string]: never; }>;


export type DailyGoalsPageDataQuery = { __typename?: 'Query', goalCardSlots?: { __typename?: 'GoalCardListGoalCardSlotsResponse', slots: Array<{ __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null, cardOptions?: Array<{ __typename?: 'GoalCardGoalCard', id: string }> | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string, target: number, description: string, requiresTeam: boolean, gameId: string, rarity: RarityRarity, game?: { __typename?: 'GameGame', id: string, name: string } | null, reward: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem' } | null } } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', value: number, completed: boolean } | null, reward?: { __typename?: 'RewardReward', id: string } | null }> } | null, dailyParticipationLimit?: { __typename?: 'ProgressionGetDailyParticipationLimitResponse', remainingDailyParticipationMinutes: number } | null };

export type GoalCardCardFragment = { __typename?: 'GoalCardGoalCard', id: string, description: string, gameId: string, rarity: RarityRarity, target: number, requiresTeam: boolean, game?: { __typename?: 'GameGame', id: string, name: string } | null, reward: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem' } | null } };

export type GoalCardSlotSlotFragment = { __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string, target: number, description: string, requiresTeam: boolean, gameId: string, rarity: RarityRarity, game?: { __typename?: 'GameGame', id: string, name: string } | null, reward: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem' } | null } } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', value: number, completed: boolean } | null, reward?: { __typename?: 'RewardReward', id: string } | null };

export type GoalCardActiveSlotGoalCardSlotFragment = { __typename?: 'GoalCardGoalCardSlot', id: string, goalCard?: { __typename?: 'GoalCardGoalCard', id: string, target: number, description: string, requiresTeam: boolean, gameId: string, rarity: RarityRarity, game?: { __typename?: 'GameGame', id: string, name: string } | null, reward: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem' } | null } } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', value: number } | null, reward?: { __typename?: 'RewardReward', id: string } | null };

export type DailyGoalCardFailedSlotGoalCardFragment = { __typename?: 'GoalCardGoalCard', id: string, description: string, gameId: string, rarity: RarityRarity, target: number, requiresTeam: boolean, game?: { __typename?: 'GameGame', id: string, name: string } | null, reward: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem' } | null } };

export type GoalCardSlotsGoalSlotFragment = { __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string, target: number, description: string, requiresTeam: boolean, gameId: string, rarity: RarityRarity, game?: { __typename?: 'GameGame', id: string, name: string } | null, reward: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem' } | null } } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', value: number, completed: boolean } | null, reward?: { __typename?: 'RewardReward', id: string } | null };

export type DailyGoalClaimRewardHookMutationVariables = Exact<{
  rewardId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type DailyGoalClaimRewardHookMutation = { __typename?: 'Mutation', claimReward?: { __typename?: 'RewardClaimRewardResponse', emptyTypeWorkaround: boolean } | null };

export type RewardUpdateGoalCardSlotFragment = { __typename?: 'GoalCardGoalCardSlot', id: string, reward?: { __typename?: 'RewardReward', id: string } | null };

export type DailyGoalReshuffleHookMutationVariables = Exact<{
  slotId: Scalars['ID']['input'];
}>;


export type DailyGoalReshuffleHookMutation = { __typename?: 'Mutation', reshuffleGoalCardSlot?: { __typename?: 'GoalCardReshuffleSlotResponse', cardOptions: Array<{ __typename?: 'GoalCardGoalCard', id: string }> } | null };

export type DailyGoalSetGoalCardHookMutationVariables = Exact<{
  slotId: Scalars['ID']['input'];
  cardId: Scalars['ID']['input'];
}>;


export type DailyGoalSetGoalCardHookMutation = { __typename?: 'Mutation', setGoalCardSlot?: { __typename?: 'GoalCardSetGoalCardSlotResponse', emptyTypeWorkaround: boolean } | null };

export type SetCardFragment = { __typename?: 'GoalCardGoalCardSlot', id: string, goalCard?: { __typename?: 'GoalCardGoalCard', id: string } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', value: number } | null, cardOptions?: Array<{ __typename?: 'GoalCardGoalCard', id: string }> | null };

export type FollowingPageLiveChannelsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  skipUserFields?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type FollowingPageLiveChannelsQuery = { __typename?: 'Query', followedChannels?: { __typename?: 'ChannelGetUserFollowedChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, title: string, following: boolean, matureRatedContent: boolean, viewerCount: number, thumbnail: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason?: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }, channelFriends?: { __typename?: 'FriendsChannelFriends', totalCount: number, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null }> } | null };

export type FollowingPageOfflineChannelsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type FollowingPageOfflineChannelsQuery = { __typename?: 'Query', followedChannels?: { __typename?: 'ChannelGetUserFollowedChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, offlineBanner: string, following: boolean, followerCount: number, liveStatus: ChannelLiveStatus, logo: string }> } | null };

export type FollowingPageEmptyQueryVariables = Exact<{
  skipUserFields: Scalars['Boolean']['input'];
}>;


export type FollowingPageEmptyQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, title: string, following: boolean, matureRatedContent: boolean, viewerCount: number, thumbnail: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason?: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }, channelFriends?: { __typename?: 'FriendsChannelFriends', totalCount: number, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null }> } | null };

export type HomeProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  isImplicitAccount: Scalars['Boolean']['input'];
}>;


export type HomeProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, stats?: { __typename?: 'PlayerStatsPlayerStats', matchesPlayed: number }, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null } | null, dailyXPBoostLimit?: { __typename?: 'ProgressionGetDailyXPBoostLimitResponse', remainingDailyXpBoost: number } | null, dailyXPEarningsLimit?: { __typename?: 'ProgressionGetDailyXPEarningsLimitResponse', remainingDailyXpEarningsMinutes: number } | null };

export type HighlightedChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, thumbnail: string, title: string, currentStreamId: string, liveStatus: ChannelLiveStatus, matureRatedContent: boolean, logo: string, game: { __typename?: 'GameGame', id: string, name: string } };

export type HomeHeaderProfileFragment = { __typename?: 'ProfileProfile', userTag: string, stats?: { __typename?: 'PlayerStatsPlayerStats', matchesPlayed: number }, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null };

export type HomeHighlightedStreamQueryVariables = Exact<{ [key: string]: never; }>;


export type HomeHighlightedStreamQuery = { __typename?: 'Query', highlightedChannels?: { __typename?: 'ChannelListHighlightedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, thumbnail: string, title: string, currentStreamId: string, liveStatus: ChannelLiveStatus, matureRatedContent: boolean, logo: string, game: { __typename?: 'GameGame', id: string, name: string } }> } | null };

export type DailyGoalWidgetGoalCardSlotsQueryVariables = Exact<{ [key: string]: never; }>;


export type DailyGoalWidgetGoalCardSlotsQuery = { __typename?: 'Query', goalCardSlots?: { __typename?: 'GoalCardListGoalCardSlotsResponse', slots: Array<{ __typename?: 'GoalCardGoalCardSlot', id: string, resetTime?: string | null, goalCard?: { __typename?: 'GoalCardGoalCard', id: string } | null, progress?: { __typename?: 'GoalCardGoalCardSlotProgress', completed: boolean } | null, reward?: { __typename?: 'RewardReward', id: string } | null }> } | null };

export type UserHeaderProfileFragment = { __typename?: 'ProfileProfile', userTag: string, stats?: { __typename?: 'PlayerStatsPlayerStats', matchesPlayed: number }, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null };

export type HomeBackupOfflineChannelsQueryVariables = Exact<{ [key: string]: never; }>;


export type HomeBackupOfflineChannelsQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, offlineBanner: string, following: boolean, followerCount: number, liveStatus: ChannelLiveStatus, logo: string }> } | null };

export type HomeLiveChannelsQueryVariables = Exact<{
  cursor?: InputMaybe<Scalars['String']['input']>;
  skipUserFields: Scalars['Boolean']['input'];
}>;


export type HomeLiveChannelsQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', hasNextPage: boolean, endCursor: string }, channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, title: string, following: boolean, matureRatedContent: boolean, viewerCount: number, thumbnail: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason?: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }, channelFriends?: { __typename?: 'FriendsChannelFriends', totalCount: number, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null }> } | null };

export type HomePageCategoryListQueryVariables = Exact<{ [key: string]: never; }>;


export type HomePageCategoryListQuery = { __typename?: 'Query', channelGameStats?: { __typename?: 'ChannelListGameStatsResponse', games: Array<{ __typename?: 'ChannelGameStats', gameId: string, liveStreams: number, game: { __typename?: 'GameGame', id: string, name: string, coverImageUrl: string } }> } | null };

export type HomePageOfflineCategoryListQueryVariables = Exact<{ [key: string]: never; }>;


export type HomePageOfflineCategoryListQuery = { __typename?: 'Query', channelGameStats?: { __typename?: 'ChannelListGameStatsResponse', games: Array<{ __typename?: 'ChannelGameStats', gameId: string, liveStreams: number, game: { __typename?: 'GameGame', id: string, name: string, coverImageUrl: string } }> } | null };

export type HomePageChannelListLiveChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, title: string, following: boolean, matureRatedContent: boolean, viewerCount: number, thumbnail: string, liveStatus: ChannelLiveStatus, logo: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason?: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }, channelFriends?: { __typename?: 'FriendsChannelFriends', totalCount: number, users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> }, activeStream?: { __typename?: 'ChannelStreamSummary', streamId: string, noicePredictionsEnabled: boolean } | null };

export type HomePageChannelListOfflineChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, offlineBanner: string, following: boolean, followerCount: number, liveStatus: ChannelLiveStatus, logo: string };

export type OAuthProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type OAuthProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type AddOAuthConsentMutationVariables = Exact<{
  clientId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
  scopes?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type AddOAuthConsentMutation = { __typename?: 'Mutation', addOAuth2Consent?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type UserTagQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type UserTagQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, temporary: boolean, account?: { __typename?: 'AuthAccount', uid: string, marketingConsent: AuthConsentStatus, pendingAgreements: Array<{ __typename?: 'AgreementAgreementRevision', name: string, revision: string, url: string }> } | null } | null };

export type SignAgreementMutationVariables = Exact<{
  agreement: AuthTermsVersionInput;
}>;


export type SignAgreementMutation = { __typename?: 'Mutation', signAgreements?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type PlatformSuspensionStatusFragment = { __typename?: 'ModerationPlatformBan', bannedAt: string, description: string, expiresAt?: string | null, status: ModerationBanStatus, violation: ModerationViolation, appeal?: { __typename?: 'ModerationPlatformBanAppeal', banId: string, appealText: string, closedAt?: string | null, createdAt: string, status: ModerationAppealStatus } | null };

export type PlatformSuspensionProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type PlatformSuspensionQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type PlatformSuspensionQuery = { __typename?: 'Query', platformBan?: { __typename?: 'ModerationPlatformBan', banId: string, bannedAt: string, description: string, expiresAt?: string | null, status: ModerationBanStatus, violation: ModerationViolation, appeal?: { __typename?: 'ModerationPlatformBanAppeal', banId: string, appealText: string, closedAt?: string | null, createdAt: string, status: ModerationAppealStatus } | null } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type CreatePlatformSuspensionAppealMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  appealText: Scalars['String']['input'];
}>;


export type CreatePlatformSuspensionAppealMutation = { __typename?: 'Mutation', createPlatformBanAppeal?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type PlatformSuspensionAppealFragment = { __typename?: 'ModerationPlatformBanAppeal', appealText: string, closedAt?: string | null, createdAt: string, status: ModerationAppealStatus };

export type PrivateProfilePageQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type PrivateProfilePageQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, discordUsername?: string | null, visibility: ProfileProfileVisibility, isNewUsername: boolean, temporary: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } } | null };

export type ProfilePageQueryVariables = Exact<{
  userTag: Scalars['String']['input'];
}>;


export type ProfilePageQuery = { __typename?: 'Query', resolveUserTags?: { __typename?: 'ProfileResolveUserTagsResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, visibility: ProfileProfileVisibility, temporary: boolean }> } | null };

export type ProfilePageHeaderProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, discordUsername?: string | null, visibility: ProfileProfileVisibility, isNewUsername: boolean, temporary: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } };

export type ProfilePageLayoutProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null };

export type ProfileCardsCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type ProfileFriendsProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ProfileGamesPublicListQueryVariables = Exact<{ [key: string]: never; }>;


export type ProfileGamesPublicListQuery = { __typename?: 'Query', listGames?: { __typename?: 'GameListGamesResponse', games: Array<{ __typename?: 'GameGame', id: string }> } | null };

export type ProfileGamesListItemFragment = { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', name: string, id: string, progression: { __typename?: 'ProgressionSeasonProgression', seasonId: string, xpAmount: number, level: number, nextLevelThreshold: number, nextLevel: number } } };

export type ProfileStatsFragment = { __typename?: 'ProfileProfile', stats: { __typename?: 'PlayerStatsPlayerStats', matchesPlayed: number, timePlayed?: string | null, cardsSucceeded: number, dailyGoalCardsCompleted: number } };

export type PublicProfilePageQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type PublicProfilePageQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, discordUsername?: string | null, visibility: ProfileProfileVisibility, isNewUsername: boolean, temporary: boolean, playedGames: Array<{ __typename?: 'ProfilePlayedGame', userId: string, id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', name: string, id: string, progression: { __typename?: 'ProgressionSeasonProgression', seasonId: string, xpAmount: number, level: number, nextLevelThreshold: number, nextLevel: number } } } }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null, stats: { __typename?: 'PlayerStatsPlayerStats', matchesPlayed: number, timePlayed?: string | null, cardsSucceeded: number, dailyGoalCardsCompleted: number }, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } } | null, listGameCards?: { __typename?: 'GameCardListGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null, friends?: { __typename?: 'FriendsListFriendsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> } | null };

export type SearchPageCategorySearchQueryVariables = Exact<{
  query?: InputMaybe<Scalars['String']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type SearchPageCategorySearchQuery = { __typename?: 'Query', publicSearch?: { __typename?: 'SearchSearchResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, resultItems: Array<{ __typename?: 'SearchResultItem', entityId: string, entity?: { __typename?: 'ChannelChannel' } | { __typename?: 'ChannelGameStats', gameId: string, liveStreams: number, game: { __typename?: 'GameGame', id: string, name: string, coverImageUrl: string } } | { __typename?: 'ProfileProfile' } | null }> } | null };

export type CategorySearchResultFragment = { __typename?: 'SearchResultItem', entityId: string, entity?: { __typename?: 'ChannelChannel' } | { __typename?: 'ChannelGameStats', gameId: string, liveStreams: number, game: { __typename?: 'GameGame', id: string, name: string, coverImageUrl: string } } | { __typename?: 'ProfileProfile' } | null };

export type SearchPageChannelSearchQueryVariables = Exact<{
  query?: InputMaybe<Scalars['String']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type SearchPageChannelSearchQuery = { __typename?: 'Query', publicSearch?: { __typename?: 'SearchSearchResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, resultItems: Array<{ __typename?: 'SearchResultItem', entityId: string, entity?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string, following: boolean, game: { __typename?: 'GameGame', id: string, name: string } } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile' } | null }> } | null };

export type ChannelSearchResultFragment = { __typename?: 'SearchResultItem', entityId: string, entity?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string, following: boolean, game: { __typename?: 'GameGame', id: string, name: string } } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile' } | null };

export type NextUnlockLevelConfigFragment = { __typename?: 'ProgressionLevelConfig', number: number, rewards: Array<{ __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency' } | { __typename?: 'RewardRewardTypeItem', item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard' } | null } } | null }> };

export type RewardTrackLevelConfigFragment = { __typename?: 'ProgressionLevelConfig', number: number, threshold: number, seasonId: string, rewards: Array<{ __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem', itemId: string, item: { __typename?: 'ItemItem', type: ItemItemType, name: string, id: string, seasonId: string, unlockItemId: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard' } | null } } | null }> };

export type RewardTrackSeasonProgressionFragment = { __typename?: 'ProgressionSeasonProgression', seasonId: string, xpAmount: number, level: number, nextLevelThreshold: number };

export type RewardTrackRewardsFragment = { __typename?: 'RewardReward', id: string, reason: { __typename?: 'ReasonReason', reason?: { __typename: 'ReasonReasonAdWatched' } | { __typename: 'ReasonReasonAdministrative' } | { __typename: 'ReasonReasonChallengeSuccessful' } | { __typename: 'ReasonReasonChannelOwner' } | { __typename: 'ReasonReasonChannelSubscription' } | { __typename: 'ReasonReasonGiftPurchaseWithInGameCurrency' } | { __typename: 'ReasonReasonGiftPurchaseWithPayment' } | { __typename: 'ReasonReasonGoalCardComplete' } | { __typename: 'ReasonReasonGoalCardSlotReshuffle' } | { __typename: 'ReasonReasonLevelUp', level: number, seasonId: string } | { __typename: 'ReasonReasonMatchEnd' } | { __typename: 'ReasonReasonProvision' } | { __typename: 'ReasonReasonPurchaseWithInGameCurrency' } | { __typename: 'ReasonReasonPurchaseWithPayment' } | { __typename: 'ReasonReasonReshuffle' } | { __typename: 'ReasonReasonRewardClaimed' } | { __typename: 'ReasonReasonStoreOrderPayment' } | null } };

export type RewardTrackItemLevelConfigFragment = { __typename?: 'ProgressionLevelConfig', number: number, threshold: number, seasonId: string, rewards: Array<{ __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem', itemId: string, item: { __typename?: 'ItemItem', type: ItemItemType, name: string, id: string, seasonId: string, unlockItemId: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard' } | null } } | null }> };

export type RewardTrackItemProgressionFragment = { __typename?: 'ProgressionSeasonProgression', xpAmount: number, level: number, nextLevelThreshold: number };

export type RewardTrackItemRewardsFragment = { __typename?: 'RewardReward', id: string, reason: { __typename?: 'ReasonReason', reason?: { __typename: 'ReasonReasonAdWatched' } | { __typename: 'ReasonReasonAdministrative' } | { __typename: 'ReasonReasonChallengeSuccessful' } | { __typename: 'ReasonReasonChannelOwner' } | { __typename: 'ReasonReasonChannelSubscription' } | { __typename: 'ReasonReasonGiftPurchaseWithInGameCurrency' } | { __typename: 'ReasonReasonGiftPurchaseWithPayment' } | { __typename: 'ReasonReasonGoalCardComplete' } | { __typename: 'ReasonReasonGoalCardSlotReshuffle' } | { __typename: 'ReasonReasonLevelUp', level: number, seasonId: string } | { __typename: 'ReasonReasonMatchEnd' } | { __typename: 'ReasonReasonProvision' } | { __typename: 'ReasonReasonPurchaseWithInGameCurrency' } | { __typename: 'ReasonReasonPurchaseWithPayment' } | { __typename: 'ReasonReasonReshuffle' } | { __typename: 'ReasonReasonRewardClaimed' } | { __typename: 'ReasonReasonStoreOrderPayment' } | null } };

export type SeasonClaimRewardMutationVariables = Exact<{
  rewardId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type SeasonClaimRewardMutation = { __typename?: 'Mutation', claimReward?: { __typename?: 'RewardClaimRewardResponse', emptyTypeWorkaround: boolean } | null };

export type SeasonsHeaderGameQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type SeasonsHeaderGameQuery = { __typename?: 'Query', game?: { __typename?: 'GameGame', id: string, name: string, activeSeasonId: string } | null };

export type SeasonsHeaderProgressionFragment = { __typename?: 'ProgressionSeasonProgression', level: number };

export type UseAllSeasonDataQueryVariables = Exact<{
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UseAllSeasonDataQuery = { __typename?: 'Query', seasonProgression?: { __typename?: 'ProgressionSeasonProgression', seasonId: string, level: number, xpAmount: number, nextLevelThreshold: number } | null, rewards?: { __typename?: 'RewardListRewardsResponse', rewards: Array<{ __typename?: 'RewardReward', id: string, reason: { __typename?: 'ReasonReason', reason?: { __typename: 'ReasonReasonAdWatched' } | { __typename: 'ReasonReasonAdministrative' } | { __typename: 'ReasonReasonChallengeSuccessful' } | { __typename: 'ReasonReasonChannelOwner' } | { __typename: 'ReasonReasonChannelSubscription' } | { __typename: 'ReasonReasonGiftPurchaseWithInGameCurrency' } | { __typename: 'ReasonReasonGiftPurchaseWithPayment' } | { __typename: 'ReasonReasonGoalCardComplete' } | { __typename: 'ReasonReasonGoalCardSlotReshuffle' } | { __typename: 'ReasonReasonLevelUp', level: number, seasonId: string } | { __typename: 'ReasonReasonMatchEnd' } | { __typename: 'ReasonReasonProvision' } | { __typename: 'ReasonReasonPurchaseWithInGameCurrency' } | { __typename: 'ReasonReasonPurchaseWithPayment' } | { __typename: 'ReasonReasonReshuffle' } | { __typename: 'ReasonReasonRewardClaimed' } | { __typename: 'ReasonReasonStoreOrderPayment' } | null } }> } | null, listLevelConfigs?: { __typename?: 'ProgressionListLevelConfigsResponse', levelConfigs: Array<{ __typename?: 'ProgressionLevelConfig', number: number, threshold: number, seasonId: string, rewards: Array<{ __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, name: string, seasonId: string, unlockItemId: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename?: 'GameLogicStreamerCard' } | null } } | null }> }> } | null };

export type SeasonsDataDailyXpBoostQueryVariables = Exact<{ [key: string]: never; }>;


export type SeasonsDataDailyXpBoostQuery = { __typename?: 'Query', dailyXPBoostLimit?: { __typename?: 'ProgressionGetDailyXPBoostLimitResponse', remainingDailyXpBoost: number } | null };

export type UseSeasonsDataFilterIdsGamesQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UseSeasonsDataFilterIdsGamesQuery = { __typename?: 'Query', playedGames?: { __typename?: 'ProfileListPlayedGamesResponse', games: Array<{ __typename?: 'ProfilePlayedGame', userId: string, id: string, game: { __typename?: 'GameGame', id: string } }> } | null };

export type ProfileAccountSettingsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ProfileAccountSettingsQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', email: string } | null } | null };

export type DeleteOwnAccountMutationVariables = Exact<{ [key: string]: never; }>;


export type DeleteOwnAccountMutation = { __typename?: 'Mutation', deleteUserData?: { __typename?: 'PrivacyDeleteUserDataResponse', taskId: string } | null };

export type SettingsConnectionsDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type SettingsConnectionsDataQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, discordUsername?: string | null, account?: { __typename?: 'AuthAccount', externalIds: Array<{ __typename?: 'AuthIdentity', type: AuthIdentityType }> } | null } | null, oauth2Consent?: { __typename?: 'AuthV4GetOAuth2ConsentResponse', clientId: string, scopes: Array<string> } | null };

export type SettingsConnectionDeleteOAuth2ConsentMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  clientId: Scalars['ID']['input'];
}>;


export type SettingsConnectionDeleteOAuth2ConsentMutation = { __typename?: 'Mutation', deleteOAuth2Consent?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SettingsConnectionDeleteExternalAccountMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  type: AuthIdentityType;
}>;


export type SettingsConnectionDeleteExternalAccountMutation = { __typename?: 'Mutation', deleteExternalAccount?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SettingsConnectionsDataFragment = { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', externalIds: Array<{ __typename?: 'AuthIdentity', type: AuthIdentityType }> } | null };

export type ChannelNotificationChannelNotificationSettingsFragment = { __typename?: 'ChannelNotificationSettings', channelLiveNotification: { __typename?: 'ChannelNotificationStatus', emailEnabled: boolean } };

export type UpdateChannelNotificationSettingsMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  emailEnabled: Scalars['Boolean']['input'];
}>;


export type UpdateChannelNotificationSettingsMutation = { __typename?: 'Mutation', updateChannelNotificationSettings?: { __typename?: 'ChannelNotificationSettings', userId: string, channelLiveNotification: { __typename?: 'ChannelNotificationStatus', emailEnabled: boolean } } | null };

export type MarketingNotificationProfileFragment = { __typename?: 'ProfileProfile', account?: { __typename?: 'AuthAccount', uid: string, marketingConsent: AuthConsentStatus } | null };

export type NotificationsSettingsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type NotificationsSettingsQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', uid: string, marketingConsent: AuthConsentStatus } | null } | null, channelNotificationSettings?: { __typename?: 'ChannelNotificationSettings', userId: string, channelLiveNotification: { __typename?: 'ChannelNotificationStatus', emailEnabled: boolean } } | null };

export type OnlineStatusSettingProfileFragment = { __typename?: 'ProfileProfile', settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null };

export type BlockedUsersFriendUserFragment = { __typename?: 'FriendsUser', lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } };

export type ContentWarningSettingProfileFragment = { __typename?: 'ProfileProfile', settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', showMatureContentWarning: boolean } } | null, account?: { __typename?: 'AuthAccount', uid: string, matureRatedContentAllowed: boolean } | null };

export type DiscordUsernameSettingsProfileFragment = { __typename?: 'ProfileProfile', account?: { __typename?: 'AuthAccount', externalIds: Array<{ __typename?: 'AuthIdentity', type: AuthIdentityType, id: string }> } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', discordUsernameVisibility: ProfilePrivacySettingsVisibility } } | null };

export type ProfilePrivacyChangeDiscordIdVisibilityMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  discordUsernameVisibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
}>;


export type ProfilePrivacyChangeDiscordIdVisibilityMutation = { __typename?: 'Mutation', updatePrivacySettings?: { __typename?: 'ProfilePrivacySettings', discordUsernameVisibility: ProfilePrivacySettingsVisibility } | null };

export type DiscordIdVisibilityUpdateProfileFragment = { __typename?: 'ProfileProfile', userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', discordUsernameVisibility: ProfilePrivacySettingsVisibility } } | null };

export type FriendRequestSettingProfileFragment = { __typename?: 'ProfileProfile', settings?: { __typename?: 'ProfileProfileSettings', friends: { __typename?: 'FriendsFriendsSettings', disableFriendRequests: boolean } } | null };

export type ProfilePrivacyFriendSettingsMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  disableFriendRequests?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type ProfilePrivacyFriendSettingsMutation = { __typename?: 'Mutation', updateFriendsSettings?: { __typename?: 'FriendsFriendsSettings', disableFriendRequests: boolean } | null };

export type DisabledFriendRequestUpdateProfileFragment = { __typename?: 'ProfileProfile', userId: string, settings?: { __typename?: 'ProfileProfileSettings', friends: { __typename?: 'FriendsFriendsSettings', disableFriendRequests: boolean } } | null };

export type PrivacyConnectionsDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type PrivacyConnectionsDataQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', showMatureContentWarning: boolean, anonymisePurchaseHighlights: boolean, discordUsernameVisibility: ProfilePrivacySettingsVisibility, visibility: ProfilePrivacySettingsVisibility, hideOnlineStatus: boolean }, friends: { __typename?: 'FriendsFriendsSettings', disableFriendRequests: boolean } } | null, account?: { __typename?: 'AuthAccount', uid: string, matureRatedContentAllowed: boolean, externalIds: Array<{ __typename?: 'AuthIdentity', type: AuthIdentityType, id: string }> } | null } | null, blockedUsers?: { __typename?: 'FriendsListBlockedUsersResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> } | null };

export type ProfilePageSettingsProfileFragment = { __typename?: 'ProfileProfile', settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', visibility: ProfilePrivacySettingsVisibility } } | null };

export type ProfilePrivacyChangeVisibilityMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  visibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
}>;


export type ProfilePrivacyChangeVisibilityMutation = { __typename?: 'Mutation', updatePrivacySettings?: { __typename?: 'ProfilePrivacySettings', visibility: ProfilePrivacySettingsVisibility } | null };

export type VisibilityUpdateProfileFragment = { __typename?: 'ProfileProfile', userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', visibility: ProfilePrivacySettingsVisibility } } | null };

export type PurchaseVisibilitySettingProfileFragment = { __typename?: 'ProfileProfile', settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', anonymisePurchaseHighlights: boolean } } | null };

export type ProfilePrivacyHidePurchaseVisibilityMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  anonymisePurchaseHighlights?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type ProfilePrivacyHidePurchaseVisibilityMutation = { __typename?: 'Mutation', updatePrivacySettings?: { __typename?: 'ProfilePrivacySettings', anonymisePurchaseHighlights: boolean } | null };

export type OnlinePurchasePrivacyUpdateProfileFragment = { __typename?: 'ProfileProfile', userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', anonymisePurchaseHighlights: boolean } } | null };

export type RequestOwnUserDataMutationVariables = Exact<{ [key: string]: never; }>;


export type RequestOwnUserDataMutation = { __typename?: 'Mutation', exportUserData?: { __typename?: 'PrivacyExportUserDataResponse', taskId: string } | null };

export type ProfileInfoSettingsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ProfileInfoSettingsQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, canChangeUsernameAt?: string | null, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', reason: ModerationViolation }> | null } | null };

export type ProfileSettingUpdateUsernameMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  userTag: Scalars['String']['input'];
}>;


export type ProfileSettingUpdateUsernameMutation = { __typename?: 'Mutation', updateProfile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, canChangeUsernameAt?: string | null, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', reason: ModerationViolation }> | null } | null };

export type SubscriptionButtonSubscriptionFragment = { __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState, channel: { __typename?: 'ChannelChannel', id: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean }, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null } };

export type SubscriptionItemBadgeQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type SubscriptionItemBadgeQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, badges: Array<{ __typename?: 'BadgeBadge', level: number, type: BadgeBadgeType }> } | null };

export type SubscriptionSettingItemSubscriptionFragment = { __typename?: 'SubscriptionChannelSubscription', activatedAt?: string | null, expiresAt?: string | null, cancelledAt?: string | null, state: SubscriptionChannelSubscriptionState, paymentFailedAt?: string | null, provider: SubscriptionChannelSubscriptionProvider, id: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, offlineBanner: string, liveStatus: ChannelLiveStatus, logo: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean }, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null } };

export type SubscriptionsSettingListQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type SubscriptionsSettingListQuery = { __typename?: 'Query', userChannelSubscriptions?: { __typename?: 'SubscriptionListUserChannelSubscriptionsResponse', subscriptions: Array<{ __typename?: 'SubscriptionChannelSubscription', id: string, activatedAt?: string | null, expiresAt?: string | null, cancelledAt?: string | null, state: SubscriptionChannelSubscriptionState, paymentFailedAt?: string | null, provider: SubscriptionChannelSubscriptionProvider, channel: { __typename?: 'ChannelChannel', id: string, name: string, offlineBanner: string, liveStatus: ChannelLiveStatus, logo: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean }, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null } }>, pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean } } | null };

export type SubscriptionsSettingInactiveListQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type SubscriptionsSettingInactiveListQuery = { __typename?: 'Query', userChannelSubscriptions?: { __typename?: 'SubscriptionListUserChannelSubscriptionsResponse', subscriptions: Array<{ __typename?: 'SubscriptionChannelSubscription', id: string, activatedAt?: string | null, expiresAt?: string | null, cancelledAt?: string | null, state: SubscriptionChannelSubscriptionState, paymentFailedAt?: string | null, provider: SubscriptionChannelSubscriptionProvider, channel: { __typename?: 'ChannelChannel', id: string, name: string, offlineBanner: string, liveStatus: ChannelLiveStatus, logo: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean }, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null } }>, pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean } } | null };

export type PaymentReceiptQueryVariables = Exact<{
  paymentId: Scalars['ID']['input'];
}>;


export type PaymentReceiptQuery = { __typename?: 'Query', payment?: { __typename?: 'PaymentPayment', id: string, timestamp: string, status: PaymentPaymentStatus, items: Array<{ __typename?: 'PaymentLineItem', description: string }>, info: { __typename?: 'PaymentPaymentInfo', cardHolderName: string, cardSummary: string }, amount: { __typename?: 'PaymentAmount', currency: PaymentCurrency, value: number }, tax: { __typename?: 'PaymentTax', rate: number, rateInBasisPoints: number, amount?: { __typename?: 'PaymentAmount', currency: PaymentCurrency, value: number } | null } } | null };

export type WalletPaymentsPaymentFragment = { __typename?: 'PaymentPayment', id: string, timestamp: string, status: PaymentPaymentStatus, items: Array<{ __typename?: 'PaymentLineItem', description: string }> };

export type SettingsWalletPaymentsQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type SettingsWalletPaymentsQuery = { __typename?: 'Query', payments?: { __typename?: 'PaymentListPaymentsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string }, payments: Array<{ __typename?: 'PaymentPayment', id: string, timestamp: string, status: PaymentPaymentStatus, items: Array<{ __typename?: 'PaymentLineItem', description: string }> }> } | null };

export type ProfilePagePathQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ProfilePagePathQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type SignupStagesCompletedProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type SignupStagesCompletedProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, account?: { __typename?: 'AuthAccount', uid: string, birthday?: { __typename?: 'AuthDate', day: number, month: number, year: number } | null } | null } | null };

export type StorePageStoreFrontQueryVariables = Exact<{
  gameID: Scalars['ID']['input'];
}>;


export type StorePageStoreFrontQuery = { __typename?: 'Query', platformStoreFront?: { __typename?: 'StoreV2StoreFront', id: string, gameId: string, categories?: Array<{ __typename?: 'StoreV2StoreFrontCategory', id: string, itemType: StoreV2ItemType, sellableItems: Array<{ __typename?: 'StoreV2SellableItem', id: string, signature: string, type: StoreV2ItemType, sku: string, discountPercent: number, availableUntil?: string | null, name: string, promotionName: string, content: Array<{ __typename?: 'StoreV2Content', value?: { __typename: 'StoreV2CurrencyRef', id: string, amount: number } | { __typename: 'StoreV2ItemRef', id: string, count: number, item: { __typename?: 'ItemItem', id: string, details?: { __typename: 'AvatarAnimation' } | { __typename: 'AvatarAvatarPart', previewImgUrl: string } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } | { __typename: 'GameLogicStreamerCard', id: string, channelId: string, gameId: string, familyId: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus }, baseCard: { __typename?: 'GameLogicCard', id: string, rarity: RarityRarity, name: string, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, season: { __typename?: 'GameSeason', id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }, leveling: { __typename?: 'GameLogicCardLeveling', nextLevelLimit: number, progressToNextLevel: number, currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } | null, season?: { __typename?: 'GameSeason', id: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', url: string, rarity: RarityRarity }> } | null, game?: { __typename?: 'GameGame', id: string, name: string } | null }, inventoryState?: { __typename?: 'InventoryInventoryItem', itemCount: number } | null } | { __typename: 'StoreV2SubscriptionRef', id: string } | null }>, igcPrices?: Array<{ __typename?: 'StoreV2InGameCurrencyPrice', currencyId: string, default: boolean, amount: number, amountWithoutDiscount: number }> | null, price?: { __typename?: 'StoreV2Price', currency: PaymentCurrency, amount: number, amountWithoutDiscount: number } | null }> }> | null } | null };

export type StorePageUserDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type StorePageUserDataQuery = { __typename?: 'Query', followedChannels?: { __typename?: 'ChannelGetUserFollowedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, offlineBanner: string, following: boolean, followerCount: number, liveStatus: ChannelLiveStatus, logo: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean } }> } | null, profile?: { __typename?: 'ProfileProfile', userId: string, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string } } }> } | null };

export type StorePageCurrentChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type StorePageCurrentChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, offlineBanner: string, following: boolean, followerCount: number, liveStatus: ChannelLiveStatus, logo: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean } } | null };

export type StoreChannelListChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, offlineBanner: string, following: boolean, followerCount: number, liveStatus: ChannelLiveStatus, logo: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean } };

export type StoreChannelSectionChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, viewerCount: number, offlineBanner: string, following: boolean, followerCount: number, liveStatus: ChannelLiveStatus, logo: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean } };

export type PlatformStoreRedirectProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type PlatformStoreRedirectProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string }> } | null };

export type GetMatchEndDailyBoostQueryVariables = Exact<{ [key: string]: never; }>;


export type GetMatchEndDailyBoostQuery = { __typename?: 'Query', dailyXPBoostLimit?: { __typename?: 'ProgressionGetDailyXPBoostLimitResponse', remainingDailyXpBoost: number } | null };

export type GetMatchEndLevelThresholdsQueryVariables = Exact<{
  seasonId: Scalars['ID']['input'];
  startLevel: Scalars['Int']['input'];
  endLevel: Scalars['Int']['input'];
}>;


export type GetMatchEndLevelThresholdsQuery = { __typename?: 'Query', listLevelConfigs?: { __typename?: 'ProgressionListLevelConfigsResponse', levelConfigs: Array<{ __typename?: 'ProgressionLevelConfig', threshold: number }> } | null };

export type MatchEndLevelThresholdsFragment = { __typename?: 'ProgressionLevelConfig', threshold: number };

export type GetMatchEndPlayerLevelQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  seasonId: Scalars['ID']['input'];
}>;


export type GetMatchEndPlayerLevelQuery = { __typename?: 'Query', seasonProgression?: { __typename?: 'ProgressionSeasonProgression', level: number, nextLevel: number } | null };

export type MatchEndPlayerLevelFragment = { __typename?: 'ProgressionSeasonProgression', level: number, nextLevel: number };

export type MatchResultsDialogBestPlayGameCardsQueryVariables = Exact<{
  cardIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type MatchResultsDialogBestPlayGameCardsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type MatchResultsDialogBestPlayProfilesQueryVariables = Exact<{
  userIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type MatchResultsDialogBestPlayProfilesQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> } | null };

export type MatchResultsDialogPlayerScoresProfileQueryVariables = Exact<{
  userIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type MatchResultsDialogPlayerScoresProfileQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string, avatar2D: string } | null }> } | null };

export type MatchResultsDialogRewardsGameQueryVariables = Exact<{
  gameId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type MatchResultsDialogRewardsGameQuery = { __typename?: 'Query', game?: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string, progression: { __typename?: 'ProgressionSeasonProgression', level: number } } } | null };

export type MatchResultsSummaryPlayerScoreProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type MatchResultsSummaryPlayerScoresProfileQueryVariables = Exact<{
  userIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type MatchResultsSummaryPlayerScoresProfileQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> } | null };

export type MatchGroupWaitingLgPlayersQueryVariables = Exact<{
  playerIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type MatchGroupWaitingLgPlayersQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } }> } | null };

export type BestPlaysDataQueryVariables = Exact<{
  cardIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
  userIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type BestPlaysDataQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null, profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null }> } | null };

export type BestPlayProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null };

export type DisplayBottomLgPlayerQueryVariables = Exact<{
  playerId: Scalars['ID']['input'];
}>;


export type DisplayBottomLgPlayerQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } | null };

export type PlayerScoreProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string };

export type AllOrNothingDialogCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type AllOrNothingDialogCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type CardSelectCardsQueryVariables = Exact<{
  cardIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type CardSelectCardsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type CardSelectMatchCardsQueryVariables = Exact<{
  cardIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type CardSelectMatchCardsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type HighScoringCardDataQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
  playerId: Scalars['ID']['input'];
}>;


export type HighScoringCardDataQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null } | null };

export type HighScoringCardPlayerFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null };

export type SpectatorPlayerDisplayProfileQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type SpectatorPlayerDisplayProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } | null };

export type SpectatorDisplayBottomProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type SpectatorPlayerInfoProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type DisplayBottomSmPlayerQueryVariables = Exact<{
  playerId: Scalars['ID']['input'];
}>;


export type DisplayBottomSmPlayerQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } | null };

export type PlayerScoreProfileQueryVariables = Exact<{
  playerId: Scalars['ID']['input'];
}>;


export type PlayerScoreProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type CardSelectSmCardsQueryVariables = Exact<{
  cardIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type CardSelectSmCardsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type ProgressionPausedSeasonQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ProgressionPausedSeasonQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, game: { __typename?: 'GameGame', id: string, activeSeason: { __typename?: 'GameSeason', id: string, progressionPaused: boolean, progressionPauseReason: string } } } | null };

export type ActiveCardSoundsQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type ActiveCardSoundsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, pointsMax: number, targetValue: number, isAllOrNothing: boolean, isMatchCard: boolean }> } | null };

export type GameCardSoundDataFragment = { __typename?: 'GameLogicCard', id: string, pointsMax: number, targetValue: number, isAllOrNothing: boolean, isMatchCard: boolean };

export type UseSpeedUpBoosterDurationQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type UseSpeedUpBoosterDurationQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, timeActive: number } | null };

export type GameStreamerBaseCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type GameStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } };

export type GameCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type GameCardBackgroundArtSeasonQueryVariables = Exact<{
  seasonId: Scalars['ID']['input'];
}>;


export type GameCardBackgroundArtSeasonQuery = { __typename?: 'Query', season?: { __typename?: 'GameSeason', id: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', rarity: RarityRarity, url: string }> } | null };

export type GameCardBackgroundArtStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string };

export type GameCardBackgroundArtCardFragment = { __typename?: 'GameLogicCard', rarity: RarityRarity, seasonId: string, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } };

export type GameCardBackgroundVideoStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, video: string, channel: { __typename?: 'ChannelChannel', id: string } };

export type GameCardBottomLabelStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, channel: { __typename?: 'ChannelChannel', id: string, name: string } };

export type GameCardBottomLabelCardFragment = { __typename?: 'GameLogicCard', isAllOrNothing: boolean, isMatchCard: boolean };

export type GameCardFrameStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string };

export type GameCardFrameCardFragment = { __typename?: 'GameLogicCard', leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } };

export type GameCardHeroCardFragment = { __typename?: 'GameLogicCard', icon: string, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } };

export type GameCardInfoCardFragment = { __typename?: 'GameLogicCard', name: string, description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type GameCardInfoDescriptionCardFragment = { __typename?: 'GameLogicCard', description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type GameCardLevelSeasonQueryVariables = Exact<{
  seasonId: Scalars['ID']['input'];
}>;


export type GameCardLevelSeasonQuery = { __typename?: 'Query', season?: { __typename?: 'GameSeason', id: string, badgeUrl: string } | null };

export type GameCardLevelCardFragment = { __typename?: 'GameLogicCard', seasonId: string, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } };

export type GameCardPointsStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string };

export type GameCardPointsCardFragment = { __typename?: 'GameLogicCard', pointsMax: number, pointsMin: number, isAllOrNothing: boolean };

export type GameCardStreamerDialogStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string } };

export type GameCardTypeBadgeStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, channel: { __typename?: 'ChannelChannel', id: string, logo: string } };

export type GameCardTypeBadgeCardFragment = { __typename?: 'GameLogicCard', isAllOrNothing: boolean, isMatchCard: boolean };

export type LeaderboardItemPlayersQueryVariables = Exact<{
  playerIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type LeaderboardItemPlayersQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> } | null };

export type AllOrNothingPendingCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type AllOrNothingPendingCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type CardWithHighlightStateCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type CardWithHighlightStateCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type SwitchOutCardDetailsQueryVariables = Exact<{
  activeCardId: Scalars['String']['input'];
}>;


export type SwitchOutCardDetailsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, isAllOrNothing: boolean }> } | null };

export type ChallengesContentChallengeFragment = { __typename?: 'GameLogicChallenge', id: string, description: string, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number }> };

export type ChallengesContentChallengesQueryVariables = Exact<{
  challengeIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type ChallengesContentChallengesQuery = { __typename?: 'Query', challengesBatch?: { __typename?: 'ChallengeListChallengesResponse', challenges: Array<{ __typename?: 'GameLogicChallenge', id: string, description: string, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number }> }> } | null };

export type PickRateRewardsQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type PickRateRewardsQuery = { __typename?: 'Query', challengeRewards?: { __typename?: 'ChallengeGetChallengeRewardsResponse', rewards: Array<{ __typename?: 'ChallengeChallengeReward', minPickRate: number, maxPickRate: number, gameId: string, reward: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem' } | null } }> } | null };

export type ActiveBoosterProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ActiveBoosterFragment = { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string, descriptionTargetSelf: string };

export type ActiveBoosterDialogContentProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ActiveBoosterDialogContentBoosterFragment = { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string, descriptionTargetSelf: string };

export type ActiveBoosterTooltipContentProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ActiveBoosterTooltipContentBoosterFragment = { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string, descriptionTargetSelf: string };

export type ActiveBoostersDataQueryVariables = Exact<{
  boosterId: Scalars['Int']['input'];
}>;


export type ActiveBoostersDataQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string, descriptionTargetSelf: string } | null };

export type ActiveBoostersProfileDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ActiveBoostersProfileDataQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type ReplacementBoosterDataQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type ReplacementBoosterDataQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string, descriptionTargetSelf: string } | null };

export type CardRowAvatarProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type LocalPlayerBoosterDialogContentQueryVariables = Exact<{
  boosterId: Scalars['Int']['input'];
}>;


export type LocalPlayerBoosterDialogContentQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string } | null };

export type LocalPlayerBoosterTooltipContentQueryVariables = Exact<{
  boosterId: Scalars['Int']['input'];
}>;


export type LocalPlayerBoosterTooltipContentQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string } | null };

export type BoosterRequestPreviewProfileQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type BoosterRequestPreviewProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type PlayerActiveCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type PlayerActiveCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type TeamMateBoosterDialogContentBoosterFragment = { __typename?: 'GameLogicBooster', name: string, descriptionCondition: string, descriptionDefaultBenefit: string };

export type TeamMateBoosterDialogContentQueryVariables = Exact<{
  boosterId: Scalars['Int']['input'];
}>;


export type TeamMateBoosterDialogContentQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string } | null };

export type TeamMateBoosterTooltipContentBoosterFragment = { __typename?: 'GameLogicBooster', name: string, descriptionCondition: string, descriptionDefaultBenefit: string };

export type TeamMateBoosterTooltipContentQueryVariables = Exact<{
  boosterId: Scalars['Int']['input'];
  userId: Scalars['ID']['input'];
}>;


export type TeamMateBoosterTooltipContentQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type CgActiveBoosterFragment = { __typename?: 'GameLogicBooster', id: number, timeActive: number, valueSelf: number, valueOther: number, image: string, name: string };

export type CgAvailableBoosterFragment = { __typename?: 'GameLogicBooster', id: number, canTargetSelf: boolean };

export type GameStateCardTargetValuesFragment = { __typename?: 'GameLogicCard', targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type GameStateCardFragment = { __typename?: 'GameLogicCard', id: string, pointsMin: number, pointsMax: number, pointsTimeTarget: number, timerDuration: number, targetValue: number, isMatchCard: boolean, isAllOrNothing: boolean, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type CgChallengesSystemChallengeFragment = { __typename?: 'GameLogicChallenge', id: string, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number }> };

export type CgChallengesSystemChallengesQueryVariables = Exact<{
  challengeIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type CgChallengesSystemChallengesQuery = { __typename?: 'Query', challengesBatch?: { __typename?: 'ChallengeListChallengesResponse', challenges: Array<{ __typename?: 'GameLogicChallenge', id: string, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number }> }> } | null };

export type GameStateGameCardQueryVariables = Exact<{
  ids: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type GameStateGameCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, pointsMin: number, pointsMax: number, pointsTimeTarget: number, timerDuration: number, targetValue: number, isMatchCard: boolean, isAllOrNothing: boolean, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type GameStateBoostersQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type GameStateBoostersQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, canTargetSelf: boolean, timeActive: number, valueSelf: number, valueOther: number, image: string, name: string } | null };

export type StreamGameChannelQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StreamGameChannelQuery = { __typename?: 'Query', stream?: { __typename?: 'ChannelStream', streamId: string, channelId: string } | null };

export type ChatChannelEventsSubscriptionSubscriptionVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChatChannelEventsSubscriptionSubscription = { __typename?: 'Subscription', channelEventsSubscribe?: { __typename?: 'ChannelChannelEvent', channelId: string, createdAt: string, id: string, content: { __typename?: 'ChannelChannelEventContent', content?: { __typename?: 'ChannelAvatarItemPurchase', itemId: string, item: { __typename?: 'ItemItem', id: string, name: string }, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string } | null } | { __typename?: 'ChannelBundlePurchase', bundleName: string, userId: string, streamerCards?: Array<{ __typename?: 'GameLogicStreamerCard', id: string, channelId: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string } }> | null, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string } | null } | { __typename?: 'ChannelGiftSubscriptionPurchase', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, recipients?: Array<{ __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> }> | null } | { __typename?: 'ChannelStreamerCardPurchase', userId: string, streamerCard: { __typename?: 'GameLogicStreamerCard', id: string, channelId: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string } }, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string } | null } | { __typename?: 'ChannelSubscriptionPurchase', userId: string, tier: number, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null } | { __typename?: 'ChannelSubscriptionRenewal' } | null } } | null };

export type ChannelEventContentProfileFragment = { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string };

export type ChannelEventSubscriptionContentProfileFragment = { __typename?: 'ProfileProfile', badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type ChannelEventAvatarItemPurchaseItemFragment = { __typename?: 'ItemItem', id: string, name: string };

export type ChatMessageAttachmentsFragment = { __typename: 'ChatTextMessageAttachment', label: string, source: string, startIndex: number, endIndex: number };

export type ChatMessagesHookProfileFragment = { __typename?: 'ProfileProfile', userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type SendChatMessageProfileFragment = { __typename?: 'ProfileProfile', userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type InventoryEmojiFragment = { __typename?: 'EmojiEmoji', id: string, label: string, image: string, channelId: string };

export type InventoryEmojisQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type InventoryEmojisQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string, label: string, image: string, channelId: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } }> } | null };

export type UpdateChatSettingsProfileMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  preferredColor: ProfileColor;
}>;


export type UpdateChatSettingsProfileMutation = { __typename?: 'Mutation', updateProfile?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor } | null };

export type ChatSettingsProfileQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type ChatSettingsProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', level: number, type: BadgeBadgeType }> } | null };

export type UpdateChatSettingsProfileFragment = { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor };

export type AvatarMovementsQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type AvatarMovementsQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation', name: string, chatCommand: string, iconUrl: string, id: string } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } }> } | null };

export type EmoteAvatarAnimationFragment = { __typename?: 'AvatarAnimation', name: string, chatCommand: string, iconUrl: string, id: string };

export type HideChatMessageMutationVariables = Exact<{
  chatId: Scalars['ID']['input'];
  messageId: Scalars['ID']['input'];
}>;


export type HideChatMessageMutation = { __typename?: 'Mutation', hideChatMessage?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChatMeProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ChatMeProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type ChatMessagesProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string };

export type UserInventoryEmojisQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UserInventoryEmojisQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string, label: string, image: string, channelId: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } }> } | null };

export type EmojiDrawerChannelFragment = { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, logo: string, name: string };

export type UserInventoryEmojisChannelsQueryVariables = Exact<{
  channelIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type UserInventoryEmojisChannelsQuery = { __typename?: 'Query', getChannels?: { __typename?: 'ChannelBatchGetChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus, logo: string, name: string }> } | null };

export type ReceivedBoosterRequestMessageProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ReceivedBoosterRequestMessageProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type SentBoosterRequestMessageProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type SentBoosterRequestMessageProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type ChatProviderDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  chatId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type ChatProviderDataQuery = { __typename?: 'Query', chatUserStatus?: { __typename?: 'ChatGetChatUserStatusResponse', muted: boolean, muteDuration?: string | null } | null, userChannelRoles?: { __typename?: 'ChannelListUserChannelRolesResponse', roles: Array<ChannelChannelRole> } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null };

export type OwnChatSenderInfoProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type OwnChatSenderInfoProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null };

export type ReasonDescriptionInputProfileFragment = { __typename?: 'ProfileProfile', userTag: string };

export type ReasonDescriptionInputChannelFragment = { __typename?: 'ChannelChannel', name: string };

export type ReasonSelectProfileFragment = { __typename?: 'ProfileProfile', userTag: string };

export type ReasonSelectChannelFragment = { __typename?: 'ChannelChannel', name: string };

export type ReportUserMutationVariables = Exact<{
  reason: SupportReportReason;
  description?: InputMaybe<Scalars['String']['input']>;
  context: SupportReportContextInput;
}>;


export type ReportUserMutation = { __typename?: 'Mutation', createReport?: { __typename?: 'SupportReport', createdAt: string } | null };

export type ReportedUserProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ReportedUserProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type ReportedChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ReportedChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string } | null };

export type ReportedChannelFragment = { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, logo: string };

export type ReportedUserProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ReportStreamTimestampQueryVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type ReportStreamTimestampQuery = { __typename?: 'Query', stream?: { __typename?: 'ChannelStream', streamId: string, segments: Array<{ __typename?: 'ChannelStreamSegment', startTime: string }> } | null };

export type SignupFlowChannelQueryVariables = Exact<{
  channelName: Scalars['String']['input'];
}>;


export type SignupFlowChannelQuery = { __typename?: 'Query', channelByName?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string } | null };

export type SignupFlowChannelFragment = { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, logo: string };

export type ChannelBannerChannelFragment = { __typename?: 'ChannelChannel', offlineBanner: string };

export type ChannelLogoChannelFragment = { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, logo: string, name: string };

export type PlatformAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', id: string, title: string, text: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, image: string };

export type ProfileImageProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ProfileImageShowOnlineStatusProfileFragment = { __typename?: 'ProfileProfile', onlineStatus: ProfilePresenceStatus, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ChannelAssetCreateTokenMutationVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
  assetType?: InputMaybe<ChannelAssetType>;
}>;


export type ChannelAssetCreateTokenMutation = { __typename?: 'Mutation', createChannelAssetUploadToken?: { __typename?: 'ChannelCreateChannelAssetUploadTokenResponse', token: string } | null };

export type LogoUpdateChannelChannelFragment = { __typename?: 'ChannelChannel', id: string, logo: string };

export type BannerUpdateChannelChannelFragment = { __typename?: 'ChannelChannel', id: string, offlineBanner: string };

export type EmojiAssetCreateTokenMutationVariables = Exact<{
  itemId: Scalars['ID']['input'];
}>;


export type EmojiAssetCreateTokenMutation = { __typename?: 'Mutation', createEmojiUploadToken?: { __typename?: 'EmojiCreateEmojiUploadTokenResponse', token: string } | null };

export type AssetUploadEmojiEmojiFragment = { __typename?: 'EmojiEmoji', image: string };

export type WalletQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type WalletQuery = { __typename?: 'Query', wallet?: { __typename?: 'WalletGetWalletResponse', wallet: { __typename?: 'WalletWallet', currencies: Array<{ __typename?: 'WalletWalletCurrency', currencyId: string, currencyAmount: number }> } } | null };

export type WalletCurrencyFragment = { __typename?: 'WalletWalletCurrency', currencyId: string, currencyAmount: number };

export type ZendeskPrefillProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null };

export type StreamSpectatorCoordinationSubscribeSubscriptionVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type StreamSpectatorCoordinationSubscribeSubscription = { __typename?: 'Subscription', streamSpectatorCoordinationEventsSubscribe?: { __typename?: 'MatchStreamSpectatorCoordinationEvent', event?: { __typename?: 'MatchStreamSpectatorChangeGroupEvent', groupId: string } | null } | null };

export type UpdateAvatarMutationVariables = Exact<{
  avatarId: Scalars['ID']['input'];
}>;


export type UpdateAvatarMutation = { __typename?: 'Mutation', updateProfileAvatar?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SubscriptionGetChannelEmojisChannelFragment = { __typename?: 'ChannelChannel', subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> }> } | null };

export type SubscriptionGetChannelEmojisChannelEmojiFragment = { __typename: 'EmojiEmoji', id: string, image: string, name: string };

export type UserBadgeFragment = { __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number };

export type SocialChannelBanMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  violation?: InputMaybe<ChannelViolation>;
  description?: InputMaybe<Scalars['String']['input']>;
  keepRecentMessages?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type SocialChannelBanMutation = { __typename?: 'Mutation', banChannelUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialChannelUnbanMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type SocialChannelUnbanMutation = { __typename?: 'Mutation', unbanChannelUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ActiveFriendsListProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type BlockUserProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type BlockedUserProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type BlockedUserProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type ChannelBanModalProfileFragment = { __typename?: 'ProfileProfile', userTag: string, userId: string };

export type MuteUserMutationVariables = Exact<{
  chatId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
  duration: Scalars['Duration']['input'];
  reason: ChatReason;
  description: Scalars['String']['input'];
}>;


export type MuteUserMutation = { __typename?: 'Mutation', muteChatUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChannelMuteModalProfileFragment = { __typename?: 'ProfileProfile', userTag: string, userId: string };

export type ChannelUnbanModalProfileFragment = { __typename?: 'ProfileProfile', userTag: string, userId: string };

export type ChannelUnbanModalChannelUserBanStatusFragment = { __typename?: 'ChannelUserBanStatus', bannedAt?: string | null, violation: ChannelViolation, description: string, moderator?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type UnmuteUserMutationVariables = Exact<{
  chatId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type UnmuteUserMutation = { __typename?: 'Mutation', unmuteChatUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChannelUnmuteModalProfileFragment = { __typename?: 'ProfileProfile', userTag: string, userId: string };

export type ChannelUnmuteModalChatStatusFragment = { __typename?: 'ChatGetChatUserStatusResponse', muteDuration?: string | null };

export type FriendRequestButtonProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, temporary: boolean, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } };

export type ResolvedAddFriendUserTagQueryVariables = Exact<{
  userTag: Scalars['String']['input'];
}>;


export type ResolvedAddFriendUserTagQuery = { __typename?: 'Query', resolveUserTags?: { __typename?: 'ProfileResolveUserTagsResponse', userIds: Array<{ __typename?: 'ProfileResolveUserTagsResponseUserIdsEntry', key: string, value: string }> } | null };

export type FriendsSidebarFriendFragment = { __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarFriendProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null };

export type FriendsSidebarFriendButtonsProfileFragment = { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type FriendsSidebarFriendPanelFriendFragment = { __typename?: 'FriendsUser', lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarFriendStatusFriendsUserFragment = { __typename?: 'FriendsUser', activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null, profile: { __typename?: 'ProfileProfile', userId: string, onlineStatus: ProfilePresenceStatus } };

export type FriendsSidebarItemExpandedFriendFragment = { __typename?: 'FriendsUser', profile: { __typename?: 'ProfileProfile', userId: string, onlineStatus: ProfilePresenceStatus, userTag: string, isNewUsername: boolean, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarItemExpandedProfileFragment = { __typename?: 'ProfileProfile', userTag: string, isNewUsername: boolean, onlineStatus: ProfilePresenceStatus, userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type FriendsSidebarFriendActionsFriendsUserFragment = { __typename?: 'FriendsUser', userId: string, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null } | null, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } };

export type FriendsSidebarFriendListFriendFragment = { __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarFriendListProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null };

export type FriendSidebarFriendsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  pageSize?: Scalars['Int']['input'];
}>;


export type FriendSidebarFriendsQuery = { __typename?: 'Query', friends?: { __typename?: 'FriendsListFriendsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, users: Array<{ __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null }> } | null };

export type FriendsSidebarFriendsViewDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FriendsSidebarFriendsViewDataQuery = { __typename?: 'Query', receivedFriendRequests?: { __typename?: 'FriendsListReceivedFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string } }> } | null };

export type FriendsSidebarPartyQueryVariables = Exact<{
  partyId: Scalars['ID']['input'];
}>;


export type FriendsSidebarPartyQuery = { __typename?: 'Query', party?: { __typename?: 'PartyParty', id: string, leaderId: string, members: Array<{ __typename?: 'PartyPartyMember', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null } }>, channel?: { __typename?: 'ChannelChannel', id: string, currentStreamId: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarMenuPendingRequestsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FriendsSidebarMenuPendingRequestsQuery = { __typename?: 'Query', receivedFriendRequests?: { __typename?: 'FriendsListReceivedFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string }> } | null };

export type FriendsSidebarPartyFriendFragment = { __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarPartyProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null };

export type FriendsSidebarPendingViewDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FriendsSidebarPendingViewDataQuery = { __typename?: 'Query', receivedFriendRequests?: { __typename?: 'FriendsListReceivedFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null }> } | null, sentFriendRequests?: { __typename?: 'FriendsListSentFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null }> } | null };

export type GiftSubscriptionToCommunityButtonRolesQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type GiftSubscriptionToCommunityButtonRolesQuery = { __typename?: 'Query', userChannelRoles?: { __typename?: 'ChannelListUserChannelRolesResponse', roles: Array<ChannelChannelRole> } | null };

export type MiniProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, temporary: boolean, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string, avatar2D: string } | null, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, name: string }, progression: { __typename?: 'GameUserProgression', level: number }, season: { __typename?: 'GameSeason', id: string, name: string } }>, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } };

export type MiniProfileChatStatusFragment = { __typename?: 'ChatGetChatUserStatusResponse', muted: boolean, muteDuration?: string | null };

export type MiniProfileChannelBanFragment = { __typename?: 'ChannelUserBanStatus', banned: boolean, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus } | null };

export type MiniProfileAvatarProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null };

export type MiniProfileFollowingStateQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type MiniProfileFollowingStateQuery = { __typename?: 'Query', channelFollowerStatus?: { __typename?: 'ChannelGetChannelFollowerStatusResponse', following: boolean, followedAt?: string | null } | null };

export type MiniProfileDetailsProfileFragment = { __typename?: 'ProfileProfile', userId: string };

export type MiniProfileFooterProfileFragment = { __typename?: 'ProfileProfile', userId: string, temporary: boolean, userTag: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type MiniProfilePopoverMenuChannelBanFragment = { __typename?: 'ChannelUserBanStatus', banned: boolean };

export type MiniProfilePopoverMenuChatStatusFragment = { __typename?: 'ChatGetChatUserStatusResponse', muted: boolean };

export type MiniProfilePopoverMenuProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, temporary: boolean, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type MiniProfileFriendStatusProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } };

export type MiniProfileGameRankProfileFragment = { __typename?: 'ProfileProfile', playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, name: string }, progression: { __typename?: 'GameUserProgression', level: number }, season: { __typename?: 'GameSeason', id: string, name: string } }> };

export type MiniProfileGameRankChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type MiniProfileGameRankChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, gameId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string } } | null };

export type MiniProfileHeaderProfileFragment = { __typename?: 'ProfileProfile', userTag: string, temporary: boolean, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type MiniProfileModerationStateChatStatusFragment = { __typename?: 'ChatGetChatUserStatusResponse', muted: boolean, muteDuration?: string | null };

export type MiniProfileModerationStateChannelBanFragment = { __typename?: 'ChannelUserBanStatus', banned: boolean, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus } | null };

export type MiniProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type MiniProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, temporary: boolean, isNewUsername: boolean, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string }, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string, avatar2D: string } | null, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, name: string }, progression: { __typename?: 'GameUserProgression', level: number }, season: { __typename?: 'GameSeason', id: string, name: string } }> } | null };

export type MiniProfileModeratorStatusQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  chatId?: InputMaybe<Scalars['ID']['input']>;
  skipChatModerationData: Scalars['Boolean']['input'];
}>;


export type MiniProfileModeratorStatusQuery = { __typename?: 'Query', channelBanUserStatus?: { __typename?: 'ChannelUserBanStatus', userId: string, channelId: string, banned: boolean, bannedAt?: string | null, violation: ChannelViolation, description: string, moderator?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus } | null } | null, chatUserStatus?: { __typename?: 'ChatGetChatUserStatusResponse', muteDuration?: string | null, muted: boolean } | null };

export type MiniProfilePortalChannelBanFragment = { __typename?: 'ChannelUserBanStatus', bannedAt?: string | null, violation: ChannelViolation, description: string, banned: boolean, moderator?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus } | null };

export type MiniProfilePortalChatStausFragment = { __typename?: 'ChatGetChatUserStatusResponse', muteDuration?: string | null, muted: boolean };

export type UserChannelRolesQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  channelId: Scalars['ID']['input'];
  skipRoles: Scalars['Boolean']['input'];
}>;


export type UserChannelRolesQuery = { __typename?: 'Query', userChannelRoles?: { __typename?: 'ChannelListUserChannelRolesResponse', roles: Array<ChannelChannelRole> } | null, channel?: { __typename?: 'ChannelChannel', id: string, currentChatId?: string | null } | null };

export type LeavePartyMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  partyId: Scalars['ID']['input'];
}>;


export type LeavePartyMutation = { __typename?: 'Mutation', deletePartyMember?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type CreatePartyMutationVariables = Exact<{ [key: string]: never; }>;


export type CreatePartyMutation = { __typename?: 'Mutation', createParty?: { __typename?: 'PartyParty', id: string } | null };

export type CreatePartyInvitationMutationVariables = Exact<{
  inviterId: Scalars['ID']['input'];
  inviteeId: Scalars['ID']['input'];
  partyId: Scalars['ID']['input'];
}>;


export type CreatePartyInvitationMutation = { __typename?: 'Mutation', createPartyInvitation?: { __typename?: 'PartyPartyInvitation', partyId: string } | null };

export type PartyInvitesCreatePartyMemberMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  partyId: Scalars['ID']['input'];
}>;


export type PartyInvitesCreatePartyMemberMutation = { __typename?: 'Mutation', createPartyMember?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type PartyInvitesDeletePartyInviteMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  partyId: Scalars['ID']['input'];
}>;


export type PartyInvitesDeletePartyInviteMutation = { __typename?: 'Mutation', deletePartyInvitation?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type PartyInvitesCurrentPartyQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type PartyInvitesCurrentPartyQuery = { __typename?: 'Query', userParty?: { __typename?: 'PartyParty', id: string, leaderId: string, streamId: string, members: Array<{ __typename?: 'PartyPartyMember', userId: string }> } | null };

export type PartyInvitesPartyUpdatesSubscriptionVariables = Exact<{
  partyId: Scalars['ID']['input'];
}>;


export type PartyInvitesPartyUpdatesSubscription = { __typename?: 'Subscription', partyUpdateSubscribe?: { __typename?: 'PartyPartyUpdateEvent', party: { __typename?: 'PartyParty', id: string, streamId: string, leaderId: string, members: Array<{ __typename?: 'PartyPartyMember', userId: string, profile: { __typename?: 'ProfileProfile', userId: string } }>, channel?: { __typename?: 'ChannelChannel', id: string } | null } } | null };

export type FriendStatusUpdateProfileFragment = { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } };

export type SocialAcceptFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  friendId: Scalars['ID']['input'];
}>;


export type SocialAcceptFriendRequestMutation = { __typename?: 'Mutation', acceptFriendRequest?: { __typename?: 'FriendsAcceptFriendRequestResponse', friendId: string, friend: { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } } } | null };

export type NewFriendRequestUserFragment = { __typename?: 'FriendsUser', userId: string };

export type SocialBlockUserMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  blockedUserId: Scalars['ID']['input'];
}>;


export type SocialBlockUserMutation = { __typename?: 'Mutation', blockUser?: { __typename?: 'FriendsBlockUserResponse', blockedUserId: string, blockedUser: { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } } } | null };

export type SocialRemoveFriendMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  friendId: Scalars['ID']['input'];
}>;


export type SocialRemoveFriendMutation = { __typename?: 'Mutation', removeFriend?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialRemoveReceivedFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  friendId: Scalars['ID']['input'];
}>;


export type SocialRemoveReceivedFriendRequestMutation = { __typename?: 'Mutation', removeFriendRequest?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialRemoveSentFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  friendId: Scalars['ID']['input'];
}>;


export type SocialRemoveSentFriendRequestMutation = { __typename?: 'Mutation', removeFriendRequest?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialSendFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  friendId: Scalars['ID']['input'];
}>;


export type SocialSendFriendRequestMutation = { __typename?: 'Mutation', sendFriendRequest?: { __typename?: 'FriendsSendFriendRequestResponse', friendId: string, friend: { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } } } | null };

export type SocialUnblockUserMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  blockedUserId: Scalars['ID']['input'];
}>;


export type SocialUnblockUserMutation = { __typename?: 'Mutation', unblockUser?: { __typename?: 'FriendsUnblockUserResponse', unblockedUserId: string, unblockedUser: { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } } } | null };

export type SpotlightBestGroupProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type SpotlightBestGroupDataQueryVariables = Exact<{
  userIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type SpotlightBestGroupDataQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> } | null };

export type SpotlightBestPlayCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type SpotlightBestPlayProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string };

export type SpotlightBestPlayDataQueryVariables = Exact<{
  cardIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type SpotlightBestPlayDataQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type SpotlightBestPlayerProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type SpotlightBestPlayerDataQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type SpotlightBestPlayerDataQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type UseStreamAvatarEmotesQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UseStreamAvatarEmotesQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename: 'AvatarAnimation', name: string, iconUrl: string, id: string } | { __typename: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji' } | { __typename: 'GameLogicCard' } | { __typename: 'GameLogicStreamerCard' } | null } }> } | null };

export const CardSucceededStatsUpdateProfileFragmentDoc = gql`
    fragment CardSucceededStatsUpdateProfile on ProfileProfile {
  stats {
    cardsPlayed
    cardsSucceeded
  }
}
    `;
export const CardFailedStatsUpdateProfileFragmentDoc = gql`
    fragment CardFailedStatsUpdateProfile on ProfileProfile {
  stats {
    cardsPlayed
  }
}
    `;
export const CompleteAccountCheckProfileFragmentDoc = gql`
    fragment CompleteAccountCheckProfile on ProfileProfile {
  avatars {
    avatar2D
  }
  account {
    uid
    birthday {
      day
      month
      year
    }
  }
}
    `;
export const AvatarEditorAvatarPartFragmentDoc = gql`
    fragment AvatarEditorAvatarPart on AvatarAvatarPart {
  id
  color
  url
  colors
  experimental
  colorPresetOptions
  glbUrlOverride {
    category
    glbUrl
  }
  userDefault
  uniqueBootstrap
  skinOptions
  skinData {
    baseMapUrl
    normalMapUrl
    ormMapUrl
    emissionMapUrl
  }
  enabled
  channelId
  sellable
}
    `;
export const AvatarEditorSellableItemFragmentDoc = gql`
    fragment AvatarEditorSellableItem on StoreV2SellableItem {
  id
  sku
  signature
  price {
    currency
    amount
    amountWithoutDiscount
  }
  igcPrices {
    currencyId
    amount
    amountWithoutDiscount
  }
  content {
    value {
      ... on StoreV2ItemRef {
        __typename
        count
        item {
          id
          gameId
          type
          attributes {
            value {
              key
              value {
                value {
                  ... on StringType {
                    value
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
    `;
export const FollowChannelChannelFragmentDoc = gql`
    fragment FollowChannelChannel on ChannelChannel {
  id
  followerCount
  following
}
    `;
export const IsGamePredictionsEnabledChannelFragmentDoc = gql`
    fragment IsGamePredictionsEnabledChannel on ChannelChannel {
  game {
    id
    activeSeason {
      id
      seasonBreak
    }
  }
  activeStream {
    streamId
    noicePredictionsEnabled
  }
}
    `;
export const ProfileImageProfileFragmentDoc = gql`
    fragment ProfileImageProfile on ProfileProfile {
  avatars {
    avatar2D
  }
  userTag
}
    `;
export const ActiveFriendsListProfileFragmentDoc = gql`
    fragment ActiveFriendsListProfile on ProfileProfile {
  userTag
  avatars {
    avatar2D
  }
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const ChannelLogoChannelFragmentDoc = gql`
    fragment ChannelLogoChannel on ChannelChannel {
  liveStatus
  logo
  name
}
    `;
export const ChannelTagsChannelFragmentDoc = gql`
    fragment ChannelTagsChannel on ChannelChannel {
  matureRatedContent
}
    `;
export const MatureRatedContentDialogChannelFragmentDoc = gql`
    fragment MatureRatedContentDialogChannel on ChannelChannel {
  id
  matureRatedContent
}
    `;
export const ChannelAutoJoinLinkPropsChannelFragmentDoc = gql`
    fragment ChannelAutoJoinLinkPropsChannel on ChannelChannel {
  id
  name
  ...MatureRatedContentDialogChannel
}
    ${MatureRatedContentDialogChannelFragmentDoc}`;
export const LiveChannelPreviewChannelFragmentDoc = gql`
    fragment LiveChannelPreviewChannel on ChannelChannel {
  id
  name
  title
  following
  matureRatedContent
  game {
    id
    name
    activeSeason @skip(if: $skipUserFields) {
      id
      seasonBreak
      seasonBreakReason
    }
  }
  viewerCount
  thumbnail
  channelFriends @skip(if: $skipUserFields) {
    totalCount
    users {
      userId
      profile {
        userId
        ...ActiveFriendsListProfile
      }
    }
  }
  activeStream @skip(if: $skipUserFields) {
    streamId
    noicePredictionsEnabled
  }
  ...ChannelLogoChannel
  ...ChannelTagsChannel
  ...ChannelAutoJoinLinkPropsChannel
}
    ${ActiveFriendsListProfileFragmentDoc}
${ChannelLogoChannelFragmentDoc}
${ChannelTagsChannelFragmentDoc}
${ChannelAutoJoinLinkPropsChannelFragmentDoc}`;
export const ChannelListPageChannelsChannelFragmentDoc = gql`
    fragment ChannelListPageChannelsChannel on ChannelChannel {
  ...LiveChannelPreviewChannel
}
    ${LiveChannelPreviewChannelFragmentDoc}`;
export const OfflineChannelLinkChannelFragmentDoc = gql`
    fragment OfflineChannelLinkChannel on ChannelChannel {
  id
  name
  viewerCount
  offlineBanner
  following
  followerCount
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const ChannelListPageChannelsOfflineChannelFragmentDoc = gql`
    fragment ChannelListPageChannelsOfflineChannel on ChannelChannel {
  ...OfflineChannelLinkChannel
}
    ${OfflineChannelLinkChannelFragmentDoc}`;
export const ChannelSectionSmTagsChannelFragmentDoc = gql`
    fragment ChannelSectionSmTagsChannel on ChannelChannel {
  id
  game {
    id
    name
  }
  ...ChannelTagsChannel
}
    ${ChannelTagsChannelFragmentDoc}`;
export const ChannelViewCountUpdateFragmentDoc = gql`
    fragment ChannelViewCountUpdate on ChannelChannel {
  id
  viewerCount
}
    `;
export const SubscriptionButtonChannelFragmentDoc = gql`
    fragment SubscriptionButtonChannel on ChannelChannel {
  id
  following
  subscriptionConfig @skip(if: $skipAuthFields) {
    channelId
    subscriptionsEnabled
  }
  subscription @skip(if: $skipAuthFields) {
    id
    state
  }
  monetizationSettings @skip(if: $skipAuthFields) {
    enabled
  }
}
    `;
export const FollowButtonChannelFragmentDoc = gql`
    fragment FollowButtonChannel on ChannelChannel {
  id
  name
  following
}
    `;
export const ChannelActionButtonsChannelFragmentDoc = gql`
    fragment ChannelActionButtonsChannel on ChannelChannel {
  id
  streamerId
  name
  following
  ...SubscriptionButtonChannel
  ...FollowButtonChannel
}
    ${SubscriptionButtonChannelFragmentDoc}
${FollowButtonChannelFragmentDoc}`;
export const ChannelSectionChannelFragmentDoc = gql`
    fragment ChannelSectionChannel on ChannelChannel {
  viewerCount
  followerCount
  name
  logo
  title
  game {
    id
    name
  }
  activeStream {
    streamId
    startTime
  }
  monetizationSettings {
    enabled
  }
  ...ChannelLogoChannel
  ...ChannelActionButtonsChannel
  ...ChannelTagsChannel
}
    ${ChannelLogoChannelFragmentDoc}
${ChannelActionButtonsChannelFragmentDoc}
${ChannelTagsChannelFragmentDoc}`;
export const GameSidebarExpandedChannelFragmentDoc = gql`
    fragment GameSidebarExpandedChannel on ChannelChannel {
  id
  ...ChannelSectionChannel
}
    ${ChannelSectionChannelFragmentDoc}`;
export const SidebarChannelLogoFragmentDoc = gql`
    fragment SidebarChannelLogo on ChannelChannel {
  ...ChannelLogoChannel
  liveStatus
}
    ${ChannelLogoChannelFragmentDoc}`;
export const GameSidebarMinimizedChannelFragmentDoc = gql`
    fragment GameSidebarMinimizedChannel on ChannelChannel {
  ...SidebarChannelLogo
}
    ${SidebarChannelLogoFragmentDoc}`;
export const SeasonBreakBottomBarSeasonFragmentDoc = gql`
    fragment SeasonBreakBottomBarSeason on GameSeason {
  seasonBreak
  seasonBreakReason
}
    `;
export const PipChannelInfoFragmentDoc = gql`
    fragment PipChannelInfo on ChannelChannel {
  ...ChannelLogoChannel
  name
  title
  game {
    id
    name
  }
}
    ${ChannelLogoChannelFragmentDoc}`;
export const StreamChannelFragmentDoc = gql`
    fragment StreamChannel on ChannelChannel {
  id
  currentChatId
  name
  ...PipChannelInfo
  game {
    id
    name
    activeSeason {
      id
      seasonBreak
      seasonBreakReason
    }
    noicePredictionsEnabled
  }
}
    ${PipChannelInfoFragmentDoc}`;
export const RestreamingHudChannelFragmentDoc = gql`
    fragment RestreamingHudChannel on ChannelChannel {
  name
  id
}
    `;
export const SpectatorChannelFragmentDoc = gql`
    fragment SpectatorChannel on ChannelChannel {
  id
  currentChatId
  ...RestreamingHudChannel
}
    ${RestreamingHudChannelFragmentDoc}`;
export const UseDefaultGameIdProfileGameFragmentDoc = gql`
    fragment UseDefaultGameIdProfileGame on ProfilePlayedGame {
  id
  lastPlayedAt
}
    `;
export const GameSelectorGameFragmentDoc = gql`
    fragment GameSelectorGame on GameGame {
  id
  name
}
    `;
export const FriendRequestAcceptedNotificationContentProfileFragmentDoc = gql`
    fragment FriendRequestAcceptedNotificationContentProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const GoalCardNotificationContentGoalCardFragmentDoc = gql`
    fragment GoalCardNotificationContentGoalCard on GoalCardGoalCard {
  id
  description
  target
}
    `;
export const GoalCardNotificationContentGoalCardSlotFragmentDoc = gql`
    fragment GoalCardNotificationContentGoalCardSlot on GoalCardGoalCardSlot {
  id
  progress {
    percentage
    value
    completed
  }
  goalCard {
    ...GoalCardNotificationContentGoalCard
  }
}
    ${GoalCardNotificationContentGoalCardFragmentDoc}`;
export const PartyInviteNotificationContentPartyFragmentDoc = gql`
    fragment PartyInviteNotificationContentParty on PartyParty {
  id
  streamId
  channel {
    id
    name
  }
}
    `;
export const PartyInviteNotificationContentLeaderProfileFragmentDoc = gql`
    fragment PartyInviteNotificationContentLeaderProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const StoreItemNotificationContentStoreV2SellableItemFragmentDoc = gql`
    fragment StoreItemNotificationContentStoreV2SellableItem on StoreV2SellableItem {
  name
  type
}
    `;
export const TimedAdsHeaderFragmentDoc = gql`
    fragment TimedAdsHeader on AdsGetPlacementResponse {
  placementId
}
    `;
export const TimedAdsHeaderRewardsFragmentDoc = gql`
    fragment TimedAdsHeaderRewards on AdsRewardDescription {
  readyAt
}
    `;
export const TimedAdsLegendPrizeFragmentDoc = gql`
    fragment TimedAdsLegendPrize on AdsRewardDescriptionPrizeDescription {
  value
  min
  max
}
    `;
export const TimedAdsRewardRowRewardFragmentDoc = gql`
    fragment TimedAdsRewardRowReward on AdsRewardDescription {
  rarity
  readyAt
  prizes {
    min
    max
    ...TimedAdsLegendPrize
  }
}
    ${TimedAdsLegendPrizeFragmentDoc}`;
export const TimedAdsSelectionRewardsFragmentDoc = gql`
    fragment TimedAdsSelectionRewards on AdsRewardDescription {
  rarity
  readyAt
  prizes {
    min
    max
    ...TimedAdsLegendPrize
  }
  ...TimedAdsRewardRowReward
}
    ${TimedAdsLegendPrizeFragmentDoc}
${TimedAdsRewardRowRewardFragmentDoc}`;
export const TimedAdsVideoRewardFragmentDoc = gql`
    fragment TimedAdsVideoReward on AdsRewardDescription {
  rarity
  prizes {
    value
    min
    max
  }
}
    `;
export const TimedAdsContentRewardFragmentDoc = gql`
    fragment TimedAdsContentReward on AdsRewardDescription {
  ...TimedAdsSelectionRewards
  ...TimedAdsVideoReward
}
    ${TimedAdsSelectionRewardsFragmentDoc}
${TimedAdsVideoRewardFragmentDoc}`;
export const TimedAdsModalAdRewardFragmentDoc = gql`
    fragment TimedAdsModalAdReward on AdsRewardDescription {
  ...TimedAdsHeaderRewards
  ...TimedAdsContentReward
}
    ${TimedAdsHeaderRewardsFragmentDoc}
${TimedAdsContentRewardFragmentDoc}`;
export const TimedAdsContentFragmentDoc = gql`
    fragment TimedAdsContent on AdsGetPlacementResponse {
  rewards {
    ...TimedAdsContentReward
  }
}
    ${TimedAdsContentRewardFragmentDoc}`;
export const TimedAdsModalAdFragmentDoc = gql`
    fragment TimedAdsModalAd on AdsGetPlacementResponse {
  placementId
  rewards {
    ...TimedAdsModalAdReward
  }
  ...TimedAdsContent
}
    ${TimedAdsModalAdRewardFragmentDoc}
${TimedAdsContentFragmentDoc}`;
export const AvailableRewardsRewardFragmentDoc = gql`
    fragment AvailableRewardsReward on AdsRewardDescription {
  readyAt
}
    `;
export const UpdateProfileOnUsernameChangeNotificationFragmentDoc = gql`
    fragment UpdateProfileOnUsernameChangeNotification on ProfileProfile {
  userTag
  canChangeUsernameAt
  usernameHistory(limit: 1) {
    reason
  }
}
    `;
export const SearchInputChannelLinkChannelFragmentDoc = gql`
    fragment SearchInputChannelLinkChannel on ChannelChannel {
  id
  name
  liveStatus
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const SearchMatchResultChannelFragmentDoc = gql`
    fragment SearchMatchResultChannel on ChannelChannel {
  id
  ...SearchInputChannelLinkChannel
}
    ${SearchInputChannelLinkChannelFragmentDoc}`;
export const SearchInputCategoryLinkGameFragmentDoc = gql`
    fragment SearchInputCategoryLinkGame on GameGame {
  id
  name
  coverImageUrl
}
    `;
export const SearchMatchResultCategoryFragmentDoc = gql`
    fragment SearchMatchResultCategory on ChannelGameStats {
  gameId
  game {
    id
    ...SearchInputCategoryLinkGame
  }
}
    ${SearchInputCategoryLinkGameFragmentDoc}`;
export const GameCardBackgroundArtStreamerCardFragmentDoc = gql`
    fragment GameCardBackgroundArtStreamerCard on GameLogicStreamerCard {
  id
  image
}
    `;
export const GameCardBackgroundVideoStreamerCardFragmentDoc = gql`
    fragment GameCardBackgroundVideoStreamerCard on GameLogicStreamerCard {
  id
  video
  channel {
    id
  }
}
    `;
export const GameCardBottomLabelStreamerCardFragmentDoc = gql`
    fragment GameCardBottomLabelStreamerCard on GameLogicStreamerCard {
  id
  channel {
    id
    name
  }
}
    `;
export const GameCardFrameStreamerCardFragmentDoc = gql`
    fragment GameCardFrameStreamerCard on GameLogicStreamerCard {
  id
  image
}
    `;
export const GameCardPointsStreamerCardFragmentDoc = gql`
    fragment GameCardPointsStreamerCard on GameLogicStreamerCard {
  id
}
    `;
export const GameCardStreamerDialogStreamerCardFragmentDoc = gql`
    fragment GameCardStreamerDialogStreamerCard on GameLogicStreamerCard {
  id
  video
  channel {
    id
    name
    ...ChannelLogoChannel
  }
}
    ${ChannelLogoChannelFragmentDoc}`;
export const GameCardTypeBadgeStreamerCardFragmentDoc = gql`
    fragment GameCardTypeBadgeStreamerCard on GameLogicStreamerCard {
  id
  channel {
    id
    logo
  }
}
    `;
export const GameStreamerCardFragmentDoc = gql`
    fragment GameStreamerCard on GameLogicStreamerCard {
  id
  ...GameCardBackgroundArtStreamerCard
  ...GameCardBackgroundVideoStreamerCard
  ...GameCardBottomLabelStreamerCard
  ...GameCardFrameStreamerCard
  ...GameCardPointsStreamerCard
  ...GameCardStreamerDialogStreamerCard
  ...GameCardTypeBadgeStreamerCard
}
    ${GameCardBackgroundArtStreamerCardFragmentDoc}
${GameCardBackgroundVideoStreamerCardFragmentDoc}
${GameCardBottomLabelStreamerCardFragmentDoc}
${GameCardFrameStreamerCardFragmentDoc}
${GameCardPointsStreamerCardFragmentDoc}
${GameCardStreamerDialogStreamerCardFragmentDoc}
${GameCardTypeBadgeStreamerCardFragmentDoc}`;
export const GameCardBackgroundArtCardFragmentDoc = gql`
    fragment GameCardBackgroundArtCard on GameLogicCard {
  leveling {
    currentLevel
  }
  rarity
  seasonId
}
    `;
export const GameCardBottomLabelCardFragmentDoc = gql`
    fragment GameCardBottomLabelCard on GameLogicCard {
  isAllOrNothing
  isMatchCard
}
    `;
export const GameCardFrameCardFragmentDoc = gql`
    fragment GameCardFrameCard on GameLogicCard {
  leveling {
    currentLevel
  }
}
    `;
export const GameCardHeroCardFragmentDoc = gql`
    fragment GameCardHeroCard on GameLogicCard {
  leveling {
    currentLevel
  }
  icon
}
    `;
export const GameStateCardTargetValuesFragmentDoc = gql`
    fragment GameStateCardTargetValues on GameLogicCard {
  targetValues {
    label
    value
    selector {
      attribute
      value {
        __typename
        ... on BooleanType {
          booleanValue: value
        }
        ... on IntType {
          intValue: value
        }
        ... on StringType {
          stringValue: value
        }
      }
    }
  }
}
    `;
export const GameCardInfoDescriptionCardFragmentDoc = gql`
    fragment GameCardInfoDescriptionCard on GameLogicCard {
  description
  targetValue
  timerDuration
  ...GameStateCardTargetValues
}
    ${GameStateCardTargetValuesFragmentDoc}`;
export const GameCardInfoCardFragmentDoc = gql`
    fragment GameCardInfoCard on GameLogicCard {
  name
  ...GameCardInfoDescriptionCard
}
    ${GameCardInfoDescriptionCardFragmentDoc}`;
export const GameCardLevelCardFragmentDoc = gql`
    fragment GameCardLevelCard on GameLogicCard {
  leveling {
    currentLevel
  }
  seasonId
}
    `;
export const GameCardPointsCardFragmentDoc = gql`
    fragment GameCardPointsCard on GameLogicCard {
  pointsMax
  pointsMin
  isAllOrNothing
}
    `;
export const GameCardTypeBadgeCardFragmentDoc = gql`
    fragment GameCardTypeBadgeCard on GameLogicCard {
  isAllOrNothing
  isMatchCard
}
    `;
export const GameStreamerBaseCardFragmentDoc = gql`
    fragment GameStreamerBaseCard on GameLogicCard {
  id
  name
  ...GameCardBackgroundArtCard
  ...GameCardBottomLabelCard
  ...GameCardFrameCard
  ...GameCardHeroCard
  ...GameCardInfoCard
  ...GameCardLevelCard
  ...GameCardPointsCard
  ...GameCardTypeBadgeCard
}
    ${GameCardBackgroundArtCardFragmentDoc}
${GameCardBottomLabelCardFragmentDoc}
${GameCardFrameCardFragmentDoc}
${GameCardHeroCardFragmentDoc}
${GameCardInfoCardFragmentDoc}
${GameCardLevelCardFragmentDoc}
${GameCardPointsCardFragmentDoc}
${GameCardTypeBadgeCardFragmentDoc}`;
export const GameCardFragmentDoc = gql`
    fragment GameCard on GameLogicCard {
  id
  activeStreamerCard {
    id
    ...GameStreamerCard
  }
  ...GameStreamerBaseCard
}
    ${GameStreamerCardFragmentDoc}
${GameStreamerBaseCardFragmentDoc}`;
export const SeasonDialogCardFanCardFragmentDoc = gql`
    fragment SeasonDialogCardFanCard on GameLogicCard {
  id
  ...GameCard
}
    ${GameCardFragmentDoc}`;
export const SeasonDialogBaseSeasonFragmentDoc = gql`
    fragment SeasonDialogBaseSeason on GameSeason {
  id
  name
  badgeUrl
  cardBackgroundUrls {
    rarity
    url
  }
  game {
    id
    name
  }
}
    `;
export const SeasonCardRewardsDialogFragmentDoc = gql`
    fragment SeasonCardRewardsDialog on GameLogicCard {
  id
  ...SeasonDialogCardFanCard
  season {
    id
    ...SeasonDialogBaseSeason
  }
}
    ${SeasonDialogCardFanCardFragmentDoc}
${SeasonDialogBaseSeasonFragmentDoc}`;
export const SeasonEndDialogSeasonFragmentDoc = gql`
    fragment SeasonEndDialogSeason on GameSeason {
  id
  name
  progression(user_id: $userId) {
    seasonId
    level
    xpAmount
  }
  ...SeasonDialogBaseSeason
}
    ${SeasonDialogBaseSeasonFragmentDoc}`;
export const SeasonEndDialogProfileFragmentDoc = gql`
    fragment SeasonEndDialogProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatarFullbody
  }
}
    `;
export const SeasonEndDialogProfileStatsFragmentDoc = gql`
    fragment SeasonEndDialogProfileStats on PlayerStatsPlayerStats {
  matchesPlayed
}
    `;
export const SeasonEndDialogInventoryFragmentDoc = gql`
    fragment SeasonEndDialogInventory on InventoryInventoryItem {
  itemId
  item {
    id
    type
  }
}
    `;
export const UseEndSeasonEndDialogsProfileFragmentDoc = gql`
    fragment UseEndSeasonEndDialogsProfile on ProfileProfile {
  playedGames {
    id
    userId
    seasonId
    game {
      id
      activeSeasonId
    }
  }
}
    `;
export const SeasonEndDialogWrapperProfileFragmentDoc = gql`
    fragment SeasonEndDialogWrapperProfile on ProfileProfile {
  ...UseEndSeasonEndDialogsProfile
}
    ${UseEndSeasonEndDialogsProfileFragmentDoc}`;
export const UseSeasonEndDialogsSeasonFragmentDoc = gql`
    fragment UseSeasonEndDialogsSeason on GameSeason {
  id
  gameId
}
    `;
export const CardProgressFragmentDoc = gql`
    fragment CardProgress on GameLogicCardLeveling {
  currentLevel
  progressToNextLevel
  nextLevelLimit
}
    `;
export const CardProgressCardFragmentDoc = gql`
    fragment CardProgressCard on GameLogicCard {
  id
  name
  leveling {
    ...CardProgress
  }
}
    ${CardProgressFragmentDoc}`;
export const UnlockedCardGameCardFragmentDoc = gql`
    fragment UnlockedCardGameCard on GameLogicCard {
  id
  seasonId
  ...GameCard
  ...CardProgressCard
  activeStreamerCards {
    ...GameStreamerCard
    channel {
      id
      ...ChannelLogoChannel
    }
  }
}
    ${GameCardFragmentDoc}
${CardProgressCardFragmentDoc}
${GameStreamerCardFragmentDoc}
${ChannelLogoChannelFragmentDoc}`;
export const CardStackCardFragmentDoc = gql`
    fragment CardStackCard on GameLogicCard {
  id
  ...GameCard
  activeStreamerCards {
    ...GameStreamerCard
  }
}
    ${GameCardFragmentDoc}
${GameStreamerCardFragmentDoc}`;
export const UncollectedCardGameCardFragmentDoc = gql`
    fragment UncollectedCardGameCard on GameLogicCard {
  id
  seasonId
  ...CardStackCard
}
    ${CardStackCardFragmentDoc}`;
export const LockedCardGameCardFragmentDoc = gql`
    fragment LockedCardGameCard on GameLogicCard {
  id
  ...CardStackCard
}
    ${CardStackCardFragmentDoc}`;
export const CardGridGameCardFragmentDoc = gql`
    fragment CardGridGameCard on GameLogicCard {
  id
  seasonId
  ...UnlockedCardGameCard
  ...UncollectedCardGameCard
  ...LockedCardGameCard
}
    ${UnlockedCardGameCardFragmentDoc}
${UncollectedCardGameCardFragmentDoc}
${LockedCardGameCardFragmentDoc}`;
export const CardDetailLevelCardLevelingFragmentDoc = gql`
    fragment CardDetailLevelCardLeveling on GameLogicCard {
  id
  leveling {
    currentLevel
    progressToNextLevel
    nextLevelLimit
  }
  ...CardProgressCard
}
    ${CardProgressCardFragmentDoc}`;
export const CollectionItemModalBaseCardFragmentDoc = gql`
    fragment CollectionItemModalBaseCard on GameLogicCard {
  id
  season {
    id
    name
    badgeUrl
    game {
      id
      name
    }
  }
  activeStreamerCards {
    id
  }
  ...GameCard
}
    ${GameCardFragmentDoc}`;
export const UseBaseCardsGameCardFragmentDoc = gql`
    fragment UseBaseCardsGameCard on GameLogicCard {
  id
  seasonId
  ...CardGridGameCard
  ...CardDetailLevelCardLeveling
  ...CollectionItemModalBaseCard
}
    ${CardGridGameCardFragmentDoc}
${CardDetailLevelCardLevelingFragmentDoc}
${CollectionItemModalBaseCardFragmentDoc}`;
export const UnclaimedSeasonRewardFragmentDoc = gql`
    fragment UnclaimedSeasonReward on RewardReward {
  id
  rewardedAt
  reason {
    reason {
      ... on ReasonReasonLevelUp {
        level
        season {
          id
          name
          cardBackgroundUrls {
            rarity
            url
          }
          game {
            id
            name
          }
        }
      }
    }
  }
  type {
    reward {
      __typename
      ... on RewardRewardTypeItem {
        item {
          gameId
          seasonId
          details {
            ... on GameLogicCard {
              ...UseBaseCardsGameCard
            }
          }
        }
      }
      ... on RewardRewardTypeCurrency {
        currencyId
        currencyAmount
      }
    }
  }
}
    ${UseBaseCardsGameCardFragmentDoc}`;
export const GameSeasonSelectorSeasonFragmentDoc = gql`
    fragment GameSeasonSelectorSeason on GameSeason {
  id
  name
  badgeUrl
  gameId
  startTime
  endTime
}
    `;
export const SeasonStartDialogCardFragmentDoc = gql`
    fragment SeasonStartDialogCard on GameLogicCard {
  id
  ...SeasonDialogCardFanCard
  season {
    id
    ...SeasonDialogBaseSeason
  }
}
    ${SeasonDialogCardFanCardFragmentDoc}
${SeasonDialogBaseSeasonFragmentDoc}`;
export const CardBundlePurchaseButtonCurrencyPriceFragmentDoc = gql`
    fragment CardBundlePurchaseButtonCurrencyPrice on StoreV2InGameCurrencyPrice {
  currencyId
  amount
  default
}
    `;
export const StoreItemContentCardItemRefFragmentDoc = gql`
    fragment StoreItemContentCardItemRef on StoreV2ItemRef {
  id
  count
  item {
    id
    details {
      ... on GameLogicStreamerCard {
        id
        ...GameStreamerCard
        baseCard {
          ...GameStreamerBaseCard
        }
      }
      ... on GameLogicCard {
        id
        ...GameCard
      }
    }
  }
  inventoryState {
    itemId
    item {
      id
      details {
        __typename
        ... on GameLogicCard {
          id
          leveling {
            progressToNextLevel
            nextLevelLimit
          }
          ...GameCard
        }
        ... on GameLogicStreamerCard {
          id
          baseCard {
            leveling {
              progressToNextLevel
              nextLevelLimit
            }
          }
        }
      }
    }
  }
}
    ${GameStreamerCardFragmentDoc}
${GameStreamerBaseCardFragmentDoc}
${GameCardFragmentDoc}`;
export const CardBundleTitleGameFragmentDoc = gql`
    fragment CardBundleTitleGame on GameGame {
  name
  activeSeason {
    id
    name
    endTime
  }
}
    `;
export const UpgradedCardLevelDetailsFragmentDoc = gql`
    fragment UpgradedCardLevelDetails on GameLogicCard {
  leveling {
    currentLevel
  }
  pointsMin
  pointsMax
}
    `;
export const StoreSuccessCardBaseCardFragmentDoc = gql`
    fragment StoreSuccessCardBaseCard on GameLogicCard {
  id
  familyId
  leveling {
    nextLevelLimit
    progressToNextLevel
    currentLevel
  }
  name
  ...UpgradedCardLevelDetails
}
    ${UpgradedCardLevelDetailsFragmentDoc}`;
export const StoreSuccessCardGameLogicCardFragmentDoc = gql`
    fragment StoreSuccessCardGameLogicCard on GameLogicCard {
  id
  familyId
  ...StoreSuccessCardBaseCard
  ...GameCard
}
    ${StoreSuccessCardBaseCardFragmentDoc}
${GameCardFragmentDoc}`;
export const StoreSuccessCardStreamerLogicCardFragmentDoc = gql`
    fragment StoreSuccessCardStreamerLogicCard on GameLogicStreamerCard {
  id
  familyId
  ...GameStreamerCard
  baseCard {
    id
    ...StoreSuccessCardBaseCard
    ...GameStreamerBaseCard
  }
}
    ${GameStreamerCardFragmentDoc}
${StoreSuccessCardBaseCardFragmentDoc}
${GameStreamerBaseCardFragmentDoc}`;
export const StoreSuccessCardItemItemFragmentDoc = gql`
    fragment StoreSuccessCardItemItem on ItemItem {
  id
  details {
    ... on GameLogicCard {
      ...StoreSuccessCardGameLogicCard
    }
    ... on GameLogicStreamerCard {
      ...StoreSuccessCardStreamerLogicCard
    }
  }
}
    ${StoreSuccessCardGameLogicCardFragmentDoc}
${StoreSuccessCardStreamerLogicCardFragmentDoc}`;
export const StoreItemSuccessCardItemRefFragmentDoc = gql`
    fragment StoreItemSuccessCardItemRef on StoreV2ItemRef {
  count
  item {
    id
    ...StoreSuccessCardItemItem
  }
  inventoryState {
    itemId
    item {
      id
      ...StoreSuccessCardItemItem
    }
  }
}
    ${StoreSuccessCardItemItemFragmentDoc}`;
export const CardBundlePurchaseSuccessItemRefFragmentDoc = gql`
    fragment CardBundlePurchaseSuccessItemRef on StoreV2ItemRef {
  id
  ...StoreItemSuccessCardItemRef
}
    ${StoreItemSuccessCardItemRefFragmentDoc}`;
export const StoreItemItemRefFragmentDoc = gql`
    fragment StoreItemItemRef on StoreV2ItemRef {
  id
  ...CardBundlePurchaseSuccessItemRef
}
    ${CardBundlePurchaseSuccessItemRefFragmentDoc}`;
export const StoreItemNavigationChannelFragmentDoc = gql`
    fragment StoreItemNavigationChannel on ChannelChannel {
  id
  name
}
    `;
export const StoreItemPageChannelFragmentDoc = gql`
    fragment StoreItemPageChannel on ChannelChannel {
  ...StoreItemNavigationChannel
}
    ${StoreItemNavigationChannelFragmentDoc}`;
export const StoreItemRevealedAnalyticsIgcPriceFragmentDoc = gql`
    fragment StoreItemRevealedAnalyticsIgcPrice on StoreV2InGameCurrencyPrice {
  currencyId
  default
  amount
}
    `;
export const StoreItemRevealedAnalyticsSellableItemFragmentDoc = gql`
    fragment StoreItemRevealedAnalyticsSellableItem on StoreV2SellableItem {
  id
  signature
  type
  content {
    value {
      ... on StoreV2ItemRef {
        id
      }
      ... on StoreV2CurrencyRef {
        id
      }
      ... on StoreV2SubscriptionRef {
        id
      }
    }
  }
  igcPrices {
    ...StoreItemRevealedAnalyticsIgcPrice
  }
}
    ${StoreItemRevealedAnalyticsIgcPriceFragmentDoc}`;
export const StoreItemRevealedItemsFragmentDoc = gql`
    fragment StoreItemRevealedItems on StoreV2SellableItem {
  id
  signature
  content {
    value {
      __typename
      ... on StoreV2ItemRef {
        id
        item {
          id
          details {
            __typename
            ... on GameLogicCard {
              id
              rarity
            }
          }
        }
      }
      ... on StoreV2CurrencyRef {
        id
      }
    }
  }
  ...StoreItemRevealedAnalyticsSellableItem
}
    ${StoreItemRevealedAnalyticsSellableItemFragmentDoc}`;
export const GiftSubscriptionGetChannelIdSellableItemFragmentDoc = gql`
    fragment GiftSubscriptionGetChannelIdSellableItem on StoreV2SellableItem {
  content {
    value {
      __typename
      ... on StoreV2SubscriptionRef {
        channelId
      }
    }
  }
}
    `;
export const OverviewSubscriptionContentSellableItemFragmentDoc = gql`
    fragment OverviewSubscriptionContentSellableItem on StoreV2SellableItem {
  ...GiftSubscriptionGetChannelIdSellableItem
}
    ${GiftSubscriptionGetChannelIdSellableItemFragmentDoc}`;
export const SellableItemContentTextFragmentDoc = gql`
    fragment SellableItemContentText on StoreV2SellableItem {
  content {
    value {
      __typename
      ... on StoreV2CurrencyRef {
        amount
        id
      }
    }
  }
}
    `;
export const OverviewCurrencyContentSellableItemFragmentDoc = gql`
    fragment OverviewCurrencyContentSellableItem on StoreV2SellableItem {
  name
  price {
    amount
    amountWithoutDiscount
    currency
  }
  ...SellableItemContentText
}
    ${SellableItemContentTextFragmentDoc}`;
export const SendGiftDialogOverviewContentSellableItemFragmentDoc = gql`
    fragment SendGiftDialogOverviewContentSellableItem on StoreV2SellableItem {
  type
  content {
    value {
      ... on StoreV2SubscriptionRef {
        channelId
        amount
      }
    }
  }
  ...OverviewSubscriptionContentSellableItem
  ...OverviewCurrencyContentSellableItem
}
    ${OverviewSubscriptionContentSellableItemFragmentDoc}
${OverviewCurrencyContentSellableItemFragmentDoc}`;
export const SendGiftDialogOverviewActionsSellableItemFragmentDoc = gql`
    fragment SendGiftDialogOverviewActionsSellableItem on StoreV2SellableItem {
  content {
    value {
      ... on StoreV2SubscriptionRef {
        amount
      }
    }
  }
  price {
    currency
    amount
  }
}
    `;
export const SendGiftToUserDialogPaymentSellableItemFragmentDoc = gql`
    fragment SendGiftToUserDialogPaymentSellableItem on StoreV2SellableItem {
  type
  name
  price {
    amount
    amountWithoutDiscount
    currency
  }
}
    `;
export const SendGiftDialogSellableItemFragmentDoc = gql`
    fragment SendGiftDialogSellableItem on StoreV2SellableItem {
  id
  signature
  ...SendGiftDialogOverviewContentSellableItem
  ...SendGiftDialogOverviewActionsSellableItem
  ...SendGiftToUserDialogPaymentSellableItem
}
    ${SendGiftDialogOverviewContentSellableItemFragmentDoc}
${SendGiftDialogOverviewActionsSellableItemFragmentDoc}
${SendGiftToUserDialogPaymentSellableItemFragmentDoc}`;
export const SendGiftToUserProfileFragmentDoc = gql`
    fragment SendGiftToUserProfile on ProfileProfile {
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const SendGiftToUserDialogProfileFragmentDoc = gql`
    fragment SendGiftToUserDialogProfile on ProfileProfile {
  userId
  ...SendGiftToUserProfile
}
    ${SendGiftToUserProfileFragmentDoc}`;
export const GiftableItemFragmentDoc = gql`
    fragment GiftableItem on StoreV2SellableItem {
  id
  content {
    value {
      ... on StoreV2SubscriptionRef {
        amount
      }
    }
  }
}
    `;
export const GiftPaymentSessionFragmentDoc = gql`
    fragment GiftPaymentSession on StoreV2BuyWithPaymentResponse {
  orderId
  session {
    session {
      ... on AdyenSession {
        id
        reference
        returnUrl
        sessionData
        amount {
          value
          currency
        }
      }
    }
  }
}
    `;
export const UpdateSubscriptionOnGiftChannelFragmentDoc = gql`
    fragment UpdateSubscriptionOnGiftChannel on ChannelChannel {
  subscription {
    state
  }
}
    `;
export const CardBundleSellableItemPriceFragmentDoc = gql`
    fragment CardBundleSellableItemPrice on StoreV2InGameCurrencyPrice {
  currencyId
  default
  amount
  amountWithoutDiscount
}
    `;
export const CardBundleCardContentSellableItemFragmentDoc = gql`
    fragment CardBundleCardContentSellableItem on StoreV2SellableItem {
  name
  content {
    value {
      ... on StoreV2ItemRef {
        __typename
        count
        item {
          id
          game {
            id
            name
          }
          details {
            __typename
            ... on GameLogicCard {
              id
              rarity
            }
          }
        }
      }
    }
  }
}
    `;
export const CardBundleAssetGameLogicCardFragmentDoc = gql`
    fragment CardBundleAssetGameLogicCard on GameLogicCard {
  id
  rarity
  ...GameCard
}
    ${GameCardFragmentDoc}`;
export const CardBundleAssetGameLogicStreamerCardFragmentDoc = gql`
    fragment CardBundleAssetGameLogicStreamerCard on GameLogicStreamerCard {
  id
  ...GameStreamerCard
  baseCard {
    id
    rarity
    ...GameStreamerBaseCard
  }
}
    ${GameStreamerCardFragmentDoc}
${GameStreamerBaseCardFragmentDoc}`;
export const CardBundleCardAssetImageSellableItemFragmentDoc = gql`
    fragment CardBundleCardAssetImageSellableItem on StoreV2SellableItem {
  type
  content {
    value {
      ... on StoreV2ItemRef {
        id
        __typename
        count
        item {
          id
          details {
            __typename
            ... on GameLogicCard {
              ...CardBundleAssetGameLogicCard
            }
            ... on GameLogicStreamerCard {
              ...CardBundleAssetGameLogicStreamerCard
            }
          }
        }
      }
    }
  }
}
    ${CardBundleAssetGameLogicCardFragmentDoc}
${CardBundleAssetGameLogicStreamerCardFragmentDoc}`;
export const StoreCardDiscountLabelSellableItemFragmentDoc = gql`
    fragment StoreCardDiscountLabelSellableItem on StoreV2SellableItem {
  discountPercent
  promotionName
}
    `;
export const CardBundleSellableItemFragmentDoc = gql`
    fragment CardBundleSellableItem on StoreV2SellableItem {
  type
  igcPrices {
    ...CardBundleSellableItemPrice
  }
  content {
    value {
      ... on StoreV2ItemRef {
        __typename
        count
        item {
          id
          season {
            id
            cardBackgroundUrls {
              url
              rarity
            }
          }
        }
      }
    }
  }
  ...CardBundleCardContentSellableItem
  ...CardBundleCardAssetImageSellableItem
  ...StoreCardDiscountLabelSellableItem
}
    ${CardBundleSellableItemPriceFragmentDoc}
${CardBundleCardContentSellableItemFragmentDoc}
${CardBundleCardAssetImageSellableItemFragmentDoc}
${StoreCardDiscountLabelSellableItemFragmentDoc}`;
export const StoreCardBundleAnalyticsIgcPriceFragmentDoc = gql`
    fragment StoreCardBundleAnalyticsIgcPrice on StoreV2InGameCurrencyPrice {
  currencyId
  default
  amount
}
    `;
export const StoreCardBundleAnalyticsSellableItemFragmentDoc = gql`
    fragment StoreCardBundleAnalyticsSellableItem on StoreV2SellableItem {
  id
  signature
  type
  content {
    value {
      ... on StoreV2ItemRef {
        id
      }
      ... on StoreV2CurrencyRef {
        id
      }
      ... on StoreV2SubscriptionRef {
        id
      }
    }
  }
  igcPrices {
    ...StoreCardBundleAnalyticsIgcPrice
  }
}
    ${StoreCardBundleAnalyticsIgcPriceFragmentDoc}`;
export const StoreCardBundleCategoryFragmentDoc = gql`
    fragment StoreCardBundleCategory on StoreV2StoreFrontCategory {
  itemType
  sellableItems {
    id
    signature
    ...CardBundleSellableItem
    ...StoreCardBundleAnalyticsSellableItem
  }
}
    ${CardBundleSellableItemFragmentDoc}
${StoreCardBundleAnalyticsSellableItemFragmentDoc}`;
export const CurrencyCardImageCurrencyPriceFragmentDoc = gql`
    fragment CurrencyCardImageCurrencyPrice on StoreV2InGameCurrencyPrice {
  currencyId
  amount
  amountWithoutDiscount
}
    `;
export const CurrencyCardSellableItemFragmentDoc = gql`
    fragment CurrencyCardSellableItem on StoreV2SellableItem {
  price {
    currency
    amount
    amountWithoutDiscount
  }
  igcPrices {
    ...CurrencyCardImageCurrencyPrice
  }
  ...SellableItemContentText
  ...StoreCardDiscountLabelSellableItem
}
    ${CurrencyCardImageCurrencyPriceFragmentDoc}
${SellableItemContentTextFragmentDoc}
${StoreCardDiscountLabelSellableItemFragmentDoc}`;
export const InGameCurrencyBuyOverlayItemPriceFragmentDoc = gql`
    fragment InGameCurrencyBuyOverlayItemPrice on StoreV2InGameCurrencyPrice {
  currencyId
  default
  amount
  amountWithoutDiscount
}
    `;
export const InGameCurrencyBuyOverlaySellableItemFragmentDoc = gql`
    fragment InGameCurrencyBuyOverlaySellableItem on StoreV2SellableItem {
  igcPrices {
    ...InGameCurrencyBuyOverlayItemPrice
  }
  ...SellableItemContentText
}
    ${InGameCurrencyBuyOverlayItemPriceFragmentDoc}
${SellableItemContentTextFragmentDoc}`;
export const InGameCurrencyBuyCurrencyCardIgcPriceFragmentDoc = gql`
    fragment InGameCurrencyBuyCurrencyCardIgcPrice on StoreV2InGameCurrencyPrice {
  currencyId
  default
  amount
}
    `;
export const InGameCurrencyBuyCurrencyCardSellableItemFragmentDoc = gql`
    fragment InGameCurrencyBuyCurrencyCardSellableItem on StoreV2SellableItem {
  id
  signature
  ...CurrencyCardSellableItem
  ...InGameCurrencyBuyOverlaySellableItem
  igcPrices {
    ...InGameCurrencyBuyCurrencyCardIgcPrice
  }
  sku
}
    ${CurrencyCardSellableItemFragmentDoc}
${InGameCurrencyBuyOverlaySellableItemFragmentDoc}
${InGameCurrencyBuyCurrencyCardIgcPriceFragmentDoc}`;
export const AdyenOverlaySellableItemFragmentDoc = gql`
    fragment AdyenOverlaySellableItem on StoreV2SellableItem {
  name
  price {
    currency
    amount
  }
  ...SellableItemContentText
}
    ${SellableItemContentTextFragmentDoc}`;
export const PaymentBuyCurrencyCardSellableItemFragmentDoc = gql`
    fragment PaymentBuyCurrencyCardSellableItem on StoreV2SellableItem {
  id
  signature
  ...CurrencyCardSellableItem
  ...AdyenOverlaySellableItem
}
    ${CurrencyCardSellableItemFragmentDoc}
${AdyenOverlaySellableItemFragmentDoc}`;
export const CurrencyListStoreFrontCategoryFragmentDoc = gql`
    fragment CurrencyListStoreFrontCategory on StoreV2StoreFrontCategory {
  id
  sellableItems {
    ...InGameCurrencyBuyCurrencyCardSellableItem
    ...PaymentBuyCurrencyCardSellableItem
  }
}
    ${InGameCurrencyBuyCurrencyCardSellableItemFragmentDoc}
${PaymentBuyCurrencyCardSellableItemFragmentDoc}`;
export const StoreCurrencyPackCategoryFragmentDoc = gql`
    fragment StoreCurrencyPackCategory on StoreV2StoreFrontCategory {
  itemType
  ...CurrencyListStoreFrontCategory
}
    ${CurrencyListStoreFrontCategoryFragmentDoc}`;
export const ShowNewSeasonBannerForUserCategoryFragmentDoc = gql`
    fragment ShowNewSeasonBannerForUserCategory on StoreV2StoreFrontCategory {
  itemType
  sellableItems {
    id
  }
}
    `;
export const PlatformStoreFrontCategoriesCategoryFragmentDoc = gql`
    fragment PlatformStoreFrontCategoriesCategory on StoreV2StoreFrontCategory {
  id
  itemType
  ...StoreCardBundleCategory
  ...StoreCurrencyPackCategory
  ...ShowNewSeasonBannerForUserCategory
}
    ${StoreCardBundleCategoryFragmentDoc}
${StoreCurrencyPackCategoryFragmentDoc}
${ShowNewSeasonBannerForUserCategoryFragmentDoc}`;
export const SellableCreatorCardFragmentDoc = gql`
    fragment SellableCreatorCard on GameLogicStreamerCard {
  id
  channel {
    id
    name
  }
  baseCard {
    id
    season {
      id
      game {
        id
        name
        activeSeason {
          id
          name
        }
      }
    }
    leveling {
      nextLevelLimit
      progressToNextLevel
    }
    ...GameStreamerBaseCard
  }
  ...GameStreamerCard
}
    ${GameStreamerBaseCardFragmentDoc}
${GameStreamerCardFragmentDoc}`;
export const StreamerCardPurchaseDescriptionChannelFragmentDoc = gql`
    fragment StreamerCardPurchaseDescriptionChannel on ChannelChannel {
  name
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const StreamerCardPurchaseDialogStreamerCardFragmentDoc = gql`
    fragment StreamerCardPurchaseDialogStreamerCard on GameLogicStreamerCard {
  channel {
    name
    ...StreamerCardPurchaseDescriptionChannel
  }
  baseCard {
    ...GameStreamerBaseCard
  }
  ...GameStreamerCard
}
    ${StreamerCardPurchaseDescriptionChannelFragmentDoc}
${GameStreamerBaseCardFragmentDoc}
${GameStreamerCardFragmentDoc}`;
export const StreamerCardPurchaseSuccessModalStreamerCardFragmentDoc = gql`
    fragment StreamerCardPurchaseSuccessModalStreamerCard on GameLogicStreamerCard {
  channel {
    id
    name
    ...ChannelLogoChannel
  }
  baseCard {
    ...GameStreamerBaseCard
  }
  ...GameStreamerCard
}
    ${ChannelLogoChannelFragmentDoc}
${GameStreamerBaseCardFragmentDoc}
${GameStreamerCardFragmentDoc}`;
export const StreamerCardPurchaseCardButtonStreamerCardFragmentDoc = gql`
    fragment StreamerCardPurchaseCardButtonStreamerCard on GameLogicStreamerCard {
  channelId
  gameId
  familyId
  ...StreamerCardPurchaseDialogStreamerCard
  ...StreamerCardPurchaseSuccessModalStreamerCard
}
    ${StreamerCardPurchaseDialogStreamerCardFragmentDoc}
${StreamerCardPurchaseSuccessModalStreamerCardFragmentDoc}`;
export const StreamerCardPurchaseCardButtonPriceFragmentDoc = gql`
    fragment StreamerCardPurchaseCardButtonPrice on StoreV2InGameCurrencyPrice {
  amount
  currencyId
}
    `;
export const PurchaseStoreItemSellableItemFragmentDoc = gql`
    fragment PurchaseStoreItemSellableItem on StoreV2SellableItem {
  id
  type
  signature
  igcPrices {
    currencyId
    default
  }
}
    `;
export const StreamerCardPurchaseDialogSellableItemFragmentDoc = gql`
    fragment StreamerCardPurchaseDialogSellableItem on StoreV2SellableItem {
  ...PurchaseStoreItemSellableItem
}
    ${PurchaseStoreItemSellableItemFragmentDoc}`;
export const StreamerCardPurchaseCardButtonSellableItemFragmentDoc = gql`
    fragment StreamerCardPurchaseCardButtonSellableItem on StoreV2SellableItem {
  ...StreamerCardPurchaseDialogSellableItem
  sku
}
    ${StreamerCardPurchaseDialogSellableItemFragmentDoc}`;
export const StoreStreamerCardSellableItemFragmentDoc = gql`
    fragment StoreStreamerCardSellableItem on StoreV2SellableItem {
  id
  discountPercent
  availableUntil
  content {
    value {
      ... on StoreV2ItemRef {
        id
        item {
          id
          details {
            ... on GameLogicStreamerCard {
              id
              ...SellableCreatorCard
              ...StreamerCardPurchaseCardButtonStreamerCard
            }
          }
        }
        inventoryState {
          itemCount
        }
      }
    }
  }
  igcPrices {
    ...StreamerCardPurchaseCardButtonPrice
  }
  ...StreamerCardPurchaseCardButtonSellableItem
}
    ${SellableCreatorCardFragmentDoc}
${StreamerCardPurchaseCardButtonStreamerCardFragmentDoc}
${StreamerCardPurchaseCardButtonPriceFragmentDoc}
${StreamerCardPurchaseCardButtonSellableItemFragmentDoc}`;
export const StoreStreamerCardCategoryFragmentDoc = gql`
    fragment StoreStreamerCardCategory on StoreV2StoreFrontCategory {
  id
  itemType
  sellableItems {
    id
    ...StoreStreamerCardSellableItem
  }
}
    ${StoreStreamerCardSellableItemFragmentDoc}`;
export const StoreChannelStoreAvatarPartFragmentDoc = gql`
    fragment StoreChannelStoreAvatarPart on StoreV2StoreFrontCategory {
  itemType
  sellableItems {
    id
    content {
      value {
        ... on StoreV2ItemRef {
          item {
            details {
              ... on AvatarAvatarPart {
                previewImgUrl
              }
            }
          }
        }
      }
    }
  }
}
    `;
export const ChannelStoreFrontCategoriesContentCategoryFragmentDoc = gql`
    fragment ChannelStoreFrontCategoriesContentCategory on StoreV2StoreFrontCategory {
  itemType
  ...StoreCardBundleCategory
  ...StoreStreamerCardCategory
  ...ShowNewSeasonBannerForUserCategory
  ...StoreChannelStoreAvatarPart
}
    ${StoreCardBundleCategoryFragmentDoc}
${StoreStreamerCardCategoryFragmentDoc}
${ShowNewSeasonBannerForUserCategoryFragmentDoc}
${StoreChannelStoreAvatarPartFragmentDoc}`;
export const ChannelStoreFrontCategoriesCategoryFragmentDoc = gql`
    fragment ChannelStoreFrontCategoriesCategory on StoreV2StoreFrontCategory {
  itemType
  ...ChannelStoreFrontCategoriesContentCategory
}
    ${ChannelStoreFrontCategoriesContentCategoryFragmentDoc}`;
export const StoreFrontCategoriesAnalyticsCategoryFragmentDoc = gql`
    fragment StoreFrontCategoriesAnalyticsCategory on StoreV2StoreFrontCategory {
  itemType
  sellableItems {
    id
    signature
    content {
      value {
        ... on StoreV2ItemRef {
          id
        }
        ... on StoreV2CurrencyRef {
          id
        }
        ... on StoreV2SubscriptionRef {
          id
        }
      }
    }
  }
}
    `;
export const StoreFrontCategoriesCategoryFragmentDoc = gql`
    fragment StoreFrontCategoriesCategory on StoreV2StoreFrontCategory {
  id
  itemType
  ...PlatformStoreFrontCategoriesCategory
  ...ChannelStoreFrontCategoriesCategory
  ...StoreFrontCategoriesAnalyticsCategory
}
    ${PlatformStoreFrontCategoriesCategoryFragmentDoc}
${ChannelStoreFrontCategoriesCategoryFragmentDoc}
${StoreFrontCategoriesAnalyticsCategoryFragmentDoc}`;
export const ShowNewSeasonBannerForUserProfileFragmentDoc = gql`
    fragment ShowNewSeasonBannerForUserProfile on ProfileProfile {
  playedGames {
    id
    userId
    seasonId
    game {
      id
      activeSeasonId
    }
  }
}
    `;
export const ChannelStoreFrontCategoriesContentProfileFragmentDoc = gql`
    fragment ChannelStoreFrontCategoriesContentProfile on ProfileProfile {
  playedGames {
    id
    userId
  }
  ...ShowNewSeasonBannerForUserProfile
}
    ${ShowNewSeasonBannerForUserProfileFragmentDoc}`;
export const ChannelStoreFrontProfileFragmentDoc = gql`
    fragment ChannelStoreFrontProfile on ProfileProfile {
  ...ChannelStoreFrontCategoriesContentProfile
}
    ${ChannelStoreFrontCategoriesContentProfileFragmentDoc}`;
export const StoreGameSelectorGameFragmentDoc = gql`
    fragment StoreGameSelectorGame on GameGame {
  id
  name
}
    `;
export const StoreNewSeasonBannerGameFragmentDoc = gql`
    fragment StoreNewSeasonBannerGame on GameGame {
  id
  name
  activeSeason {
    id
    name
  }
}
    `;
export const PlatformStoreFrontCategoriesProfileFragmentDoc = gql`
    fragment PlatformStoreFrontCategoriesProfile on ProfileProfile {
  userId
  playedGames {
    id
    userId
    game {
      id
      ...StoreGameSelectorGame
      ...StoreNewSeasonBannerGame
    }
  }
  ...ShowNewSeasonBannerForUserProfile
}
    ${StoreGameSelectorGameFragmentDoc}
${StoreNewSeasonBannerGameFragmentDoc}
${ShowNewSeasonBannerForUserProfileFragmentDoc}`;
export const StoreFrontCategoryProfileFragmentDoc = gql`
    fragment StoreFrontCategoryProfile on ProfileProfile {
  ...ChannelStoreFrontProfile
  ...PlatformStoreFrontCategoriesProfile
}
    ${ChannelStoreFrontProfileFragmentDoc}
${PlatformStoreFrontCategoriesProfileFragmentDoc}`;
export const StreamGameProxyStreamFragmentDoc = gql`
    fragment StreamGameProxyStream on ChannelStreamSummary {
  streamId
  channelId
  noicePredictionsEnabled
}
    `;
export const ActiveChannelLiveStatusFragmentDoc = gql`
    fragment ActiveChannelLiveStatus on ChannelChannel {
  liveStatus
  currentStreamId
  id
  matureRatedContent
}
    `;
export const ActiveStreamLiveStatusFragmentDoc = gql`
    fragment ActiveStreamLiveStatus on ChannelStream {
  streamId
  serverRenderingEnabled
}
    `;
export const ActiveChannelSummaryLiveStatusFragmentDoc = gql`
    fragment ActiveChannelSummaryLiveStatus on ChannelStreamSummary {
  streamId
  matureRatedContent
  serverRenderingEnabled
  channelId
}
    `;
export const ActiveMenuCancelUpdateSubscriptionFragmentDoc = gql`
    fragment ActiveMenuCancelUpdateSubscription on SubscriptionChannelSubscription {
  id
  state
}
    `;
export const ChargebeeSubscriptionCancellationModalActionsSubscriptionFragmentDoc = gql`
    fragment ChargebeeSubscriptionCancellationModalActionsSubscription on SubscriptionChannelSubscription {
  id
}
    `;
export const SubscriptionCancellationModalActionsSubscriptionFragmentDoc = gql`
    fragment SubscriptionCancellationModalActionsSubscription on SubscriptionChannelSubscription {
  id
  provider
  ...ChargebeeSubscriptionCancellationModalActionsSubscription
}
    ${ChargebeeSubscriptionCancellationModalActionsSubscriptionFragmentDoc}`;
export const ChargebeeSubscriptionCancellationModalActionsChannelFragmentDoc = gql`
    fragment ChargebeeSubscriptionCancellationModalActionsChannel on ChannelChannel {
  id
}
    `;
export const SubscriptionCancellationModalActionsChannelFragmentDoc = gql`
    fragment SubscriptionCancellationModalActionsChannel on ChannelChannel {
  ...ChargebeeSubscriptionCancellationModalActionsChannel
}
    ${ChargebeeSubscriptionCancellationModalActionsChannelFragmentDoc}`;
export const ChargebeeSubscriptionCancellationModalContentSubscriptionFragmentDoc = gql`
    fragment ChargebeeSubscriptionCancellationModalContentSubscription on SubscriptionChannelSubscription {
  expiresAt
}
    `;
export const SubscriptionCancellationModalContentSubscriptionFragmentDoc = gql`
    fragment SubscriptionCancellationModalContentSubscription on SubscriptionChannelSubscription {
  id
  provider
  ...ChargebeeSubscriptionCancellationModalContentSubscription
}
    ${ChargebeeSubscriptionCancellationModalContentSubscriptionFragmentDoc}`;
export const SubscriptionDialogChannelContentChannelFragmentDoc = gql`
    fragment SubscriptionDialogChannelContentChannel on ChannelChannel {
  name
  logo
  followerCount
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const SubscriptionGetChannelEmojisChannelEmojiFragmentDoc = gql`
    fragment SubscriptionGetChannelEmojisChannelEmoji on EmojiEmoji {
  __typename
  id
  image
  name
}
    `;
export const SubscriptionGetChannelEmojisChannelFragmentDoc = gql`
    fragment SubscriptionGetChannelEmojisChannel on ChannelChannel {
  subscriptionConfig {
    channelId
    tiers {
      level
      entitlements {
        itemId
        item {
          id
          type
          children {
            id
            type
            details {
              ... on EmojiEmoji {
                ...SubscriptionGetChannelEmojisChannelEmoji
              }
            }
          }
        }
      }
    }
  }
}
    ${SubscriptionGetChannelEmojisChannelEmojiFragmentDoc}`;
export const ChargebeeSubscriptionCancellationModalContentChannelFragmentDoc = gql`
    fragment ChargebeeSubscriptionCancellationModalContentChannel on ChannelChannel {
  id
  ...SubscriptionGetChannelEmojisChannel
}
    ${SubscriptionGetChannelEmojisChannelFragmentDoc}`;
export const SubscriptionCancellationModalContentChannelFragmentDoc = gql`
    fragment SubscriptionCancellationModalContentChannel on ChannelChannel {
  id
  ...SubscriptionDialogChannelContentChannel
  ...ChargebeeSubscriptionCancellationModalContentChannel
}
    ${SubscriptionDialogChannelContentChannelFragmentDoc}
${ChargebeeSubscriptionCancellationModalContentChannelFragmentDoc}`;
export const SubscriptionModalCompleteStageChannelFragmentDoc = gql`
    fragment SubscriptionModalCompleteStageChannel on ChannelChannel {
  name
}
    `;
export const SubscriptionModalOverviewStageChannelFragmentDoc = gql`
    fragment SubscriptionModalOverviewStageChannel on ChannelChannel {
  name
  ...SubscriptionGetChannelEmojisChannel
}
    ${SubscriptionGetChannelEmojisChannelFragmentDoc}`;
export const SubscriptionModalActionsChannelFragmentDoc = gql`
    fragment SubscriptionModalActionsChannel on ChannelChannel {
  id
  subscription {
    id
    state
  }
}
    `;
export const SubscriptionModalStageFlowsSubscriptionFragmentDoc = gql`
    fragment SubscriptionModalStageFlowsSubscription on SubscriptionChannelSubscription {
  id
  state
  cancelReason
}
    `;
export const ReactiveSubscriptionChannelFragmentDoc = gql`
    fragment ReactiveSubscriptionChannel on ChannelChannel {
  id
  subscription {
    id
    state
  }
}
    `;
export const ReactiveSubscriptionChannelSubscriptionFragmentDoc = gql`
    fragment ReactiveSubscriptionChannelSubscription on SubscriptionChannelSubscription {
  id
  state
}
    `;
export const SubscriptionCheckoutModalOnClickUpdateChannelFragmentDoc = gql`
    fragment SubscriptionCheckoutModalOnClickUpdateChannel on ChannelChannel {
  id
  subscription {
    id
    state
  }
}
    `;
export const SubscriptionBadgeProfileFragmentDoc = gql`
    fragment SubscriptionBadgeProfile on ProfileProfile {
  badges(channel_id: $channelId) {
    __typename
    type
    level
  }
}
    `;
export const ConsentWarningSettingUpdateProfileFragmentDoc = gql`
    fragment ConsentWarningSettingUpdateProfile on ProfileProfile {
  settings {
    privacy {
      showMatureContentWarning
    }
  }
}
    `;
export const OnlineVisibilityUpdateProfileFragmentDoc = gql`
    fragment OnlineVisibilityUpdateProfile on ProfileProfile {
  userId
  settings {
    privacy {
      hideOnlineStatus
    }
  }
}
    `;
export const MarketingConsentUpdateProfileFragmentDoc = gql`
    fragment MarketingConsentUpdateProfile on ProfileProfile {
  account {
    marketingConsent
  }
}
    `;
export const SelectedSeasonsSeasonFragmentDoc = gql`
    fragment SelectedSeasonsSeason on GameSeason {
  id
  gameId
}
    `;
export const DebugMenuMatchInfoProfileFragmentDoc = gql`
    fragment DebugMenuMatchInfoProfile on ProfileProfile {
  userTag
}
    `;
export const DebugMenuProfileFragmentDoc = gql`
    fragment DebugMenuProfile on ProfileProfile {
  ...DebugMenuMatchInfoProfile
}
    ${DebugMenuMatchInfoProfileFragmentDoc}`;
export const NotificationsTabUsernameRejectedProfileFragmentDoc = gql`
    fragment NotificationsTabUsernameRejectedProfile on ProfileProfile {
  userId
  usernameHistory(limit: 1) {
    reason
    changedAt
  }
}
    `;
export const NotificationProfileFragmentDoc = gql`
    fragment NotificationProfile on ProfileProfile {
  ...NotificationsTabUsernameRejectedProfile
}
    ${NotificationsTabUsernameRejectedProfileFragmentDoc}`;
export const MenuButtonsProfileFragmentDoc = gql`
    fragment MenuButtonsProfile on ProfileProfile {
  ...DebugMenuProfile
  ...NotificationProfile
}
    ${DebugMenuProfileFragmentDoc}
${NotificationProfileFragmentDoc}`;
export const ProfileImageShowOnlineStatusProfileFragmentDoc = gql`
    fragment ProfileImageShowOnlineStatusProfile on ProfileProfile {
  ...ProfileImageProfile
  onlineStatus
  settings {
    privacy {
      hideOnlineStatus
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;
export const ProfileMenuProfileFragmentDoc = gql`
    fragment ProfileMenuProfile on ProfileProfile {
  ...ProfileImageShowOnlineStatusProfile
  ...NotificationProfile
}
    ${ProfileImageShowOnlineStatusProfileFragmentDoc}
${NotificationProfileFragmentDoc}`;
export const PageLayoutHeaderProfileFragmentDoc = gql`
    fragment PageLayoutHeaderProfile on ProfileProfile {
  ...MenuButtonsProfile
  ...ProfileMenuProfile
}
    ${MenuButtonsProfileFragmentDoc}
${ProfileMenuProfileFragmentDoc}`;
export const PageLayoutProfileFragmentDoc = gql`
    fragment PageLayoutProfile on ProfileProfile {
  ...PageLayoutHeaderProfile
}
    ${PageLayoutHeaderProfileFragmentDoc}`;
export const NotificationAnnouncementFragmentDoc = gql`
    fragment NotificationAnnouncement on AnnouncementAnnouncement {
  id
  title
  text
  category
  startTime
}
    `;
export const FriendRequestNotificationContentProfileFragmentDoc = gql`
    fragment FriendRequestNotificationContentProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const NotificationsTabFriendRequestFriendsUserFragmentDoc = gql`
    fragment NotificationsTabFriendRequestFriendsUser on FriendsUser {
  userId
  lastStatusChange
  profile {
    userId
    ...FriendRequestNotificationContentProfile
  }
}
    ${FriendRequestNotificationContentProfileFragmentDoc}`;
export const NotificationsTabSubscriptionPaymentFailedSubscriptionFragmentDoc = gql`
    fragment NotificationsTabSubscriptionPaymentFailedSubscription on SubscriptionChannelSubscription {
  id
  paymentFailedAt
  channel {
    id
    name
  }
}
    `;
export const SeasonNotificationContentSeasonFragmentDoc = gql`
    fragment SeasonNotificationContentSeason on GameSeason {
  id
  name
  game {
    id
    name
  }
  progression(user_id: $userId) {
    level
  }
}
    `;
export const NotificationsTabRewardRewardFragmentDoc = gql`
    fragment NotificationsTabRewardReward on RewardReward {
  id
  rewardedAt
  reason {
    reason {
      ... on ReasonReasonGoalCardComplete {
        goalCardSlotId
        goalCardId
        goalCard {
          id
          ...GoalCardNotificationContentGoalCard
        }
      }
      ... on ReasonReasonLevelUp {
        seasonId
        season {
          id
          ...SeasonNotificationContentSeason
        }
      }
    }
  }
}
    ${GoalCardNotificationContentGoalCardFragmentDoc}
${SeasonNotificationContentSeasonFragmentDoc}`;
export const NotificationRewardFragmentDoc = gql`
    fragment NotificationReward on RewardReward {
  ...NotificationsTabRewardReward
}
    ${NotificationsTabRewardRewardFragmentDoc}`;
export const ChannelButtonOwnChannelFragmentDoc = gql`
    fragment ChannelButtonOwnChannel on ChannelChannel {
  name
}
    `;
export const ChannelButtonProfileFragmentDoc = gql`
    fragment ChannelButtonProfile on ProfileProfile {
  temporary
  account {
    uid
    channelCreationEligibility {
      canCreateChannel
    }
  }
}
    `;
export const HideOnlineStatusSettingSectionProfileFragmentDoc = gql`
    fragment HideOnlineStatusSettingSectionProfile on ProfileProfile {
  settings {
    privacy {
      hideOnlineStatus
    }
  }
}
    `;
export const ProfileMenuLinksSectionProfileFragmentDoc = gql`
    fragment ProfileMenuLinksSectionProfile on ProfileProfile {
  userTag
}
    `;
export const ProfileMenuProfileSectionProfileFragmentDoc = gql`
    fragment ProfileMenuProfileSectionProfile on ProfileProfile {
  userTag
  settings {
    privacy {
      hideOnlineStatus
    }
  }
  ...ProfileImageShowOnlineStatusProfile
}
    ${ProfileImageShowOnlineStatusProfileFragmentDoc}`;
export const ProfileMenuImplicitAccountProfileSectionProfileFragmentDoc = gql`
    fragment ProfileMenuImplicitAccountProfileSectionProfile on ProfileProfile {
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const GoalCardSlotResetTimePastGoalCardSlotFragmentDoc = gql`
    fragment GoalCardSlotResetTimePastGoalCardSlot on GoalCardGoalCardSlot {
  id
  resetTime
}
    `;
export const GoalCardSlotStateGoalCardSlotFragmentDoc = gql`
    fragment GoalCardSlotStateGoalCardSlot on GoalCardGoalCardSlot {
  id
  goalCard {
    id
  }
  progress {
    completed
  }
  reward {
    id
  }
  ...GoalCardSlotResetTimePastGoalCardSlot
}
    ${GoalCardSlotResetTimePastGoalCardSlotFragmentDoc}`;
export const GoalCardSlotReadyForPickGoalCardCardSlotFragmentDoc = gql`
    fragment GoalCardSlotReadyForPickGoalCardCardSlot on GoalCardGoalCardSlot {
  id
  ...GoalCardSlotResetTimePastGoalCardSlot
  ...GoalCardSlotStateGoalCardSlot
}
    ${GoalCardSlotResetTimePastGoalCardSlotFragmentDoc}
${GoalCardSlotStateGoalCardSlotFragmentDoc}`;
export const DailyGoalTooltipContentGoalCardSlotFragmentDoc = gql`
    fragment DailyGoalTooltipContentGoalCardSlot on GoalCardGoalCardSlot {
  id
  reward {
    __typename
  }
  goalCard {
    id
    description
    target
  }
  progress {
    value
    completed
  }
  ...GoalCardSlotStateGoalCardSlot
  ...GoalCardSlotReadyForPickGoalCardCardSlot
}
    ${GoalCardSlotStateGoalCardSlotFragmentDoc}
${GoalCardSlotReadyForPickGoalCardCardSlotFragmentDoc}`;
export const UseDailyGoalsTooltipDataSlotFragmentDoc = gql`
    fragment UseDailyGoalsTooltipDataSlot on GoalCardGoalCardSlot {
  id
  reward {
    id
  }
  resetTime
  progress {
    completed
  }
  ...DailyGoalTooltipContentGoalCardSlot
  ...GoalCardSlotStateGoalCardSlot
  ...GoalCardSlotResetTimePastGoalCardSlot
}
    ${DailyGoalTooltipContentGoalCardSlotFragmentDoc}
${GoalCardSlotStateGoalCardSlotFragmentDoc}
${GoalCardSlotResetTimePastGoalCardSlotFragmentDoc}`;
export const StoreTooltipSellableItemPriceFragmentDoc = gql`
    fragment StoreTooltipSellableItemPrice on StoreV2InGameCurrencyPrice {
  currencyId
  default
  amount
}
    `;
export const SidebarChannelFragmentDoc = gql`
    fragment SidebarChannel on ChannelChannel {
  id
  name
  liveStatus
  game {
    id
    name
  }
  viewerCount
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const AvatarSelectorGridAvatarFragmentDoc = gql`
    fragment AvatarSelectorGridAvatar on AvatarAvatar {
  id
  body
}
    `;
export const UseAvatarSelectorAvatarFragmentDoc = gql`
    fragment UseAvatarSelectorAvatar on AvatarAvatar {
  id
  gender
  avatar3D
  body
  ...AvatarSelectorGridAvatar
}
    ${AvatarSelectorGridAvatarFragmentDoc}`;
export const BrowseChannelsGameFragmentDoc = gql`
    fragment BrowseChannelsGame on GameGame {
  id
  name
}
    `;
export const ChannelPageHeaderChannelFragmentDoc = gql`
    fragment ChannelPageHeaderChannel on ChannelChannel {
  id
  liveStatus
}
    `;
export const ChannelPageLinksChannelFragmentDoc = gql`
    fragment ChannelPageLinksChannel on ChannelChannel {
  links {
    type
    name
    url
  }
}
    `;
export const ChannelPageInfoSectionChannelFragmentDoc = gql`
    fragment ChannelPageInfoSectionChannel on ChannelChannel {
  id
  name
  followerCount
  liveStatus
  streamerId
  currentStreamId
  description
  ...ChannelLogoChannel
  ...ChannelActionButtonsChannel
  ...ChannelPageLinksChannel
}
    ${ChannelLogoChannelFragmentDoc}
${ChannelActionButtonsChannelFragmentDoc}
${ChannelPageLinksChannelFragmentDoc}`;
export const StoreNewSeasonBannerChannelFragmentDoc = gql`
    fragment StoreNewSeasonBannerChannel on ChannelChannel {
  name
}
    `;
export const ChannelStorePremiumBundlePrefixChannelFragmentDoc = gql`
    fragment ChannelStorePremiumBundlePrefixChannel on ChannelChannel {
  name
}
    `;
export const ChannelStoreFrontCategoriesContentChannelFragmentDoc = gql`
    fragment ChannelStoreFrontCategoriesContentChannel on ChannelChannel {
  name
  streamedGames {
    id
    noicePredictionsEnabled
    ...StoreNewSeasonBannerGame
    ...StoreGameSelectorGame
  }
  ...StoreNewSeasonBannerChannel
  ...ChannelStorePremiumBundlePrefixChannel
}
    ${StoreNewSeasonBannerGameFragmentDoc}
${StoreGameSelectorGameFragmentDoc}
${StoreNewSeasonBannerChannelFragmentDoc}
${ChannelStorePremiumBundlePrefixChannelFragmentDoc}`;
export const ChannelStoreFrontChannelFragmentDoc = gql`
    fragment ChannelStoreFrontChannel on ChannelChannel {
  logo
  offlineBanner
  ...ChannelStoreFrontCategoriesContentChannel
}
    ${ChannelStoreFrontCategoriesContentChannelFragmentDoc}`;
export const StoreFrontCategoriesChannelFragmentDoc = gql`
    fragment StoreFrontCategoriesChannel on ChannelChannel {
  id
  ...ChannelStoreFrontChannel
}
    ${ChannelStoreFrontChannelFragmentDoc}`;
export const ChannelStoreRedirectChannelFragmentDoc = gql`
    fragment ChannelStoreRedirectChannel on ChannelChannel {
  id
  name
  monetizationSettings @skip(if: $skipAuthFields) {
    enabled
  }
}
    `;
export const ChannelPageStoreSectionChannelFragmentDoc = gql`
    fragment ChannelPageStoreSectionChannel on ChannelChannel {
  id
  name
  monetizationSettings @skip(if: $skipAuthFields) {
    enabled
  }
  ...StoreFrontCategoriesChannel
  ...ChannelStoreRedirectChannel
}
    ${StoreFrontCategoriesChannelFragmentDoc}
${ChannelStoreRedirectChannelFragmentDoc}`;
export const ChannelPageContentChannelFragmentDoc = gql`
    fragment ChannelPageContentChannel on ChannelChannel {
  id
  ...ChannelPageHeaderChannel
  ...ChannelPageInfoSectionChannel
  ...ChannelPageStoreSectionChannel
}
    ${ChannelPageHeaderChannelFragmentDoc}
${ChannelPageInfoSectionChannelFragmentDoc}
${ChannelPageStoreSectionChannelFragmentDoc}`;
export const OfflineChannelIndicatorButtonChannelFragmentDoc = gql`
    fragment OfflineChannelIndicatorButtonChannel on ChannelChannel {
  id
  following
}
    `;
export const OfflineChannelIndicatorChannelFragmentDoc = gql`
    fragment OfflineChannelIndicatorChannel on ChannelChannel {
  id
  name
  following
  ...OfflineChannelIndicatorButtonChannel
}
    ${OfflineChannelIndicatorButtonChannelFragmentDoc}`;
export const ChannelPageHeaderOfflineChannelFragmentDoc = gql`
    fragment ChannelPageHeaderOfflineChannel on ChannelChannel {
  id
  offlineBanner
  name
  streamerId
  ...OfflineChannelIndicatorChannel
}
    ${OfflineChannelIndicatorChannelFragmentDoc}`;
export const ChannelFriendsListChannelFragmentDoc = gql`
    fragment ChannelFriendsListChannel on ChannelChannel {
  id
  channelFriends {
    totalCount
  }
}
    `;
export const LiveChannelHeaderStreamInfoChannelFragmentDoc = gql`
    fragment LiveChannelHeaderStreamInfoChannel on ChannelChannel {
  title
  viewerCount
  game {
    id
    name
  }
  ...ChannelLogoChannel
  ...ChannelTagsChannel
}
    ${ChannelLogoChannelFragmentDoc}
${ChannelTagsChannelFragmentDoc}`;
export const JoinGameClickChannelFragmentDoc = gql`
    fragment JoinGameClickChannel on ChannelChannel {
  id
  ...MatureRatedContentDialogChannel
}
    ${MatureRatedContentDialogChannelFragmentDoc}`;
export const LiveChannelButtonWrapperChannelFragmentDoc = gql`
    fragment LiveChannelButtonWrapperChannel on ChannelChannel {
  name
  ...JoinGameClickChannel
}
    ${JoinGameClickChannelFragmentDoc}`;
export const LiveChannelHeaderChannelFragmentDoc = gql`
    fragment LiveChannelHeaderChannel on ChannelChannel {
  currentStreamId
  thumbnail
  matureRatedContent
  ...ChannelFriendsListChannel
  ...LiveChannelHeaderStreamInfoChannel
  ...LiveChannelButtonWrapperChannel
}
    ${ChannelFriendsListChannelFragmentDoc}
${LiveChannelHeaderStreamInfoChannelFragmentDoc}
${LiveChannelButtonWrapperChannelFragmentDoc}`;
export const ChannelPageHeaderLiveChannelFragmentDoc = gql`
    fragment ChannelPageHeaderLiveChannel on ChannelChannel {
  id
  ...LiveChannelHeaderChannel
}
    ${LiveChannelHeaderChannelFragmentDoc}`;
export const OfflineChannelIndicatorFollowerNotificationSettingFragmentDoc = gql`
    fragment OfflineChannelIndicatorFollowerNotificationSetting on ChannelFollowerNotificationSettings {
  channelId
  channelLiveNotificationEnabled
}
    `;
export const ChannelStreamContextChannelFragmentDoc = gql`
    fragment ChannelStreamContextChannel on ChannelChannel {
  currentStreamId
  name
}
    `;
export const ChannelStreamAutoJoinChannelFragmentDoc = gql`
    fragment ChannelStreamAutoJoinChannel on ChannelChannel {
  id
  currentStreamId
  liveStatus
  name
  ...MatureRatedContentDialogChannel
}
    ${MatureRatedContentDialogChannelFragmentDoc}`;
export const ChannelStreamStateChannelFragmentDoc = gql`
    fragment ChannelStreamStateChannel on ChannelChannel {
  id
  currentStreamId
  name
}
    `;
export const ChannelLiveStatusFragmentDoc = gql`
    fragment ChannelLiveStatus on ChannelChannel {
  liveStatus
  currentStreamId
  game {
    id
  }
  matureRatedContent
}
    `;
export const ChannelBanFormBanAppealInfoFragmentDoc = gql`
    fragment ChannelBanFormBanAppealInfo on ChannelBanAppealInfo {
  status
  appealText
}
    `;
export const CardModalChannelSelectorChannelFragmentDoc = gql`
    fragment CardModalChannelSelectorChannel on ChannelChannel {
  id
  name
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const CollectionChannelSelectorChannelFragmentDoc = gql`
    fragment CollectionChannelSelectorChannel on ChannelChannel {
  id
  name
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const CreatorCardGridStreamerCardFragmentDoc = gql`
    fragment CreatorCardGridStreamerCard on GameLogicStreamerCard {
  ...GameStreamerCard
  baseCard(season_id: $seasonId) {
    ...GameCard
    activeStreamerCards {
      ...GameStreamerCard
    }
  }
}
    ${GameStreamerCardFragmentDoc}
${GameCardFragmentDoc}`;
export const CollectionItemModalStreamerCardFragmentDoc = gql`
    fragment CollectionItemModalStreamerCard on GameLogicStreamerCard {
  ...GameStreamerCard
  baseCard(season_id: $seasonId) {
    id
    ...CollectionItemModalBaseCard
  }
}
    ${GameStreamerCardFragmentDoc}
${CollectionItemModalBaseCardFragmentDoc}`;
export const CreatorCardModalCreatorCardFragmentDoc = gql`
    fragment CreatorCardModalCreatorCard on GameLogicStreamerCard {
  ...CollectionItemModalStreamerCard
  saleConfig {
    cardId
    channelId
    enabled
    period {
      from
      until
    }
  }
  ... on GameLogicStreamerCard {
    baseCard(season_id: $seasonId) {
      ...CardDetailLevelCardLeveling
    }
    channel {
      id
      name
      ...ChannelLogoChannel
    }
  }
}
    ${CollectionItemModalStreamerCardFragmentDoc}
${CardDetailLevelCardLevelingFragmentDoc}
${ChannelLogoChannelFragmentDoc}`;
export const GoalCardCardFragmentDoc = gql`
    fragment GoalCardCard on GoalCardGoalCard {
  id
  description
  gameId
  rarity
  target
  requiresTeam
  game {
    id
    name
  }
  reward {
    reward {
      ... on RewardRewardTypeCurrency {
        currencyId
        currencyAmount
      }
    }
  }
}
    `;
export const DailyGoalCardFailedSlotGoalCardFragmentDoc = gql`
    fragment DailyGoalCardFailedSlotGoalCard on GoalCardGoalCard {
  ...GoalCardCard
}
    ${GoalCardCardFragmentDoc}`;
export const GoalCardActiveSlotGoalCardSlotFragmentDoc = gql`
    fragment GoalCardActiveSlotGoalCardSlot on GoalCardGoalCardSlot {
  id
  goalCard {
    id
    target
    description
    requiresTeam
    ...GoalCardCard
  }
  progress {
    value
  }
  reward {
    id
  }
}
    ${GoalCardCardFragmentDoc}`;
export const GoalCardSlotSlotFragmentDoc = gql`
    fragment GoalCardSlotSlot on GoalCardGoalCardSlot {
  id
  ...GoalCardActiveSlotGoalCardSlot
  ...GoalCardSlotStateGoalCardSlot
  ...GoalCardSlotResetTimePastGoalCardSlot
}
    ${GoalCardActiveSlotGoalCardSlotFragmentDoc}
${GoalCardSlotStateGoalCardSlotFragmentDoc}
${GoalCardSlotResetTimePastGoalCardSlotFragmentDoc}`;
export const GoalCardSlotsGoalSlotFragmentDoc = gql`
    fragment GoalCardSlotsGoalSlot on GoalCardGoalCardSlot {
  ...GoalCardSlotSlot
}
    ${GoalCardSlotSlotFragmentDoc}`;
export const RewardUpdateGoalCardSlotFragmentDoc = gql`
    fragment RewardUpdateGoalCardSlot on GoalCardGoalCardSlot {
  id
  reward {
    id
  }
}
    `;
export const SetCardFragmentDoc = gql`
    fragment SetCard on GoalCardGoalCardSlot {
  id
  goalCard {
    id
  }
  progress {
    value
  }
  cardOptions {
    id
  }
}
    `;
export const HighlightedChannelFragmentDoc = gql`
    fragment HighlightedChannel on ChannelChannel {
  id
  name
  viewerCount
  thumbnail
  title
  game {
    id
    name
  }
  currentStreamId
  liveStatus
  ...ChannelTagsChannel
  ...ChannelLogoChannel
  ...ChannelAutoJoinLinkPropsChannel
}
    ${ChannelTagsChannelFragmentDoc}
${ChannelLogoChannelFragmentDoc}
${ChannelAutoJoinLinkPropsChannelFragmentDoc}`;
export const UserHeaderProfileFragmentDoc = gql`
    fragment UserHeaderProfile on ProfileProfile {
  userTag
  stats @skip(if: $isImplicitAccount) {
    matchesPlayed
  }
  avatars {
    avatarFullbody
  }
}
    `;
export const HomeHeaderProfileFragmentDoc = gql`
    fragment HomeHeaderProfile on ProfileProfile {
  ...UserHeaderProfile
}
    ${UserHeaderProfileFragmentDoc}`;
export const HomePageChannelListLiveChannelFragmentDoc = gql`
    fragment HomePageChannelListLiveChannel on ChannelChannel {
  ...LiveChannelPreviewChannel
}
    ${LiveChannelPreviewChannelFragmentDoc}`;
export const HomePageChannelListOfflineChannelFragmentDoc = gql`
    fragment HomePageChannelListOfflineChannel on ChannelChannel {
  ...OfflineChannelLinkChannel
}
    ${OfflineChannelLinkChannelFragmentDoc}`;
export const PlatformSuspensionAppealFragmentDoc = gql`
    fragment PlatformSuspensionAppeal on ModerationPlatformBanAppeal {
  appealText
  closedAt
  createdAt
  status
}
    `;
export const PlatformSuspensionStatusFragmentDoc = gql`
    fragment PlatformSuspensionStatus on ModerationPlatformBan {
  appeal {
    banId
    ...PlatformSuspensionAppeal
  }
  bannedAt
  description
  expiresAt
  status
  violation
}
    ${PlatformSuspensionAppealFragmentDoc}`;
export const PlatformSuspensionProfileFragmentDoc = gql`
    fragment PlatformSuspensionProfile on ProfileProfile {
  avatars {
    avatar2D
  }
  userId
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const FriendRequestButtonProfileFragmentDoc = gql`
    fragment FriendRequestButtonProfile on ProfileProfile {
  userId
  userTag
  friendshipStatus {
    status
    lastStatusChange
  }
  temporary
}
    `;
export const ProfilePageHeaderProfileFragmentDoc = gql`
    fragment ProfilePageHeaderProfile on ProfileProfile {
  userId
  userTag
  discordUsername
  visibility
  isNewUsername
  avatars {
    avatar2D
  }
  ...FriendRequestButtonProfile
  ...ProfileImageProfile
}
    ${FriendRequestButtonProfileFragmentDoc}
${ProfileImageProfileFragmentDoc}`;
export const ProfilePageLayoutProfileFragmentDoc = gql`
    fragment ProfilePageLayoutProfile on ProfileProfile {
  avatars {
    avatarFullbody
  }
  userTag
}
    `;
export const ProfileCardsCardFragmentDoc = gql`
    fragment ProfileCardsCard on GameLogicCard {
  ...GameCard
}
    ${GameCardFragmentDoc}`;
export const ProfileFriendsProfileFragmentDoc = gql`
    fragment ProfileFriendsProfile on ProfileProfile {
  userId
  userTag
  ...ProfileImageShowOnlineStatusProfile
}
    ${ProfileImageShowOnlineStatusProfileFragmentDoc}`;
export const GameProgressionGameFragmentDoc = gql`
    fragment GameProgressionGame on GameGame {
  id
  name
  activeSeason {
    name
    id
    progression(user_id: $userId) {
      seasonId
      xpAmount
      level
      nextLevelThreshold
      nextLevel
    }
  }
}
    `;
export const ProfileGamesListItemFragmentDoc = gql`
    fragment ProfileGamesListItem on GameGame {
  id
  name
  ...GameProgressionGame
}
    ${GameProgressionGameFragmentDoc}`;
export const ProfileStatsFragmentDoc = gql`
    fragment ProfileStats on ProfileProfile {
  stats {
    matchesPlayed
    timePlayed
    cardsSucceeded
    dailyGoalCardsCompleted
  }
}
    `;
export const CategoryLinkGameStatsFragmentDoc = gql`
    fragment CategoryLinkGameStats on ChannelGameStats {
  gameId
  liveStreams
  game {
    id
    name
    coverImageUrl
  }
}
    `;
export const CategorySearchResultFragmentDoc = gql`
    fragment CategorySearchResult on SearchResultItem {
  entityId
  entity {
    ... on ChannelGameStats {
      gameId
      ...CategoryLinkGameStats
    }
  }
}
    ${CategoryLinkGameStatsFragmentDoc}`;
export const ChannelSearchResultFragmentDoc = gql`
    fragment ChannelSearchResult on SearchResultItem {
  entityId
  entity {
    ... on ChannelChannel {
      id
      name
      liveStatus
      game {
        id
        name
      }
      ...ChannelLogoChannel
      ...FollowButtonChannel
    }
  }
}
    ${ChannelLogoChannelFragmentDoc}
${FollowButtonChannelFragmentDoc}`;
export const NextUnlockLevelConfigFragmentDoc = gql`
    fragment NextUnlockLevelConfig on ProgressionLevelConfig {
  number
  rewards {
    reward {
      ... on RewardRewardTypeItem {
        item {
          id
          details {
            ...GameCard
          }
        }
      }
    }
  }
}
    ${GameCardFragmentDoc}`;
export const RewardTrackItemLevelConfigFragmentDoc = gql`
    fragment RewardTrackItemLevelConfig on ProgressionLevelConfig {
  number
  threshold
  seasonId
  rewards {
    reward {
      ... on RewardRewardTypeItem {
        itemId
        item {
          type
          name
          id
          seasonId
          unlockItemId
          details {
            ...GameCard
          }
        }
      }
      ... on RewardRewardTypeCurrency {
        currencyId
        currencyAmount
      }
    }
  }
}
    ${GameCardFragmentDoc}`;
export const RewardTrackLevelConfigFragmentDoc = gql`
    fragment RewardTrackLevelConfig on ProgressionLevelConfig {
  ...RewardTrackItemLevelConfig
}
    ${RewardTrackItemLevelConfigFragmentDoc}`;
export const RewardTrackItemProgressionFragmentDoc = gql`
    fragment RewardTrackItemProgression on ProgressionSeasonProgression {
  xpAmount
  level
  nextLevelThreshold
}
    `;
export const RewardTrackSeasonProgressionFragmentDoc = gql`
    fragment RewardTrackSeasonProgression on ProgressionSeasonProgression {
  seasonId
  ...RewardTrackItemProgression
}
    ${RewardTrackItemProgressionFragmentDoc}`;
export const RewardTrackItemRewardsFragmentDoc = gql`
    fragment RewardTrackItemRewards on RewardReward {
  id
  reason {
    reason {
      __typename
      ... on ReasonReasonLevelUp {
        level
        seasonId
      }
    }
  }
}
    `;
export const RewardTrackRewardsFragmentDoc = gql`
    fragment RewardTrackRewards on RewardReward {
  id
  ...RewardTrackItemRewards
}
    ${RewardTrackItemRewardsFragmentDoc}`;
export const SeasonsHeaderProgressionFragmentDoc = gql`
    fragment SeasonsHeaderProgression on ProgressionSeasonProgression {
  level
}
    `;
export const SettingsConnectionsDataFragmentDoc = gql`
    fragment SettingsConnectionsData on ProfileProfile {
  userId
  account {
    externalIds {
      type
    }
  }
}
    `;
export const ChannelNotificationChannelNotificationSettingsFragmentDoc = gql`
    fragment ChannelNotificationChannelNotificationSettings on ChannelNotificationSettings {
  channelLiveNotification {
    emailEnabled
  }
}
    `;
export const MarketingNotificationProfileFragmentDoc = gql`
    fragment MarketingNotificationProfile on ProfileProfile {
  account {
    uid
    marketingConsent
  }
}
    `;
export const OnlineStatusSettingProfileFragmentDoc = gql`
    fragment OnlineStatusSettingProfile on ProfileProfile {
  settings {
    privacy {
      hideOnlineStatus
    }
  }
}
    `;
export const BlockedUsersFriendUserFragmentDoc = gql`
    fragment BlockedUsersFriendUser on FriendsUser {
  lastStatusChange
  profile {
    userId
    userTag
    avatars {
      avatar2D
    }
    ...ProfileImageProfile
  }
}
    ${ProfileImageProfileFragmentDoc}`;
export const ContentWarningSettingProfileFragmentDoc = gql`
    fragment ContentWarningSettingProfile on ProfileProfile {
  settings {
    privacy {
      showMatureContentWarning
    }
  }
  account {
    uid
    matureRatedContentAllowed
  }
}
    `;
export const DiscordUsernameSettingsProfileFragmentDoc = gql`
    fragment DiscordUsernameSettingsProfile on ProfileProfile {
  account {
    externalIds {
      type
      id
    }
  }
  settings {
    privacy {
      discordUsernameVisibility
    }
  }
}
    `;
export const DiscordIdVisibilityUpdateProfileFragmentDoc = gql`
    fragment DiscordIdVisibilityUpdateProfile on ProfileProfile {
  userId
  settings {
    privacy {
      discordUsernameVisibility
    }
  }
}
    `;
export const FriendRequestSettingProfileFragmentDoc = gql`
    fragment FriendRequestSettingProfile on ProfileProfile {
  settings {
    friends {
      disableFriendRequests
    }
  }
}
    `;
export const DisabledFriendRequestUpdateProfileFragmentDoc = gql`
    fragment DisabledFriendRequestUpdateProfile on ProfileProfile {
  userId
  settings {
    friends {
      disableFriendRequests
    }
  }
}
    `;
export const ProfilePageSettingsProfileFragmentDoc = gql`
    fragment ProfilePageSettingsProfile on ProfileProfile {
  settings {
    privacy {
      visibility
    }
  }
}
    `;
export const VisibilityUpdateProfileFragmentDoc = gql`
    fragment VisibilityUpdateProfile on ProfileProfile {
  userId
  settings {
    privacy {
      visibility
    }
  }
}
    `;
export const PurchaseVisibilitySettingProfileFragmentDoc = gql`
    fragment PurchaseVisibilitySettingProfile on ProfileProfile {
  settings {
    privacy {
      anonymisePurchaseHighlights
    }
  }
}
    `;
export const OnlinePurchasePrivacyUpdateProfileFragmentDoc = gql`
    fragment OnlinePurchasePrivacyUpdateProfile on ProfileProfile {
  userId
  settings {
    privacy {
      anonymisePurchaseHighlights
    }
  }
}
    `;
export const SubscriptionButtonSubscriptionFragmentDoc = gql`
    fragment SubscriptionButtonSubscription on SubscriptionChannelSubscription {
  id
  state
  channel {
    id
    monetizationSettings {
      enabled
    }
    subscriptionConfig {
      channelId
      subscriptionsEnabled
    }
  }
}
    `;
export const SubscriptionSettingItemSubscriptionFragmentDoc = gql`
    fragment SubscriptionSettingItemSubscription on SubscriptionChannelSubscription {
  activatedAt
  expiresAt
  cancelledAt
  state
  paymentFailedAt
  provider
  channel {
    id
    name
    offlineBanner
    ...ChannelLogoChannel
  }
  ...SubscriptionButtonSubscription
}
    ${ChannelLogoChannelFragmentDoc}
${SubscriptionButtonSubscriptionFragmentDoc}`;
export const WalletPaymentsPaymentFragmentDoc = gql`
    fragment WalletPaymentsPayment on PaymentPayment {
  id
  timestamp
  status
  items {
    description
  }
}
    `;
export const StoreChannelListChannelFragmentDoc = gql`
    fragment StoreChannelListChannel on ChannelChannel {
  id
  monetizationSettings {
    enabled
  }
  ...OfflineChannelLinkChannel
}
    ${OfflineChannelLinkChannelFragmentDoc}`;
export const StoreChannelSectionChannelFragmentDoc = gql`
    fragment StoreChannelSectionChannel on ChannelChannel {
  ...StoreChannelListChannel
}
    ${StoreChannelListChannelFragmentDoc}`;
export const MatchEndLevelThresholdsFragmentDoc = gql`
    fragment MatchEndLevelThresholds on ProgressionLevelConfig {
  threshold
}
    `;
export const MatchEndPlayerLevelFragmentDoc = gql`
    fragment MatchEndPlayerLevel on ProgressionSeasonProgression {
  level
  nextLevel
}
    `;
export const MatchResultsSummaryPlayerScoreProfileFragmentDoc = gql`
    fragment MatchResultsSummaryPlayerScoreProfile on ProfileProfile {
  userId
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const BestPlayProfileFragmentDoc = gql`
    fragment BestPlayProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatarFullbody
  }
}
    `;
export const PlayerScoreProfileFragmentDoc = gql`
    fragment PlayerScoreProfile on ProfileProfile {
  userId
  userTag
}
    `;
export const HighScoringCardPlayerFragmentDoc = gql`
    fragment HighScoringCardPlayer on ProfileProfile {
  userId
  userTag
  avatars {
    avatarFullbody
  }
}
    `;
export const CardRowAvatarProfileFragmentDoc = gql`
    fragment CardRowAvatarProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
  friendshipStatus {
    status
  }
}
    `;
export const SpectatorPlayerInfoProfileFragmentDoc = gql`
    fragment SpectatorPlayerInfoProfile on ProfileProfile {
  userId
  userTag
  ...CardRowAvatarProfile
}
    ${CardRowAvatarProfileFragmentDoc}`;
export const SpectatorDisplayBottomProfileFragmentDoc = gql`
    fragment SpectatorDisplayBottomProfile on ProfileProfile {
  userId
  ...SpectatorPlayerInfoProfile
}
    ${SpectatorPlayerInfoProfileFragmentDoc}`;
export const GameCardSoundDataFragmentDoc = gql`
    fragment GameCardSoundData on GameLogicCard {
  id
  pointsMax
  targetValue
  isAllOrNothing
  isMatchCard
}
    `;
export const ChallengesContentChallengeFragmentDoc = gql`
    fragment ChallengesContentChallenge on GameLogicChallenge {
  id
  description
  targetValues {
    label
    value
  }
}
    `;
export const ActiveBoosterTooltipContentProfileFragmentDoc = gql`
    fragment ActiveBoosterTooltipContentProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
}
    `;
export const ActiveBoosterDialogContentProfileFragmentDoc = gql`
    fragment ActiveBoosterDialogContentProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
}
    `;
export const ActiveBoosterProfileFragmentDoc = gql`
    fragment ActiveBoosterProfile on ProfileProfile {
  ...ActiveBoosterTooltipContentProfile
  ...ActiveBoosterDialogContentProfile
}
    ${ActiveBoosterTooltipContentProfileFragmentDoc}
${ActiveBoosterDialogContentProfileFragmentDoc}`;
export const ActiveBoosterTooltipContentBoosterFragmentDoc = gql`
    fragment ActiveBoosterTooltipContentBooster on GameLogicBooster {
  id
  name
  descriptionCondition
  descriptionDefaultBenefit
  descriptionTargetNoneBenefit
  descriptionTargetSelf
}
    `;
export const ActiveBoosterDialogContentBoosterFragmentDoc = gql`
    fragment ActiveBoosterDialogContentBooster on GameLogicBooster {
  id
  name
  descriptionCondition
  descriptionDefaultBenefit
  descriptionTargetNoneBenefit
  descriptionTargetSelf
}
    `;
export const ActiveBoosterFragmentDoc = gql`
    fragment ActiveBooster on GameLogicBooster {
  id
  ...ActiveBoosterTooltipContentBooster
  ...ActiveBoosterDialogContentBooster
}
    ${ActiveBoosterTooltipContentBoosterFragmentDoc}
${ActiveBoosterDialogContentBoosterFragmentDoc}`;
export const TeamMateBoosterDialogContentBoosterFragmentDoc = gql`
    fragment TeamMateBoosterDialogContentBooster on GameLogicBooster {
  name
  descriptionCondition
  descriptionDefaultBenefit
}
    `;
export const TeamMateBoosterTooltipContentBoosterFragmentDoc = gql`
    fragment TeamMateBoosterTooltipContentBooster on GameLogicBooster {
  name
  descriptionCondition
  descriptionDefaultBenefit
}
    `;
export const CgActiveBoosterFragmentDoc = gql`
    fragment CgActiveBooster on GameLogicBooster {
  id
  timeActive
  valueSelf
  valueOther
  image
  name
}
    `;
export const CgAvailableBoosterFragmentDoc = gql`
    fragment CgAvailableBooster on GameLogicBooster {
  id
  canTargetSelf
}
    `;
export const GameStateCardFragmentDoc = gql`
    fragment GameStateCard on GameLogicCard {
  id
  pointsMin
  pointsMax
  pointsTimeTarget
  timerDuration
  targetValue
  isMatchCard
  isAllOrNothing
  ...GameStateCardTargetValues
}
    ${GameStateCardTargetValuesFragmentDoc}`;
export const CgChallengesSystemChallengeFragmentDoc = gql`
    fragment CGChallengesSystemChallenge on GameLogicChallenge {
  id
  targetValues {
    label
    value
  }
}
    `;
export const ChannelEventContentProfileFragmentDoc = gql`
    fragment ChannelEventContentProfile on ProfileProfile {
  preferredColor
  userId
  userTag
}
    `;
export const ChannelEventSubscriptionContentProfileFragmentDoc = gql`
    fragment ChannelEventSubscriptionContentProfile on ProfileProfile {
  badges(channel_id: $channelId) {
    type
    level
  }
}
    `;
export const ChannelEventAvatarItemPurchaseItemFragmentDoc = gql`
    fragment ChannelEventAvatarItemPurchaseItem on ItemItem {
  id
  name
}
    `;
export const ChatMessageAttachmentsFragmentDoc = gql`
    fragment ChatMessageAttachments on ChatTextMessageAttachment {
  label
  source
  startIndex
  endIndex
  __typename
}
    `;
export const SendChatMessageProfileFragmentDoc = gql`
    fragment SendChatMessageProfile on ProfileProfile {
  userTag
  avatars {
    avatar2D
  }
  badges(channel_id: $channelId) {
    type
    level
  }
  preferredColor
}
    `;
export const ChatMessagesHookProfileFragmentDoc = gql`
    fragment ChatMessagesHookProfile on ProfileProfile {
  ...SendChatMessageProfile
}
    ${SendChatMessageProfileFragmentDoc}`;
export const InventoryEmojiFragmentDoc = gql`
    fragment InventoryEmoji on EmojiEmoji {
  id
  label
  image
  channelId
}
    `;
export const UpdateChatSettingsProfileFragmentDoc = gql`
    fragment UpdateChatSettingsProfile on ProfileProfile {
  userId
  preferredColor
}
    `;
export const EmoteAvatarAnimationFragmentDoc = gql`
    fragment EmoteAvatarAnimation on AvatarAnimation {
  name
  chatCommand
  iconUrl
  id
}
    `;
export const ChatMessagesProfileFragmentDoc = gql`
    fragment ChatMessagesProfile on ProfileProfile {
  userId
  userTag
}
    `;
export const EmojiDrawerChannelFragmentDoc = gql`
    fragment EmojiDrawerChannel on ChannelChannel {
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const ReasonDescriptionInputProfileFragmentDoc = gql`
    fragment ReasonDescriptionInputProfile on ProfileProfile {
  userTag
}
    `;
export const ReasonSelectProfileFragmentDoc = gql`
    fragment ReasonSelectProfile on ProfileProfile {
  ...ReasonDescriptionInputProfile
}
    ${ReasonDescriptionInputProfileFragmentDoc}`;
export const ReasonDescriptionInputChannelFragmentDoc = gql`
    fragment ReasonDescriptionInputChannel on ChannelChannel {
  name
}
    `;
export const ReasonSelectChannelFragmentDoc = gql`
    fragment ReasonSelectChannel on ChannelChannel {
  ...ReasonDescriptionInputChannel
}
    ${ReasonDescriptionInputChannelFragmentDoc}`;
export const ReportedChannelFragmentDoc = gql`
    fragment ReportedChannel on ChannelChannel {
  name
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const ReportedUserProfileFragmentDoc = gql`
    fragment ReportedUserProfile on ProfileProfile {
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const SignupFlowChannelFragmentDoc = gql`
    fragment SignupFlowChannel on ChannelChannel {
  name
  liveStatus
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const ChannelBannerChannelFragmentDoc = gql`
    fragment ChannelBannerChannel on ChannelChannel {
  offlineBanner
}
    `;
export const PlatformAnnouncementFragmentDoc = gql`
    fragment PlatformAnnouncement on AnnouncementAnnouncement {
  id
  title
  text
  category
  startTime
  image
}
    `;
export const LogoUpdateChannelChannelFragmentDoc = gql`
    fragment LogoUpdateChannelChannel on ChannelChannel {
  id
  logo
}
    `;
export const BannerUpdateChannelChannelFragmentDoc = gql`
    fragment BannerUpdateChannelChannel on ChannelChannel {
  id
  offlineBanner
}
    `;
export const AssetUploadEmojiEmojiFragmentDoc = gql`
    fragment AssetUploadEmojiEmoji on EmojiEmoji {
  image
}
    `;
export const WalletCurrencyFragmentDoc = gql`
    fragment WalletCurrency on WalletWalletCurrency {
  currencyId
  currencyAmount
}
    `;
export const ZendeskPrefillProfileFragmentDoc = gql`
    fragment ZendeskPrefillProfile on ProfileProfile {
  userId
  userTag
  account {
    email
  }
}
    `;
export const UserBadgeFragmentDoc = gql`
    fragment UserBadge on BadgeBadge {
  type
  level
}
    `;
export const BlockUserProfileFragmentDoc = gql`
    fragment BlockUserProfile on ProfileProfile {
  avatars {
    avatar2D
  }
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const ChannelBanModalProfileFragmentDoc = gql`
    fragment ChannelBanModalProfile on ProfileProfile {
  userTag
  userId
}
    `;
export const ChannelMuteModalProfileFragmentDoc = gql`
    fragment ChannelMuteModalProfile on ProfileProfile {
  userTag
  userId
}
    `;
export const ChannelUnbanModalProfileFragmentDoc = gql`
    fragment ChannelUnbanModalProfile on ProfileProfile {
  userTag
  userId
}
    `;
export const ChannelUnmuteModalProfileFragmentDoc = gql`
    fragment ChannelUnmuteModalProfile on ProfileProfile {
  userTag
  userId
}
    `;
export const FriendsSidebarFriendButtonsProfileFragmentDoc = gql`
    fragment FriendsSidebarFriendButtonsProfile on ProfileProfile {
  userId
  friendshipStatus {
    status
  }
}
    `;
export const FriendsSidebarItemExpandedProfileFragmentDoc = gql`
    fragment FriendsSidebarItemExpandedProfile on ProfileProfile {
  userTag
  isNewUsername
  ...ProfileImageShowOnlineStatusProfile
  ...FriendsSidebarFriendButtonsProfile
}
    ${ProfileImageShowOnlineStatusProfileFragmentDoc}
${FriendsSidebarFriendButtonsProfileFragmentDoc}`;
export const FriendsSidebarFriendProfileFragmentDoc = gql`
    fragment FriendsSidebarFriendProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
  onlineStatus
  ...FriendsSidebarFriendButtonsProfile
  ...ProfileImageProfile
  ...FriendsSidebarItemExpandedProfile
}
    ${FriendsSidebarFriendButtonsProfileFragmentDoc}
${ProfileImageProfileFragmentDoc}
${FriendsSidebarItemExpandedProfileFragmentDoc}`;
export const FriendsSidebarFriendStatusFriendsUserFragmentDoc = gql`
    fragment FriendsSidebarFriendStatusFriendsUser on FriendsUser {
  activity {
    isOnline
    channel {
      id
      name
      game {
        id
        name
      }
    }
  }
  profile {
    userId
    onlineStatus
  }
}
    `;
export const FriendsSidebarFriendPanelFriendFragmentDoc = gql`
    fragment FriendsSidebarFriendPanelFriend on FriendsUser {
  lastStatusChange
  profile {
    userId
    userTag
    avatars {
      avatar2D
    }
    onlineStatus
    userTag
    isNewUsername
    ...ProfileImageShowOnlineStatusProfile
  }
  ...FriendsSidebarFriendStatusFriendsUser
}
    ${ProfileImageShowOnlineStatusProfileFragmentDoc}
${FriendsSidebarFriendStatusFriendsUserFragmentDoc}`;
export const FriendsSidebarItemExpandedFriendFragmentDoc = gql`
    fragment FriendsSidebarItemExpandedFriend on FriendsUser {
  profile {
    userId
    ...FriendsSidebarItemExpandedProfile
  }
  ...FriendsSidebarFriendStatusFriendsUser
}
    ${FriendsSidebarItemExpandedProfileFragmentDoc}
${FriendsSidebarFriendStatusFriendsUserFragmentDoc}`;
export const FriendsSidebarFriendActionsFriendsUserFragmentDoc = gql`
    fragment FriendsSidebarFriendActionsFriendsUser on FriendsUser {
  userId
  activity {
    isOnline
    channel {
      id
      name
    }
  }
  profile {
    userId
    userTag
    friendshipStatus {
      status
    }
  }
}
    `;
export const FriendsSidebarFriendFragmentDoc = gql`
    fragment FriendsSidebarFriend on FriendsUser {
  userId
  profile {
    ...FriendsSidebarFriendProfile
    ...ProfileImageShowOnlineStatusProfile
  }
  ...FriendsSidebarFriendPanelFriend
  ...FriendsSidebarFriendStatusFriendsUser
  ...FriendsSidebarItemExpandedFriend
  ...FriendsSidebarFriendActionsFriendsUser
}
    ${FriendsSidebarFriendProfileFragmentDoc}
${ProfileImageShowOnlineStatusProfileFragmentDoc}
${FriendsSidebarFriendPanelFriendFragmentDoc}
${FriendsSidebarFriendStatusFriendsUserFragmentDoc}
${FriendsSidebarItemExpandedFriendFragmentDoc}
${FriendsSidebarFriendActionsFriendsUserFragmentDoc}`;
export const FriendsSidebarFriendListFriendFragmentDoc = gql`
    fragment FriendsSidebarFriendListFriend on FriendsUser {
  ...FriendsSidebarFriend
}
    ${FriendsSidebarFriendFragmentDoc}`;
export const FriendsSidebarFriendListProfileFragmentDoc = gql`
    fragment FriendsSidebarFriendListProfile on ProfileProfile {
  ...FriendsSidebarFriendProfile
}
    ${FriendsSidebarFriendProfileFragmentDoc}`;
export const FriendsSidebarPartyFriendFragmentDoc = gql`
    fragment FriendsSidebarPartyFriend on FriendsUser {
  ...FriendsSidebarFriend
}
    ${FriendsSidebarFriendFragmentDoc}`;
export const FriendsSidebarPartyProfileFragmentDoc = gql`
    fragment FriendsSidebarPartyProfile on ProfileProfile {
  ...FriendsSidebarFriendProfile
}
    ${FriendsSidebarFriendProfileFragmentDoc}`;
export const MiniProfileAvatarProfileFragmentDoc = gql`
    fragment MiniProfileAvatarProfile on ProfileProfile {
  avatars {
    avatarFullbody
  }
  userTag
}
    `;
export const MiniProfileHeaderProfileFragmentDoc = gql`
    fragment MiniProfileHeaderProfile on ProfileProfile {
  userTag
  temporary
  isNewUsername
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const MiniProfileDetailsProfileFragmentDoc = gql`
    fragment MiniProfileDetailsProfile on ProfileProfile {
  userId
}
    `;
export const MiniProfileGameRankProfileFragmentDoc = gql`
    fragment MiniProfileGameRankProfile on ProfileProfile {
  playedGames {
    id
    userId
    seasonId
    game {
      id
      name
    }
    progression {
      level
    }
    season {
      id
      name
    }
  }
}
    `;
export const MiniProfileFriendStatusProfileFragmentDoc = gql`
    fragment MiniProfileFriendStatusProfile on ProfileProfile {
  userId
  userTag
  friendshipStatus {
    status
    lastStatusChange
  }
}
    `;
export const MiniProfilePopoverMenuProfileFragmentDoc = gql`
    fragment MiniProfilePopoverMenuProfile on ProfileProfile {
  userId
  userTag
  friendshipStatus {
    status
  }
  temporary
}
    `;
export const MiniProfileFooterProfileFragmentDoc = gql`
    fragment MiniProfileFooterProfile on ProfileProfile {
  userId
  friendshipStatus {
    status
  }
  temporary
  ...MiniProfilePopoverMenuProfile
}
    ${MiniProfilePopoverMenuProfileFragmentDoc}`;
export const MiniProfileFragmentDoc = gql`
    fragment MiniProfile on ProfileProfile {
  userId
  ...MiniProfileAvatarProfile
  ...MiniProfileHeaderProfile
  ...MiniProfileDetailsProfile
  ...MiniProfileGameRankProfile
  ...MiniProfileFriendStatusProfile
  ...MiniProfileFooterProfile
}
    ${MiniProfileAvatarProfileFragmentDoc}
${MiniProfileHeaderProfileFragmentDoc}
${MiniProfileDetailsProfileFragmentDoc}
${MiniProfileGameRankProfileFragmentDoc}
${MiniProfileFriendStatusProfileFragmentDoc}
${MiniProfileFooterProfileFragmentDoc}`;
export const MiniProfilePopoverMenuChannelBanFragmentDoc = gql`
    fragment MiniProfilePopoverMenuChannelBan on ChannelUserBanStatus {
  banned
}
    `;
export const MiniProfileModerationStateChannelBanFragmentDoc = gql`
    fragment MiniProfileModerationStateChannelBan on ChannelUserBanStatus {
  banned
  appeal {
    status
  }
}
    `;
export const MiniProfileChannelBanFragmentDoc = gql`
    fragment MiniProfileChannelBan on ChannelUserBanStatus {
  ...MiniProfilePopoverMenuChannelBan
  ...MiniProfileModerationStateChannelBan
}
    ${MiniProfilePopoverMenuChannelBanFragmentDoc}
${MiniProfileModerationStateChannelBanFragmentDoc}`;
export const ChannelUnbanModalChannelUserBanStatusFragmentDoc = gql`
    fragment ChannelUnbanModalChannelUserBanStatus on ChannelUserBanStatus {
  bannedAt
  violation
  description
  moderator {
    userId
    userTag
  }
}
    `;
export const MiniProfilePortalChannelBanFragmentDoc = gql`
    fragment MiniProfilePortalChannelBan on ChannelUserBanStatus {
  ...MiniProfileChannelBan
  ...ChannelUnbanModalChannelUserBanStatus
}
    ${MiniProfileChannelBanFragmentDoc}
${ChannelUnbanModalChannelUserBanStatusFragmentDoc}`;
export const MiniProfileModerationStateChatStatusFragmentDoc = gql`
    fragment MiniProfileModerationStateChatStatus on ChatGetChatUserStatusResponse {
  muted
  muteDuration
}
    `;
export const MiniProfilePopoverMenuChatStatusFragmentDoc = gql`
    fragment MiniProfilePopoverMenuChatStatus on ChatGetChatUserStatusResponse {
  muted
}
    `;
export const MiniProfileChatStatusFragmentDoc = gql`
    fragment MiniProfileChatStatus on ChatGetChatUserStatusResponse {
  ...MiniProfileModerationStateChatStatus
  ...MiniProfilePopoverMenuChatStatus
}
    ${MiniProfileModerationStateChatStatusFragmentDoc}
${MiniProfilePopoverMenuChatStatusFragmentDoc}`;
export const ChannelUnmuteModalChatStatusFragmentDoc = gql`
    fragment ChannelUnmuteModalChatStatus on ChatGetChatUserStatusResponse {
  muteDuration
}
    `;
export const MiniProfilePortalChatStausFragmentDoc = gql`
    fragment MiniProfilePortalChatStaus on ChatGetChatUserStatusResponse {
  ...MiniProfileChatStatus
  ...ChannelUnmuteModalChatStatus
}
    ${MiniProfileChatStatusFragmentDoc}
${ChannelUnmuteModalChatStatusFragmentDoc}`;
export const FriendStatusUpdateProfileFragmentDoc = gql`
    fragment FriendStatusUpdateProfile on ProfileProfile {
  userId
  friendshipStatus {
    status
    lastStatusChange
  }
}
    `;
export const NewFriendRequestUserFragmentDoc = gql`
    fragment NewFriendRequestUser on FriendsUser {
  userId
}
    `;
export const SpotlightBestGroupProfileFragmentDoc = gql`
    fragment SpotlightBestGroupProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const SpotlightBestPlayCardFragmentDoc = gql`
    fragment SpotlightBestPlayCard on GameLogicCard {
  ...GameCard
}
    ${GameCardFragmentDoc}`;
export const SpotlightBestPlayProfileFragmentDoc = gql`
    fragment SpotlightBestPlayProfile on ProfileProfile {
  userId
  userTag
}
    `;
export const SpotlightBestPlayerProfileFragmentDoc = gql`
    fragment SpotlightBestPlayerProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const FtueDismissComponentsDocument = gql`
    query FTUEDismissComponents($userId: ID!) {
  dismissedTooltips(userId: $userId) {
    tooltipIds
  }
}
    `;

/**
 * __useFtueDismissComponentsQuery__
 *
 * To run a query within a React component, call `useFtueDismissComponentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFtueDismissComponentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFtueDismissComponentsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFtueDismissComponentsQuery(baseOptions: Apollo.QueryHookOptions<FtueDismissComponentsQuery, FtueDismissComponentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FtueDismissComponentsQuery, FtueDismissComponentsQueryVariables>(FtueDismissComponentsDocument, options);
      }
export function useFtueDismissComponentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FtueDismissComponentsQuery, FtueDismissComponentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FtueDismissComponentsQuery, FtueDismissComponentsQueryVariables>(FtueDismissComponentsDocument, options);
        }
export type FtueDismissComponentsQueryHookResult = ReturnType<typeof useFtueDismissComponentsQuery>;
export type FtueDismissComponentsLazyQueryHookResult = ReturnType<typeof useFtueDismissComponentsLazyQuery>;
export type FtueDismissComponentsQueryResult = Apollo.QueryResult<FtueDismissComponentsQuery, FtueDismissComponentsQueryVariables>;
export const FtueCurrentStreamChannelDocument = gql`
    query FTUECurrentStreamChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
    game {
      id
      name
    }
  }
}
    `;

/**
 * __useFtueCurrentStreamChannelQuery__
 *
 * To run a query within a React component, call `useFtueCurrentStreamChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useFtueCurrentStreamChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFtueCurrentStreamChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useFtueCurrentStreamChannelQuery(baseOptions: Apollo.QueryHookOptions<FtueCurrentStreamChannelQuery, FtueCurrentStreamChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FtueCurrentStreamChannelQuery, FtueCurrentStreamChannelQueryVariables>(FtueCurrentStreamChannelDocument, options);
      }
export function useFtueCurrentStreamChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FtueCurrentStreamChannelQuery, FtueCurrentStreamChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FtueCurrentStreamChannelQuery, FtueCurrentStreamChannelQueryVariables>(FtueCurrentStreamChannelDocument, options);
        }
export type FtueCurrentStreamChannelQueryHookResult = ReturnType<typeof useFtueCurrentStreamChannelQuery>;
export type FtueCurrentStreamChannelLazyQueryHookResult = ReturnType<typeof useFtueCurrentStreamChannelLazyQuery>;
export type FtueCurrentStreamChannelQueryResult = Apollo.QueryResult<FtueCurrentStreamChannelQuery, FtueCurrentStreamChannelQueryVariables>;
export const FtuePlayerDataDocument = gql`
    query FTUEPlayerData($userId: ID!) {
  profile(userId: $userId) {
    userId
    stats {
      adsWatched
      matchesPlayed
      soloMatchesPlayed
      partyMatchesPlayed
      timePlayed
      dailyGoalCardsCompleted
      cardsPlayed
      shufflesUsed
      cardBundlesPurchased
      cardsSucceeded
      boosterUsage {
        total
        doubt
        goodCall
        letsGo
        nextUp
        scavenge
        speedUp
      }
      currencySpending {
        hardCurrency
        softCurrency
        channelCurrency
      }
      dailyGoalCardsSet
      cardLevelUps
    }
    avatarConfig {
      modelId
      model {
        id
        selectable
      }
    }
    playedGames {
      id
      userId
      progression {
        level
      }
    }
  }
}
    `;

/**
 * __useFtuePlayerDataQuery__
 *
 * To run a query within a React component, call `useFtuePlayerDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useFtuePlayerDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFtuePlayerDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFtuePlayerDataQuery(baseOptions: Apollo.QueryHookOptions<FtuePlayerDataQuery, FtuePlayerDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FtuePlayerDataQuery, FtuePlayerDataQueryVariables>(FtuePlayerDataDocument, options);
      }
export function useFtuePlayerDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FtuePlayerDataQuery, FtuePlayerDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FtuePlayerDataQuery, FtuePlayerDataQueryVariables>(FtuePlayerDataDocument, options);
        }
export type FtuePlayerDataQueryHookResult = ReturnType<typeof useFtuePlayerDataQuery>;
export type FtuePlayerDataLazyQueryHookResult = ReturnType<typeof useFtuePlayerDataLazyQuery>;
export type FtuePlayerDataQueryResult = Apollo.QueryResult<FtuePlayerDataQuery, FtuePlayerDataQueryVariables>;
export const FtuePlayerDataMatchProfileDocument = gql`
    query FTUEPlayerDataMatchProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    stats {
      matchesPlayed
      soloMatchesPlayed
      partyMatchesPlayed
      timePlayed
    }
  }
}
    `;

/**
 * __useFtuePlayerDataMatchProfileQuery__
 *
 * To run a query within a React component, call `useFtuePlayerDataMatchProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useFtuePlayerDataMatchProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFtuePlayerDataMatchProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFtuePlayerDataMatchProfileQuery(baseOptions: Apollo.QueryHookOptions<FtuePlayerDataMatchProfileQuery, FtuePlayerDataMatchProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FtuePlayerDataMatchProfileQuery, FtuePlayerDataMatchProfileQueryVariables>(FtuePlayerDataMatchProfileDocument, options);
      }
export function useFtuePlayerDataMatchProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FtuePlayerDataMatchProfileQuery, FtuePlayerDataMatchProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FtuePlayerDataMatchProfileQuery, FtuePlayerDataMatchProfileQueryVariables>(FtuePlayerDataMatchProfileDocument, options);
        }
export type FtuePlayerDataMatchProfileQueryHookResult = ReturnType<typeof useFtuePlayerDataMatchProfileQuery>;
export type FtuePlayerDataMatchProfileLazyQueryHookResult = ReturnType<typeof useFtuePlayerDataMatchProfileLazyQuery>;
export type FtuePlayerDataMatchProfileQueryResult = Apollo.QueryResult<FtuePlayerDataMatchProfileQuery, FtuePlayerDataMatchProfileQueryVariables>;
export const FtuePlayerDataBoosterProfileDocument = gql`
    query FTUEPlayerDataBoosterProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    stats {
      boosterUsage {
        total
        doubt
        goodCall
        letsGo
        nextUp
        scavenge
        speedUp
      }
    }
  }
}
    `;

/**
 * __useFtuePlayerDataBoosterProfileQuery__
 *
 * To run a query within a React component, call `useFtuePlayerDataBoosterProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useFtuePlayerDataBoosterProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFtuePlayerDataBoosterProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFtuePlayerDataBoosterProfileQuery(baseOptions: Apollo.QueryHookOptions<FtuePlayerDataBoosterProfileQuery, FtuePlayerDataBoosterProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FtuePlayerDataBoosterProfileQuery, FtuePlayerDataBoosterProfileQueryVariables>(FtuePlayerDataBoosterProfileDocument, options);
      }
export function useFtuePlayerDataBoosterProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FtuePlayerDataBoosterProfileQuery, FtuePlayerDataBoosterProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FtuePlayerDataBoosterProfileQuery, FtuePlayerDataBoosterProfileQueryVariables>(FtuePlayerDataBoosterProfileDocument, options);
        }
export type FtuePlayerDataBoosterProfileQueryHookResult = ReturnType<typeof useFtuePlayerDataBoosterProfileQuery>;
export type FtuePlayerDataBoosterProfileLazyQueryHookResult = ReturnType<typeof useFtuePlayerDataBoosterProfileLazyQuery>;
export type FtuePlayerDataBoosterProfileQueryResult = Apollo.QueryResult<FtuePlayerDataBoosterProfileQuery, FtuePlayerDataBoosterProfileQueryVariables>;
export const FtueCriteriaDataCardDocument = gql`
    query FTUECriteriaDataCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      isMatchCard
      isAllOrNothing
    }
  }
}
    `;

/**
 * __useFtueCriteriaDataCardQuery__
 *
 * To run a query within a React component, call `useFtueCriteriaDataCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useFtueCriteriaDataCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFtueCriteriaDataCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useFtueCriteriaDataCardQuery(baseOptions: Apollo.QueryHookOptions<FtueCriteriaDataCardQuery, FtueCriteriaDataCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FtueCriteriaDataCardQuery, FtueCriteriaDataCardQueryVariables>(FtueCriteriaDataCardDocument, options);
      }
export function useFtueCriteriaDataCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FtueCriteriaDataCardQuery, FtueCriteriaDataCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FtueCriteriaDataCardQuery, FtueCriteriaDataCardQueryVariables>(FtueCriteriaDataCardDocument, options);
        }
export type FtueCriteriaDataCardQueryHookResult = ReturnType<typeof useFtueCriteriaDataCardQuery>;
export type FtueCriteriaDataCardLazyQueryHookResult = ReturnType<typeof useFtueCriteriaDataCardLazyQuery>;
export type FtueCriteriaDataCardQueryResult = Apollo.QueryResult<FtueCriteriaDataCardQuery, FtueCriteriaDataCardQueryVariables>;
export const FtueDismissComponentDocument = gql`
    mutation FTUEDismissComponent($tooltipId: ID!, $type: FtueDismissalType) {
  dismissTooltip(tooltipId: $tooltipId, dismissalType: $type) {
    emptyTypeWorkaround
  }
}
    `;
export type FtueDismissComponentMutationFn = Apollo.MutationFunction<FtueDismissComponentMutation, FtueDismissComponentMutationVariables>;

/**
 * __useFtueDismissComponentMutation__
 *
 * To run a mutation, you first call `useFtueDismissComponentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFtueDismissComponentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [ftueDismissComponentMutation, { data, loading, error }] = useFtueDismissComponentMutation({
 *   variables: {
 *      tooltipId: // value for 'tooltipId'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useFtueDismissComponentMutation(baseOptions?: Apollo.MutationHookOptions<FtueDismissComponentMutation, FtueDismissComponentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FtueDismissComponentMutation, FtueDismissComponentMutationVariables>(FtueDismissComponentDocument, options);
      }
export type FtueDismissComponentMutationHookResult = ReturnType<typeof useFtueDismissComponentMutation>;
export type FtueDismissComponentMutationResult = Apollo.MutationResult<FtueDismissComponentMutation>;
export type FtueDismissComponentMutationOptions = Apollo.BaseMutationOptions<FtueDismissComponentMutation, FtueDismissComponentMutationVariables>;
export const PlatformAppDataDocument = gql`
    query PlatformAppData($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ZendeskPrefillProfile
    ...SeasonEndDialogWrapperProfile
    ...PageLayoutProfile
  }
}
    ${ZendeskPrefillProfileFragmentDoc}
${SeasonEndDialogWrapperProfileFragmentDoc}
${PageLayoutProfileFragmentDoc}`;

/**
 * __usePlatformAppDataQuery__
 *
 * To run a query within a React component, call `usePlatformAppDataQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlatformAppDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlatformAppDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function usePlatformAppDataQuery(baseOptions: Apollo.QueryHookOptions<PlatformAppDataQuery, PlatformAppDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlatformAppDataQuery, PlatformAppDataQueryVariables>(PlatformAppDataDocument, options);
      }
export function usePlatformAppDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlatformAppDataQuery, PlatformAppDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlatformAppDataQuery, PlatformAppDataQueryVariables>(PlatformAppDataDocument, options);
        }
export type PlatformAppDataQueryHookResult = ReturnType<typeof usePlatformAppDataQuery>;
export type PlatformAppDataLazyQueryHookResult = ReturnType<typeof usePlatformAppDataLazyQuery>;
export type PlatformAppDataQueryResult = Apollo.QueryResult<PlatformAppDataQuery, PlatformAppDataQueryVariables>;
export const UserAnnouncementsDocument = gql`
    query UserAnnouncements($userId: ID!) {
  userAnnouncements(userId: $userId, target: ANNOUNCEMENT_TARGET_WEB) {
    announcements {
      id
      ...PlatformAnnouncement
    }
  }
}
    ${PlatformAnnouncementFragmentDoc}`;

/**
 * __useUserAnnouncementsQuery__
 *
 * To run a query within a React component, call `useUserAnnouncementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserAnnouncementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserAnnouncementsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserAnnouncementsQuery(baseOptions: Apollo.QueryHookOptions<UserAnnouncementsQuery, UserAnnouncementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserAnnouncementsQuery, UserAnnouncementsQueryVariables>(UserAnnouncementsDocument, options);
      }
export function useUserAnnouncementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserAnnouncementsQuery, UserAnnouncementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserAnnouncementsQuery, UserAnnouncementsQueryVariables>(UserAnnouncementsDocument, options);
        }
export type UserAnnouncementsQueryHookResult = ReturnType<typeof useUserAnnouncementsQuery>;
export type UserAnnouncementsLazyQueryHookResult = ReturnType<typeof useUserAnnouncementsLazyQuery>;
export type UserAnnouncementsQueryResult = Apollo.QueryResult<UserAnnouncementsQuery, UserAnnouncementsQueryVariables>;
export const AppRouteRedirectsProfileDocument = gql`
    query AppRouteRedirectsProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      flags
      state
    }
    ...CompleteAccountCheckProfile
  }
  platformBan(userId: $userId) {
    banId
  }
}
    ${CompleteAccountCheckProfileFragmentDoc}`;

/**
 * __useAppRouteRedirectsProfileQuery__
 *
 * To run a query within a React component, call `useAppRouteRedirectsProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useAppRouteRedirectsProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAppRouteRedirectsProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useAppRouteRedirectsProfileQuery(baseOptions: Apollo.QueryHookOptions<AppRouteRedirectsProfileQuery, AppRouteRedirectsProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AppRouteRedirectsProfileQuery, AppRouteRedirectsProfileQueryVariables>(AppRouteRedirectsProfileDocument, options);
      }
export function useAppRouteRedirectsProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AppRouteRedirectsProfileQuery, AppRouteRedirectsProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AppRouteRedirectsProfileQuery, AppRouteRedirectsProfileQueryVariables>(AppRouteRedirectsProfileDocument, options);
        }
export type AppRouteRedirectsProfileQueryHookResult = ReturnType<typeof useAppRouteRedirectsProfileQuery>;
export type AppRouteRedirectsProfileLazyQueryHookResult = ReturnType<typeof useAppRouteRedirectsProfileLazyQuery>;
export type AppRouteRedirectsProfileQueryResult = Apollo.QueryResult<AppRouteRedirectsProfileQuery, AppRouteRedirectsProfileQueryVariables>;
export const UserPendingAgreementsDocument = gql`
    query UserPendingAgreements($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      uid
      pendingAgreements {
        name
        revision
        url
      }
      marketingConsent
    }
  }
}
    `;

/**
 * __useUserPendingAgreementsQuery__
 *
 * To run a query within a React component, call `useUserPendingAgreementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserPendingAgreementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserPendingAgreementsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserPendingAgreementsQuery(baseOptions: Apollo.QueryHookOptions<UserPendingAgreementsQuery, UserPendingAgreementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserPendingAgreementsQuery, UserPendingAgreementsQueryVariables>(UserPendingAgreementsDocument, options);
      }
export function useUserPendingAgreementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserPendingAgreementsQuery, UserPendingAgreementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserPendingAgreementsQuery, UserPendingAgreementsQueryVariables>(UserPendingAgreementsDocument, options);
        }
export type UserPendingAgreementsQueryHookResult = ReturnType<typeof useUserPendingAgreementsQuery>;
export type UserPendingAgreementsLazyQueryHookResult = ReturnType<typeof useUserPendingAgreementsLazyQuery>;
export type UserPendingAgreementsQueryResult = Apollo.QueryResult<UserPendingAgreementsQuery, UserPendingAgreementsQueryVariables>;
export const AvatarPartChannelLogoChannelDocument = gql`
    query AvatarPartChannelLogoChannel($channelId: ID!) {
  channel(id: $channelId) {
    ...ChannelLogoChannel
  }
}
    ${ChannelLogoChannelFragmentDoc}`;

/**
 * __useAvatarPartChannelLogoChannelQuery__
 *
 * To run a query within a React component, call `useAvatarPartChannelLogoChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useAvatarPartChannelLogoChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAvatarPartChannelLogoChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useAvatarPartChannelLogoChannelQuery(baseOptions: Apollo.QueryHookOptions<AvatarPartChannelLogoChannelQuery, AvatarPartChannelLogoChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AvatarPartChannelLogoChannelQuery, AvatarPartChannelLogoChannelQueryVariables>(AvatarPartChannelLogoChannelDocument, options);
      }
export function useAvatarPartChannelLogoChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AvatarPartChannelLogoChannelQuery, AvatarPartChannelLogoChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AvatarPartChannelLogoChannelQuery, AvatarPartChannelLogoChannelQueryVariables>(AvatarPartChannelLogoChannelDocument, options);
        }
export type AvatarPartChannelLogoChannelQueryHookResult = ReturnType<typeof useAvatarPartChannelLogoChannelQuery>;
export type AvatarPartChannelLogoChannelLazyQueryHookResult = ReturnType<typeof useAvatarPartChannelLogoChannelLazyQuery>;
export type AvatarPartChannelLogoChannelQueryResult = Apollo.QueryResult<AvatarPartChannelLogoChannelQuery, AvatarPartChannelLogoChannelQueryVariables>;
export const AvatarPartChannelDocument = gql`
    query AvatarPartChannel($channelId: ID) {
  channel(id: $channelId) {
    id
    name
    logo
    liveStatus
  }
}
    `;

/**
 * __useAvatarPartChannelQuery__
 *
 * To run a query within a React component, call `useAvatarPartChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useAvatarPartChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAvatarPartChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useAvatarPartChannelQuery(baseOptions?: Apollo.QueryHookOptions<AvatarPartChannelQuery, AvatarPartChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AvatarPartChannelQuery, AvatarPartChannelQueryVariables>(AvatarPartChannelDocument, options);
      }
export function useAvatarPartChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AvatarPartChannelQuery, AvatarPartChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AvatarPartChannelQuery, AvatarPartChannelQueryVariables>(AvatarPartChannelDocument, options);
        }
export type AvatarPartChannelQueryHookResult = ReturnType<typeof useAvatarPartChannelQuery>;
export type AvatarPartChannelLazyQueryHookResult = ReturnType<typeof useAvatarPartChannelLazyQuery>;
export type AvatarPartChannelQueryResult = Apollo.QueryResult<AvatarPartChannelQuery, AvatarPartChannelQueryVariables>;
export const AvatarEditorAvatarPartsDocument = gql`
    query AvatarEditorAvatarParts {
  avatarEditorStoreFront {
    id
    gameId
    categories {
      id
      ... on StoreV2StoreFrontCategory {
        id
        itemType
        sellableItems {
          ...AvatarEditorSellableItem
        }
      }
    }
  }
}
    ${AvatarEditorSellableItemFragmentDoc}`;

/**
 * __useAvatarEditorAvatarPartsQuery__
 *
 * To run a query within a React component, call `useAvatarEditorAvatarPartsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAvatarEditorAvatarPartsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAvatarEditorAvatarPartsQuery({
 *   variables: {
 *   },
 * });
 */
export function useAvatarEditorAvatarPartsQuery(baseOptions?: Apollo.QueryHookOptions<AvatarEditorAvatarPartsQuery, AvatarEditorAvatarPartsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AvatarEditorAvatarPartsQuery, AvatarEditorAvatarPartsQueryVariables>(AvatarEditorAvatarPartsDocument, options);
      }
export function useAvatarEditorAvatarPartsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AvatarEditorAvatarPartsQuery, AvatarEditorAvatarPartsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AvatarEditorAvatarPartsQuery, AvatarEditorAvatarPartsQueryVariables>(AvatarEditorAvatarPartsDocument, options);
        }
export type AvatarEditorAvatarPartsQueryHookResult = ReturnType<typeof useAvatarEditorAvatarPartsQuery>;
export type AvatarEditorAvatarPartsLazyQueryHookResult = ReturnType<typeof useAvatarEditorAvatarPartsLazyQuery>;
export type AvatarEditorAvatarPartsQueryResult = Apollo.QueryResult<AvatarEditorAvatarPartsQuery, AvatarEditorAvatarPartsQueryVariables>;
export const ChannelFollowerNotificationSettingsDocument = gql`
    query ChannelFollowerNotificationSettings($channelId: ID!, $userId: ID!) {
  channelFollowerNotificationSettings(channelId: $channelId, userId: $userId) {
    userId
    channelId
    channelLiveNotificationEnabled
  }
  channelNotificationSettings(userId: $userId) {
    userId
    channelLiveNotification {
      emailEnabled
    }
  }
}
    `;

/**
 * __useChannelFollowerNotificationSettingsQuery__
 *
 * To run a query within a React component, call `useChannelFollowerNotificationSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelFollowerNotificationSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelFollowerNotificationSettingsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChannelFollowerNotificationSettingsQuery(baseOptions: Apollo.QueryHookOptions<ChannelFollowerNotificationSettingsQuery, ChannelFollowerNotificationSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelFollowerNotificationSettingsQuery, ChannelFollowerNotificationSettingsQueryVariables>(ChannelFollowerNotificationSettingsDocument, options);
      }
export function useChannelFollowerNotificationSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelFollowerNotificationSettingsQuery, ChannelFollowerNotificationSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelFollowerNotificationSettingsQuery, ChannelFollowerNotificationSettingsQueryVariables>(ChannelFollowerNotificationSettingsDocument, options);
        }
export type ChannelFollowerNotificationSettingsQueryHookResult = ReturnType<typeof useChannelFollowerNotificationSettingsQuery>;
export type ChannelFollowerNotificationSettingsLazyQueryHookResult = ReturnType<typeof useChannelFollowerNotificationSettingsLazyQuery>;
export type ChannelFollowerNotificationSettingsQueryResult = Apollo.QueryResult<ChannelFollowerNotificationSettingsQuery, ChannelFollowerNotificationSettingsQueryVariables>;
export const LiveChannelProfileDocument = gql`
    query LiveChannelProfile($userId: ID!, $channelId: ID!) {
  profile(userId: $userId) {
    userId
    badges(channel_id: $channelId) {
      level
      type
    }
  }
}
    `;

/**
 * __useLiveChannelProfileQuery__
 *
 * To run a query within a React component, call `useLiveChannelProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useLiveChannelProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLiveChannelProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useLiveChannelProfileQuery(baseOptions: Apollo.QueryHookOptions<LiveChannelProfileQuery, LiveChannelProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LiveChannelProfileQuery, LiveChannelProfileQueryVariables>(LiveChannelProfileDocument, options);
      }
export function useLiveChannelProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LiveChannelProfileQuery, LiveChannelProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LiveChannelProfileQuery, LiveChannelProfileQueryVariables>(LiveChannelProfileDocument, options);
        }
export type LiveChannelProfileQueryHookResult = ReturnType<typeof useLiveChannelProfileQuery>;
export type LiveChannelProfileLazyQueryHookResult = ReturnType<typeof useLiveChannelProfileLazyQuery>;
export type LiveChannelProfileQueryResult = Apollo.QueryResult<LiveChannelProfileQuery, LiveChannelProfileQueryVariables>;
export const MatureRatedContentDialogProviderProfileDocument = gql`
    query MatureRatedContentDialogProviderProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      uid
      matureRatedContentAllowed
    }
    settings {
      privacy {
        showMatureContentWarning
      }
    }
  }
}
    `;

/**
 * __useMatureRatedContentDialogProviderProfileQuery__
 *
 * To run a query within a React component, call `useMatureRatedContentDialogProviderProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatureRatedContentDialogProviderProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatureRatedContentDialogProviderProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useMatureRatedContentDialogProviderProfileQuery(baseOptions: Apollo.QueryHookOptions<MatureRatedContentDialogProviderProfileQuery, MatureRatedContentDialogProviderProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatureRatedContentDialogProviderProfileQuery, MatureRatedContentDialogProviderProfileQueryVariables>(MatureRatedContentDialogProviderProfileDocument, options);
      }
export function useMatureRatedContentDialogProviderProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatureRatedContentDialogProviderProfileQuery, MatureRatedContentDialogProviderProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatureRatedContentDialogProviderProfileQuery, MatureRatedContentDialogProviderProfileQueryVariables>(MatureRatedContentDialogProviderProfileDocument, options);
        }
export type MatureRatedContentDialogProviderProfileQueryHookResult = ReturnType<typeof useMatureRatedContentDialogProviderProfileQuery>;
export type MatureRatedContentDialogProviderProfileLazyQueryHookResult = ReturnType<typeof useMatureRatedContentDialogProviderProfileLazyQuery>;
export type MatureRatedContentDialogProviderProfileQueryResult = Apollo.QueryResult<MatureRatedContentDialogProviderProfileQuery, MatureRatedContentDialogProviderProfileQueryVariables>;
export const MatureRatedContentDialogProviderChannelDocument = gql`
    query MatureRatedContentDialogProviderChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    ...IsGamePredictionsEnabledChannel
  }
}
    ${IsGamePredictionsEnabledChannelFragmentDoc}`;

/**
 * __useMatureRatedContentDialogProviderChannelQuery__
 *
 * To run a query within a React component, call `useMatureRatedContentDialogProviderChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatureRatedContentDialogProviderChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatureRatedContentDialogProviderChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useMatureRatedContentDialogProviderChannelQuery(baseOptions: Apollo.QueryHookOptions<MatureRatedContentDialogProviderChannelQuery, MatureRatedContentDialogProviderChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatureRatedContentDialogProviderChannelQuery, MatureRatedContentDialogProviderChannelQueryVariables>(MatureRatedContentDialogProviderChannelDocument, options);
      }
export function useMatureRatedContentDialogProviderChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatureRatedContentDialogProviderChannelQuery, MatureRatedContentDialogProviderChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatureRatedContentDialogProviderChannelQuery, MatureRatedContentDialogProviderChannelQueryVariables>(MatureRatedContentDialogProviderChannelDocument, options);
        }
export type MatureRatedContentDialogProviderChannelQueryHookResult = ReturnType<typeof useMatureRatedContentDialogProviderChannelQuery>;
export type MatureRatedContentDialogProviderChannelLazyQueryHookResult = ReturnType<typeof useMatureRatedContentDialogProviderChannelLazyQuery>;
export type MatureRatedContentDialogProviderChannelQueryResult = Apollo.QueryResult<MatureRatedContentDialogProviderChannelQuery, MatureRatedContentDialogProviderChannelQueryVariables>;
export const ChannelFollowChannelDocument = gql`
    mutation ChannelFollowChannel($channelId: ID!, $userId: ID!) {
  followChannel(channelId: $channelId, userId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type ChannelFollowChannelMutationFn = Apollo.MutationFunction<ChannelFollowChannelMutation, ChannelFollowChannelMutationVariables>;

/**
 * __useChannelFollowChannelMutation__
 *
 * To run a mutation, you first call `useChannelFollowChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelFollowChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelFollowChannelMutation, { data, loading, error }] = useChannelFollowChannelMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChannelFollowChannelMutation(baseOptions?: Apollo.MutationHookOptions<ChannelFollowChannelMutation, ChannelFollowChannelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelFollowChannelMutation, ChannelFollowChannelMutationVariables>(ChannelFollowChannelDocument, options);
      }
export type ChannelFollowChannelMutationHookResult = ReturnType<typeof useChannelFollowChannelMutation>;
export type ChannelFollowChannelMutationResult = Apollo.MutationResult<ChannelFollowChannelMutation>;
export type ChannelFollowChannelMutationOptions = Apollo.BaseMutationOptions<ChannelFollowChannelMutation, ChannelFollowChannelMutationVariables>;
export const UseLocalPlayerChannelIdsDocument = gql`
    query UseLocalPlayerChannelIds($userId: ID) {
  followedChannels(userId: $userId) {
    channels {
      id
    }
  }
}
    `;

/**
 * __useUseLocalPlayerChannelIdsQuery__
 *
 * To run a query within a React component, call `useUseLocalPlayerChannelIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseLocalPlayerChannelIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseLocalPlayerChannelIdsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUseLocalPlayerChannelIdsQuery(baseOptions?: Apollo.QueryHookOptions<UseLocalPlayerChannelIdsQuery, UseLocalPlayerChannelIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseLocalPlayerChannelIdsQuery, UseLocalPlayerChannelIdsQueryVariables>(UseLocalPlayerChannelIdsDocument, options);
      }
export function useUseLocalPlayerChannelIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseLocalPlayerChannelIdsQuery, UseLocalPlayerChannelIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseLocalPlayerChannelIdsQuery, UseLocalPlayerChannelIdsQueryVariables>(UseLocalPlayerChannelIdsDocument, options);
        }
export type UseLocalPlayerChannelIdsQueryHookResult = ReturnType<typeof useUseLocalPlayerChannelIdsQuery>;
export type UseLocalPlayerChannelIdsLazyQueryHookResult = ReturnType<typeof useUseLocalPlayerChannelIdsLazyQuery>;
export type UseLocalPlayerChannelIdsQueryResult = Apollo.QueryResult<UseLocalPlayerChannelIdsQuery, UseLocalPlayerChannelIdsQueryVariables>;
export const ChannelUnfollowChannelDocument = gql`
    mutation ChannelUnfollowChannel($channelId: ID!, $userId: ID!) {
  unfollowChannel(channelId: $channelId, userId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type ChannelUnfollowChannelMutationFn = Apollo.MutationFunction<ChannelUnfollowChannelMutation, ChannelUnfollowChannelMutationVariables>;

/**
 * __useChannelUnfollowChannelMutation__
 *
 * To run a mutation, you first call `useChannelUnfollowChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelUnfollowChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelUnfollowChannelMutation, { data, loading, error }] = useChannelUnfollowChannelMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChannelUnfollowChannelMutation(baseOptions?: Apollo.MutationHookOptions<ChannelUnfollowChannelMutation, ChannelUnfollowChannelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelUnfollowChannelMutation, ChannelUnfollowChannelMutationVariables>(ChannelUnfollowChannelDocument, options);
      }
export type ChannelUnfollowChannelMutationHookResult = ReturnType<typeof useChannelUnfollowChannelMutation>;
export type ChannelUnfollowChannelMutationResult = Apollo.MutationResult<ChannelUnfollowChannelMutation>;
export type ChannelUnfollowChannelMutationOptions = Apollo.BaseMutationOptions<ChannelUnfollowChannelMutation, ChannelUnfollowChannelMutationVariables>;
export const UpdateChannelFollowerNotificationSettingsDocument = gql`
    mutation UpdateChannelFollowerNotificationSettings($channelId: ID!, $userId: ID!, $enabled: Boolean!) {
  updateFollowerNotificationSettings(
    body: {channelId: $channelId, userId: $userId, channelLiveNotificationEnabled: $enabled}
  ) {
    userId
    channelId
    channelLiveNotificationEnabled
  }
}
    `;
export type UpdateChannelFollowerNotificationSettingsMutationFn = Apollo.MutationFunction<UpdateChannelFollowerNotificationSettingsMutation, UpdateChannelFollowerNotificationSettingsMutationVariables>;

/**
 * __useUpdateChannelFollowerNotificationSettingsMutation__
 *
 * To run a mutation, you first call `useUpdateChannelFollowerNotificationSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChannelFollowerNotificationSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChannelFollowerNotificationSettingsMutation, { data, loading, error }] = useUpdateChannelFollowerNotificationSettingsMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *      enabled: // value for 'enabled'
 *   },
 * });
 */
export function useUpdateChannelFollowerNotificationSettingsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChannelFollowerNotificationSettingsMutation, UpdateChannelFollowerNotificationSettingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChannelFollowerNotificationSettingsMutation, UpdateChannelFollowerNotificationSettingsMutationVariables>(UpdateChannelFollowerNotificationSettingsDocument, options);
      }
export type UpdateChannelFollowerNotificationSettingsMutationHookResult = ReturnType<typeof useUpdateChannelFollowerNotificationSettingsMutation>;
export type UpdateChannelFollowerNotificationSettingsMutationResult = Apollo.MutationResult<UpdateChannelFollowerNotificationSettingsMutation>;
export type UpdateChannelFollowerNotificationSettingsMutationOptions = Apollo.BaseMutationOptions<UpdateChannelFollowerNotificationSettingsMutation, UpdateChannelFollowerNotificationSettingsMutationVariables>;
export const GameProgressionLevelConfigsDocument = gql`
    query GameProgressionLevelConfigs($seasonId: ID, $minLevel: Int) {
  listLevelConfigs(seasonId: $seasonId, minLevel: $minLevel) {
    levelConfigs {
      threshold
    }
  }
}
    `;

/**
 * __useGameProgressionLevelConfigsQuery__
 *
 * To run a query within a React component, call `useGameProgressionLevelConfigsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameProgressionLevelConfigsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameProgressionLevelConfigsQuery({
 *   variables: {
 *      seasonId: // value for 'seasonId'
 *      minLevel: // value for 'minLevel'
 *   },
 * });
 */
export function useGameProgressionLevelConfigsQuery(baseOptions?: Apollo.QueryHookOptions<GameProgressionLevelConfigsQuery, GameProgressionLevelConfigsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameProgressionLevelConfigsQuery, GameProgressionLevelConfigsQueryVariables>(GameProgressionLevelConfigsDocument, options);
      }
export function useGameProgressionLevelConfigsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameProgressionLevelConfigsQuery, GameProgressionLevelConfigsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameProgressionLevelConfigsQuery, GameProgressionLevelConfigsQueryVariables>(GameProgressionLevelConfigsDocument, options);
        }
export type GameProgressionLevelConfigsQueryHookResult = ReturnType<typeof useGameProgressionLevelConfigsQuery>;
export type GameProgressionLevelConfigsLazyQueryHookResult = ReturnType<typeof useGameProgressionLevelConfigsLazyQuery>;
export type GameProgressionLevelConfigsQueryResult = Apollo.QueryResult<GameProgressionLevelConfigsQuery, GameProgressionLevelConfigsQueryVariables>;
export const UseAvatarEmotesDocument = gql`
    query UseAvatarEmotes($userId: ID) {
  inventory(
    userId: $userId
    filters: [{itemType: TYPE_EMOTE}, {itemType: TYPE_EMOJI}]
  ) {
    items {
      itemId
      item {
        id
        type
        details {
          __typename
          ... on AvatarAnimation {
            name
            chatCommand
            iconUrl
            id
          }
          ... on EmojiEmoji {
            id
            label
            image
          }
        }
      }
    }
  }
}
    `;

/**
 * __useUseAvatarEmotesQuery__
 *
 * To run a query within a React component, call `useUseAvatarEmotesQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseAvatarEmotesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseAvatarEmotesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUseAvatarEmotesQuery(baseOptions?: Apollo.QueryHookOptions<UseAvatarEmotesQuery, UseAvatarEmotesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseAvatarEmotesQuery, UseAvatarEmotesQueryVariables>(UseAvatarEmotesDocument, options);
      }
export function useUseAvatarEmotesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseAvatarEmotesQuery, UseAvatarEmotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseAvatarEmotesQuery, UseAvatarEmotesQueryVariables>(UseAvatarEmotesDocument, options);
        }
export type UseAvatarEmotesQueryHookResult = ReturnType<typeof useUseAvatarEmotesQuery>;
export type UseAvatarEmotesLazyQueryHookResult = ReturnType<typeof useUseAvatarEmotesLazyQuery>;
export type UseAvatarEmotesQueryResult = Apollo.QueryResult<UseAvatarEmotesQuery, UseAvatarEmotesQueryVariables>;
export const ChannelSectionSmChannelDocument = gql`
    query ChannelSectionSmChannel($channelId: ID!, $skipAuthFields: Boolean = false) {
  channel(id: $channelId) {
    id
    name
    liveStatus
    ...ChannelLogoChannel
    ...ChannelActionButtonsChannel
    ...ChannelSectionSmTagsChannel
  }
}
    ${ChannelLogoChannelFragmentDoc}
${ChannelActionButtonsChannelFragmentDoc}
${ChannelSectionSmTagsChannelFragmentDoc}`;

/**
 * __useChannelSectionSmChannelQuery__
 *
 * To run a query within a React component, call `useChannelSectionSmChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelSectionSmChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelSectionSmChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      skipAuthFields: // value for 'skipAuthFields'
 *   },
 * });
 */
export function useChannelSectionSmChannelQuery(baseOptions: Apollo.QueryHookOptions<ChannelSectionSmChannelQuery, ChannelSectionSmChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelSectionSmChannelQuery, ChannelSectionSmChannelQueryVariables>(ChannelSectionSmChannelDocument, options);
      }
export function useChannelSectionSmChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelSectionSmChannelQuery, ChannelSectionSmChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelSectionSmChannelQuery, ChannelSectionSmChannelQueryVariables>(ChannelSectionSmChannelDocument, options);
        }
export type ChannelSectionSmChannelQueryHookResult = ReturnType<typeof useChannelSectionSmChannelQuery>;
export type ChannelSectionSmChannelLazyQueryHookResult = ReturnType<typeof useChannelSectionSmChannelLazyQuery>;
export type ChannelSectionSmChannelQueryResult = Apollo.QueryResult<ChannelSectionSmChannelQuery, ChannelSectionSmChannelQueryVariables>;
export const ChannelSectionViewerCountDocument = gql`
    query ChannelSectionViewerCount($channelId: ID!) {
  channel(id: $channelId) {
    id
    viewerCount
  }
}
    `;

/**
 * __useChannelSectionViewerCountQuery__
 *
 * To run a query within a React component, call `useChannelSectionViewerCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelSectionViewerCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelSectionViewerCountQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelSectionViewerCountQuery(baseOptions: Apollo.QueryHookOptions<ChannelSectionViewerCountQuery, ChannelSectionViewerCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelSectionViewerCountQuery, ChannelSectionViewerCountQueryVariables>(ChannelSectionViewerCountDocument, options);
      }
export function useChannelSectionViewerCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelSectionViewerCountQuery, ChannelSectionViewerCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelSectionViewerCountQuery, ChannelSectionViewerCountQueryVariables>(ChannelSectionViewerCountDocument, options);
        }
export type ChannelSectionViewerCountQueryHookResult = ReturnType<typeof useChannelSectionViewerCountQuery>;
export type ChannelSectionViewerCountLazyQueryHookResult = ReturnType<typeof useChannelSectionViewerCountLazyQuery>;
export type ChannelSectionViewerCountQueryResult = Apollo.QueryResult<ChannelSectionViewerCountQuery, ChannelSectionViewerCountQueryVariables>;
export const GameSidebarChannelDocument = gql`
    query GameSidebarChannel($channelId: ID!, $skipAuthFields: Boolean = false) {
  channel(id: $channelId) {
    id
    ...GameSidebarMinimizedChannel
    ...GameSidebarExpandedChannel
  }
}
    ${GameSidebarMinimizedChannelFragmentDoc}
${GameSidebarExpandedChannelFragmentDoc}`;

/**
 * __useGameSidebarChannelQuery__
 *
 * To run a query within a React component, call `useGameSidebarChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameSidebarChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameSidebarChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      skipAuthFields: // value for 'skipAuthFields'
 *   },
 * });
 */
export function useGameSidebarChannelQuery(baseOptions: Apollo.QueryHookOptions<GameSidebarChannelQuery, GameSidebarChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameSidebarChannelQuery, GameSidebarChannelQueryVariables>(GameSidebarChannelDocument, options);
      }
export function useGameSidebarChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameSidebarChannelQuery, GameSidebarChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameSidebarChannelQuery, GameSidebarChannelQueryVariables>(GameSidebarChannelDocument, options);
        }
export type GameSidebarChannelQueryHookResult = ReturnType<typeof useGameSidebarChannelQuery>;
export type GameSidebarChannelLazyQueryHookResult = ReturnType<typeof useGameSidebarChannelLazyQuery>;
export type GameSidebarChannelQueryResult = Apollo.QueryResult<GameSidebarChannelQuery, GameSidebarChannelQueryVariables>;
export const ChannelSectionChannelViewerCountDocument = gql`
    subscription ChannelSectionChannelViewerCount($channelId: ID!) {
  channelViewerCountSubscribe(channelId: $channelId) {
    viewerCount
  }
}
    `;

/**
 * __useChannelSectionChannelViewerCountSubscription__
 *
 * To run a query within a React component, call `useChannelSectionChannelViewerCountSubscription` and pass it any options that fit your needs.
 * When your component renders, `useChannelSectionChannelViewerCountSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelSectionChannelViewerCountSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelSectionChannelViewerCountSubscription(baseOptions: Apollo.SubscriptionHookOptions<ChannelSectionChannelViewerCountSubscription, ChannelSectionChannelViewerCountSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ChannelSectionChannelViewerCountSubscription, ChannelSectionChannelViewerCountSubscriptionVariables>(ChannelSectionChannelViewerCountDocument, options);
      }
export type ChannelSectionChannelViewerCountSubscriptionHookResult = ReturnType<typeof useChannelSectionChannelViewerCountSubscription>;
export type ChannelSectionChannelViewerCountSubscriptionResult = Apollo.SubscriptionResult<ChannelSectionChannelViewerCountSubscription>;
export const AonDoubleDownCardDocument = gql`
    query AonDoubleDownCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useAonDoubleDownCardQuery__
 *
 * To run a query within a React component, call `useAonDoubleDownCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useAonDoubleDownCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAonDoubleDownCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useAonDoubleDownCardQuery(baseOptions: Apollo.QueryHookOptions<AonDoubleDownCardQuery, AonDoubleDownCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AonDoubleDownCardQuery, AonDoubleDownCardQueryVariables>(AonDoubleDownCardDocument, options);
      }
export function useAonDoubleDownCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AonDoubleDownCardQuery, AonDoubleDownCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AonDoubleDownCardQuery, AonDoubleDownCardQueryVariables>(AonDoubleDownCardDocument, options);
        }
export type AonDoubleDownCardQueryHookResult = ReturnType<typeof useAonDoubleDownCardQuery>;
export type AonDoubleDownCardLazyQueryHookResult = ReturnType<typeof useAonDoubleDownCardLazyQuery>;
export type AonDoubleDownCardQueryResult = Apollo.QueryResult<AonDoubleDownCardQuery, AonDoubleDownCardQueryVariables>;
export const BoosterScoredCardDocument = gql`
    query BoosterScoredCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useBoosterScoredCardQuery__
 *
 * To run a query within a React component, call `useBoosterScoredCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useBoosterScoredCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBoosterScoredCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useBoosterScoredCardQuery(baseOptions: Apollo.QueryHookOptions<BoosterScoredCardQuery, BoosterScoredCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BoosterScoredCardQuery, BoosterScoredCardQueryVariables>(BoosterScoredCardDocument, options);
      }
export function useBoosterScoredCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BoosterScoredCardQuery, BoosterScoredCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BoosterScoredCardQuery, BoosterScoredCardQueryVariables>(BoosterScoredCardDocument, options);
        }
export type BoosterScoredCardQueryHookResult = ReturnType<typeof useBoosterScoredCardQuery>;
export type BoosterScoredCardLazyQueryHookResult = ReturnType<typeof useBoosterScoredCardLazyQuery>;
export type BoosterScoredCardQueryResult = Apollo.QueryResult<BoosterScoredCardQuery, BoosterScoredCardQueryVariables>;
export const CardFailedBoostersDocument = gql`
    query CardFailedBoosters($cardId: String!) {
  boosters {
    boosters {
      id
      name
    }
  }
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useCardFailedBoostersQuery__
 *
 * To run a query within a React component, call `useCardFailedBoostersQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardFailedBoostersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardFailedBoostersQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useCardFailedBoostersQuery(baseOptions: Apollo.QueryHookOptions<CardFailedBoostersQuery, CardFailedBoostersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardFailedBoostersQuery, CardFailedBoostersQueryVariables>(CardFailedBoostersDocument, options);
      }
export function useCardFailedBoostersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardFailedBoostersQuery, CardFailedBoostersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardFailedBoostersQuery, CardFailedBoostersQueryVariables>(CardFailedBoostersDocument, options);
        }
export type CardFailedBoostersQueryHookResult = ReturnType<typeof useCardFailedBoostersQuery>;
export type CardFailedBoostersLazyQueryHookResult = ReturnType<typeof useCardFailedBoostersLazyQuery>;
export type CardFailedBoostersQueryResult = Apollo.QueryResult<CardFailedBoostersQuery, CardFailedBoostersQueryVariables>;
export const CardScavengeDataDocument = gql`
    query CardScavengeData($cardId: String!) {
  boosters {
    boosters {
      id
      name
    }
  }
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useCardScavengeDataQuery__
 *
 * To run a query within a React component, call `useCardScavengeDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardScavengeDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardScavengeDataQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useCardScavengeDataQuery(baseOptions: Apollo.QueryHookOptions<CardScavengeDataQuery, CardScavengeDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardScavengeDataQuery, CardScavengeDataQueryVariables>(CardScavengeDataDocument, options);
      }
export function useCardScavengeDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardScavengeDataQuery, CardScavengeDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardScavengeDataQuery, CardScavengeDataQueryVariables>(CardScavengeDataDocument, options);
        }
export type CardScavengeDataQueryHookResult = ReturnType<typeof useCardScavengeDataQuery>;
export type CardScavengeDataLazyQueryHookResult = ReturnType<typeof useCardScavengeDataLazyQuery>;
export type CardScavengeDataQueryResult = Apollo.QueryResult<CardScavengeDataQuery, CardScavengeDataQueryVariables>;
export const CardSuccessDataDocument = gql`
    query CardSuccessData($cardId: String!) {
  boosters {
    boosters {
      id
      name
    }
  }
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      ...GameCard
      activeStreamerCard {
        channel {
          id
          streamer {
            userId
          }
          name
        }
      }
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useCardSuccessDataQuery__
 *
 * To run a query within a React component, call `useCardSuccessDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardSuccessDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardSuccessDataQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useCardSuccessDataQuery(baseOptions: Apollo.QueryHookOptions<CardSuccessDataQuery, CardSuccessDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardSuccessDataQuery, CardSuccessDataQueryVariables>(CardSuccessDataDocument, options);
      }
export function useCardSuccessDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardSuccessDataQuery, CardSuccessDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardSuccessDataQuery, CardSuccessDataQueryVariables>(CardSuccessDataDocument, options);
        }
export type CardSuccessDataQueryHookResult = ReturnType<typeof useCardSuccessDataQuery>;
export type CardSuccessDataLazyQueryHookResult = ReturnType<typeof useCardSuccessDataLazyQuery>;
export type CardSuccessDataQueryResult = Apollo.QueryResult<CardSuccessDataQuery, CardSuccessDataQueryVariables>;
export const UseGroupEventsBoosterDataDocument = gql`
    query useGroupEventsBoosterData($id: Int!) {
  booster(id: $id) {
    id
    name
  }
}
    `;

/**
 * __useUseGroupEventsBoosterDataQuery__
 *
 * To run a query within a React component, call `useUseGroupEventsBoosterDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseGroupEventsBoosterDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseGroupEventsBoosterDataQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUseGroupEventsBoosterDataQuery(baseOptions: Apollo.QueryHookOptions<UseGroupEventsBoosterDataQuery, UseGroupEventsBoosterDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseGroupEventsBoosterDataQuery, UseGroupEventsBoosterDataQueryVariables>(UseGroupEventsBoosterDataDocument, options);
      }
export function useUseGroupEventsBoosterDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseGroupEventsBoosterDataQuery, UseGroupEventsBoosterDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseGroupEventsBoosterDataQuery, UseGroupEventsBoosterDataQueryVariables>(UseGroupEventsBoosterDataDocument, options);
        }
export type UseGroupEventsBoosterDataQueryHookResult = ReturnType<typeof useUseGroupEventsBoosterDataQuery>;
export type UseGroupEventsBoosterDataLazyQueryHookResult = ReturnType<typeof useUseGroupEventsBoosterDataLazyQuery>;
export type UseGroupEventsBoosterDataQueryResult = Apollo.QueryResult<UseGroupEventsBoosterDataQuery, UseGroupEventsBoosterDataQueryVariables>;
export const UseGroupEventsPlayerProfileDocument = gql`
    query useGroupEventsPlayerProfile($playerId: ID!) {
  profile(userId: $playerId) {
    userId
    userTag
    avatars {
      avatar2D
    }
    onlineStatus
    preferredColor
    ...ProfileImageProfile
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useUseGroupEventsPlayerProfileQuery__
 *
 * To run a query within a React component, call `useUseGroupEventsPlayerProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseGroupEventsPlayerProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseGroupEventsPlayerProfileQuery({
 *   variables: {
 *      playerId: // value for 'playerId'
 *   },
 * });
 */
export function useUseGroupEventsPlayerProfileQuery(baseOptions: Apollo.QueryHookOptions<UseGroupEventsPlayerProfileQuery, UseGroupEventsPlayerProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseGroupEventsPlayerProfileQuery, UseGroupEventsPlayerProfileQueryVariables>(UseGroupEventsPlayerProfileDocument, options);
      }
export function useUseGroupEventsPlayerProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseGroupEventsPlayerProfileQuery, UseGroupEventsPlayerProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseGroupEventsPlayerProfileQuery, UseGroupEventsPlayerProfileQueryVariables>(UseGroupEventsPlayerProfileDocument, options);
        }
export type UseGroupEventsPlayerProfileQueryHookResult = ReturnType<typeof useUseGroupEventsPlayerProfileQuery>;
export type UseGroupEventsPlayerProfileLazyQueryHookResult = ReturnType<typeof useUseGroupEventsPlayerProfileLazyQuery>;
export type UseGroupEventsPlayerProfileQueryResult = Apollo.QueryResult<UseGroupEventsPlayerProfileQuery, UseGroupEventsPlayerProfileQueryVariables>;
export const ImplicitAccountGameBannerRankDocument = gql`
    query ImplicitAccountGameBannerRank($userId: ID!) {
  profile(userId: $userId) {
    userId
    playedGames {
      userId
      id
      game {
        id
        ...GameProgressionGame
      }
    }
  }
}
    ${GameProgressionGameFragmentDoc}`;

/**
 * __useImplicitAccountGameBannerRankQuery__
 *
 * To run a query within a React component, call `useImplicitAccountGameBannerRankQuery` and pass it any options that fit your needs.
 * When your component renders, `useImplicitAccountGameBannerRankQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImplicitAccountGameBannerRankQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useImplicitAccountGameBannerRankQuery(baseOptions: Apollo.QueryHookOptions<ImplicitAccountGameBannerRankQuery, ImplicitAccountGameBannerRankQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ImplicitAccountGameBannerRankQuery, ImplicitAccountGameBannerRankQueryVariables>(ImplicitAccountGameBannerRankDocument, options);
      }
export function useImplicitAccountGameBannerRankLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImplicitAccountGameBannerRankQuery, ImplicitAccountGameBannerRankQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ImplicitAccountGameBannerRankQuery, ImplicitAccountGameBannerRankQueryVariables>(ImplicitAccountGameBannerRankDocument, options);
        }
export type ImplicitAccountGameBannerRankQueryHookResult = ReturnType<typeof useImplicitAccountGameBannerRankQuery>;
export type ImplicitAccountGameBannerRankLazyQueryHookResult = ReturnType<typeof useImplicitAccountGameBannerRankLazyQuery>;
export type ImplicitAccountGameBannerRankQueryResult = Apollo.QueryResult<ImplicitAccountGameBannerRankQuery, ImplicitAccountGameBannerRankQueryVariables>;
export const StreamComponentDataDocument = gql`
    query StreamComponentData($id: ID!) {
  streamSummary(id: $id) {
    serverRenderingEnabled
  }
}
    `;

/**
 * __useStreamComponentDataQuery__
 *
 * To run a query within a React component, call `useStreamComponentDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamComponentDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamComponentDataQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStreamComponentDataQuery(baseOptions: Apollo.QueryHookOptions<StreamComponentDataQuery, StreamComponentDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamComponentDataQuery, StreamComponentDataQueryVariables>(StreamComponentDataDocument, options);
      }
export function useStreamComponentDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamComponentDataQuery, StreamComponentDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamComponentDataQuery, StreamComponentDataQueryVariables>(StreamComponentDataDocument, options);
        }
export type StreamComponentDataQueryHookResult = ReturnType<typeof useStreamComponentDataQuery>;
export type StreamComponentDataLazyQueryHookResult = ReturnType<typeof useStreamComponentDataLazyQuery>;
export type StreamComponentDataQueryResult = Apollo.QueryResult<StreamComponentDataQuery, StreamComponentDataQueryVariables>;
export const PartyInvitationAcceptedPartyDocument = gql`
    query PartyInvitationAcceptedParty($partyId: ID!) {
  party(partyId: $partyId) {
    streamId
    channel {
      name
    }
  }
}
    `;

/**
 * __usePartyInvitationAcceptedPartyQuery__
 *
 * To run a query within a React component, call `usePartyInvitationAcceptedPartyQuery` and pass it any options that fit your needs.
 * When your component renders, `usePartyInvitationAcceptedPartyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePartyInvitationAcceptedPartyQuery({
 *   variables: {
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function usePartyInvitationAcceptedPartyQuery(baseOptions: Apollo.QueryHookOptions<PartyInvitationAcceptedPartyQuery, PartyInvitationAcceptedPartyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PartyInvitationAcceptedPartyQuery, PartyInvitationAcceptedPartyQueryVariables>(PartyInvitationAcceptedPartyDocument, options);
      }
export function usePartyInvitationAcceptedPartyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PartyInvitationAcceptedPartyQuery, PartyInvitationAcceptedPartyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PartyInvitationAcceptedPartyQuery, PartyInvitationAcceptedPartyQueryVariables>(PartyInvitationAcceptedPartyDocument, options);
        }
export type PartyInvitationAcceptedPartyQueryHookResult = ReturnType<typeof usePartyInvitationAcceptedPartyQuery>;
export type PartyInvitationAcceptedPartyLazyQueryHookResult = ReturnType<typeof usePartyInvitationAcceptedPartyLazyQuery>;
export type PartyInvitationAcceptedPartyQueryResult = Apollo.QueryResult<PartyInvitationAcceptedPartyQuery, PartyInvitationAcceptedPartyQueryVariables>;
export const GuideToMetaGameDataDocument = gql`
    query GuideToMetaGameData($placementId: ID!) {
  placement(placementId: $placementId) {
    placementId
    rewards {
      ...AvailableRewardsReward
    }
  }
  goalCardSlots {
    slots {
      id
      ...GoalCardSlotStateGoalCardSlot
      ...GoalCardSlotReadyForPickGoalCardCardSlot
      ...GoalCardSlotReadyForPickGoalCardCardSlot
    }
  }
}
    ${AvailableRewardsRewardFragmentDoc}
${GoalCardSlotStateGoalCardSlotFragmentDoc}
${GoalCardSlotReadyForPickGoalCardCardSlotFragmentDoc}`;

/**
 * __useGuideToMetaGameDataQuery__
 *
 * To run a query within a React component, call `useGuideToMetaGameDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGuideToMetaGameDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGuideToMetaGameDataQuery({
 *   variables: {
 *      placementId: // value for 'placementId'
 *   },
 * });
 */
export function useGuideToMetaGameDataQuery(baseOptions: Apollo.QueryHookOptions<GuideToMetaGameDataQuery, GuideToMetaGameDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GuideToMetaGameDataQuery, GuideToMetaGameDataQueryVariables>(GuideToMetaGameDataDocument, options);
      }
export function useGuideToMetaGameDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GuideToMetaGameDataQuery, GuideToMetaGameDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GuideToMetaGameDataQuery, GuideToMetaGameDataQueryVariables>(GuideToMetaGameDataDocument, options);
        }
export type GuideToMetaGameDataQueryHookResult = ReturnType<typeof useGuideToMetaGameDataQuery>;
export type GuideToMetaGameDataLazyQueryHookResult = ReturnType<typeof useGuideToMetaGameDataLazyQuery>;
export type GuideToMetaGameDataQueryResult = Apollo.QueryResult<GuideToMetaGameDataQuery, GuideToMetaGameDataQueryVariables>;
export const MatchGroupChatIdDocument = gql`
    query MatchGroupChatId($streamId: ID!, $groupId: ID!) {
  matchGroupChatID(streamId: $streamId, groupId: $groupId) {
    chatId
  }
}
    `;

/**
 * __useMatchGroupChatIdQuery__
 *
 * To run a query within a React component, call `useMatchGroupChatIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchGroupChatIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchGroupChatIdQuery({
 *   variables: {
 *      streamId: // value for 'streamId'
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useMatchGroupChatIdQuery(baseOptions: Apollo.QueryHookOptions<MatchGroupChatIdQuery, MatchGroupChatIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchGroupChatIdQuery, MatchGroupChatIdQueryVariables>(MatchGroupChatIdDocument, options);
      }
export function useMatchGroupChatIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchGroupChatIdQuery, MatchGroupChatIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchGroupChatIdQuery, MatchGroupChatIdQueryVariables>(MatchGroupChatIdDocument, options);
        }
export type MatchGroupChatIdQueryHookResult = ReturnType<typeof useMatchGroupChatIdQuery>;
export type MatchGroupChatIdLazyQueryHookResult = ReturnType<typeof useMatchGroupChatIdLazyQuery>;
export type MatchGroupChatIdQueryResult = Apollo.QueryResult<MatchGroupChatIdQuery, MatchGroupChatIdQueryVariables>;
export const StreamChannelDocument = gql`
    query StreamChannel($streamId: String!) {
  getStreamChannels(streamIds: [$streamId]) {
    channels {
      id
      ...StreamChannel
    }
  }
}
    ${StreamChannelFragmentDoc}`;

/**
 * __useStreamChannelQuery__
 *
 * To run a query within a React component, call `useStreamChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamChannelQuery({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useStreamChannelQuery(baseOptions: Apollo.QueryHookOptions<StreamChannelQuery, StreamChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamChannelQuery, StreamChannelQueryVariables>(StreamChannelDocument, options);
      }
export function useStreamChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamChannelQuery, StreamChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamChannelQuery, StreamChannelQueryVariables>(StreamChannelDocument, options);
        }
export type StreamChannelQueryHookResult = ReturnType<typeof useStreamChannelQuery>;
export type StreamChannelLazyQueryHookResult = ReturnType<typeof useStreamChannelLazyQuery>;
export type StreamChannelQueryResult = Apollo.QueryResult<StreamChannelQuery, StreamChannelQueryVariables>;
export const RestreamingHudChannelDocument = gql`
    query RestreamingHudChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    viewerCount
  }
}
    `;

/**
 * __useRestreamingHudChannelQuery__
 *
 * To run a query within a React component, call `useRestreamingHudChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useRestreamingHudChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRestreamingHudChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useRestreamingHudChannelQuery(baseOptions: Apollo.QueryHookOptions<RestreamingHudChannelQuery, RestreamingHudChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RestreamingHudChannelQuery, RestreamingHudChannelQueryVariables>(RestreamingHudChannelDocument, options);
      }
export function useRestreamingHudChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RestreamingHudChannelQuery, RestreamingHudChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RestreamingHudChannelQuery, RestreamingHudChannelQueryVariables>(RestreamingHudChannelDocument, options);
        }
export type RestreamingHudChannelQueryHookResult = ReturnType<typeof useRestreamingHudChannelQuery>;
export type RestreamingHudChannelLazyQueryHookResult = ReturnType<typeof useRestreamingHudChannelLazyQuery>;
export type RestreamingHudChannelQueryResult = Apollo.QueryResult<RestreamingHudChannelQuery, RestreamingHudChannelQueryVariables>;
export const SpectatorChannelDocument = gql`
    query SpectatorChannel($streamId: String!) {
  getStreamChannels(streamIds: [$streamId]) {
    channels {
      ...SpectatorChannel
    }
  }
}
    ${SpectatorChannelFragmentDoc}`;

/**
 * __useSpectatorChannelQuery__
 *
 * To run a query within a React component, call `useSpectatorChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useSpectatorChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSpectatorChannelQuery({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useSpectatorChannelQuery(baseOptions: Apollo.QueryHookOptions<SpectatorChannelQuery, SpectatorChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SpectatorChannelQuery, SpectatorChannelQueryVariables>(SpectatorChannelDocument, options);
      }
export function useSpectatorChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SpectatorChannelQuery, SpectatorChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SpectatorChannelQuery, SpectatorChannelQueryVariables>(SpectatorChannelDocument, options);
        }
export type SpectatorChannelQueryHookResult = ReturnType<typeof useSpectatorChannelQuery>;
export type SpectatorChannelLazyQueryHookResult = ReturnType<typeof useSpectatorChannelLazyQuery>;
export type SpectatorChannelQueryResult = Apollo.QueryResult<SpectatorChannelQuery, SpectatorChannelQueryVariables>;
export const UseDefaultGameIdProfileDocument = gql`
    query UseDefaultGameIdProfile($userId: ID) {
  profile(userId: $userId) {
    userId
    playedGames {
      userId
      id
      ...UseDefaultGameIdProfileGame
    }
  }
}
    ${UseDefaultGameIdProfileGameFragmentDoc}`;

/**
 * __useUseDefaultGameIdProfileQuery__
 *
 * To run a query within a React component, call `useUseDefaultGameIdProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseDefaultGameIdProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseDefaultGameIdProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUseDefaultGameIdProfileQuery(baseOptions?: Apollo.QueryHookOptions<UseDefaultGameIdProfileQuery, UseDefaultGameIdProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseDefaultGameIdProfileQuery, UseDefaultGameIdProfileQueryVariables>(UseDefaultGameIdProfileDocument, options);
      }
export function useUseDefaultGameIdProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseDefaultGameIdProfileQuery, UseDefaultGameIdProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseDefaultGameIdProfileQuery, UseDefaultGameIdProfileQueryVariables>(UseDefaultGameIdProfileDocument, options);
        }
export type UseDefaultGameIdProfileQueryHookResult = ReturnType<typeof useUseDefaultGameIdProfileQuery>;
export type UseDefaultGameIdProfileLazyQueryHookResult = ReturnType<typeof useUseDefaultGameIdProfileLazyQuery>;
export type UseDefaultGameIdProfileQueryResult = Apollo.QueryResult<UseDefaultGameIdProfileQuery, UseDefaultGameIdProfileQueryVariables>;
export const UsePlayedGameIdsDocument = gql`
    query UsePlayedGameIds($userId: ID) {
  playedGames(userId: $userId) {
    games {
      id
      userId
    }
  }
}
    `;

/**
 * __useUsePlayedGameIdsQuery__
 *
 * To run a query within a React component, call `useUsePlayedGameIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsePlayedGameIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsePlayedGameIdsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUsePlayedGameIdsQuery(baseOptions?: Apollo.QueryHookOptions<UsePlayedGameIdsQuery, UsePlayedGameIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsePlayedGameIdsQuery, UsePlayedGameIdsQueryVariables>(UsePlayedGameIdsDocument, options);
      }
export function useUsePlayedGameIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsePlayedGameIdsQuery, UsePlayedGameIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsePlayedGameIdsQuery, UsePlayedGameIdsQueryVariables>(UsePlayedGameIdsDocument, options);
        }
export type UsePlayedGameIdsQueryHookResult = ReturnType<typeof useUsePlayedGameIdsQuery>;
export type UsePlayedGameIdsLazyQueryHookResult = ReturnType<typeof useUsePlayedGameIdsLazyQuery>;
export type UsePlayedGameIdsQueryResult = Apollo.QueryResult<UsePlayedGameIdsQuery, UsePlayedGameIdsQueryVariables>;
export const UseGameSelectorDocument = gql`
    query UseGameSelector($gameIds: [String!]) {
  games(ids: $gameIds) {
    games {
      id
      ...GameSelectorGame
    }
  }
}
    ${GameSelectorGameFragmentDoc}`;

/**
 * __useUseGameSelectorQuery__
 *
 * To run a query within a React component, call `useUseGameSelectorQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseGameSelectorQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseGameSelectorQuery({
 *   variables: {
 *      gameIds: // value for 'gameIds'
 *   },
 * });
 */
export function useUseGameSelectorQuery(baseOptions?: Apollo.QueryHookOptions<UseGameSelectorQuery, UseGameSelectorQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseGameSelectorQuery, UseGameSelectorQueryVariables>(UseGameSelectorDocument, options);
      }
export function useUseGameSelectorLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseGameSelectorQuery, UseGameSelectorQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseGameSelectorQuery, UseGameSelectorQueryVariables>(UseGameSelectorDocument, options);
        }
export type UseGameSelectorQueryHookResult = ReturnType<typeof useUseGameSelectorQuery>;
export type UseGameSelectorLazyQueryHookResult = ReturnType<typeof useUseGameSelectorLazyQuery>;
export type UseGameSelectorQueryResult = Apollo.QueryResult<UseGameSelectorQuery, UseGameSelectorQueryVariables>;
export const ChannelSubscriptionUpdateNotificationChannelDocument = gql`
    query ChannelSubscriptionUpdateNotificationChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
  }
}
    `;

/**
 * __useChannelSubscriptionUpdateNotificationChannelQuery__
 *
 * To run a query within a React component, call `useChannelSubscriptionUpdateNotificationChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelSubscriptionUpdateNotificationChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelSubscriptionUpdateNotificationChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelSubscriptionUpdateNotificationChannelQuery(baseOptions: Apollo.QueryHookOptions<ChannelSubscriptionUpdateNotificationChannelQuery, ChannelSubscriptionUpdateNotificationChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelSubscriptionUpdateNotificationChannelQuery, ChannelSubscriptionUpdateNotificationChannelQueryVariables>(ChannelSubscriptionUpdateNotificationChannelDocument, options);
      }
export function useChannelSubscriptionUpdateNotificationChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelSubscriptionUpdateNotificationChannelQuery, ChannelSubscriptionUpdateNotificationChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelSubscriptionUpdateNotificationChannelQuery, ChannelSubscriptionUpdateNotificationChannelQueryVariables>(ChannelSubscriptionUpdateNotificationChannelDocument, options);
        }
export type ChannelSubscriptionUpdateNotificationChannelQueryHookResult = ReturnType<typeof useChannelSubscriptionUpdateNotificationChannelQuery>;
export type ChannelSubscriptionUpdateNotificationChannelLazyQueryHookResult = ReturnType<typeof useChannelSubscriptionUpdateNotificationChannelLazyQuery>;
export type ChannelSubscriptionUpdateNotificationChannelQueryResult = Apollo.QueryResult<ChannelSubscriptionUpdateNotificationChannelQuery, ChannelSubscriptionUpdateNotificationChannelQueryVariables>;
export const NotificationFriendRequestProfileDocument = gql`
    query NotificationFriendRequestProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...FriendRequestNotificationContentProfile
  }
}
    ${FriendRequestNotificationContentProfileFragmentDoc}`;

/**
 * __useNotificationFriendRequestProfileQuery__
 *
 * To run a query within a React component, call `useNotificationFriendRequestProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationFriendRequestProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationFriendRequestProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useNotificationFriendRequestProfileQuery(baseOptions: Apollo.QueryHookOptions<NotificationFriendRequestProfileQuery, NotificationFriendRequestProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationFriendRequestProfileQuery, NotificationFriendRequestProfileQueryVariables>(NotificationFriendRequestProfileDocument, options);
      }
export function useNotificationFriendRequestProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationFriendRequestProfileQuery, NotificationFriendRequestProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationFriendRequestProfileQuery, NotificationFriendRequestProfileQueryVariables>(NotificationFriendRequestProfileDocument, options);
        }
export type NotificationFriendRequestProfileQueryHookResult = ReturnType<typeof useNotificationFriendRequestProfileQuery>;
export type NotificationFriendRequestProfileLazyQueryHookResult = ReturnType<typeof useNotificationFriendRequestProfileLazyQuery>;
export type NotificationFriendRequestProfileQueryResult = Apollo.QueryResult<NotificationFriendRequestProfileQuery, NotificationFriendRequestProfileQueryVariables>;
export const NotificationGoalCardDocument = gql`
    query NotificationGoalCard($id: ID!) {
  goalCard(id: $id) {
    id
    ...GoalCardNotificationContentGoalCard
  }
}
    ${GoalCardNotificationContentGoalCardFragmentDoc}`;

/**
 * __useNotificationGoalCardQuery__
 *
 * To run a query within a React component, call `useNotificationGoalCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationGoalCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationGoalCardQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useNotificationGoalCardQuery(baseOptions: Apollo.QueryHookOptions<NotificationGoalCardQuery, NotificationGoalCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationGoalCardQuery, NotificationGoalCardQueryVariables>(NotificationGoalCardDocument, options);
      }
export function useNotificationGoalCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationGoalCardQuery, NotificationGoalCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationGoalCardQuery, NotificationGoalCardQueryVariables>(NotificationGoalCardDocument, options);
        }
export type NotificationGoalCardQueryHookResult = ReturnType<typeof useNotificationGoalCardQuery>;
export type NotificationGoalCardLazyQueryHookResult = ReturnType<typeof useNotificationGoalCardLazyQuery>;
export type NotificationGoalCardQueryResult = Apollo.QueryResult<NotificationGoalCardQuery, NotificationGoalCardQueryVariables>;
export const PartyInviterNotificationProfileDocument = gql`
    query PartyInviterNotificationProfile($userId: ID!) {
  profile(userId: $userId) {
    ...PartyInviteNotificationContentLeaderProfile
  }
}
    ${PartyInviteNotificationContentLeaderProfileFragmentDoc}`;

/**
 * __usePartyInviterNotificationProfileQuery__
 *
 * To run a query within a React component, call `usePartyInviterNotificationProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `usePartyInviterNotificationProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePartyInviterNotificationProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function usePartyInviterNotificationProfileQuery(baseOptions: Apollo.QueryHookOptions<PartyInviterNotificationProfileQuery, PartyInviterNotificationProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PartyInviterNotificationProfileQuery, PartyInviterNotificationProfileQueryVariables>(PartyInviterNotificationProfileDocument, options);
      }
export function usePartyInviterNotificationProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PartyInviterNotificationProfileQuery, PartyInviterNotificationProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PartyInviterNotificationProfileQuery, PartyInviterNotificationProfileQueryVariables>(PartyInviterNotificationProfileDocument, options);
        }
export type PartyInviterNotificationProfileQueryHookResult = ReturnType<typeof usePartyInviterNotificationProfileQuery>;
export type PartyInviterNotificationProfileLazyQueryHookResult = ReturnType<typeof usePartyInviterNotificationProfileLazyQuery>;
export type PartyInviterNotificationProfileQueryResult = Apollo.QueryResult<PartyInviterNotificationProfileQuery, PartyInviterNotificationProfileQueryVariables>;
export const PartyInviterNotificationPartyDocument = gql`
    query PartyInviterNotificationParty($partyId: ID!) {
  party(partyId: $partyId) {
    ...PartyInviteNotificationContentParty
  }
}
    ${PartyInviteNotificationContentPartyFragmentDoc}`;

/**
 * __usePartyInviterNotificationPartyQuery__
 *
 * To run a query within a React component, call `usePartyInviterNotificationPartyQuery` and pass it any options that fit your needs.
 * When your component renders, `usePartyInviterNotificationPartyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePartyInviterNotificationPartyQuery({
 *   variables: {
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function usePartyInviterNotificationPartyQuery(baseOptions: Apollo.QueryHookOptions<PartyInviterNotificationPartyQuery, PartyInviterNotificationPartyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PartyInviterNotificationPartyQuery, PartyInviterNotificationPartyQueryVariables>(PartyInviterNotificationPartyDocument, options);
      }
export function usePartyInviterNotificationPartyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PartyInviterNotificationPartyQuery, PartyInviterNotificationPartyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PartyInviterNotificationPartyQuery, PartyInviterNotificationPartyQueryVariables>(PartyInviterNotificationPartyDocument, options);
        }
export type PartyInviterNotificationPartyQueryHookResult = ReturnType<typeof usePartyInviterNotificationPartyQuery>;
export type PartyInviterNotificationPartyLazyQueryHookResult = ReturnType<typeof usePartyInviterNotificationPartyLazyQuery>;
export type PartyInviterNotificationPartyQueryResult = Apollo.QueryResult<PartyInviterNotificationPartyQuery, PartyInviterNotificationPartyQueryVariables>;
export const UsePartyLeaderStreamChangedPartyDocument = gql`
    query UsePartyLeaderStreamChangedParty($partyId: ID!) {
  party(partyId: $partyId) {
    id
    leaderId
    channel {
      id
      name
    }
    streamId
    members {
      userId
      profile {
        userId
        userTag
      }
    }
  }
}
    `;

/**
 * __useUsePartyLeaderStreamChangedPartyQuery__
 *
 * To run a query within a React component, call `useUsePartyLeaderStreamChangedPartyQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsePartyLeaderStreamChangedPartyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsePartyLeaderStreamChangedPartyQuery({
 *   variables: {
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function useUsePartyLeaderStreamChangedPartyQuery(baseOptions: Apollo.QueryHookOptions<UsePartyLeaderStreamChangedPartyQuery, UsePartyLeaderStreamChangedPartyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsePartyLeaderStreamChangedPartyQuery, UsePartyLeaderStreamChangedPartyQueryVariables>(UsePartyLeaderStreamChangedPartyDocument, options);
      }
export function useUsePartyLeaderStreamChangedPartyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsePartyLeaderStreamChangedPartyQuery, UsePartyLeaderStreamChangedPartyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsePartyLeaderStreamChangedPartyQuery, UsePartyLeaderStreamChangedPartyQueryVariables>(UsePartyLeaderStreamChangedPartyDocument, options);
        }
export type UsePartyLeaderStreamChangedPartyQueryHookResult = ReturnType<typeof useUsePartyLeaderStreamChangedPartyQuery>;
export type UsePartyLeaderStreamChangedPartyLazyQueryHookResult = ReturnType<typeof useUsePartyLeaderStreamChangedPartyLazyQuery>;
export type UsePartyLeaderStreamChangedPartyQueryResult = Apollo.QueryResult<UsePartyLeaderStreamChangedPartyQuery, UsePartyLeaderStreamChangedPartyQueryVariables>;
export const NotificationReceivedSubscriptionGiftDocument = gql`
    query NotificationReceivedSubscriptionGift($userId: ID, $channelId: ID!, $skipProfile: Boolean = false) {
  profile(userId: $userId) @skip(if: $skipProfile) {
    userId
    userTag
  }
  channel(id: $channelId) {
    id
    name
  }
}
    `;

/**
 * __useNotificationReceivedSubscriptionGiftQuery__
 *
 * To run a query within a React component, call `useNotificationReceivedSubscriptionGiftQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationReceivedSubscriptionGiftQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationReceivedSubscriptionGiftQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *      skipProfile: // value for 'skipProfile'
 *   },
 * });
 */
export function useNotificationReceivedSubscriptionGiftQuery(baseOptions: Apollo.QueryHookOptions<NotificationReceivedSubscriptionGiftQuery, NotificationReceivedSubscriptionGiftQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationReceivedSubscriptionGiftQuery, NotificationReceivedSubscriptionGiftQueryVariables>(NotificationReceivedSubscriptionGiftDocument, options);
      }
export function useNotificationReceivedSubscriptionGiftLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationReceivedSubscriptionGiftQuery, NotificationReceivedSubscriptionGiftQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationReceivedSubscriptionGiftQuery, NotificationReceivedSubscriptionGiftQueryVariables>(NotificationReceivedSubscriptionGiftDocument, options);
        }
export type NotificationReceivedSubscriptionGiftQueryHookResult = ReturnType<typeof useNotificationReceivedSubscriptionGiftQuery>;
export type NotificationReceivedSubscriptionGiftLazyQueryHookResult = ReturnType<typeof useNotificationReceivedSubscriptionGiftLazyQuery>;
export type NotificationReceivedSubscriptionGiftQueryResult = Apollo.QueryResult<NotificationReceivedSubscriptionGiftQuery, NotificationReceivedSubscriptionGiftQueryVariables>;
export const NotificationSeasonDocument = gql`
    query NotificationSeason($id: ID!, $userId: ID!) {
  season(id: $id) {
    id
    ...SeasonNotificationContentSeason
  }
}
    ${SeasonNotificationContentSeasonFragmentDoc}`;

/**
 * __useNotificationSeasonQuery__
 *
 * To run a query within a React component, call `useNotificationSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationSeasonQuery({
 *   variables: {
 *      id: // value for 'id'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useNotificationSeasonQuery(baseOptions: Apollo.QueryHookOptions<NotificationSeasonQuery, NotificationSeasonQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationSeasonQuery, NotificationSeasonQueryVariables>(NotificationSeasonDocument, options);
      }
export function useNotificationSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationSeasonQuery, NotificationSeasonQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationSeasonQuery, NotificationSeasonQueryVariables>(NotificationSeasonDocument, options);
        }
export type NotificationSeasonQueryHookResult = ReturnType<typeof useNotificationSeasonQuery>;
export type NotificationSeasonLazyQueryHookResult = ReturnType<typeof useNotificationSeasonLazyQuery>;
export type NotificationSeasonQueryResult = Apollo.QueryResult<NotificationSeasonQuery, NotificationSeasonQueryVariables>;
export const NotificationsStoreFrontDocument = gql`
    query NotificationsStoreFront($gameId: ID!) {
  platformStoreFront(gameId: $gameId) {
    id
    gameId
    categories {
      id
      sellableItems {
        id
        igcPrices {
          currencyId
          amount
        }
        ...StoreItemNotificationContentStoreV2SellableItem
      }
    }
  }
}
    ${StoreItemNotificationContentStoreV2SellableItemFragmentDoc}`;

/**
 * __useNotificationsStoreFrontQuery__
 *
 * To run a query within a React component, call `useNotificationsStoreFrontQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationsStoreFrontQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationsStoreFrontQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useNotificationsStoreFrontQuery(baseOptions: Apollo.QueryHookOptions<NotificationsStoreFrontQuery, NotificationsStoreFrontQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationsStoreFrontQuery, NotificationsStoreFrontQueryVariables>(NotificationsStoreFrontDocument, options);
      }
export function useNotificationsStoreFrontLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationsStoreFrontQuery, NotificationsStoreFrontQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationsStoreFrontQuery, NotificationsStoreFrontQueryVariables>(NotificationsStoreFrontDocument, options);
        }
export type NotificationsStoreFrontQueryHookResult = ReturnType<typeof useNotificationsStoreFrontQuery>;
export type NotificationsStoreFrontLazyQueryHookResult = ReturnType<typeof useNotificationsStoreFrontLazyQuery>;
export type NotificationsStoreFrontQueryResult = Apollo.QueryResult<NotificationsStoreFrontQuery, NotificationsStoreFrontQueryVariables>;
export const TimedAdsPlacementDocument = gql`
    query TimedAdsPlacement($placementId: ID!) {
  placement(placementId: $placementId) {
    placementId
    ...TimedAdsModalAd
  }
}
    ${TimedAdsModalAdFragmentDoc}`;

/**
 * __useTimedAdsPlacementQuery__
 *
 * To run a query within a React component, call `useTimedAdsPlacementQuery` and pass it any options that fit your needs.
 * When your component renders, `useTimedAdsPlacementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTimedAdsPlacementQuery({
 *   variables: {
 *      placementId: // value for 'placementId'
 *   },
 * });
 */
export function useTimedAdsPlacementQuery(baseOptions: Apollo.QueryHookOptions<TimedAdsPlacementQuery, TimedAdsPlacementQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TimedAdsPlacementQuery, TimedAdsPlacementQueryVariables>(TimedAdsPlacementDocument, options);
      }
export function useTimedAdsPlacementLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TimedAdsPlacementQuery, TimedAdsPlacementQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TimedAdsPlacementQuery, TimedAdsPlacementQueryVariables>(TimedAdsPlacementDocument, options);
        }
export type TimedAdsPlacementQueryHookResult = ReturnType<typeof useTimedAdsPlacementQuery>;
export type TimedAdsPlacementLazyQueryHookResult = ReturnType<typeof useTimedAdsPlacementLazyQuery>;
export type TimedAdsPlacementQueryResult = Apollo.QueryResult<TimedAdsPlacementQuery, TimedAdsPlacementQueryVariables>;
export const TimedAdsRewardPlacementDocument = gql`
    mutation TimedAdsRewardPlacement($placementId: ID!) {
  rewardPlacement(placementId: $placementId) {
    emptyTypeWorkaround
  }
}
    `;
export type TimedAdsRewardPlacementMutationFn = Apollo.MutationFunction<TimedAdsRewardPlacementMutation, TimedAdsRewardPlacementMutationVariables>;

/**
 * __useTimedAdsRewardPlacementMutation__
 *
 * To run a mutation, you first call `useTimedAdsRewardPlacementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTimedAdsRewardPlacementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [timedAdsRewardPlacementMutation, { data, loading, error }] = useTimedAdsRewardPlacementMutation({
 *   variables: {
 *      placementId: // value for 'placementId'
 *   },
 * });
 */
export function useTimedAdsRewardPlacementMutation(baseOptions?: Apollo.MutationHookOptions<TimedAdsRewardPlacementMutation, TimedAdsRewardPlacementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TimedAdsRewardPlacementMutation, TimedAdsRewardPlacementMutationVariables>(TimedAdsRewardPlacementDocument, options);
      }
export type TimedAdsRewardPlacementMutationHookResult = ReturnType<typeof useTimedAdsRewardPlacementMutation>;
export type TimedAdsRewardPlacementMutationResult = Apollo.MutationResult<TimedAdsRewardPlacementMutation>;
export type TimedAdsRewardPlacementMutationOptions = Apollo.BaseMutationOptions<TimedAdsRewardPlacementMutation, TimedAdsRewardPlacementMutationVariables>;
export const InitialRewardsDocument = gql`
    query InitialRewards($placementId: ID) {
  placement(placementId: $placementId) {
    placementId
    rewards {
      readyAt
    }
  }
}
    `;

/**
 * __useInitialRewardsQuery__
 *
 * To run a query within a React component, call `useInitialRewardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useInitialRewardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInitialRewardsQuery({
 *   variables: {
 *      placementId: // value for 'placementId'
 *   },
 * });
 */
export function useInitialRewardsQuery(baseOptions?: Apollo.QueryHookOptions<InitialRewardsQuery, InitialRewardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InitialRewardsQuery, InitialRewardsQueryVariables>(InitialRewardsDocument, options);
      }
export function useInitialRewardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InitialRewardsQuery, InitialRewardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InitialRewardsQuery, InitialRewardsQueryVariables>(InitialRewardsDocument, options);
        }
export type InitialRewardsQueryHookResult = ReturnType<typeof useInitialRewardsQuery>;
export type InitialRewardsLazyQueryHookResult = ReturnType<typeof useInitialRewardsLazyQuery>;
export type InitialRewardsQueryResult = Apollo.QueryResult<InitialRewardsQuery, InitialRewardsQueryVariables>;
export const AdyenContentCancelOrderDocument = gql`
    mutation AdyenContentCancelOrder($orderId: ID!) {
  cancelOrder(orderId: $orderId) {
    emptyTypeWorkaround
  }
}
    `;
export type AdyenContentCancelOrderMutationFn = Apollo.MutationFunction<AdyenContentCancelOrderMutation, AdyenContentCancelOrderMutationVariables>;

/**
 * __useAdyenContentCancelOrderMutation__
 *
 * To run a mutation, you first call `useAdyenContentCancelOrderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAdyenContentCancelOrderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [adyenContentCancelOrderMutation, { data, loading, error }] = useAdyenContentCancelOrderMutation({
 *   variables: {
 *      orderId: // value for 'orderId'
 *   },
 * });
 */
export function useAdyenContentCancelOrderMutation(baseOptions?: Apollo.MutationHookOptions<AdyenContentCancelOrderMutation, AdyenContentCancelOrderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AdyenContentCancelOrderMutation, AdyenContentCancelOrderMutationVariables>(AdyenContentCancelOrderDocument, options);
      }
export type AdyenContentCancelOrderMutationHookResult = ReturnType<typeof useAdyenContentCancelOrderMutation>;
export type AdyenContentCancelOrderMutationResult = Apollo.MutationResult<AdyenContentCancelOrderMutation>;
export type AdyenContentCancelOrderMutationOptions = Apollo.BaseMutationOptions<AdyenContentCancelOrderMutation, AdyenContentCancelOrderMutationVariables>;
export const CancelAdyenOrderDocument = gql`
    mutation CancelAdyenOrder($orderId: ID!) {
  cancelOrder(orderId: $orderId) {
    emptyTypeWorkaround
  }
}
    `;
export type CancelAdyenOrderMutationFn = Apollo.MutationFunction<CancelAdyenOrderMutation, CancelAdyenOrderMutationVariables>;

/**
 * __useCancelAdyenOrderMutation__
 *
 * To run a mutation, you first call `useCancelAdyenOrderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCancelAdyenOrderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cancelAdyenOrderMutation, { data, loading, error }] = useCancelAdyenOrderMutation({
 *   variables: {
 *      orderId: // value for 'orderId'
 *   },
 * });
 */
export function useCancelAdyenOrderMutation(baseOptions?: Apollo.MutationHookOptions<CancelAdyenOrderMutation, CancelAdyenOrderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CancelAdyenOrderMutation, CancelAdyenOrderMutationVariables>(CancelAdyenOrderDocument, options);
      }
export type CancelAdyenOrderMutationHookResult = ReturnType<typeof useCancelAdyenOrderMutation>;
export type CancelAdyenOrderMutationResult = Apollo.MutationResult<CancelAdyenOrderMutation>;
export type CancelAdyenOrderMutationOptions = Apollo.BaseMutationOptions<CancelAdyenOrderMutation, CancelAdyenOrderMutationVariables>;
export const SearchInputChannelSearchDocument = gql`
    query SearchInputChannelSearch($query: String, $amount: Int!, $skipCategories: Boolean!) {
  searchChannels: publicSearch(
    query: $query
    entityTypes: [ENTITY_TYPE_CHANNEL]
    cursor: {first: $amount}
  ) {
    resultItems {
      entityId
      entity {
        ...SearchMatchResultChannel
      }
    }
  }
  searchCategories: publicSearch(
    query: $query
    entityTypes: [ENTITY_TYPE_GAME]
    cursor: {first: $amount}
  ) @skip(if: $skipCategories) {
    resultItems {
      entityId
      entity {
        ...SearchMatchResultCategory
      }
    }
  }
}
    ${SearchMatchResultChannelFragmentDoc}
${SearchMatchResultCategoryFragmentDoc}`;

/**
 * __useSearchInputChannelSearchQuery__
 *
 * To run a query within a React component, call `useSearchInputChannelSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchInputChannelSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchInputChannelSearchQuery({
 *   variables: {
 *      query: // value for 'query'
 *      amount: // value for 'amount'
 *      skipCategories: // value for 'skipCategories'
 *   },
 * });
 */
export function useSearchInputChannelSearchQuery(baseOptions: Apollo.QueryHookOptions<SearchInputChannelSearchQuery, SearchInputChannelSearchQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchInputChannelSearchQuery, SearchInputChannelSearchQueryVariables>(SearchInputChannelSearchDocument, options);
      }
export function useSearchInputChannelSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchInputChannelSearchQuery, SearchInputChannelSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchInputChannelSearchQuery, SearchInputChannelSearchQueryVariables>(SearchInputChannelSearchDocument, options);
        }
export type SearchInputChannelSearchQueryHookResult = ReturnType<typeof useSearchInputChannelSearchQuery>;
export type SearchInputChannelSearchLazyQueryHookResult = ReturnType<typeof useSearchInputChannelSearchLazyQuery>;
export type SearchInputChannelSearchQueryResult = Apollo.QueryResult<SearchInputChannelSearchQuery, SearchInputChannelSearchQueryVariables>;
export const SeasonBreakInfoGameDocument = gql`
    query SeasonBreakInfoGame($gameId: ID!) {
  game(id: $gameId) {
    id
    name
    activeSeason {
      id
      seasonBreak
      seasonBreakReason
    }
  }
}
    `;

/**
 * __useSeasonBreakInfoGameQuery__
 *
 * To run a query within a React component, call `useSeasonBreakInfoGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useSeasonBreakInfoGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSeasonBreakInfoGameQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useSeasonBreakInfoGameQuery(baseOptions: Apollo.QueryHookOptions<SeasonBreakInfoGameQuery, SeasonBreakInfoGameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SeasonBreakInfoGameQuery, SeasonBreakInfoGameQueryVariables>(SeasonBreakInfoGameDocument, options);
      }
export function useSeasonBreakInfoGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SeasonBreakInfoGameQuery, SeasonBreakInfoGameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SeasonBreakInfoGameQuery, SeasonBreakInfoGameQueryVariables>(SeasonBreakInfoGameDocument, options);
        }
export type SeasonBreakInfoGameQueryHookResult = ReturnType<typeof useSeasonBreakInfoGameQuery>;
export type SeasonBreakInfoGameLazyQueryHookResult = ReturnType<typeof useSeasonBreakInfoGameLazyQuery>;
export type SeasonBreakInfoGameQueryResult = Apollo.QueryResult<SeasonBreakInfoGameQuery, SeasonBreakInfoGameQueryVariables>;
export const UseSeasonEndDialogWrapperProfileDocument = gql`
    query UseSeasonEndDialogWrapperProfile($userId: ID, $seasonId: String) {
  profile(userId: $userId) {
    userId
    ...SeasonEndDialogProfile
    stats(season_id: $seasonId) {
      ...SeasonEndDialogProfileStats
    }
  }
}
    ${SeasonEndDialogProfileFragmentDoc}
${SeasonEndDialogProfileStatsFragmentDoc}`;

/**
 * __useUseSeasonEndDialogWrapperProfileQuery__
 *
 * To run a query within a React component, call `useUseSeasonEndDialogWrapperProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseSeasonEndDialogWrapperProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseSeasonEndDialogWrapperProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useUseSeasonEndDialogWrapperProfileQuery(baseOptions?: Apollo.QueryHookOptions<UseSeasonEndDialogWrapperProfileQuery, UseSeasonEndDialogWrapperProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseSeasonEndDialogWrapperProfileQuery, UseSeasonEndDialogWrapperProfileQueryVariables>(UseSeasonEndDialogWrapperProfileDocument, options);
      }
export function useUseSeasonEndDialogWrapperProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseSeasonEndDialogWrapperProfileQuery, UseSeasonEndDialogWrapperProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseSeasonEndDialogWrapperProfileQuery, UseSeasonEndDialogWrapperProfileQueryVariables>(UseSeasonEndDialogWrapperProfileDocument, options);
        }
export type UseSeasonEndDialogWrapperProfileQueryHookResult = ReturnType<typeof useUseSeasonEndDialogWrapperProfileQuery>;
export type UseSeasonEndDialogWrapperProfileLazyQueryHookResult = ReturnType<typeof useUseSeasonEndDialogWrapperProfileLazyQuery>;
export type UseSeasonEndDialogWrapperProfileQueryResult = Apollo.QueryResult<UseSeasonEndDialogWrapperProfileQuery, UseSeasonEndDialogWrapperProfileQueryVariables>;
export const UseSeasonEndDialogWrapperMutatingDocument = gql`
    query UseSeasonEndDialogWrapperMutating($userId: ID, $gameId: ID, $seasonId: ID) {
  inventory(
    userId: $userId
    filters: [{gameId: $gameId}, {itemType: TYPE_GAME_CARD}, {seasonId: $seasonId}]
  ) {
    items {
      itemId
      ...SeasonEndDialogInventory
    }
  }
  season(id: $seasonId) {
    id
    ...SeasonEndDialogSeason
  }
}
    ${SeasonEndDialogInventoryFragmentDoc}
${SeasonEndDialogSeasonFragmentDoc}`;

/**
 * __useUseSeasonEndDialogWrapperMutatingQuery__
 *
 * To run a query within a React component, call `useUseSeasonEndDialogWrapperMutatingQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseSeasonEndDialogWrapperMutatingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseSeasonEndDialogWrapperMutatingQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      gameId: // value for 'gameId'
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useUseSeasonEndDialogWrapperMutatingQuery(baseOptions?: Apollo.QueryHookOptions<UseSeasonEndDialogWrapperMutatingQuery, UseSeasonEndDialogWrapperMutatingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseSeasonEndDialogWrapperMutatingQuery, UseSeasonEndDialogWrapperMutatingQueryVariables>(UseSeasonEndDialogWrapperMutatingDocument, options);
      }
export function useUseSeasonEndDialogWrapperMutatingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseSeasonEndDialogWrapperMutatingQuery, UseSeasonEndDialogWrapperMutatingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseSeasonEndDialogWrapperMutatingQuery, UseSeasonEndDialogWrapperMutatingQueryVariables>(UseSeasonEndDialogWrapperMutatingDocument, options);
        }
export type UseSeasonEndDialogWrapperMutatingQueryHookResult = ReturnType<typeof useUseSeasonEndDialogWrapperMutatingQuery>;
export type UseSeasonEndDialogWrapperMutatingLazyQueryHookResult = ReturnType<typeof useUseSeasonEndDialogWrapperMutatingLazyQuery>;
export type UseSeasonEndDialogWrapperMutatingQueryResult = Apollo.QueryResult<UseSeasonEndDialogWrapperMutatingQuery, UseSeasonEndDialogWrapperMutatingQueryVariables>;
export const UseSeasonEndDialogsSeasonsDocument = gql`
    query UseSeasonEndDialogsSeasons($seasonIds: [String!]) {
  seasons(ids: $seasonIds) {
    seasons {
      id
      ...UseSeasonEndDialogsSeason
    }
  }
}
    ${UseSeasonEndDialogsSeasonFragmentDoc}`;

/**
 * __useUseSeasonEndDialogsSeasonsQuery__
 *
 * To run a query within a React component, call `useUseSeasonEndDialogsSeasonsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseSeasonEndDialogsSeasonsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseSeasonEndDialogsSeasonsQuery({
 *   variables: {
 *      seasonIds: // value for 'seasonIds'
 *   },
 * });
 */
export function useUseSeasonEndDialogsSeasonsQuery(baseOptions?: Apollo.QueryHookOptions<UseSeasonEndDialogsSeasonsQuery, UseSeasonEndDialogsSeasonsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseSeasonEndDialogsSeasonsQuery, UseSeasonEndDialogsSeasonsQueryVariables>(UseSeasonEndDialogsSeasonsDocument, options);
      }
export function useUseSeasonEndDialogsSeasonsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseSeasonEndDialogsSeasonsQuery, UseSeasonEndDialogsSeasonsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseSeasonEndDialogsSeasonsQuery, UseSeasonEndDialogsSeasonsQueryVariables>(UseSeasonEndDialogsSeasonsDocument, options);
        }
export type UseSeasonEndDialogsSeasonsQueryHookResult = ReturnType<typeof useUseSeasonEndDialogsSeasonsQuery>;
export type UseSeasonEndDialogsSeasonsLazyQueryHookResult = ReturnType<typeof useUseSeasonEndDialogsSeasonsLazyQuery>;
export type UseSeasonEndDialogsSeasonsQueryResult = Apollo.QueryResult<UseSeasonEndDialogsSeasonsQuery, UseSeasonEndDialogsSeasonsQueryVariables>;
export const SeasonRankUpDialogClaimRewardDocument = gql`
    mutation SeasonRankUpDialogClaimReward($rewardId: ID) {
  claimReward(rewardId: $rewardId) {
    emptyTypeWorkaround
  }
}
    `;
export type SeasonRankUpDialogClaimRewardMutationFn = Apollo.MutationFunction<SeasonRankUpDialogClaimRewardMutation, SeasonRankUpDialogClaimRewardMutationVariables>;

/**
 * __useSeasonRankUpDialogClaimRewardMutation__
 *
 * To run a mutation, you first call `useSeasonRankUpDialogClaimRewardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSeasonRankUpDialogClaimRewardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [seasonRankUpDialogClaimRewardMutation, { data, loading, error }] = useSeasonRankUpDialogClaimRewardMutation({
 *   variables: {
 *      rewardId: // value for 'rewardId'
 *   },
 * });
 */
export function useSeasonRankUpDialogClaimRewardMutation(baseOptions?: Apollo.MutationHookOptions<SeasonRankUpDialogClaimRewardMutation, SeasonRankUpDialogClaimRewardMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SeasonRankUpDialogClaimRewardMutation, SeasonRankUpDialogClaimRewardMutationVariables>(SeasonRankUpDialogClaimRewardDocument, options);
      }
export type SeasonRankUpDialogClaimRewardMutationHookResult = ReturnType<typeof useSeasonRankUpDialogClaimRewardMutation>;
export type SeasonRankUpDialogClaimRewardMutationResult = Apollo.MutationResult<SeasonRankUpDialogClaimRewardMutation>;
export type SeasonRankUpDialogClaimRewardMutationOptions = Apollo.BaseMutationOptions<SeasonRankUpDialogClaimRewardMutation, SeasonRankUpDialogClaimRewardMutationVariables>;
export const UnclaimedSeasonRewardsDocument = gql`
    query UnclaimedSeasonRewards($userId: ID) {
  rewards(userId: $userId) {
    rewards {
      id
      ... on RewardReward {
        ...UnclaimedSeasonReward
      }
    }
  }
}
    ${UnclaimedSeasonRewardFragmentDoc}`;

/**
 * __useUnclaimedSeasonRewardsQuery__
 *
 * To run a query within a React component, call `useUnclaimedSeasonRewardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUnclaimedSeasonRewardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUnclaimedSeasonRewardsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUnclaimedSeasonRewardsQuery(baseOptions?: Apollo.QueryHookOptions<UnclaimedSeasonRewardsQuery, UnclaimedSeasonRewardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UnclaimedSeasonRewardsQuery, UnclaimedSeasonRewardsQueryVariables>(UnclaimedSeasonRewardsDocument, options);
      }
export function useUnclaimedSeasonRewardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UnclaimedSeasonRewardsQuery, UnclaimedSeasonRewardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UnclaimedSeasonRewardsQuery, UnclaimedSeasonRewardsQueryVariables>(UnclaimedSeasonRewardsDocument, options);
        }
export type UnclaimedSeasonRewardsQueryHookResult = ReturnType<typeof useUnclaimedSeasonRewardsQuery>;
export type UnclaimedSeasonRewardsLazyQueryHookResult = ReturnType<typeof useUnclaimedSeasonRewardsLazyQuery>;
export type UnclaimedSeasonRewardsQueryResult = Apollo.QueryResult<UnclaimedSeasonRewardsQuery, UnclaimedSeasonRewardsQueryVariables>;
export const GameSeasonSelectorProgressionDocument = gql`
    query GameSeasonSelectorProgression($userId: ID!, $gameId: ID!) {
  listSeasonProgression(userId: $userId) {
    progression {
      season {
        ...GameSeasonSelectorSeason
        game {
          id
          activeSeason {
            id
          }
        }
      }
    }
  }
  game(id: $gameId) {
    id
    activeSeason {
      ...GameSeasonSelectorSeason
    }
  }
}
    ${GameSeasonSelectorSeasonFragmentDoc}`;

/**
 * __useGameSeasonSelectorProgressionQuery__
 *
 * To run a query within a React component, call `useGameSeasonSelectorProgressionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameSeasonSelectorProgressionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameSeasonSelectorProgressionQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGameSeasonSelectorProgressionQuery(baseOptions: Apollo.QueryHookOptions<GameSeasonSelectorProgressionQuery, GameSeasonSelectorProgressionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameSeasonSelectorProgressionQuery, GameSeasonSelectorProgressionQueryVariables>(GameSeasonSelectorProgressionDocument, options);
      }
export function useGameSeasonSelectorProgressionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameSeasonSelectorProgressionQuery, GameSeasonSelectorProgressionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameSeasonSelectorProgressionQuery, GameSeasonSelectorProgressionQueryVariables>(GameSeasonSelectorProgressionDocument, options);
        }
export type GameSeasonSelectorProgressionQueryHookResult = ReturnType<typeof useGameSeasonSelectorProgressionQuery>;
export type GameSeasonSelectorProgressionLazyQueryHookResult = ReturnType<typeof useGameSeasonSelectorProgressionLazyQuery>;
export type GameSeasonSelectorProgressionQueryResult = Apollo.QueryResult<GameSeasonSelectorProgressionQuery, GameSeasonSelectorProgressionQueryVariables>;
export const UseDefaultSeasonIdGameDocument = gql`
    query UseDefaultSeasonIdGame($gameId: ID!) {
  game(id: $gameId) {
    id
    activeSeasonId
  }
}
    `;

/**
 * __useUseDefaultSeasonIdGameQuery__
 *
 * To run a query within a React component, call `useUseDefaultSeasonIdGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseDefaultSeasonIdGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseDefaultSeasonIdGameQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useUseDefaultSeasonIdGameQuery(baseOptions: Apollo.QueryHookOptions<UseDefaultSeasonIdGameQuery, UseDefaultSeasonIdGameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseDefaultSeasonIdGameQuery, UseDefaultSeasonIdGameQueryVariables>(UseDefaultSeasonIdGameDocument, options);
      }
export function useUseDefaultSeasonIdGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseDefaultSeasonIdGameQuery, UseDefaultSeasonIdGameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseDefaultSeasonIdGameQuery, UseDefaultSeasonIdGameQueryVariables>(UseDefaultSeasonIdGameDocument, options);
        }
export type UseDefaultSeasonIdGameQueryHookResult = ReturnType<typeof useUseDefaultSeasonIdGameQuery>;
export type UseDefaultSeasonIdGameLazyQueryHookResult = ReturnType<typeof useUseDefaultSeasonIdGameLazyQuery>;
export type UseDefaultSeasonIdGameQueryResult = Apollo.QueryResult<UseDefaultSeasonIdGameQuery, UseDefaultSeasonIdGameQueryVariables>;
export const HasUnclaimedSeasonRewardsDocument = gql`
    query HasUnclaimedSeasonRewards($userId: ID!) {
  rewards(userId: $userId) {
    rewards {
      id
      rewardedAt
      reason {
        reason {
          ... on ReasonReasonLevelUp {
            season {
              id
              game {
                id
              }
            }
          }
        }
      }
    }
  }
}
    `;

/**
 * __useHasUnclaimedSeasonRewardsQuery__
 *
 * To run a query within a React component, call `useHasUnclaimedSeasonRewardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useHasUnclaimedSeasonRewardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHasUnclaimedSeasonRewardsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useHasUnclaimedSeasonRewardsQuery(baseOptions: Apollo.QueryHookOptions<HasUnclaimedSeasonRewardsQuery, HasUnclaimedSeasonRewardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HasUnclaimedSeasonRewardsQuery, HasUnclaimedSeasonRewardsQueryVariables>(HasUnclaimedSeasonRewardsDocument, options);
      }
export function useHasUnclaimedSeasonRewardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HasUnclaimedSeasonRewardsQuery, HasUnclaimedSeasonRewardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HasUnclaimedSeasonRewardsQuery, HasUnclaimedSeasonRewardsQueryVariables>(HasUnclaimedSeasonRewardsDocument, options);
        }
export type HasUnclaimedSeasonRewardsQueryHookResult = ReturnType<typeof useHasUnclaimedSeasonRewardsQuery>;
export type HasUnclaimedSeasonRewardsLazyQueryHookResult = ReturnType<typeof useHasUnclaimedSeasonRewardsLazyQuery>;
export type HasUnclaimedSeasonRewardsQueryResult = Apollo.QueryResult<HasUnclaimedSeasonRewardsQuery, HasUnclaimedSeasonRewardsQueryVariables>;
export const UseSeasonStartDialogCardsDocument = gql`
    query UseSeasonStartDialogCards($ids: [String!]!) {
  itemsBatchExpand(ids: $ids) {
    items {
      id
      type
      details {
        ...SeasonStartDialogCard
      }
    }
  }
}
    ${SeasonStartDialogCardFragmentDoc}`;

/**
 * __useUseSeasonStartDialogCardsQuery__
 *
 * To run a query within a React component, call `useUseSeasonStartDialogCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseSeasonStartDialogCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseSeasonStartDialogCardsQuery({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useUseSeasonStartDialogCardsQuery(baseOptions: Apollo.QueryHookOptions<UseSeasonStartDialogCardsQuery, UseSeasonStartDialogCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseSeasonStartDialogCardsQuery, UseSeasonStartDialogCardsQueryVariables>(UseSeasonStartDialogCardsDocument, options);
      }
export function useUseSeasonStartDialogCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseSeasonStartDialogCardsQuery, UseSeasonStartDialogCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseSeasonStartDialogCardsQuery, UseSeasonStartDialogCardsQueryVariables>(UseSeasonStartDialogCardsDocument, options);
        }
export type UseSeasonStartDialogCardsQueryHookResult = ReturnType<typeof useUseSeasonStartDialogCardsQuery>;
export type UseSeasonStartDialogCardsLazyQueryHookResult = ReturnType<typeof useUseSeasonStartDialogCardsLazyQuery>;
export type UseSeasonStartDialogCardsQueryResult = Apollo.QueryResult<UseSeasonStartDialogCardsQuery, UseSeasonStartDialogCardsQueryVariables>;
export const StoreItemPageDocument = gql`
    query StoreItemPage($id: ID!, $gameId: ID!) {
  sellableItem(id: $id) {
    id
    name
    type
    igcPrices {
      ...CardBundlePurchaseButtonCurrencyPrice
    }
    content {
      value {
        __typename
        ... on StoreV2ItemRef {
          id
          ...StoreItemItemRef
          ...StoreItemContentCardItemRef
        }
      }
    }
    sku
    ...StoreItemRevealedItems
    ...PurchaseStoreItemSellableItem
  }
  game(id: $gameId) {
    id
    ...CardBundleTitleGame
  }
}
    ${CardBundlePurchaseButtonCurrencyPriceFragmentDoc}
${StoreItemItemRefFragmentDoc}
${StoreItemContentCardItemRefFragmentDoc}
${StoreItemRevealedItemsFragmentDoc}
${PurchaseStoreItemSellableItemFragmentDoc}
${CardBundleTitleGameFragmentDoc}`;

/**
 * __useStoreItemPageQuery__
 *
 * To run a query within a React component, call `useStoreItemPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoreItemPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoreItemPageQuery({
 *   variables: {
 *      id: // value for 'id'
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useStoreItemPageQuery(baseOptions: Apollo.QueryHookOptions<StoreItemPageQuery, StoreItemPageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoreItemPageQuery, StoreItemPageQueryVariables>(StoreItemPageDocument, options);
      }
export function useStoreItemPageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoreItemPageQuery, StoreItemPageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoreItemPageQuery, StoreItemPageQueryVariables>(StoreItemPageDocument, options);
        }
export type StoreItemPageQueryHookResult = ReturnType<typeof useStoreItemPageQuery>;
export type StoreItemPageLazyQueryHookResult = ReturnType<typeof useStoreItemPageLazyQuery>;
export type StoreItemPageQueryResult = Apollo.QueryResult<StoreItemPageQuery, StoreItemPageQueryVariables>;
export const PurchaseStoreItemDocument = gql`
    mutation PurchaseStoreItem($itemId: ID!, $signature: String!, $currencyId: ID) {
  buyWithInGameCurrency(
    itemId: $itemId
    signature: $signature
    currencyId: $currencyId
  ) {
    orderId
  }
}
    `;
export type PurchaseStoreItemMutationFn = Apollo.MutationFunction<PurchaseStoreItemMutation, PurchaseStoreItemMutationVariables>;

/**
 * __usePurchaseStoreItemMutation__
 *
 * To run a mutation, you first call `usePurchaseStoreItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePurchaseStoreItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [purchaseStoreItemMutation, { data, loading, error }] = usePurchaseStoreItemMutation({
 *   variables: {
 *      itemId: // value for 'itemId'
 *      signature: // value for 'signature'
 *      currencyId: // value for 'currencyId'
 *   },
 * });
 */
export function usePurchaseStoreItemMutation(baseOptions?: Apollo.MutationHookOptions<PurchaseStoreItemMutation, PurchaseStoreItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PurchaseStoreItemMutation, PurchaseStoreItemMutationVariables>(PurchaseStoreItemDocument, options);
      }
export type PurchaseStoreItemMutationHookResult = ReturnType<typeof usePurchaseStoreItemMutation>;
export type PurchaseStoreItemMutationResult = Apollo.MutationResult<PurchaseStoreItemMutation>;
export type PurchaseStoreItemMutationOptions = Apollo.BaseMutationOptions<PurchaseStoreItemMutation, PurchaseStoreItemMutationVariables>;
export const StoreItemPlatformNavigationDocument = gql`
    query StoreItemPlatformNavigation($gameId: ID!) {
  platformStoreFront(gameId: $gameId) {
    id
    gameId
    categories {
      id
      sellableItems {
        id
      }
    }
  }
}
    `;

/**
 * __useStoreItemPlatformNavigationQuery__
 *
 * To run a query within a React component, call `useStoreItemPlatformNavigationQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoreItemPlatformNavigationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoreItemPlatformNavigationQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useStoreItemPlatformNavigationQuery(baseOptions: Apollo.QueryHookOptions<StoreItemPlatformNavigationQuery, StoreItemPlatformNavigationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoreItemPlatformNavigationQuery, StoreItemPlatformNavigationQueryVariables>(StoreItemPlatformNavigationDocument, options);
      }
export function useStoreItemPlatformNavigationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoreItemPlatformNavigationQuery, StoreItemPlatformNavigationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoreItemPlatformNavigationQuery, StoreItemPlatformNavigationQueryVariables>(StoreItemPlatformNavigationDocument, options);
        }
export type StoreItemPlatformNavigationQueryHookResult = ReturnType<typeof useStoreItemPlatformNavigationQuery>;
export type StoreItemPlatformNavigationLazyQueryHookResult = ReturnType<typeof useStoreItemPlatformNavigationLazyQuery>;
export type StoreItemPlatformNavigationQueryResult = Apollo.QueryResult<StoreItemPlatformNavigationQuery, StoreItemPlatformNavigationQueryVariables>;
export const StoreItemChannelNavigationDocument = gql`
    query StoreItemChannelNavigation($gameId: ID!, $channelId: ID!) {
  channelStoreFront(gameId: $gameId, channelId: $channelId) {
    id
    gameId
    categories {
      id
      sellableItems {
        id
      }
    }
  }
}
    `;

/**
 * __useStoreItemChannelNavigationQuery__
 *
 * To run a query within a React component, call `useStoreItemChannelNavigationQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoreItemChannelNavigationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoreItemChannelNavigationQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStoreItemChannelNavigationQuery(baseOptions: Apollo.QueryHookOptions<StoreItemChannelNavigationQuery, StoreItemChannelNavigationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoreItemChannelNavigationQuery, StoreItemChannelNavigationQueryVariables>(StoreItemChannelNavigationDocument, options);
      }
export function useStoreItemChannelNavigationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoreItemChannelNavigationQuery, StoreItemChannelNavigationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoreItemChannelNavigationQuery, StoreItemChannelNavigationQueryVariables>(StoreItemChannelNavigationDocument, options);
        }
export type StoreItemChannelNavigationQueryHookResult = ReturnType<typeof useStoreItemChannelNavigationQuery>;
export type StoreItemChannelNavigationLazyQueryHookResult = ReturnType<typeof useStoreItemChannelNavigationLazyQuery>;
export type StoreItemChannelNavigationQueryResult = Apollo.QueryResult<StoreItemChannelNavigationQuery, StoreItemChannelNavigationQueryVariables>;
export const SendGiftToCommunityDialogOverviewContentChannelDocument = gql`
    query SendGiftToCommunityDialogOverviewContentChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    ...SubscriptionDialogChannelContentChannel
  }
}
    ${SubscriptionDialogChannelContentChannelFragmentDoc}`;

/**
 * __useSendGiftToCommunityDialogOverviewContentChannelQuery__
 *
 * To run a query within a React component, call `useSendGiftToCommunityDialogOverviewContentChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendGiftToCommunityDialogOverviewContentChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendGiftToCommunityDialogOverviewContentChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSendGiftToCommunityDialogOverviewContentChannelQuery(baseOptions: Apollo.QueryHookOptions<SendGiftToCommunityDialogOverviewContentChannelQuery, SendGiftToCommunityDialogOverviewContentChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendGiftToCommunityDialogOverviewContentChannelQuery, SendGiftToCommunityDialogOverviewContentChannelQueryVariables>(SendGiftToCommunityDialogOverviewContentChannelDocument, options);
      }
export function useSendGiftToCommunityDialogOverviewContentChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendGiftToCommunityDialogOverviewContentChannelQuery, SendGiftToCommunityDialogOverviewContentChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendGiftToCommunityDialogOverviewContentChannelQuery, SendGiftToCommunityDialogOverviewContentChannelQueryVariables>(SendGiftToCommunityDialogOverviewContentChannelDocument, options);
        }
export type SendGiftToCommunityDialogOverviewContentChannelQueryHookResult = ReturnType<typeof useSendGiftToCommunityDialogOverviewContentChannelQuery>;
export type SendGiftToCommunityDialogOverviewContentChannelLazyQueryHookResult = ReturnType<typeof useSendGiftToCommunityDialogOverviewContentChannelLazyQuery>;
export type SendGiftToCommunityDialogOverviewContentChannelQueryResult = Apollo.QueryResult<SendGiftToCommunityDialogOverviewContentChannelQuery, SendGiftToCommunityDialogOverviewContentChannelQueryVariables>;
export const SendGiftToUserDialogOverviewContentChannelDocument = gql`
    query SendGiftToUserDialogOverviewContentChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
  }
}
    `;

/**
 * __useSendGiftToUserDialogOverviewContentChannelQuery__
 *
 * To run a query within a React component, call `useSendGiftToUserDialogOverviewContentChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendGiftToUserDialogOverviewContentChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendGiftToUserDialogOverviewContentChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSendGiftToUserDialogOverviewContentChannelQuery(baseOptions: Apollo.QueryHookOptions<SendGiftToUserDialogOverviewContentChannelQuery, SendGiftToUserDialogOverviewContentChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendGiftToUserDialogOverviewContentChannelQuery, SendGiftToUserDialogOverviewContentChannelQueryVariables>(SendGiftToUserDialogOverviewContentChannelDocument, options);
      }
export function useSendGiftToUserDialogOverviewContentChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendGiftToUserDialogOverviewContentChannelQuery, SendGiftToUserDialogOverviewContentChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendGiftToUserDialogOverviewContentChannelQuery, SendGiftToUserDialogOverviewContentChannelQueryVariables>(SendGiftToUserDialogOverviewContentChannelDocument, options);
        }
export type SendGiftToUserDialogOverviewContentChannelQueryHookResult = ReturnType<typeof useSendGiftToUserDialogOverviewContentChannelQuery>;
export type SendGiftToUserDialogOverviewContentChannelLazyQueryHookResult = ReturnType<typeof useSendGiftToUserDialogOverviewContentChannelLazyQuery>;
export type SendGiftToUserDialogOverviewContentChannelQueryResult = Apollo.QueryResult<SendGiftToUserDialogOverviewContentChannelQuery, SendGiftToUserDialogOverviewContentChannelQueryVariables>;
export const OverviewSubscriptionContentChannelDocument = gql`
    query OverviewSubscriptionContentChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
  }
}
    `;

/**
 * __useOverviewSubscriptionContentChannelQuery__
 *
 * To run a query within a React component, call `useOverviewSubscriptionContentChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useOverviewSubscriptionContentChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOverviewSubscriptionContentChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useOverviewSubscriptionContentChannelQuery(baseOptions: Apollo.QueryHookOptions<OverviewSubscriptionContentChannelQuery, OverviewSubscriptionContentChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OverviewSubscriptionContentChannelQuery, OverviewSubscriptionContentChannelQueryVariables>(OverviewSubscriptionContentChannelDocument, options);
      }
export function useOverviewSubscriptionContentChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OverviewSubscriptionContentChannelQuery, OverviewSubscriptionContentChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OverviewSubscriptionContentChannelQuery, OverviewSubscriptionContentChannelQueryVariables>(OverviewSubscriptionContentChannelDocument, options);
        }
export type OverviewSubscriptionContentChannelQueryHookResult = ReturnType<typeof useOverviewSubscriptionContentChannelQuery>;
export type OverviewSubscriptionContentChannelLazyQueryHookResult = ReturnType<typeof useOverviewSubscriptionContentChannelLazyQuery>;
export type OverviewSubscriptionContentChannelQueryResult = Apollo.QueryResult<OverviewSubscriptionContentChannelQuery, OverviewSubscriptionContentChannelQueryVariables>;
export const SendGiftDialogPaymentContentChannelDocument = gql`
    query SendGiftDialogPaymentContentChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
    ...SubscriptionDialogChannelContentChannel
  }
}
    ${SubscriptionDialogChannelContentChannelFragmentDoc}`;

/**
 * __useSendGiftDialogPaymentContentChannelQuery__
 *
 * To run a query within a React component, call `useSendGiftDialogPaymentContentChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendGiftDialogPaymentContentChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendGiftDialogPaymentContentChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSendGiftDialogPaymentContentChannelQuery(baseOptions: Apollo.QueryHookOptions<SendGiftDialogPaymentContentChannelQuery, SendGiftDialogPaymentContentChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendGiftDialogPaymentContentChannelQuery, SendGiftDialogPaymentContentChannelQueryVariables>(SendGiftDialogPaymentContentChannelDocument, options);
      }
export function useSendGiftDialogPaymentContentChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendGiftDialogPaymentContentChannelQuery, SendGiftDialogPaymentContentChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendGiftDialogPaymentContentChannelQuery, SendGiftDialogPaymentContentChannelQueryVariables>(SendGiftDialogPaymentContentChannelDocument, options);
        }
export type SendGiftDialogPaymentContentChannelQueryHookResult = ReturnType<typeof useSendGiftDialogPaymentContentChannelQuery>;
export type SendGiftDialogPaymentContentChannelLazyQueryHookResult = ReturnType<typeof useSendGiftDialogPaymentContentChannelLazyQuery>;
export type SendGiftDialogPaymentContentChannelQueryResult = Apollo.QueryResult<SendGiftDialogPaymentContentChannelQuery, SendGiftDialogPaymentContentChannelQueryVariables>;
export const SendGiftToUserDialogDataDocument = gql`
    query SendGiftToUserDialogData($userId: ID!, $channelId: ID) {
  profile(userId: $userId) {
    userId
    userTag
    ...SendGiftToUserDialogProfile
  }
  userChannelSubscription(userId: $userId, channelId: $channelId) {
    state
  }
}
    ${SendGiftToUserDialogProfileFragmentDoc}`;

/**
 * __useSendGiftToUserDialogDataQuery__
 *
 * To run a query within a React component, call `useSendGiftToUserDialogDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendGiftToUserDialogDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendGiftToUserDialogDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSendGiftToUserDialogDataQuery(baseOptions: Apollo.QueryHookOptions<SendGiftToUserDialogDataQuery, SendGiftToUserDialogDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendGiftToUserDialogDataQuery, SendGiftToUserDialogDataQueryVariables>(SendGiftToUserDialogDataDocument, options);
      }
export function useSendGiftToUserDialogDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendGiftToUserDialogDataQuery, SendGiftToUserDialogDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendGiftToUserDialogDataQuery, SendGiftToUserDialogDataQueryVariables>(SendGiftToUserDialogDataDocument, options);
        }
export type SendGiftToUserDialogDataQueryHookResult = ReturnType<typeof useSendGiftToUserDialogDataQuery>;
export type SendGiftToUserDialogDataLazyQueryHookResult = ReturnType<typeof useSendGiftToUserDialogDataLazyQuery>;
export type SendGiftToUserDialogDataQueryResult = Apollo.QueryResult<SendGiftToUserDialogDataQuery, SendGiftToUserDialogDataQueryVariables>;
export const SendGiftGiftItemsDocument = gql`
    query SendGiftGiftItems($channelId: ID!) {
  giftSellableItems(channelId: $channelId, itemType: ITEM_TYPE_GIFT_SUBSCRIPTION) {
    items {
      id
      ...GiftableItem
      ...SendGiftDialogSellableItem
    }
  }
}
    ${GiftableItemFragmentDoc}
${SendGiftDialogSellableItemFragmentDoc}`;

/**
 * __useSendGiftGiftItemsQuery__
 *
 * To run a query within a React component, call `useSendGiftGiftItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendGiftGiftItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendGiftGiftItemsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSendGiftGiftItemsQuery(baseOptions: Apollo.QueryHookOptions<SendGiftGiftItemsQuery, SendGiftGiftItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendGiftGiftItemsQuery, SendGiftGiftItemsQueryVariables>(SendGiftGiftItemsDocument, options);
      }
export function useSendGiftGiftItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendGiftGiftItemsQuery, SendGiftGiftItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendGiftGiftItemsQuery, SendGiftGiftItemsQueryVariables>(SendGiftGiftItemsDocument, options);
        }
export type SendGiftGiftItemsQueryHookResult = ReturnType<typeof useSendGiftGiftItemsQuery>;
export type SendGiftGiftItemsLazyQueryHookResult = ReturnType<typeof useSendGiftGiftItemsLazyQuery>;
export type SendGiftGiftItemsQueryResult = Apollo.QueryResult<SendGiftGiftItemsQuery, SendGiftGiftItemsQueryVariables>;
export const SendGiftToUserIsTemporaryDocument = gql`
    query SendGiftToUserIsTemporary($userId: ID!) {
  profile(userId: $userId) {
    userId
    temporary
  }
}
    `;

/**
 * __useSendGiftToUserIsTemporaryQuery__
 *
 * To run a query within a React component, call `useSendGiftToUserIsTemporaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendGiftToUserIsTemporaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendGiftToUserIsTemporaryQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSendGiftToUserIsTemporaryQuery(baseOptions: Apollo.QueryHookOptions<SendGiftToUserIsTemporaryQuery, SendGiftToUserIsTemporaryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendGiftToUserIsTemporaryQuery, SendGiftToUserIsTemporaryQueryVariables>(SendGiftToUserIsTemporaryDocument, options);
      }
export function useSendGiftToUserIsTemporaryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendGiftToUserIsTemporaryQuery, SendGiftToUserIsTemporaryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendGiftToUserIsTemporaryQuery, SendGiftToUserIsTemporaryQueryVariables>(SendGiftToUserIsTemporaryDocument, options);
        }
export type SendGiftToUserIsTemporaryQueryHookResult = ReturnType<typeof useSendGiftToUserIsTemporaryQuery>;
export type SendGiftToUserIsTemporaryLazyQueryHookResult = ReturnType<typeof useSendGiftToUserIsTemporaryLazyQuery>;
export type SendGiftToUserIsTemporaryQueryResult = Apollo.QueryResult<SendGiftToUserIsTemporaryQuery, SendGiftToUserIsTemporaryQueryVariables>;
export const SendGiftToUserSubscriptionStateDocument = gql`
    query SendGiftToUserSubscriptionState($userId: ID!, $channelId: ID!) {
  userChannelSubscription(userId: $userId, channelId: $channelId) {
    state
  }
}
    `;

/**
 * __useSendGiftToUserSubscriptionStateQuery__
 *
 * To run a query within a React component, call `useSendGiftToUserSubscriptionStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendGiftToUserSubscriptionStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendGiftToUserSubscriptionStateQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSendGiftToUserSubscriptionStateQuery(baseOptions: Apollo.QueryHookOptions<SendGiftToUserSubscriptionStateQuery, SendGiftToUserSubscriptionStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendGiftToUserSubscriptionStateQuery, SendGiftToUserSubscriptionStateQueryVariables>(SendGiftToUserSubscriptionStateDocument, options);
      }
export function useSendGiftToUserSubscriptionStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendGiftToUserSubscriptionStateQuery, SendGiftToUserSubscriptionStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendGiftToUserSubscriptionStateQuery, SendGiftToUserSubscriptionStateQueryVariables>(SendGiftToUserSubscriptionStateDocument, options);
        }
export type SendGiftToUserSubscriptionStateQueryHookResult = ReturnType<typeof useSendGiftToUserSubscriptionStateQuery>;
export type SendGiftToUserSubscriptionStateLazyQueryHookResult = ReturnType<typeof useSendGiftToUserSubscriptionStateLazyQuery>;
export type SendGiftToUserSubscriptionStateQueryResult = Apollo.QueryResult<SendGiftToUserSubscriptionStateQuery, SendGiftToUserSubscriptionStateQueryVariables>;
export const SendGiftToUserWithPaymentDocument = gql`
    mutation SendGiftToUserWithPayment($itemId: ID!, $signature: String!, $giftedUserId: String!, $giftAnonymously: Boolean!) {
  buyWithPayment(
    itemId: $itemId
    signature: $signature
    giftOptions: {recipientIds: [$giftedUserId], giftAnonymously: $giftAnonymously}
  ) {
    ...GiftPaymentSession
  }
}
    ${GiftPaymentSessionFragmentDoc}`;
export type SendGiftToUserWithPaymentMutationFn = Apollo.MutationFunction<SendGiftToUserWithPaymentMutation, SendGiftToUserWithPaymentMutationVariables>;

/**
 * __useSendGiftToUserWithPaymentMutation__
 *
 * To run a mutation, you first call `useSendGiftToUserWithPaymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendGiftToUserWithPaymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendGiftToUserWithPaymentMutation, { data, loading, error }] = useSendGiftToUserWithPaymentMutation({
 *   variables: {
 *      itemId: // value for 'itemId'
 *      signature: // value for 'signature'
 *      giftedUserId: // value for 'giftedUserId'
 *      giftAnonymously: // value for 'giftAnonymously'
 *   },
 * });
 */
export function useSendGiftToUserWithPaymentMutation(baseOptions?: Apollo.MutationHookOptions<SendGiftToUserWithPaymentMutation, SendGiftToUserWithPaymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendGiftToUserWithPaymentMutation, SendGiftToUserWithPaymentMutationVariables>(SendGiftToUserWithPaymentDocument, options);
      }
export type SendGiftToUserWithPaymentMutationHookResult = ReturnType<typeof useSendGiftToUserWithPaymentMutation>;
export type SendGiftToUserWithPaymentMutationResult = Apollo.MutationResult<SendGiftToUserWithPaymentMutation>;
export type SendGiftToUserWithPaymentMutationOptions = Apollo.BaseMutationOptions<SendGiftToUserWithPaymentMutation, SendGiftToUserWithPaymentMutationVariables>;
export const SendGiftToCommunityWithPaymentDocument = gql`
    mutation SendGiftToCommunityWithPayment($itemId: ID!, $signature: String!, $giftAnonymously: Boolean!) {
  buyWithPayment(
    itemId: $itemId
    signature: $signature
    giftOptions: {giftAnonymously: $giftAnonymously}
  ) {
    ...GiftPaymentSession
  }
}
    ${GiftPaymentSessionFragmentDoc}`;
export type SendGiftToCommunityWithPaymentMutationFn = Apollo.MutationFunction<SendGiftToCommunityWithPaymentMutation, SendGiftToCommunityWithPaymentMutationVariables>;

/**
 * __useSendGiftToCommunityWithPaymentMutation__
 *
 * To run a mutation, you first call `useSendGiftToCommunityWithPaymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendGiftToCommunityWithPaymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendGiftToCommunityWithPaymentMutation, { data, loading, error }] = useSendGiftToCommunityWithPaymentMutation({
 *   variables: {
 *      itemId: // value for 'itemId'
 *      signature: // value for 'signature'
 *      giftAnonymously: // value for 'giftAnonymously'
 *   },
 * });
 */
export function useSendGiftToCommunityWithPaymentMutation(baseOptions?: Apollo.MutationHookOptions<SendGiftToCommunityWithPaymentMutation, SendGiftToCommunityWithPaymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendGiftToCommunityWithPaymentMutation, SendGiftToCommunityWithPaymentMutationVariables>(SendGiftToCommunityWithPaymentDocument, options);
      }
export type SendGiftToCommunityWithPaymentMutationHookResult = ReturnType<typeof useSendGiftToCommunityWithPaymentMutation>;
export type SendGiftToCommunityWithPaymentMutationResult = Apollo.MutationResult<SendGiftToCommunityWithPaymentMutation>;
export type SendGiftToCommunityWithPaymentMutationOptions = Apollo.BaseMutationOptions<SendGiftToCommunityWithPaymentMutation, SendGiftToCommunityWithPaymentMutationVariables>;
export const StoreHasBundlesToBuyStoreFrontDocument = gql`
    query StoreHasBundlesToBuyStoreFront($gameId: ID!) {
  platformStoreFront(gameId: $gameId) {
    id
    gameId
    categories {
      id
      itemType
      sellableItems {
        id
        igcPrices {
          currencyId
          amount
        }
        name
      }
    }
  }
}
    `;

/**
 * __useStoreHasBundlesToBuyStoreFrontQuery__
 *
 * To run a query within a React component, call `useStoreHasBundlesToBuyStoreFrontQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoreHasBundlesToBuyStoreFrontQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoreHasBundlesToBuyStoreFrontQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useStoreHasBundlesToBuyStoreFrontQuery(baseOptions: Apollo.QueryHookOptions<StoreHasBundlesToBuyStoreFrontQuery, StoreHasBundlesToBuyStoreFrontQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoreHasBundlesToBuyStoreFrontQuery, StoreHasBundlesToBuyStoreFrontQueryVariables>(StoreHasBundlesToBuyStoreFrontDocument, options);
      }
export function useStoreHasBundlesToBuyStoreFrontLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoreHasBundlesToBuyStoreFrontQuery, StoreHasBundlesToBuyStoreFrontQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoreHasBundlesToBuyStoreFrontQuery, StoreHasBundlesToBuyStoreFrontQueryVariables>(StoreHasBundlesToBuyStoreFrontDocument, options);
        }
export type StoreHasBundlesToBuyStoreFrontQueryHookResult = ReturnType<typeof useStoreHasBundlesToBuyStoreFrontQuery>;
export type StoreHasBundlesToBuyStoreFrontLazyQueryHookResult = ReturnType<typeof useStoreHasBundlesToBuyStoreFrontLazyQuery>;
export type StoreHasBundlesToBuyStoreFrontQueryResult = Apollo.QueryResult<StoreHasBundlesToBuyStoreFrontQuery, StoreHasBundlesToBuyStoreFrontQueryVariables>;
export const StoreBuyCurrencyBundleWithInGameCurrencyDocument = gql`
    mutation StoreBuyCurrencyBundleWithInGameCurrency($itemId: ID!, $signature: String!, $currencyId: ID!) {
  buyWithInGameCurrency(
    itemId: $itemId
    signature: $signature
    currencyId: $currencyId
  ) {
    orderId
  }
}
    `;
export type StoreBuyCurrencyBundleWithInGameCurrencyMutationFn = Apollo.MutationFunction<StoreBuyCurrencyBundleWithInGameCurrencyMutation, StoreBuyCurrencyBundleWithInGameCurrencyMutationVariables>;

/**
 * __useStoreBuyCurrencyBundleWithInGameCurrencyMutation__
 *
 * To run a mutation, you first call `useStoreBuyCurrencyBundleWithInGameCurrencyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStoreBuyCurrencyBundleWithInGameCurrencyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [storeBuyCurrencyBundleWithInGameCurrencyMutation, { data, loading, error }] = useStoreBuyCurrencyBundleWithInGameCurrencyMutation({
 *   variables: {
 *      itemId: // value for 'itemId'
 *      signature: // value for 'signature'
 *      currencyId: // value for 'currencyId'
 *   },
 * });
 */
export function useStoreBuyCurrencyBundleWithInGameCurrencyMutation(baseOptions?: Apollo.MutationHookOptions<StoreBuyCurrencyBundleWithInGameCurrencyMutation, StoreBuyCurrencyBundleWithInGameCurrencyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<StoreBuyCurrencyBundleWithInGameCurrencyMutation, StoreBuyCurrencyBundleWithInGameCurrencyMutationVariables>(StoreBuyCurrencyBundleWithInGameCurrencyDocument, options);
      }
export type StoreBuyCurrencyBundleWithInGameCurrencyMutationHookResult = ReturnType<typeof useStoreBuyCurrencyBundleWithInGameCurrencyMutation>;
export type StoreBuyCurrencyBundleWithInGameCurrencyMutationResult = Apollo.MutationResult<StoreBuyCurrencyBundleWithInGameCurrencyMutation>;
export type StoreBuyCurrencyBundleWithInGameCurrencyMutationOptions = Apollo.BaseMutationOptions<StoreBuyCurrencyBundleWithInGameCurrencyMutation, StoreBuyCurrencyBundleWithInGameCurrencyMutationVariables>;
export const StoreBuyCurrencyBundleWithPaymentDocument = gql`
    mutation StoreBuyCurrencyBundleWithPayment($itemId: ID!, $signature: String!) {
  buyWithPayment(itemId: $itemId, signature: $signature) {
    orderId
    session {
      session {
        ... on AdyenSession {
          id
          reference
          returnUrl
          sessionData
          amount {
            value
            currency
          }
        }
      }
    }
  }
}
    `;
export type StoreBuyCurrencyBundleWithPaymentMutationFn = Apollo.MutationFunction<StoreBuyCurrencyBundleWithPaymentMutation, StoreBuyCurrencyBundleWithPaymentMutationVariables>;

/**
 * __useStoreBuyCurrencyBundleWithPaymentMutation__
 *
 * To run a mutation, you first call `useStoreBuyCurrencyBundleWithPaymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStoreBuyCurrencyBundleWithPaymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [storeBuyCurrencyBundleWithPaymentMutation, { data, loading, error }] = useStoreBuyCurrencyBundleWithPaymentMutation({
 *   variables: {
 *      itemId: // value for 'itemId'
 *      signature: // value for 'signature'
 *   },
 * });
 */
export function useStoreBuyCurrencyBundleWithPaymentMutation(baseOptions?: Apollo.MutationHookOptions<StoreBuyCurrencyBundleWithPaymentMutation, StoreBuyCurrencyBundleWithPaymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<StoreBuyCurrencyBundleWithPaymentMutation, StoreBuyCurrencyBundleWithPaymentMutationVariables>(StoreBuyCurrencyBundleWithPaymentDocument, options);
      }
export type StoreBuyCurrencyBundleWithPaymentMutationHookResult = ReturnType<typeof useStoreBuyCurrencyBundleWithPaymentMutation>;
export type StoreBuyCurrencyBundleWithPaymentMutationResult = Apollo.MutationResult<StoreBuyCurrencyBundleWithPaymentMutation>;
export type StoreBuyCurrencyBundleWithPaymentMutationOptions = Apollo.BaseMutationOptions<StoreBuyCurrencyBundleWithPaymentMutation, StoreBuyCurrencyBundleWithPaymentMutationVariables>;
export const StreamGameProxyChannelDocument = gql`
    query StreamGameProxyChannel($streamId: ID!) {
  streamSummary(id: $streamId) {
    ...StreamGameProxyStream
  }
}
    ${StreamGameProxyStreamFragmentDoc}`;

/**
 * __useStreamGameProxyChannelQuery__
 *
 * To run a query within a React component, call `useStreamGameProxyChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamGameProxyChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamGameProxyChannelQuery({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useStreamGameProxyChannelQuery(baseOptions: Apollo.QueryHookOptions<StreamGameProxyChannelQuery, StreamGameProxyChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamGameProxyChannelQuery, StreamGameProxyChannelQueryVariables>(StreamGameProxyChannelDocument, options);
      }
export function useStreamGameProxyChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamGameProxyChannelQuery, StreamGameProxyChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamGameProxyChannelQuery, StreamGameProxyChannelQueryVariables>(StreamGameProxyChannelDocument, options);
        }
export type StreamGameProxyChannelQueryHookResult = ReturnType<typeof useStreamGameProxyChannelQuery>;
export type StreamGameProxyChannelLazyQueryHookResult = ReturnType<typeof useStreamGameProxyChannelLazyQuery>;
export type StreamGameProxyChannelQueryResult = Apollo.QueryResult<StreamGameProxyChannelQuery, StreamGameProxyChannelQueryVariables>;
export const StreamStateChannelLiveStateDocument = gql`
    subscription StreamStateChannelLiveState($channelId: ID) {
  channelStreamDetailSubscribe(channelId: $channelId) {
    channelId
    liveStatus
    streamId
    matureRatedContent
    serverRenderingEnabled
  }
}
    `;

/**
 * __useStreamStateChannelLiveStateSubscription__
 *
 * To run a query within a React component, call `useStreamStateChannelLiveStateSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStreamStateChannelLiveStateSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamStateChannelLiveStateSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStreamStateChannelLiveStateSubscription(baseOptions?: Apollo.SubscriptionHookOptions<StreamStateChannelLiveStateSubscription, StreamStateChannelLiveStateSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StreamStateChannelLiveStateSubscription, StreamStateChannelLiveStateSubscriptionVariables>(StreamStateChannelLiveStateDocument, options);
      }
export type StreamStateChannelLiveStateSubscriptionHookResult = ReturnType<typeof useStreamStateChannelLiveStateSubscription>;
export type StreamStateChannelLiveStateSubscriptionResult = Apollo.SubscriptionResult<StreamStateChannelLiveStateSubscription>;
export const StreamStateProfileDocument = gql`
    query StreamStateProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      uid
      matureRatedContentAllowed
    }
  }
}
    `;

/**
 * __useStreamStateProfileQuery__
 *
 * To run a query within a React component, call `useStreamStateProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamStateProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamStateProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useStreamStateProfileQuery(baseOptions: Apollo.QueryHookOptions<StreamStateProfileQuery, StreamStateProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamStateProfileQuery, StreamStateProfileQueryVariables>(StreamStateProfileDocument, options);
      }
export function useStreamStateProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamStateProfileQuery, StreamStateProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamStateProfileQuery, StreamStateProfileQueryVariables>(StreamStateProfileDocument, options);
        }
export type StreamStateProfileQueryHookResult = ReturnType<typeof useStreamStateProfileQuery>;
export type StreamStateProfileLazyQueryHookResult = ReturnType<typeof useStreamStateProfileLazyQuery>;
export type StreamStateProfileQueryResult = Apollo.QueryResult<StreamStateProfileQuery, StreamStateProfileQueryVariables>;
export const ActiveSubscriptionMenuCancelDocument = gql`
    mutation ActiveSubscriptionMenuCancel($channelId: ID!) {
  cancelChannelSubscription(channelId: $channelId) {
    emptyTypeWorkaround
  }
}
    `;
export type ActiveSubscriptionMenuCancelMutationFn = Apollo.MutationFunction<ActiveSubscriptionMenuCancelMutation, ActiveSubscriptionMenuCancelMutationVariables>;

/**
 * __useActiveSubscriptionMenuCancelMutation__
 *
 * To run a mutation, you first call `useActiveSubscriptionMenuCancelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useActiveSubscriptionMenuCancelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [activeSubscriptionMenuCancelMutation, { data, loading, error }] = useActiveSubscriptionMenuCancelMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useActiveSubscriptionMenuCancelMutation(baseOptions?: Apollo.MutationHookOptions<ActiveSubscriptionMenuCancelMutation, ActiveSubscriptionMenuCancelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ActiveSubscriptionMenuCancelMutation, ActiveSubscriptionMenuCancelMutationVariables>(ActiveSubscriptionMenuCancelDocument, options);
      }
export type ActiveSubscriptionMenuCancelMutationHookResult = ReturnType<typeof useActiveSubscriptionMenuCancelMutation>;
export type ActiveSubscriptionMenuCancelMutationResult = Apollo.MutationResult<ActiveSubscriptionMenuCancelMutation>;
export type ActiveSubscriptionMenuCancelMutationOptions = Apollo.BaseMutationOptions<ActiveSubscriptionMenuCancelMutation, ActiveSubscriptionMenuCancelMutationVariables>;
export const ActiveSubscriptionMenuUserBadgeDocument = gql`
    query ActiveSubscriptionMenuUserBadge($userId: ID!, $channelId: ID!) {
  profile(userId: $userId) {
    userId
    badges(channel_id: $channelId) {
      ...UserBadge
    }
  }
}
    ${UserBadgeFragmentDoc}`;

/**
 * __useActiveSubscriptionMenuUserBadgeQuery__
 *
 * To run a query within a React component, call `useActiveSubscriptionMenuUserBadgeQuery` and pass it any options that fit your needs.
 * When your component renders, `useActiveSubscriptionMenuUserBadgeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActiveSubscriptionMenuUserBadgeQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useActiveSubscriptionMenuUserBadgeQuery(baseOptions: Apollo.QueryHookOptions<ActiveSubscriptionMenuUserBadgeQuery, ActiveSubscriptionMenuUserBadgeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActiveSubscriptionMenuUserBadgeQuery, ActiveSubscriptionMenuUserBadgeQueryVariables>(ActiveSubscriptionMenuUserBadgeDocument, options);
      }
export function useActiveSubscriptionMenuUserBadgeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActiveSubscriptionMenuUserBadgeQuery, ActiveSubscriptionMenuUserBadgeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActiveSubscriptionMenuUserBadgeQuery, ActiveSubscriptionMenuUserBadgeQueryVariables>(ActiveSubscriptionMenuUserBadgeDocument, options);
        }
export type ActiveSubscriptionMenuUserBadgeQueryHookResult = ReturnType<typeof useActiveSubscriptionMenuUserBadgeQuery>;
export type ActiveSubscriptionMenuUserBadgeLazyQueryHookResult = ReturnType<typeof useActiveSubscriptionMenuUserBadgeLazyQuery>;
export type ActiveSubscriptionMenuUserBadgeQueryResult = Apollo.QueryResult<ActiveSubscriptionMenuUserBadgeQuery, ActiveSubscriptionMenuUserBadgeQueryVariables>;
export const SubscriptionCancellationModalChannelDocument = gql`
    query SubscriptionCancellationModalChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    subscription {
      id
      ...SubscriptionCancellationModalContentSubscription
      ...SubscriptionCancellationModalActionsSubscription
    }
    ...SubscriptionCancellationModalContentChannel
    ...SubscriptionCancellationModalActionsChannel
  }
}
    ${SubscriptionCancellationModalContentSubscriptionFragmentDoc}
${SubscriptionCancellationModalActionsSubscriptionFragmentDoc}
${SubscriptionCancellationModalContentChannelFragmentDoc}
${SubscriptionCancellationModalActionsChannelFragmentDoc}`;

/**
 * __useSubscriptionCancellationModalChannelQuery__
 *
 * To run a query within a React component, call `useSubscriptionCancellationModalChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionCancellationModalChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionCancellationModalChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSubscriptionCancellationModalChannelQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionCancellationModalChannelQuery, SubscriptionCancellationModalChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionCancellationModalChannelQuery, SubscriptionCancellationModalChannelQueryVariables>(SubscriptionCancellationModalChannelDocument, options);
      }
export function useSubscriptionCancellationModalChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionCancellationModalChannelQuery, SubscriptionCancellationModalChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionCancellationModalChannelQuery, SubscriptionCancellationModalChannelQueryVariables>(SubscriptionCancellationModalChannelDocument, options);
        }
export type SubscriptionCancellationModalChannelQueryHookResult = ReturnType<typeof useSubscriptionCancellationModalChannelQuery>;
export type SubscriptionCancellationModalChannelLazyQueryHookResult = ReturnType<typeof useSubscriptionCancellationModalChannelLazyQuery>;
export type SubscriptionCancellationModalChannelQueryResult = Apollo.QueryResult<SubscriptionCancellationModalChannelQuery, SubscriptionCancellationModalChannelQueryVariables>;
export const ChargebeeSubscriptionModelChannelDocument = gql`
    query ChargebeeSubscriptionModelChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    subscriptionConfig {
      channelId
      tiers {
        level
        prices {
          period
          price
          currency
        }
      }
    }
    subscription {
      id
      ...SubscriptionModalStageFlowsSubscription
    }
    ...SubscriptionDialogChannelContentChannel
    ...SubscriptionModalOverviewStageChannel
    ...SubscriptionModalCompleteStageChannel
    ...SubscriptionModalActionsChannel
  }
}
    ${SubscriptionModalStageFlowsSubscriptionFragmentDoc}
${SubscriptionDialogChannelContentChannelFragmentDoc}
${SubscriptionModalOverviewStageChannelFragmentDoc}
${SubscriptionModalCompleteStageChannelFragmentDoc}
${SubscriptionModalActionsChannelFragmentDoc}`;

/**
 * __useChargebeeSubscriptionModelChannelQuery__
 *
 * To run a query within a React component, call `useChargebeeSubscriptionModelChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useChargebeeSubscriptionModelChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChargebeeSubscriptionModelChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChargebeeSubscriptionModelChannelQuery(baseOptions: Apollo.QueryHookOptions<ChargebeeSubscriptionModelChannelQuery, ChargebeeSubscriptionModelChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChargebeeSubscriptionModelChannelQuery, ChargebeeSubscriptionModelChannelQueryVariables>(ChargebeeSubscriptionModelChannelDocument, options);
      }
export function useChargebeeSubscriptionModelChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChargebeeSubscriptionModelChannelQuery, ChargebeeSubscriptionModelChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChargebeeSubscriptionModelChannelQuery, ChargebeeSubscriptionModelChannelQueryVariables>(ChargebeeSubscriptionModelChannelDocument, options);
        }
export type ChargebeeSubscriptionModelChannelQueryHookResult = ReturnType<typeof useChargebeeSubscriptionModelChannelQuery>;
export type ChargebeeSubscriptionModelChannelLazyQueryHookResult = ReturnType<typeof useChargebeeSubscriptionModelChannelLazyQuery>;
export type ChargebeeSubscriptionModelChannelQueryResult = Apollo.QueryResult<ChargebeeSubscriptionModelChannelQuery, ChargebeeSubscriptionModelChannelQueryVariables>;
export const ReactiveChannelSubscriptionDocument = gql`
    mutation ReactiveChannelSubscription($channelId: ID!) {
  reactivateChannelSubscription(channelId: $channelId) {
    emptyTypeWorkaround
  }
}
    `;
export type ReactiveChannelSubscriptionMutationFn = Apollo.MutationFunction<ReactiveChannelSubscriptionMutation, ReactiveChannelSubscriptionMutationVariables>;

/**
 * __useReactiveChannelSubscriptionMutation__
 *
 * To run a mutation, you first call `useReactiveChannelSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReactiveChannelSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [reactiveChannelSubscriptionMutation, { data, loading, error }] = useReactiveChannelSubscriptionMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useReactiveChannelSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<ReactiveChannelSubscriptionMutation, ReactiveChannelSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReactiveChannelSubscriptionMutation, ReactiveChannelSubscriptionMutationVariables>(ReactiveChannelSubscriptionDocument, options);
      }
export type ReactiveChannelSubscriptionMutationHookResult = ReturnType<typeof useReactiveChannelSubscriptionMutation>;
export type ReactiveChannelSubscriptionMutationResult = Apollo.MutationResult<ReactiveChannelSubscriptionMutation>;
export type ReactiveChannelSubscriptionMutationOptions = Apollo.BaseMutationOptions<ReactiveChannelSubscriptionMutation, ReactiveChannelSubscriptionMutationVariables>;
export const CheckoutExistingChannelSubscriptionDocument = gql`
    mutation CheckoutExistingChannelSubscription($channelId: ID!) {
  checkoutExistingChannelSubscription(channelId: $channelId) {
    sessionData
  }
}
    `;
export type CheckoutExistingChannelSubscriptionMutationFn = Apollo.MutationFunction<CheckoutExistingChannelSubscriptionMutation, CheckoutExistingChannelSubscriptionMutationVariables>;

/**
 * __useCheckoutExistingChannelSubscriptionMutation__
 *
 * To run a mutation, you first call `useCheckoutExistingChannelSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCheckoutExistingChannelSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [checkoutExistingChannelSubscriptionMutation, { data, loading, error }] = useCheckoutExistingChannelSubscriptionMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useCheckoutExistingChannelSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<CheckoutExistingChannelSubscriptionMutation, CheckoutExistingChannelSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CheckoutExistingChannelSubscriptionMutation, CheckoutExistingChannelSubscriptionMutationVariables>(CheckoutExistingChannelSubscriptionDocument, options);
      }
export type CheckoutExistingChannelSubscriptionMutationHookResult = ReturnType<typeof useCheckoutExistingChannelSubscriptionMutation>;
export type CheckoutExistingChannelSubscriptionMutationResult = Apollo.MutationResult<CheckoutExistingChannelSubscriptionMutation>;
export type CheckoutExistingChannelSubscriptionMutationOptions = Apollo.BaseMutationOptions<CheckoutExistingChannelSubscriptionMutation, CheckoutExistingChannelSubscriptionMutationVariables>;
export const CheckoutNewChannelSubscriptionDocument = gql`
    mutation CheckoutNewChannelSubscription($channelId: ID!, $tier: Int) {
  checkoutNewChannelSubscription(channelId: $channelId, tier: $tier) {
    sessionData
  }
}
    `;
export type CheckoutNewChannelSubscriptionMutationFn = Apollo.MutationFunction<CheckoutNewChannelSubscriptionMutation, CheckoutNewChannelSubscriptionMutationVariables>;

/**
 * __useCheckoutNewChannelSubscriptionMutation__
 *
 * To run a mutation, you first call `useCheckoutNewChannelSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCheckoutNewChannelSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [checkoutNewChannelSubscriptionMutation, { data, loading, error }] = useCheckoutNewChannelSubscriptionMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      tier: // value for 'tier'
 *   },
 * });
 */
export function useCheckoutNewChannelSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<CheckoutNewChannelSubscriptionMutation, CheckoutNewChannelSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CheckoutNewChannelSubscriptionMutation, CheckoutNewChannelSubscriptionMutationVariables>(CheckoutNewChannelSubscriptionDocument, options);
      }
export type CheckoutNewChannelSubscriptionMutationHookResult = ReturnType<typeof useCheckoutNewChannelSubscriptionMutation>;
export type CheckoutNewChannelSubscriptionMutationResult = Apollo.MutationResult<CheckoutNewChannelSubscriptionMutation>;
export type CheckoutNewChannelSubscriptionMutationOptions = Apollo.BaseMutationOptions<CheckoutNewChannelSubscriptionMutation, CheckoutNewChannelSubscriptionMutationVariables>;
export const SubscriptionCheckoutCacheUpdateProfileDocument = gql`
    query SubscriptionCheckoutCacheUpdateProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    settings {
      privacy {
        anonymisePurchaseHighlights
      }
    }
  }
}
    `;

/**
 * __useSubscriptionCheckoutCacheUpdateProfileQuery__
 *
 * To run a query within a React component, call `useSubscriptionCheckoutCacheUpdateProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionCheckoutCacheUpdateProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionCheckoutCacheUpdateProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSubscriptionCheckoutCacheUpdateProfileQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionCheckoutCacheUpdateProfileQuery, SubscriptionCheckoutCacheUpdateProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionCheckoutCacheUpdateProfileQuery, SubscriptionCheckoutCacheUpdateProfileQueryVariables>(SubscriptionCheckoutCacheUpdateProfileDocument, options);
      }
export function useSubscriptionCheckoutCacheUpdateProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionCheckoutCacheUpdateProfileQuery, SubscriptionCheckoutCacheUpdateProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionCheckoutCacheUpdateProfileQuery, SubscriptionCheckoutCacheUpdateProfileQueryVariables>(SubscriptionCheckoutCacheUpdateProfileDocument, options);
        }
export type SubscriptionCheckoutCacheUpdateProfileQueryHookResult = ReturnType<typeof useSubscriptionCheckoutCacheUpdateProfileQuery>;
export type SubscriptionCheckoutCacheUpdateProfileLazyQueryHookResult = ReturnType<typeof useSubscriptionCheckoutCacheUpdateProfileLazyQuery>;
export type SubscriptionCheckoutCacheUpdateProfileQueryResult = Apollo.QueryResult<SubscriptionCheckoutCacheUpdateProfileQuery, SubscriptionCheckoutCacheUpdateProfileQueryVariables>;
export const SubscriptionPaymentMethodSessionDocument = gql`
    mutation SubscriptionPaymentMethodSession {
  updateSubscriptionPaymentMethod {
    sessionData
  }
}
    `;
export type SubscriptionPaymentMethodSessionMutationFn = Apollo.MutationFunction<SubscriptionPaymentMethodSessionMutation, SubscriptionPaymentMethodSessionMutationVariables>;

/**
 * __useSubscriptionPaymentMethodSessionMutation__
 *
 * To run a mutation, you first call `useSubscriptionPaymentMethodSessionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionPaymentMethodSessionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [subscriptionPaymentMethodSessionMutation, { data, loading, error }] = useSubscriptionPaymentMethodSessionMutation({
 *   variables: {
 *   },
 * });
 */
export function useSubscriptionPaymentMethodSessionMutation(baseOptions?: Apollo.MutationHookOptions<SubscriptionPaymentMethodSessionMutation, SubscriptionPaymentMethodSessionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubscriptionPaymentMethodSessionMutation, SubscriptionPaymentMethodSessionMutationVariables>(SubscriptionPaymentMethodSessionDocument, options);
      }
export type SubscriptionPaymentMethodSessionMutationHookResult = ReturnType<typeof useSubscriptionPaymentMethodSessionMutation>;
export type SubscriptionPaymentMethodSessionMutationResult = Apollo.MutationResult<SubscriptionPaymentMethodSessionMutation>;
export type SubscriptionPaymentMethodSessionMutationOptions = Apollo.BaseMutationOptions<SubscriptionPaymentMethodSessionMutation, SubscriptionPaymentMethodSessionMutationVariables>;
export const UpdateConsentWarningSettingDocument = gql`
    mutation UpdateConsentWarningSetting($userId: ID!, $showMatureContentWarning: Boolean!) {
  updatePrivacySettings(
    userId: $userId
    body: {showMatureContentWarning: $showMatureContentWarning}
  ) {
    showMatureContentWarning
  }
}
    `;
export type UpdateConsentWarningSettingMutationFn = Apollo.MutationFunction<UpdateConsentWarningSettingMutation, UpdateConsentWarningSettingMutationVariables>;

/**
 * __useUpdateConsentWarningSettingMutation__
 *
 * To run a mutation, you first call `useUpdateConsentWarningSettingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateConsentWarningSettingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateConsentWarningSettingMutation, { data, loading, error }] = useUpdateConsentWarningSettingMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      showMatureContentWarning: // value for 'showMatureContentWarning'
 *   },
 * });
 */
export function useUpdateConsentWarningSettingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateConsentWarningSettingMutation, UpdateConsentWarningSettingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateConsentWarningSettingMutation, UpdateConsentWarningSettingMutationVariables>(UpdateConsentWarningSettingDocument, options);
      }
export type UpdateConsentWarningSettingMutationHookResult = ReturnType<typeof useUpdateConsentWarningSettingMutation>;
export type UpdateConsentWarningSettingMutationResult = Apollo.MutationResult<UpdateConsentWarningSettingMutation>;
export type UpdateConsentWarningSettingMutationOptions = Apollo.BaseMutationOptions<UpdateConsentWarningSettingMutation, UpdateConsentWarningSettingMutationVariables>;
export const UpdateHideOnlineStatusDocument = gql`
    mutation UpdateHideOnlineStatus($hideOnlineStatus: Boolean!) {
  updatePrivacySettings(body: {hideOnlineStatus: $hideOnlineStatus}) {
    hideOnlineStatus
  }
}
    `;
export type UpdateHideOnlineStatusMutationFn = Apollo.MutationFunction<UpdateHideOnlineStatusMutation, UpdateHideOnlineStatusMutationVariables>;

/**
 * __useUpdateHideOnlineStatusMutation__
 *
 * To run a mutation, you first call `useUpdateHideOnlineStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateHideOnlineStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateHideOnlineStatusMutation, { data, loading, error }] = useUpdateHideOnlineStatusMutation({
 *   variables: {
 *      hideOnlineStatus: // value for 'hideOnlineStatus'
 *   },
 * });
 */
export function useUpdateHideOnlineStatusMutation(baseOptions?: Apollo.MutationHookOptions<UpdateHideOnlineStatusMutation, UpdateHideOnlineStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateHideOnlineStatusMutation, UpdateHideOnlineStatusMutationVariables>(UpdateHideOnlineStatusDocument, options);
      }
export type UpdateHideOnlineStatusMutationHookResult = ReturnType<typeof useUpdateHideOnlineStatusMutation>;
export type UpdateHideOnlineStatusMutationResult = Apollo.MutationResult<UpdateHideOnlineStatusMutation>;
export type UpdateHideOnlineStatusMutationOptions = Apollo.BaseMutationOptions<UpdateHideOnlineStatusMutation, UpdateHideOnlineStatusMutationVariables>;
export const UpdateMarketingConsentDocument = gql`
    mutation UpdateMarketingConsent($consent: AuthConsentStatus!) {
  updateMarketingConsent(marketingConsent: $consent) {
    emptyTypeWorkaround
  }
}
    `;
export type UpdateMarketingConsentMutationFn = Apollo.MutationFunction<UpdateMarketingConsentMutation, UpdateMarketingConsentMutationVariables>;

/**
 * __useUpdateMarketingConsentMutation__
 *
 * To run a mutation, you first call `useUpdateMarketingConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMarketingConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMarketingConsentMutation, { data, loading, error }] = useUpdateMarketingConsentMutation({
 *   variables: {
 *      consent: // value for 'consent'
 *   },
 * });
 */
export function useUpdateMarketingConsentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMarketingConsentMutation, UpdateMarketingConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateMarketingConsentMutation, UpdateMarketingConsentMutationVariables>(UpdateMarketingConsentDocument, options);
      }
export type UpdateMarketingConsentMutationHookResult = ReturnType<typeof useUpdateMarketingConsentMutation>;
export type UpdateMarketingConsentMutationResult = Apollo.MutationResult<UpdateMarketingConsentMutation>;
export type UpdateMarketingConsentMutationOptions = Apollo.BaseMutationOptions<UpdateMarketingConsentMutation, UpdateMarketingConsentMutationVariables>;
export const GetPushNotificationTokenDocument = gql`
    query GetPushNotificationToken($token: String!) {
  pushNotificationToken(token: $token) {
    token
  }
}
    `;

/**
 * __useGetPushNotificationTokenQuery__
 *
 * To run a query within a React component, call `useGetPushNotificationTokenQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPushNotificationTokenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPushNotificationTokenQuery({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useGetPushNotificationTokenQuery(baseOptions: Apollo.QueryHookOptions<GetPushNotificationTokenQuery, GetPushNotificationTokenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPushNotificationTokenQuery, GetPushNotificationTokenQueryVariables>(GetPushNotificationTokenDocument, options);
      }
export function useGetPushNotificationTokenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPushNotificationTokenQuery, GetPushNotificationTokenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPushNotificationTokenQuery, GetPushNotificationTokenQueryVariables>(GetPushNotificationTokenDocument, options);
        }
export type GetPushNotificationTokenQueryHookResult = ReturnType<typeof useGetPushNotificationTokenQuery>;
export type GetPushNotificationTokenLazyQueryHookResult = ReturnType<typeof useGetPushNotificationTokenLazyQuery>;
export type GetPushNotificationTokenQueryResult = Apollo.QueryResult<GetPushNotificationTokenQuery, GetPushNotificationTokenQueryVariables>;
export const AddPushNotificationTokenDocument = gql`
    mutation AddPushNotificationToken($token: String!) {
  addPushNotificationToken(
    token: $token
    tokenType: PUSH_NOTIFICATION_TOKEN_TYPE_FIREBASE
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type AddPushNotificationTokenMutationFn = Apollo.MutationFunction<AddPushNotificationTokenMutation, AddPushNotificationTokenMutationVariables>;

/**
 * __useAddPushNotificationTokenMutation__
 *
 * To run a mutation, you first call `useAddPushNotificationTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddPushNotificationTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addPushNotificationTokenMutation, { data, loading, error }] = useAddPushNotificationTokenMutation({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useAddPushNotificationTokenMutation(baseOptions?: Apollo.MutationHookOptions<AddPushNotificationTokenMutation, AddPushNotificationTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddPushNotificationTokenMutation, AddPushNotificationTokenMutationVariables>(AddPushNotificationTokenDocument, options);
      }
export type AddPushNotificationTokenMutationHookResult = ReturnType<typeof useAddPushNotificationTokenMutation>;
export type AddPushNotificationTokenMutationResult = Apollo.MutationResult<AddPushNotificationTokenMutation>;
export type AddPushNotificationTokenMutationOptions = Apollo.BaseMutationOptions<AddPushNotificationTokenMutation, AddPushNotificationTokenMutationVariables>;
export const DeletePushNotificationTokenDocument = gql`
    mutation DeletePushNotificationToken($token: String!) {
  deletePushNotificationToken(token: $token) {
    emptyTypeWorkaround
  }
}
    `;
export type DeletePushNotificationTokenMutationFn = Apollo.MutationFunction<DeletePushNotificationTokenMutation, DeletePushNotificationTokenMutationVariables>;

/**
 * __useDeletePushNotificationTokenMutation__
 *
 * To run a mutation, you first call `useDeletePushNotificationTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePushNotificationTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePushNotificationTokenMutation, { data, loading, error }] = useDeletePushNotificationTokenMutation({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useDeletePushNotificationTokenMutation(baseOptions?: Apollo.MutationHookOptions<DeletePushNotificationTokenMutation, DeletePushNotificationTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePushNotificationTokenMutation, DeletePushNotificationTokenMutationVariables>(DeletePushNotificationTokenDocument, options);
      }
export type DeletePushNotificationTokenMutationHookResult = ReturnType<typeof useDeletePushNotificationTokenMutation>;
export type DeletePushNotificationTokenMutationResult = Apollo.MutationResult<DeletePushNotificationTokenMutation>;
export type DeletePushNotificationTokenMutationOptions = Apollo.BaseMutationOptions<DeletePushNotificationTokenMutation, DeletePushNotificationTokenMutationVariables>;
export const MicroSurveyPlayerTraitsDocument = gql`
    query MicroSurveyPlayerTraits($userId: ID!) {
  profile(userId: $userId) {
    userId
    stats {
      adsWatched
      matchesPlayed
      timePlayed
      cardsPlayed
      cardsSucceeded
    }
    account {
      createdAt
      email
    }
  }
}
    `;

/**
 * __useMicroSurveyPlayerTraitsQuery__
 *
 * To run a query within a React component, call `useMicroSurveyPlayerTraitsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMicroSurveyPlayerTraitsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMicroSurveyPlayerTraitsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useMicroSurveyPlayerTraitsQuery(baseOptions: Apollo.QueryHookOptions<MicroSurveyPlayerTraitsQuery, MicroSurveyPlayerTraitsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MicroSurveyPlayerTraitsQuery, MicroSurveyPlayerTraitsQueryVariables>(MicroSurveyPlayerTraitsDocument, options);
      }
export function useMicroSurveyPlayerTraitsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MicroSurveyPlayerTraitsQuery, MicroSurveyPlayerTraitsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MicroSurveyPlayerTraitsQuery, MicroSurveyPlayerTraitsQueryVariables>(MicroSurveyPlayerTraitsDocument, options);
        }
export type MicroSurveyPlayerTraitsQueryHookResult = ReturnType<typeof useMicroSurveyPlayerTraitsQuery>;
export type MicroSurveyPlayerTraitsLazyQueryHookResult = ReturnType<typeof useMicroSurveyPlayerTraitsLazyQuery>;
export type MicroSurveyPlayerTraitsQueryResult = Apollo.QueryResult<MicroSurveyPlayerTraitsQuery, MicroSurveyPlayerTraitsQueryVariables>;
export const UseSelectedGameIdWithDefaultDocument = gql`
    query UseSelectedGameIdWithDefault($userId: ID!) {
  playedGames(userId: $userId) {
    games {
      userId
      id
      game {
        id
      }
    }
  }
}
    `;

/**
 * __useUseSelectedGameIdWithDefaultQuery__
 *
 * To run a query within a React component, call `useUseSelectedGameIdWithDefaultQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseSelectedGameIdWithDefaultQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseSelectedGameIdWithDefaultQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUseSelectedGameIdWithDefaultQuery(baseOptions: Apollo.QueryHookOptions<UseSelectedGameIdWithDefaultQuery, UseSelectedGameIdWithDefaultQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseSelectedGameIdWithDefaultQuery, UseSelectedGameIdWithDefaultQueryVariables>(UseSelectedGameIdWithDefaultDocument, options);
      }
export function useUseSelectedGameIdWithDefaultLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseSelectedGameIdWithDefaultQuery, UseSelectedGameIdWithDefaultQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseSelectedGameIdWithDefaultQuery, UseSelectedGameIdWithDefaultQueryVariables>(UseSelectedGameIdWithDefaultDocument, options);
        }
export type UseSelectedGameIdWithDefaultQueryHookResult = ReturnType<typeof useUseSelectedGameIdWithDefaultQuery>;
export type UseSelectedGameIdWithDefaultLazyQueryHookResult = ReturnType<typeof useUseSelectedGameIdWithDefaultLazyQuery>;
export type UseSelectedGameIdWithDefaultQueryResult = Apollo.QueryResult<UseSelectedGameIdWithDefaultQuery, UseSelectedGameIdWithDefaultQueryVariables>;
export const SelectedSeasonSeasonsDocument = gql`
    query SelectedSeasonSeasons($userId: ID!, $gameId: ID!) {
  listSeasonProgression(userId: $userId) {
    progression {
      season {
        ...SelectedSeasonsSeason
      }
    }
  }
  playedGames(userId: $userId) {
    games {
      userId
      id
      game {
        id
        activeSeason {
          ...SelectedSeasonsSeason
        }
      }
    }
  }
  game(id: $gameId) {
    id
    activeSeasonId
  }
}
    ${SelectedSeasonsSeasonFragmentDoc}`;

/**
 * __useSelectedSeasonSeasonsQuery__
 *
 * To run a query within a React component, call `useSelectedSeasonSeasonsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectedSeasonSeasonsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectedSeasonSeasonsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useSelectedSeasonSeasonsQuery(baseOptions: Apollo.QueryHookOptions<SelectedSeasonSeasonsQuery, SelectedSeasonSeasonsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectedSeasonSeasonsQuery, SelectedSeasonSeasonsQueryVariables>(SelectedSeasonSeasonsDocument, options);
      }
export function useSelectedSeasonSeasonsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectedSeasonSeasonsQuery, SelectedSeasonSeasonsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectedSeasonSeasonsQuery, SelectedSeasonSeasonsQueryVariables>(SelectedSeasonSeasonsDocument, options);
        }
export type SelectedSeasonSeasonsQueryHookResult = ReturnType<typeof useSelectedSeasonSeasonsQuery>;
export type SelectedSeasonSeasonsLazyQueryHookResult = ReturnType<typeof useSelectedSeasonSeasonsLazyQuery>;
export type SelectedSeasonSeasonsQueryResult = Apollo.QueryResult<SelectedSeasonSeasonsQuery, SelectedSeasonSeasonsQueryVariables>;
export const CreateChannelDocument = gql`
    mutation CreateChannel($channelName: String!) {
  createChannel(name: $channelName) {
    id
    name
  }
}
    `;
export type CreateChannelMutationFn = Apollo.MutationFunction<CreateChannelMutation, CreateChannelMutationVariables>;

/**
 * __useCreateChannelMutation__
 *
 * To run a mutation, you first call `useCreateChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createChannelMutation, { data, loading, error }] = useCreateChannelMutation({
 *   variables: {
 *      channelName: // value for 'channelName'
 *   },
 * });
 */
export function useCreateChannelMutation(baseOptions?: Apollo.MutationHookOptions<CreateChannelMutation, CreateChannelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateChannelMutation, CreateChannelMutationVariables>(CreateChannelDocument, options);
      }
export type CreateChannelMutationHookResult = ReturnType<typeof useCreateChannelMutation>;
export type CreateChannelMutationResult = Apollo.MutationResult<CreateChannelMutation>;
export type CreateChannelMutationOptions = Apollo.BaseMutationOptions<CreateChannelMutation, CreateChannelMutationVariables>;
export const NotificationAnnouncementsDocument = gql`
    query NotificationAnnouncements($userId: ID!) {
  userAnnouncements(userId: $userId, target: ANNOUNCEMENT_TARGET_WEB) {
    announcements {
      id
      ...NotificationAnnouncement
      ...PlatformAnnouncement
    }
  }
}
    ${NotificationAnnouncementFragmentDoc}
${PlatformAnnouncementFragmentDoc}`;

/**
 * __useNotificationAnnouncementsQuery__
 *
 * To run a query within a React component, call `useNotificationAnnouncementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationAnnouncementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationAnnouncementsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useNotificationAnnouncementsQuery(baseOptions: Apollo.QueryHookOptions<NotificationAnnouncementsQuery, NotificationAnnouncementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationAnnouncementsQuery, NotificationAnnouncementsQueryVariables>(NotificationAnnouncementsDocument, options);
      }
export function useNotificationAnnouncementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationAnnouncementsQuery, NotificationAnnouncementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationAnnouncementsQuery, NotificationAnnouncementsQueryVariables>(NotificationAnnouncementsDocument, options);
        }
export type NotificationAnnouncementsQueryHookResult = ReturnType<typeof useNotificationAnnouncementsQuery>;
export type NotificationAnnouncementsLazyQueryHookResult = ReturnType<typeof useNotificationAnnouncementsLazyQuery>;
export type NotificationAnnouncementsQueryResult = Apollo.QueryResult<NotificationAnnouncementsQuery, NotificationAnnouncementsQueryVariables>;
export const NotificationReceivedFriendRequestsDocument = gql`
    query NotificationReceivedFriendRequests($userId: ID!) {
  receivedFriendRequests(userId: $userId) {
    users {
      userId
      ...NotificationsTabFriendRequestFriendsUser
    }
  }
}
    ${NotificationsTabFriendRequestFriendsUserFragmentDoc}`;

/**
 * __useNotificationReceivedFriendRequestsQuery__
 *
 * To run a query within a React component, call `useNotificationReceivedFriendRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationReceivedFriendRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationReceivedFriendRequestsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useNotificationReceivedFriendRequestsQuery(baseOptions: Apollo.QueryHookOptions<NotificationReceivedFriendRequestsQuery, NotificationReceivedFriendRequestsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationReceivedFriendRequestsQuery, NotificationReceivedFriendRequestsQueryVariables>(NotificationReceivedFriendRequestsDocument, options);
      }
export function useNotificationReceivedFriendRequestsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationReceivedFriendRequestsQuery, NotificationReceivedFriendRequestsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationReceivedFriendRequestsQuery, NotificationReceivedFriendRequestsQueryVariables>(NotificationReceivedFriendRequestsDocument, options);
        }
export type NotificationReceivedFriendRequestsQueryHookResult = ReturnType<typeof useNotificationReceivedFriendRequestsQuery>;
export type NotificationReceivedFriendRequestsLazyQueryHookResult = ReturnType<typeof useNotificationReceivedFriendRequestsLazyQuery>;
export type NotificationReceivedFriendRequestsQueryResult = Apollo.QueryResult<NotificationReceivedFriendRequestsQuery, NotificationReceivedFriendRequestsQueryVariables>;
export const NotificationPaymentFailedSubscriptionsDocument = gql`
    query NotificationPaymentFailedSubscriptions($userId: ID!) {
  userChannelSubscriptions(userId: $userId, filters: [{paymentFailed: true}]) {
    subscriptions {
      id
      ...NotificationsTabSubscriptionPaymentFailedSubscription
    }
  }
}
    ${NotificationsTabSubscriptionPaymentFailedSubscriptionFragmentDoc}`;

/**
 * __useNotificationPaymentFailedSubscriptionsQuery__
 *
 * To run a query within a React component, call `useNotificationPaymentFailedSubscriptionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationPaymentFailedSubscriptionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationPaymentFailedSubscriptionsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useNotificationPaymentFailedSubscriptionsQuery(baseOptions: Apollo.QueryHookOptions<NotificationPaymentFailedSubscriptionsQuery, NotificationPaymentFailedSubscriptionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationPaymentFailedSubscriptionsQuery, NotificationPaymentFailedSubscriptionsQueryVariables>(NotificationPaymentFailedSubscriptionsDocument, options);
      }
export function useNotificationPaymentFailedSubscriptionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationPaymentFailedSubscriptionsQuery, NotificationPaymentFailedSubscriptionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationPaymentFailedSubscriptionsQuery, NotificationPaymentFailedSubscriptionsQueryVariables>(NotificationPaymentFailedSubscriptionsDocument, options);
        }
export type NotificationPaymentFailedSubscriptionsQueryHookResult = ReturnType<typeof useNotificationPaymentFailedSubscriptionsQuery>;
export type NotificationPaymentFailedSubscriptionsLazyQueryHookResult = ReturnType<typeof useNotificationPaymentFailedSubscriptionsLazyQuery>;
export type NotificationPaymentFailedSubscriptionsQueryResult = Apollo.QueryResult<NotificationPaymentFailedSubscriptionsQuery, NotificationPaymentFailedSubscriptionsQueryVariables>;
export const NotificationRewardsDocument = gql`
    query NotificationRewards($userId: ID!) {
  rewards(userId: $userId) {
    rewards {
      id
      ...NotificationReward
    }
  }
}
    ${NotificationRewardFragmentDoc}`;

/**
 * __useNotificationRewardsQuery__
 *
 * To run a query within a React component, call `useNotificationRewardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationRewardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationRewardsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useNotificationRewardsQuery(baseOptions: Apollo.QueryHookOptions<NotificationRewardsQuery, NotificationRewardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationRewardsQuery, NotificationRewardsQueryVariables>(NotificationRewardsDocument, options);
      }
export function useNotificationRewardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationRewardsQuery, NotificationRewardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationRewardsQuery, NotificationRewardsQueryVariables>(NotificationRewardsDocument, options);
        }
export type NotificationRewardsQueryHookResult = ReturnType<typeof useNotificationRewardsQuery>;
export type NotificationRewardsLazyQueryHookResult = ReturnType<typeof useNotificationRewardsLazyQuery>;
export type NotificationRewardsQueryResult = Apollo.QueryResult<NotificationRewardsQuery, NotificationRewardsQueryVariables>;
export const ProfileMenuQueryDocument = gql`
    query ProfileMenuQuery($userId: ID!, $isImplicitAccount: Boolean!) {
  profile(userId: $userId) {
    userId
    ...ProfileMenuProfileSectionProfile @skip(if: $isImplicitAccount)
    ...HideOnlineStatusSettingSectionProfile @skip(if: $isImplicitAccount)
    ...ProfileMenuImplicitAccountProfileSectionProfile @include(if: $isImplicitAccount)
    ...ProfileMenuLinksSectionProfile
    ...DebugMenuProfile
    ...ChannelButtonProfile
  }
  userPrivilegedChannels(userId: $userId) @skip(if: $isImplicitAccount) {
    channels {
      channelId
      roles
      channel {
        id
        ...ChannelButtonOwnChannel
      }
    }
  }
}
    ${ProfileMenuProfileSectionProfileFragmentDoc}
${HideOnlineStatusSettingSectionProfileFragmentDoc}
${ProfileMenuImplicitAccountProfileSectionProfileFragmentDoc}
${ProfileMenuLinksSectionProfileFragmentDoc}
${DebugMenuProfileFragmentDoc}
${ChannelButtonProfileFragmentDoc}
${ChannelButtonOwnChannelFragmentDoc}`;

/**
 * __useProfileMenuQueryQuery__
 *
 * To run a query within a React component, call `useProfileMenuQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileMenuQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileMenuQueryQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      isImplicitAccount: // value for 'isImplicitAccount'
 *   },
 * });
 */
export function useProfileMenuQueryQuery(baseOptions: Apollo.QueryHookOptions<ProfileMenuQueryQuery, ProfileMenuQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileMenuQueryQuery, ProfileMenuQueryQueryVariables>(ProfileMenuQueryDocument, options);
      }
export function useProfileMenuQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileMenuQueryQuery, ProfileMenuQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileMenuQueryQuery, ProfileMenuQueryQueryVariables>(ProfileMenuQueryDocument, options);
        }
export type ProfileMenuQueryQueryHookResult = ReturnType<typeof useProfileMenuQueryQuery>;
export type ProfileMenuQueryLazyQueryHookResult = ReturnType<typeof useProfileMenuQueryLazyQuery>;
export type ProfileMenuQueryQueryResult = Apollo.QueryResult<ProfileMenuQueryQuery, ProfileMenuQueryQueryVariables>;
export const TimeAdsRewardsDocument = gql`
    query TimeAdsRewards($placementId: ID!) {
  placement(placementId: $placementId) {
    placementId
    rewards {
      ...AvailableRewardsReward
    }
  }
}
    ${AvailableRewardsRewardFragmentDoc}`;

/**
 * __useTimeAdsRewardsQuery__
 *
 * To run a query within a React component, call `useTimeAdsRewardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTimeAdsRewardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTimeAdsRewardsQuery({
 *   variables: {
 *      placementId: // value for 'placementId'
 *   },
 * });
 */
export function useTimeAdsRewardsQuery(baseOptions: Apollo.QueryHookOptions<TimeAdsRewardsQuery, TimeAdsRewardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TimeAdsRewardsQuery, TimeAdsRewardsQueryVariables>(TimeAdsRewardsDocument, options);
      }
export function useTimeAdsRewardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TimeAdsRewardsQuery, TimeAdsRewardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TimeAdsRewardsQuery, TimeAdsRewardsQueryVariables>(TimeAdsRewardsDocument, options);
        }
export type TimeAdsRewardsQueryHookResult = ReturnType<typeof useTimeAdsRewardsQuery>;
export type TimeAdsRewardsLazyQueryHookResult = ReturnType<typeof useTimeAdsRewardsLazyQuery>;
export type TimeAdsRewardsQueryResult = Apollo.QueryResult<TimeAdsRewardsQuery, TimeAdsRewardsQueryVariables>;
export const UseDailyGoalsTooltipDataDocument = gql`
    query UseDailyGoalsTooltipData {
  goalCardSlots {
    slots {
      ...UseDailyGoalsTooltipDataSlot
    }
  }
}
    ${UseDailyGoalsTooltipDataSlotFragmentDoc}`;

/**
 * __useUseDailyGoalsTooltipDataQuery__
 *
 * To run a query within a React component, call `useUseDailyGoalsTooltipDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseDailyGoalsTooltipDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseDailyGoalsTooltipDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useUseDailyGoalsTooltipDataQuery(baseOptions?: Apollo.QueryHookOptions<UseDailyGoalsTooltipDataQuery, UseDailyGoalsTooltipDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseDailyGoalsTooltipDataQuery, UseDailyGoalsTooltipDataQueryVariables>(UseDailyGoalsTooltipDataDocument, options);
      }
export function useUseDailyGoalsTooltipDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseDailyGoalsTooltipDataQuery, UseDailyGoalsTooltipDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseDailyGoalsTooltipDataQuery, UseDailyGoalsTooltipDataQueryVariables>(UseDailyGoalsTooltipDataDocument, options);
        }
export type UseDailyGoalsTooltipDataQueryHookResult = ReturnType<typeof useUseDailyGoalsTooltipDataQuery>;
export type UseDailyGoalsTooltipDataLazyQueryHookResult = ReturnType<typeof useUseDailyGoalsTooltipDataLazyQuery>;
export type UseDailyGoalsTooltipDataQueryResult = Apollo.QueryResult<UseDailyGoalsTooltipDataQuery, UseDailyGoalsTooltipDataQueryVariables>;
export const StoreTooltipStoreFrontDocument = gql`
    query StoreTooltipStoreFront($gameId: ID!) {
  platformStoreFront(gameId: $gameId) {
    id
    gameId
    categories {
      id
      itemType
      sellableItems {
        id
        igcPrices {
          ...StoreTooltipSellableItemPrice
        }
        name
      }
    }
  }
}
    ${StoreTooltipSellableItemPriceFragmentDoc}`;

/**
 * __useStoreTooltipStoreFrontQuery__
 *
 * To run a query within a React component, call `useStoreTooltipStoreFrontQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoreTooltipStoreFrontQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoreTooltipStoreFrontQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useStoreTooltipStoreFrontQuery(baseOptions: Apollo.QueryHookOptions<StoreTooltipStoreFrontQuery, StoreTooltipStoreFrontQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoreTooltipStoreFrontQuery, StoreTooltipStoreFrontQueryVariables>(StoreTooltipStoreFrontDocument, options);
      }
export function useStoreTooltipStoreFrontLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoreTooltipStoreFrontQuery, StoreTooltipStoreFrontQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoreTooltipStoreFrontQuery, StoreTooltipStoreFrontQueryVariables>(StoreTooltipStoreFrontDocument, options);
        }
export type StoreTooltipStoreFrontQueryHookResult = ReturnType<typeof useStoreTooltipStoreFrontQuery>;
export type StoreTooltipStoreFrontLazyQueryHookResult = ReturnType<typeof useStoreTooltipStoreFrontLazyQuery>;
export type StoreTooltipStoreFrontQueryResult = Apollo.QueryResult<StoreTooltipStoreFrontQuery, StoreTooltipStoreFrontQueryVariables>;
export const UseShouldVisitDailyGoalsGoalCardSlotsDocument = gql`
    query UseShouldVisitDailyGoalsGoalCardSlots {
  goalCardSlots {
    slots {
      id
      ...GoalCardSlotStateGoalCardSlot
      ...GoalCardSlotResetTimePastGoalCardSlot
    }
  }
}
    ${GoalCardSlotStateGoalCardSlotFragmentDoc}
${GoalCardSlotResetTimePastGoalCardSlotFragmentDoc}`;

/**
 * __useUseShouldVisitDailyGoalsGoalCardSlotsQuery__
 *
 * To run a query within a React component, call `useUseShouldVisitDailyGoalsGoalCardSlotsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseShouldVisitDailyGoalsGoalCardSlotsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseShouldVisitDailyGoalsGoalCardSlotsQuery({
 *   variables: {
 *   },
 * });
 */
export function useUseShouldVisitDailyGoalsGoalCardSlotsQuery(baseOptions?: Apollo.QueryHookOptions<UseShouldVisitDailyGoalsGoalCardSlotsQuery, UseShouldVisitDailyGoalsGoalCardSlotsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseShouldVisitDailyGoalsGoalCardSlotsQuery, UseShouldVisitDailyGoalsGoalCardSlotsQueryVariables>(UseShouldVisitDailyGoalsGoalCardSlotsDocument, options);
      }
export function useUseShouldVisitDailyGoalsGoalCardSlotsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseShouldVisitDailyGoalsGoalCardSlotsQuery, UseShouldVisitDailyGoalsGoalCardSlotsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseShouldVisitDailyGoalsGoalCardSlotsQuery, UseShouldVisitDailyGoalsGoalCardSlotsQueryVariables>(UseShouldVisitDailyGoalsGoalCardSlotsDocument, options);
        }
export type UseShouldVisitDailyGoalsGoalCardSlotsQueryHookResult = ReturnType<typeof useUseShouldVisitDailyGoalsGoalCardSlotsQuery>;
export type UseShouldVisitDailyGoalsGoalCardSlotsLazyQueryHookResult = ReturnType<typeof useUseShouldVisitDailyGoalsGoalCardSlotsLazyQuery>;
export type UseShouldVisitDailyGoalsGoalCardSlotsQueryResult = Apollo.QueryResult<UseShouldVisitDailyGoalsGoalCardSlotsQuery, UseShouldVisitDailyGoalsGoalCardSlotsQueryVariables>;
export const SidebarFollowedChannelsDocument = gql`
    query SidebarFollowedChannels($userId: ID!, $cursor: String, $pageSize: Int = 5) {
  followedChannels(userId: $userId, cursor: {first: $pageSize, after: $cursor}) @connection(key: "sidebar") {
    pageInfo {
      endCursor
      hasNextPage
    }
    channels {
      id
      ...SidebarChannel
    }
  }
}
    ${SidebarChannelFragmentDoc}`;

/**
 * __useSidebarFollowedChannelsQuery__
 *
 * To run a query within a React component, call `useSidebarFollowedChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSidebarFollowedChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSidebarFollowedChannelsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useSidebarFollowedChannelsQuery(baseOptions: Apollo.QueryHookOptions<SidebarFollowedChannelsQuery, SidebarFollowedChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SidebarFollowedChannelsQuery, SidebarFollowedChannelsQueryVariables>(SidebarFollowedChannelsDocument, options);
      }
export function useSidebarFollowedChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SidebarFollowedChannelsQuery, SidebarFollowedChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SidebarFollowedChannelsQuery, SidebarFollowedChannelsQueryVariables>(SidebarFollowedChannelsDocument, options);
        }
export type SidebarFollowedChannelsQueryHookResult = ReturnType<typeof useSidebarFollowedChannelsQuery>;
export type SidebarFollowedChannelsLazyQueryHookResult = ReturnType<typeof useSidebarFollowedChannelsLazyQuery>;
export type SidebarFollowedChannelsQueryResult = Apollo.QueryResult<SidebarFollowedChannelsQuery, SidebarFollowedChannelsQueryVariables>;
export const SidebarRecommendedChannelsDocument = gql`
    query SidebarRecommendedChannels {
  channels(liveStatus: LIVE_STATUS_LIVE, cursor: {first: 5}) @connection(key: "sidebar") {
    channels {
      id
      ...SidebarChannel
    }
  }
}
    ${SidebarChannelFragmentDoc}`;

/**
 * __useSidebarRecommendedChannelsQuery__
 *
 * To run a query within a React component, call `useSidebarRecommendedChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSidebarRecommendedChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSidebarRecommendedChannelsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSidebarRecommendedChannelsQuery(baseOptions?: Apollo.QueryHookOptions<SidebarRecommendedChannelsQuery, SidebarRecommendedChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SidebarRecommendedChannelsQuery, SidebarRecommendedChannelsQueryVariables>(SidebarRecommendedChannelsDocument, options);
      }
export function useSidebarRecommendedChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SidebarRecommendedChannelsQuery, SidebarRecommendedChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SidebarRecommendedChannelsQuery, SidebarRecommendedChannelsQueryVariables>(SidebarRecommendedChannelsDocument, options);
        }
export type SidebarRecommendedChannelsQueryHookResult = ReturnType<typeof useSidebarRecommendedChannelsQuery>;
export type SidebarRecommendedChannelsLazyQueryHookResult = ReturnType<typeof useSidebarRecommendedChannelsLazyQuery>;
export type SidebarRecommendedChannelsQueryResult = Apollo.QueryResult<SidebarRecommendedChannelsQuery, SidebarRecommendedChannelsQueryVariables>;
export const AccountStateDocument = gql`
    query AccountState($userId: ID) {
  profile(userId: $userId) {
    userId
    account {
      uid
      state
      flags
    }
  }
}
    `;

/**
 * __useAccountStateQuery__
 *
 * To run a query within a React component, call `useAccountStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountStateQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useAccountStateQuery(baseOptions?: Apollo.QueryHookOptions<AccountStateQuery, AccountStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccountStateQuery, AccountStateQueryVariables>(AccountStateDocument, options);
      }
export function useAccountStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountStateQuery, AccountStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccountStateQuery, AccountStateQueryVariables>(AccountStateDocument, options);
        }
export type AccountStateQueryHookResult = ReturnType<typeof useAccountStateQuery>;
export type AccountStateLazyQueryHookResult = ReturnType<typeof useAccountStateLazyQuery>;
export type AccountStateQueryResult = Apollo.QueryResult<AccountStateQuery, AccountStateQueryVariables>;
export const CancelUserDeletionDocument = gql`
    mutation CancelUserDeletion {
  cancelDataDeletion {
    emptyTypeWorkaround
  }
}
    `;
export type CancelUserDeletionMutationFn = Apollo.MutationFunction<CancelUserDeletionMutation, CancelUserDeletionMutationVariables>;

/**
 * __useCancelUserDeletionMutation__
 *
 * To run a mutation, you first call `useCancelUserDeletionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCancelUserDeletionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cancelUserDeletionMutation, { data, loading, error }] = useCancelUserDeletionMutation({
 *   variables: {
 *   },
 * });
 */
export function useCancelUserDeletionMutation(baseOptions?: Apollo.MutationHookOptions<CancelUserDeletionMutation, CancelUserDeletionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CancelUserDeletionMutation, CancelUserDeletionMutationVariables>(CancelUserDeletionDocument, options);
      }
export type CancelUserDeletionMutationHookResult = ReturnType<typeof useCancelUserDeletionMutation>;
export type CancelUserDeletionMutationResult = Apollo.MutationResult<CancelUserDeletionMutation>;
export type CancelUserDeletionMutationOptions = Apollo.BaseMutationOptions<CancelUserDeletionMutation, CancelUserDeletionMutationVariables>;
export const AvatarSetupProfileDocument = gql`
    query AvatarSetupProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    avatars {
      avatar2D
    }
  }
}
    `;

/**
 * __useAvatarSetupProfileQuery__
 *
 * To run a query within a React component, call `useAvatarSetupProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useAvatarSetupProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAvatarSetupProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useAvatarSetupProfileQuery(baseOptions: Apollo.QueryHookOptions<AvatarSetupProfileQuery, AvatarSetupProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AvatarSetupProfileQuery, AvatarSetupProfileQueryVariables>(AvatarSetupProfileDocument, options);
      }
export function useAvatarSetupProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AvatarSetupProfileQuery, AvatarSetupProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AvatarSetupProfileQuery, AvatarSetupProfileQueryVariables>(AvatarSetupProfileDocument, options);
        }
export type AvatarSetupProfileQueryHookResult = ReturnType<typeof useAvatarSetupProfileQuery>;
export type AvatarSetupProfileLazyQueryHookResult = ReturnType<typeof useAvatarSetupProfileLazyQuery>;
export type AvatarSetupProfileQueryResult = Apollo.QueryResult<AvatarSetupProfileQuery, AvatarSetupProfileQueryVariables>;
export const UseAvatarSelectorAvatarsDocument = gql`
    query UseAvatarSelectorAvatars {
  avatars {
    avatars {
      ...UseAvatarSelectorAvatar
    }
  }
}
    ${UseAvatarSelectorAvatarFragmentDoc}`;

/**
 * __useUseAvatarSelectorAvatarsQuery__
 *
 * To run a query within a React component, call `useUseAvatarSelectorAvatarsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseAvatarSelectorAvatarsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseAvatarSelectorAvatarsQuery({
 *   variables: {
 *   },
 * });
 */
export function useUseAvatarSelectorAvatarsQuery(baseOptions?: Apollo.QueryHookOptions<UseAvatarSelectorAvatarsQuery, UseAvatarSelectorAvatarsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseAvatarSelectorAvatarsQuery, UseAvatarSelectorAvatarsQueryVariables>(UseAvatarSelectorAvatarsDocument, options);
      }
export function useUseAvatarSelectorAvatarsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseAvatarSelectorAvatarsQuery, UseAvatarSelectorAvatarsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseAvatarSelectorAvatarsQuery, UseAvatarSelectorAvatarsQueryVariables>(UseAvatarSelectorAvatarsDocument, options);
        }
export type UseAvatarSelectorAvatarsQueryHookResult = ReturnType<typeof useUseAvatarSelectorAvatarsQuery>;
export type UseAvatarSelectorAvatarsLazyQueryHookResult = ReturnType<typeof useUseAvatarSelectorAvatarsLazyQuery>;
export type UseAvatarSelectorAvatarsQueryResult = Apollo.QueryResult<UseAvatarSelectorAvatarsQuery, UseAvatarSelectorAvatarsQueryVariables>;
export const SetBirthdayProfileDocument = gql`
    query SetBirthdayProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      uid
      birthday {
        day
        month
        year
      }
    }
  }
}
    `;

/**
 * __useSetBirthdayProfileQuery__
 *
 * To run a query within a React component, call `useSetBirthdayProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useSetBirthdayProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSetBirthdayProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSetBirthdayProfileQuery(baseOptions: Apollo.QueryHookOptions<SetBirthdayProfileQuery, SetBirthdayProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SetBirthdayProfileQuery, SetBirthdayProfileQueryVariables>(SetBirthdayProfileDocument, options);
      }
export function useSetBirthdayProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SetBirthdayProfileQuery, SetBirthdayProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SetBirthdayProfileQuery, SetBirthdayProfileQueryVariables>(SetBirthdayProfileDocument, options);
        }
export type SetBirthdayProfileQueryHookResult = ReturnType<typeof useSetBirthdayProfileQuery>;
export type SetBirthdayProfileLazyQueryHookResult = ReturnType<typeof useSetBirthdayProfileLazyQuery>;
export type SetBirthdayProfileQueryResult = Apollo.QueryResult<SetBirthdayProfileQuery, SetBirthdayProfileQueryVariables>;
export const SetBirthdayDocument = gql`
    mutation SetBirthday($day: Int!, $month: Int!, $year: Int!) {
  setBirthday(birthday: {day: $day, month: $month, year: $year}) {
    emptyTypeWorkaround
  }
}
    `;
export type SetBirthdayMutationFn = Apollo.MutationFunction<SetBirthdayMutation, SetBirthdayMutationVariables>;

/**
 * __useSetBirthdayMutation__
 *
 * To run a mutation, you first call `useSetBirthdayMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetBirthdayMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setBirthdayMutation, { data, loading, error }] = useSetBirthdayMutation({
 *   variables: {
 *      day: // value for 'day'
 *      month: // value for 'month'
 *      year: // value for 'year'
 *   },
 * });
 */
export function useSetBirthdayMutation(baseOptions?: Apollo.MutationHookOptions<SetBirthdayMutation, SetBirthdayMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetBirthdayMutation, SetBirthdayMutationVariables>(SetBirthdayDocument, options);
      }
export type SetBirthdayMutationHookResult = ReturnType<typeof useSetBirthdayMutation>;
export type SetBirthdayMutationResult = Apollo.MutationResult<SetBirthdayMutation>;
export type SetBirthdayMutationOptions = Apollo.BaseMutationOptions<SetBirthdayMutation, SetBirthdayMutationVariables>;
export const AvatarEditorProfileDocument = gql`
    query AvatarEditorProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    avatarConfig {
      modelId
    }
  }
}
    `;

/**
 * __useAvatarEditorProfileQuery__
 *
 * To run a query within a React component, call `useAvatarEditorProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useAvatarEditorProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAvatarEditorProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useAvatarEditorProfileQuery(baseOptions: Apollo.QueryHookOptions<AvatarEditorProfileQuery, AvatarEditorProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AvatarEditorProfileQuery, AvatarEditorProfileQueryVariables>(AvatarEditorProfileDocument, options);
      }
export function useAvatarEditorProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AvatarEditorProfileQuery, AvatarEditorProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AvatarEditorProfileQuery, AvatarEditorProfileQueryVariables>(AvatarEditorProfileDocument, options);
        }
export type AvatarEditorProfileQueryHookResult = ReturnType<typeof useAvatarEditorProfileQuery>;
export type AvatarEditorProfileLazyQueryHookResult = ReturnType<typeof useAvatarEditorProfileLazyQuery>;
export type AvatarEditorProfileQueryResult = Apollo.QueryResult<AvatarEditorProfileQuery, AvatarEditorProfileQueryVariables>;
export const BrowseCategoriesDocument = gql`
    query BrowseCategories($cursor: String) {
  channelGameStats(cursor: {first: 21, after: $cursor}) {
    pageInfo {
      hasNextPage
      endCursor
    }
    games {
      gameId
      ...CategoryLinkGameStats
    }
  }
}
    ${CategoryLinkGameStatsFragmentDoc}`;

/**
 * __useBrowseCategoriesQuery__
 *
 * To run a query within a React component, call `useBrowseCategoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useBrowseCategoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBrowseCategoriesQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useBrowseCategoriesQuery(baseOptions?: Apollo.QueryHookOptions<BrowseCategoriesQuery, BrowseCategoriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BrowseCategoriesQuery, BrowseCategoriesQueryVariables>(BrowseCategoriesDocument, options);
      }
export function useBrowseCategoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BrowseCategoriesQuery, BrowseCategoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BrowseCategoriesQuery, BrowseCategoriesQueryVariables>(BrowseCategoriesDocument, options);
        }
export type BrowseCategoriesQueryHookResult = ReturnType<typeof useBrowseCategoriesQuery>;
export type BrowseCategoriesLazyQueryHookResult = ReturnType<typeof useBrowseCategoriesLazyQuery>;
export type BrowseCategoriesQueryResult = Apollo.QueryResult<BrowseCategoriesQuery, BrowseCategoriesQueryVariables>;
export const BrowseCategoryDocument = gql`
    query BrowseCategory($categoryId: ID!) {
  game(id: $categoryId) {
    id
    name
  }
}
    `;

/**
 * __useBrowseCategoryQuery__
 *
 * To run a query within a React component, call `useBrowseCategoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useBrowseCategoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBrowseCategoryQuery({
 *   variables: {
 *      categoryId: // value for 'categoryId'
 *   },
 * });
 */
export function useBrowseCategoryQuery(baseOptions: Apollo.QueryHookOptions<BrowseCategoryQuery, BrowseCategoryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BrowseCategoryQuery, BrowseCategoryQueryVariables>(BrowseCategoryDocument, options);
      }
export function useBrowseCategoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BrowseCategoryQuery, BrowseCategoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BrowseCategoryQuery, BrowseCategoryQueryVariables>(BrowseCategoryDocument, options);
        }
export type BrowseCategoryQueryHookResult = ReturnType<typeof useBrowseCategoryQuery>;
export type BrowseCategoryLazyQueryHookResult = ReturnType<typeof useBrowseCategoryLazyQuery>;
export type BrowseCategoryQueryResult = Apollo.QueryResult<BrowseCategoryQuery, BrowseCategoryQueryVariables>;
export const BrowseCategoryChannelsDocument = gql`
    query BrowseCategoryChannels($categoryId: ID!, $cursor: String, $skipUserFields: Boolean = false) {
  channels(
    liveStatus: LIVE_STATUS_LIVE
    gameId: $categoryId
    cursor: {first: 16, after: $cursor}
  ) {
    pageInfo {
      endCursor
      hasNextPage
    }
    channels {
      id
      ...ChannelListPageChannelsChannel
    }
  }
}
    ${ChannelListPageChannelsChannelFragmentDoc}`;

/**
 * __useBrowseCategoryChannelsQuery__
 *
 * To run a query within a React component, call `useBrowseCategoryChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBrowseCategoryChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBrowseCategoryChannelsQuery({
 *   variables: {
 *      categoryId: // value for 'categoryId'
 *      cursor: // value for 'cursor'
 *      skipUserFields: // value for 'skipUserFields'
 *   },
 * });
 */
export function useBrowseCategoryChannelsQuery(baseOptions: Apollo.QueryHookOptions<BrowseCategoryChannelsQuery, BrowseCategoryChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BrowseCategoryChannelsQuery, BrowseCategoryChannelsQueryVariables>(BrowseCategoryChannelsDocument, options);
      }
export function useBrowseCategoryChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BrowseCategoryChannelsQuery, BrowseCategoryChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BrowseCategoryChannelsQuery, BrowseCategoryChannelsQueryVariables>(BrowseCategoryChannelsDocument, options);
        }
export type BrowseCategoryChannelsQueryHookResult = ReturnType<typeof useBrowseCategoryChannelsQuery>;
export type BrowseCategoryChannelsLazyQueryHookResult = ReturnType<typeof useBrowseCategoryChannelsLazyQuery>;
export type BrowseCategoryChannelsQueryResult = Apollo.QueryResult<BrowseCategoryChannelsQuery, BrowseCategoryChannelsQueryVariables>;
export const BrowseCategoryOfflineChannelsDocument = gql`
    query BrowseCategoryOfflineChannels($categoryId: ID!, $cursor: String) {
  channels(
    liveStatus: LIVE_STATUS_OFFLINE
    gameId: $categoryId
    cursor: {first: 16, after: $cursor}
  ) {
    pageInfo {
      endCursor
      hasNextPage
    }
    channels {
      id
      ...ChannelListPageChannelsOfflineChannel
    }
  }
}
    ${ChannelListPageChannelsOfflineChannelFragmentDoc}`;

/**
 * __useBrowseCategoryOfflineChannelsQuery__
 *
 * To run a query within a React component, call `useBrowseCategoryOfflineChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBrowseCategoryOfflineChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBrowseCategoryOfflineChannelsQuery({
 *   variables: {
 *      categoryId: // value for 'categoryId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useBrowseCategoryOfflineChannelsQuery(baseOptions: Apollo.QueryHookOptions<BrowseCategoryOfflineChannelsQuery, BrowseCategoryOfflineChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BrowseCategoryOfflineChannelsQuery, BrowseCategoryOfflineChannelsQueryVariables>(BrowseCategoryOfflineChannelsDocument, options);
      }
export function useBrowseCategoryOfflineChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BrowseCategoryOfflineChannelsQuery, BrowseCategoryOfflineChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BrowseCategoryOfflineChannelsQuery, BrowseCategoryOfflineChannelsQueryVariables>(BrowseCategoryOfflineChannelsDocument, options);
        }
export type BrowseCategoryOfflineChannelsQueryHookResult = ReturnType<typeof useBrowseCategoryOfflineChannelsQuery>;
export type BrowseCategoryOfflineChannelsLazyQueryHookResult = ReturnType<typeof useBrowseCategoryOfflineChannelsLazyQuery>;
export type BrowseCategoryOfflineChannelsQueryResult = Apollo.QueryResult<BrowseCategoryOfflineChannelsQuery, BrowseCategoryOfflineChannelsQueryVariables>;
export const BrowseChannelsHighlightedChannelsDocument = gql`
    query BrowseChannelsHighlightedChannels($skipUserFields: Boolean = false) {
  highlightedChannels(limit: 3) {
    channels {
      id
      ...LiveChannelPreviewChannel
    }
  }
}
    ${LiveChannelPreviewChannelFragmentDoc}`;

/**
 * __useBrowseChannelsHighlightedChannelsQuery__
 *
 * To run a query within a React component, call `useBrowseChannelsHighlightedChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBrowseChannelsHighlightedChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBrowseChannelsHighlightedChannelsQuery({
 *   variables: {
 *      skipUserFields: // value for 'skipUserFields'
 *   },
 * });
 */
export function useBrowseChannelsHighlightedChannelsQuery(baseOptions?: Apollo.QueryHookOptions<BrowseChannelsHighlightedChannelsQuery, BrowseChannelsHighlightedChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BrowseChannelsHighlightedChannelsQuery, BrowseChannelsHighlightedChannelsQueryVariables>(BrowseChannelsHighlightedChannelsDocument, options);
      }
export function useBrowseChannelsHighlightedChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BrowseChannelsHighlightedChannelsQuery, BrowseChannelsHighlightedChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BrowseChannelsHighlightedChannelsQuery, BrowseChannelsHighlightedChannelsQueryVariables>(BrowseChannelsHighlightedChannelsDocument, options);
        }
export type BrowseChannelsHighlightedChannelsQueryHookResult = ReturnType<typeof useBrowseChannelsHighlightedChannelsQuery>;
export type BrowseChannelsHighlightedChannelsLazyQueryHookResult = ReturnType<typeof useBrowseChannelsHighlightedChannelsLazyQuery>;
export type BrowseChannelsHighlightedChannelsQueryResult = Apollo.QueryResult<BrowseChannelsHighlightedChannelsQuery, BrowseChannelsHighlightedChannelsQueryVariables>;
export const BrowseChannelsLiveChannelsDocument = gql`
    query BrowseChannelsLiveChannels($cursor: String, $skipUserFields: Boolean = false) {
  channels(liveStatus: LIVE_STATUS_LIVE, cursor: {first: 16, after: $cursor}) {
    pageInfo {
      endCursor
      hasNextPage
    }
    channels {
      id
      ...LiveChannelPreviewChannel
    }
  }
}
    ${LiveChannelPreviewChannelFragmentDoc}`;

/**
 * __useBrowseChannelsLiveChannelsQuery__
 *
 * To run a query within a React component, call `useBrowseChannelsLiveChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBrowseChannelsLiveChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBrowseChannelsLiveChannelsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      skipUserFields: // value for 'skipUserFields'
 *   },
 * });
 */
export function useBrowseChannelsLiveChannelsQuery(baseOptions?: Apollo.QueryHookOptions<BrowseChannelsLiveChannelsQuery, BrowseChannelsLiveChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BrowseChannelsLiveChannelsQuery, BrowseChannelsLiveChannelsQueryVariables>(BrowseChannelsLiveChannelsDocument, options);
      }
export function useBrowseChannelsLiveChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BrowseChannelsLiveChannelsQuery, BrowseChannelsLiveChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BrowseChannelsLiveChannelsQuery, BrowseChannelsLiveChannelsQueryVariables>(BrowseChannelsLiveChannelsDocument, options);
        }
export type BrowseChannelsLiveChannelsQueryHookResult = ReturnType<typeof useBrowseChannelsLiveChannelsQuery>;
export type BrowseChannelsLiveChannelsLazyQueryHookResult = ReturnType<typeof useBrowseChannelsLiveChannelsLazyQuery>;
export type BrowseChannelsLiveChannelsQueryResult = Apollo.QueryResult<BrowseChannelsLiveChannelsQuery, BrowseChannelsLiveChannelsQueryVariables>;
export const BrowseChannelsGameSelectorDocument = gql`
    query BrowseChannelsGameSelector {
  listGames {
    games {
      ...BrowseChannelsGame
    }
  }
}
    ${BrowseChannelsGameFragmentDoc}`;

/**
 * __useBrowseChannelsGameSelectorQuery__
 *
 * To run a query within a React component, call `useBrowseChannelsGameSelectorQuery` and pass it any options that fit your needs.
 * When your component renders, `useBrowseChannelsGameSelectorQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBrowseChannelsGameSelectorQuery({
 *   variables: {
 *   },
 * });
 */
export function useBrowseChannelsGameSelectorQuery(baseOptions?: Apollo.QueryHookOptions<BrowseChannelsGameSelectorQuery, BrowseChannelsGameSelectorQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BrowseChannelsGameSelectorQuery, BrowseChannelsGameSelectorQueryVariables>(BrowseChannelsGameSelectorDocument, options);
      }
export function useBrowseChannelsGameSelectorLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BrowseChannelsGameSelectorQuery, BrowseChannelsGameSelectorQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BrowseChannelsGameSelectorQuery, BrowseChannelsGameSelectorQueryVariables>(BrowseChannelsGameSelectorDocument, options);
        }
export type BrowseChannelsGameSelectorQueryHookResult = ReturnType<typeof useBrowseChannelsGameSelectorQuery>;
export type BrowseChannelsGameSelectorLazyQueryHookResult = ReturnType<typeof useBrowseChannelsGameSelectorLazyQuery>;
export type BrowseChannelsGameSelectorQueryResult = Apollo.QueryResult<BrowseChannelsGameSelectorQuery, BrowseChannelsGameSelectorQueryVariables>;
export const BrowseHighlightedChannelsDocument = gql`
    query BrowseHighlightedChannels($gameId: ID, $skipUserFields: Boolean = false) {
  highlightedChannels(limit: 3, gameId: $gameId) {
    channels {
      id
      ...LiveChannelPreviewChannel
    }
  }
}
    ${LiveChannelPreviewChannelFragmentDoc}`;

/**
 * __useBrowseHighlightedChannelsQuery__
 *
 * To run a query within a React component, call `useBrowseHighlightedChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBrowseHighlightedChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBrowseHighlightedChannelsQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      skipUserFields: // value for 'skipUserFields'
 *   },
 * });
 */
export function useBrowseHighlightedChannelsQuery(baseOptions?: Apollo.QueryHookOptions<BrowseHighlightedChannelsQuery, BrowseHighlightedChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BrowseHighlightedChannelsQuery, BrowseHighlightedChannelsQueryVariables>(BrowseHighlightedChannelsDocument, options);
      }
export function useBrowseHighlightedChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BrowseHighlightedChannelsQuery, BrowseHighlightedChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BrowseHighlightedChannelsQuery, BrowseHighlightedChannelsQueryVariables>(BrowseHighlightedChannelsDocument, options);
        }
export type BrowseHighlightedChannelsQueryHookResult = ReturnType<typeof useBrowseHighlightedChannelsQuery>;
export type BrowseHighlightedChannelsLazyQueryHookResult = ReturnType<typeof useBrowseHighlightedChannelsLazyQuery>;
export type BrowseHighlightedChannelsQueryResult = Apollo.QueryResult<BrowseHighlightedChannelsQuery, BrowseHighlightedChannelsQueryVariables>;
export const BrowseLiveChannelsDocument = gql`
    query BrowseLiveChannels($cursor: String, $pageSize: Int, $gameId: ID, $skipUserFields: Boolean = false) {
  channels(
    liveStatus: LIVE_STATUS_LIVE
    cursor: {first: $pageSize, after: $cursor}
    gameId: $gameId
  ) {
    pageInfo {
      endCursor
      hasNextPage
    }
    channels {
      id
      ...LiveChannelPreviewChannel
    }
  }
}
    ${LiveChannelPreviewChannelFragmentDoc}`;

/**
 * __useBrowseLiveChannelsQuery__
 *
 * To run a query within a React component, call `useBrowseLiveChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBrowseLiveChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBrowseLiveChannelsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      pageSize: // value for 'pageSize'
 *      gameId: // value for 'gameId'
 *      skipUserFields: // value for 'skipUserFields'
 *   },
 * });
 */
export function useBrowseLiveChannelsQuery(baseOptions?: Apollo.QueryHookOptions<BrowseLiveChannelsQuery, BrowseLiveChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BrowseLiveChannelsQuery, BrowseLiveChannelsQueryVariables>(BrowseLiveChannelsDocument, options);
      }
export function useBrowseLiveChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BrowseLiveChannelsQuery, BrowseLiveChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BrowseLiveChannelsQuery, BrowseLiveChannelsQueryVariables>(BrowseLiveChannelsDocument, options);
        }
export type BrowseLiveChannelsQueryHookResult = ReturnType<typeof useBrowseLiveChannelsQuery>;
export type BrowseLiveChannelsLazyQueryHookResult = ReturnType<typeof useBrowseLiveChannelsLazyQuery>;
export type BrowseLiveChannelsQueryResult = Apollo.QueryResult<BrowseLiveChannelsQuery, BrowseLiveChannelsQueryVariables>;
export const BrowseOfflineChannelsDocument = gql`
    query BrowseOfflineChannels($cursor: String, $pageSize: Int, $gameId: ID) {
  channels(
    liveStatus: LIVE_STATUS_OFFLINE
    cursor: {first: $pageSize, after: $cursor}
    gameId: $gameId
  ) {
    pageInfo {
      endCursor
      hasNextPage
    }
    channels {
      id
      ...OfflineChannelLinkChannel
    }
  }
}
    ${OfflineChannelLinkChannelFragmentDoc}`;

/**
 * __useBrowseOfflineChannelsQuery__
 *
 * To run a query within a React component, call `useBrowseOfflineChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBrowseOfflineChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBrowseOfflineChannelsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      pageSize: // value for 'pageSize'
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useBrowseOfflineChannelsQuery(baseOptions?: Apollo.QueryHookOptions<BrowseOfflineChannelsQuery, BrowseOfflineChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BrowseOfflineChannelsQuery, BrowseOfflineChannelsQueryVariables>(BrowseOfflineChannelsDocument, options);
      }
export function useBrowseOfflineChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BrowseOfflineChannelsQuery, BrowseOfflineChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BrowseOfflineChannelsQuery, BrowseOfflineChannelsQueryVariables>(BrowseOfflineChannelsDocument, options);
        }
export type BrowseOfflineChannelsQueryHookResult = ReturnType<typeof useBrowseOfflineChannelsQuery>;
export type BrowseOfflineChannelsLazyQueryHookResult = ReturnType<typeof useBrowseOfflineChannelsLazyQuery>;
export type BrowseOfflineChannelsQueryResult = Apollo.QueryResult<BrowseOfflineChannelsQuery, BrowseOfflineChannelsQueryVariables>;
export const ChannelPageEntryChannelDocument = gql`
    query ChannelPageEntryChannel($channelName: String!, $skipAuthFields: Boolean!) {
  channelByName(name: $channelName) {
    id
    name
    currentStreamId
    userBanStatus @skip(if: $skipAuthFields) {
      banned
    }
    liveStatus
    ...ChannelStreamStateChannel
    ...ChannelStreamAutoJoinChannel
  }
}
    ${ChannelStreamStateChannelFragmentDoc}
${ChannelStreamAutoJoinChannelFragmentDoc}`;

/**
 * __useChannelPageEntryChannelQuery__
 *
 * To run a query within a React component, call `useChannelPageEntryChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelPageEntryChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelPageEntryChannelQuery({
 *   variables: {
 *      channelName: // value for 'channelName'
 *      skipAuthFields: // value for 'skipAuthFields'
 *   },
 * });
 */
export function useChannelPageEntryChannelQuery(baseOptions: Apollo.QueryHookOptions<ChannelPageEntryChannelQuery, ChannelPageEntryChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelPageEntryChannelQuery, ChannelPageEntryChannelQueryVariables>(ChannelPageEntryChannelDocument, options);
      }
export function useChannelPageEntryChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelPageEntryChannelQuery, ChannelPageEntryChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelPageEntryChannelQuery, ChannelPageEntryChannelQueryVariables>(ChannelPageEntryChannelDocument, options);
        }
export type ChannelPageEntryChannelQueryHookResult = ReturnType<typeof useChannelPageEntryChannelQuery>;
export type ChannelPageEntryChannelLazyQueryHookResult = ReturnType<typeof useChannelPageEntryChannelLazyQuery>;
export type ChannelPageEntryChannelQueryResult = Apollo.QueryResult<ChannelPageEntryChannelQuery, ChannelPageEntryChannelQueryVariables>;
export const ChannelPageChannelDocument = gql`
    query ChannelPageChannel($channelId: ID!, $skipAuthFields: Boolean!) {
  channel(id: $channelId) {
    id
    ...ChannelPageContentChannel
    ...ChannelStreamContextChannel
  }
}
    ${ChannelPageContentChannelFragmentDoc}
${ChannelStreamContextChannelFragmentDoc}`;

/**
 * __useChannelPageChannelQuery__
 *
 * To run a query within a React component, call `useChannelPageChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelPageChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelPageChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      skipAuthFields: // value for 'skipAuthFields'
 *   },
 * });
 */
export function useChannelPageChannelQuery(baseOptions: Apollo.QueryHookOptions<ChannelPageChannelQuery, ChannelPageChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelPageChannelQuery, ChannelPageChannelQueryVariables>(ChannelPageChannelDocument, options);
      }
export function useChannelPageChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelPageChannelQuery, ChannelPageChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelPageChannelQuery, ChannelPageChannelQueryVariables>(ChannelPageChannelDocument, options);
        }
export type ChannelPageChannelQueryHookResult = ReturnType<typeof useChannelPageChannelQuery>;
export type ChannelPageChannelLazyQueryHookResult = ReturnType<typeof useChannelPageChannelLazyQuery>;
export type ChannelPageChannelQueryResult = Apollo.QueryResult<ChannelPageChannelQuery, ChannelPageChannelQueryVariables>;
export const ChannelPageContentRolesDocument = gql`
    query ChannelPageContentRoles($userId: ID!, $channelId: ID!) {
  userChannelRoles(userId: $userId, channelId: $channelId) {
    roles
  }
}
    `;

/**
 * __useChannelPageContentRolesQuery__
 *
 * To run a query within a React component, call `useChannelPageContentRolesQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelPageContentRolesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelPageContentRolesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelPageContentRolesQuery(baseOptions: Apollo.QueryHookOptions<ChannelPageContentRolesQuery, ChannelPageContentRolesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelPageContentRolesQuery, ChannelPageContentRolesQueryVariables>(ChannelPageContentRolesDocument, options);
      }
export function useChannelPageContentRolesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelPageContentRolesQuery, ChannelPageContentRolesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelPageContentRolesQuery, ChannelPageContentRolesQueryVariables>(ChannelPageContentRolesDocument, options);
        }
export type ChannelPageContentRolesQueryHookResult = ReturnType<typeof useChannelPageContentRolesQuery>;
export type ChannelPageContentRolesLazyQueryHookResult = ReturnType<typeof useChannelPageContentRolesLazyQuery>;
export type ChannelPageContentRolesQueryResult = Apollo.QueryResult<ChannelPageContentRolesQuery, ChannelPageContentRolesQueryVariables>;
export const ChannelPageChannelHeaderDocument = gql`
    query ChannelPageChannelHeader($channelId: ID!, $isLive: Boolean!) {
  channel(id: $channelId) {
    id
    ...ChannelPageHeaderLiveChannel @include(if: $isLive)
    ...ChannelPageHeaderOfflineChannel @skip(if: $isLive)
  }
}
    ${ChannelPageHeaderLiveChannelFragmentDoc}
${ChannelPageHeaderOfflineChannelFragmentDoc}`;

/**
 * __useChannelPageChannelHeaderQuery__
 *
 * To run a query within a React component, call `useChannelPageChannelHeaderQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelPageChannelHeaderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelPageChannelHeaderQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      isLive: // value for 'isLive'
 *   },
 * });
 */
export function useChannelPageChannelHeaderQuery(baseOptions: Apollo.QueryHookOptions<ChannelPageChannelHeaderQuery, ChannelPageChannelHeaderQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelPageChannelHeaderQuery, ChannelPageChannelHeaderQueryVariables>(ChannelPageChannelHeaderDocument, options);
      }
export function useChannelPageChannelHeaderLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelPageChannelHeaderQuery, ChannelPageChannelHeaderQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelPageChannelHeaderQuery, ChannelPageChannelHeaderQueryVariables>(ChannelPageChannelHeaderDocument, options);
        }
export type ChannelPageChannelHeaderQueryHookResult = ReturnType<typeof useChannelPageChannelHeaderQuery>;
export type ChannelPageChannelHeaderLazyQueryHookResult = ReturnType<typeof useChannelPageChannelHeaderLazyQuery>;
export type ChannelPageChannelHeaderQueryResult = Apollo.QueryResult<ChannelPageChannelHeaderQuery, ChannelPageChannelHeaderQueryVariables>;
export const ChannelActiveFriendsDocument = gql`
    query ChannelActiveFriends($userId: ID!, $channelId: ID!, $cursor: APICursorInput) {
  friends(userId: $userId, filters: [{channelId: $channelId}], cursor: $cursor) {
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    users {
      userId
      profile {
        userId
        userTag
        avatars {
          avatar2D
        }
        ...ProfileImageProfile
      }
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useChannelActiveFriendsQuery__
 *
 * To run a query within a React component, call `useChannelActiveFriendsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelActiveFriendsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelActiveFriendsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useChannelActiveFriendsQuery(baseOptions: Apollo.QueryHookOptions<ChannelActiveFriendsQuery, ChannelActiveFriendsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelActiveFriendsQuery, ChannelActiveFriendsQueryVariables>(ChannelActiveFriendsDocument, options);
      }
export function useChannelActiveFriendsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelActiveFriendsQuery, ChannelActiveFriendsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelActiveFriendsQuery, ChannelActiveFriendsQueryVariables>(ChannelActiveFriendsDocument, options);
        }
export type ChannelActiveFriendsQueryHookResult = ReturnType<typeof useChannelActiveFriendsQuery>;
export type ChannelActiveFriendsLazyQueryHookResult = ReturnType<typeof useChannelActiveFriendsLazyQuery>;
export type ChannelActiveFriendsQueryResult = Apollo.QueryResult<ChannelActiveFriendsQuery, ChannelActiveFriendsQueryVariables>;
export const LiveChannelHeaderProfileDocument = gql`
    query LiveChannelHeaderProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      uid
      matureRatedContentAllowed
    }
  }
}
    `;

/**
 * __useLiveChannelHeaderProfileQuery__
 *
 * To run a query within a React component, call `useLiveChannelHeaderProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useLiveChannelHeaderProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLiveChannelHeaderProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useLiveChannelHeaderProfileQuery(baseOptions: Apollo.QueryHookOptions<LiveChannelHeaderProfileQuery, LiveChannelHeaderProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LiveChannelHeaderProfileQuery, LiveChannelHeaderProfileQueryVariables>(LiveChannelHeaderProfileDocument, options);
      }
export function useLiveChannelHeaderProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LiveChannelHeaderProfileQuery, LiveChannelHeaderProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LiveChannelHeaderProfileQuery, LiveChannelHeaderProfileQueryVariables>(LiveChannelHeaderProfileDocument, options);
        }
export type LiveChannelHeaderProfileQueryHookResult = ReturnType<typeof useLiveChannelHeaderProfileQuery>;
export type LiveChannelHeaderProfileLazyQueryHookResult = ReturnType<typeof useLiveChannelHeaderProfileLazyQuery>;
export type LiveChannelHeaderProfileQueryResult = Apollo.QueryResult<LiveChannelHeaderProfileQuery, LiveChannelHeaderProfileQueryVariables>;
export const ChannelStoreStoreFrontDocument = gql`
    query ChannelStoreStoreFront($gameID: ID, $channelId: ID!) {
  channelStoreFront(gameId: $gameID, channelId: $channelId) {
    id
    gameId
    categories {
      id
      itemType
      ...StoreFrontCategoriesCategory
    }
  }
}
    ${StoreFrontCategoriesCategoryFragmentDoc}`;

/**
 * __useChannelStoreStoreFrontQuery__
 *
 * To run a query within a React component, call `useChannelStoreStoreFrontQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelStoreStoreFrontQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelStoreStoreFrontQuery({
 *   variables: {
 *      gameID: // value for 'gameID'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelStoreStoreFrontQuery(baseOptions: Apollo.QueryHookOptions<ChannelStoreStoreFrontQuery, ChannelStoreStoreFrontQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelStoreStoreFrontQuery, ChannelStoreStoreFrontQueryVariables>(ChannelStoreStoreFrontDocument, options);
      }
export function useChannelStoreStoreFrontLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelStoreStoreFrontQuery, ChannelStoreStoreFrontQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelStoreStoreFrontQuery, ChannelStoreStoreFrontQueryVariables>(ChannelStoreStoreFrontDocument, options);
        }
export type ChannelStoreStoreFrontQueryHookResult = ReturnType<typeof useChannelStoreStoreFrontQuery>;
export type ChannelStoreStoreFrontLazyQueryHookResult = ReturnType<typeof useChannelStoreStoreFrontLazyQuery>;
export type ChannelStoreStoreFrontQueryResult = Apollo.QueryResult<ChannelStoreStoreFrontQuery, ChannelStoreStoreFrontQueryVariables>;
export const ChannelStoreProfileDocument = gql`
    query ChannelStoreProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...StoreFrontCategoryProfile
  }
}
    ${StoreFrontCategoryProfileFragmentDoc}`;

/**
 * __useChannelStoreProfileQuery__
 *
 * To run a query within a React component, call `useChannelStoreProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelStoreProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelStoreProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChannelStoreProfileQuery(baseOptions: Apollo.QueryHookOptions<ChannelStoreProfileQuery, ChannelStoreProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelStoreProfileQuery, ChannelStoreProfileQueryVariables>(ChannelStoreProfileDocument, options);
      }
export function useChannelStoreProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelStoreProfileQuery, ChannelStoreProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelStoreProfileQuery, ChannelStoreProfileQueryVariables>(ChannelStoreProfileDocument, options);
        }
export type ChannelStoreProfileQueryHookResult = ReturnType<typeof useChannelStoreProfileQuery>;
export type ChannelStoreProfileLazyQueryHookResult = ReturnType<typeof useChannelStoreProfileLazyQuery>;
export type ChannelStoreProfileQueryResult = Apollo.QueryResult<ChannelStoreProfileQuery, ChannelStoreProfileQueryVariables>;
export const ChannelStoreRedirectChannelDocument = gql`
    query ChannelStoreRedirectChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    streamedGames {
      id
      noicePredictionsEnabled
    }
  }
}
    `;

/**
 * __useChannelStoreRedirectChannelQuery__
 *
 * To run a query within a React component, call `useChannelStoreRedirectChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelStoreRedirectChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelStoreRedirectChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelStoreRedirectChannelQuery(baseOptions: Apollo.QueryHookOptions<ChannelStoreRedirectChannelQuery, ChannelStoreRedirectChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelStoreRedirectChannelQuery, ChannelStoreRedirectChannelQueryVariables>(ChannelStoreRedirectChannelDocument, options);
      }
export function useChannelStoreRedirectChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelStoreRedirectChannelQuery, ChannelStoreRedirectChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelStoreRedirectChannelQuery, ChannelStoreRedirectChannelQueryVariables>(ChannelStoreRedirectChannelDocument, options);
        }
export type ChannelStoreRedirectChannelQueryHookResult = ReturnType<typeof useChannelStoreRedirectChannelQuery>;
export type ChannelStoreRedirectChannelLazyQueryHookResult = ReturnType<typeof useChannelStoreRedirectChannelLazyQuery>;
export type ChannelStoreRedirectChannelQueryResult = Apollo.QueryResult<ChannelStoreRedirectChannelQuery, ChannelStoreRedirectChannelQueryVariables>;
export const OfflineChannelIndicatorChannelNotificationSettingsDocument = gql`
    query OfflineChannelIndicatorChannelNotificationSettings($channelId: ID!, $userId: ID!) {
  channelFollowerNotificationSettings(channelId: $channelId, userId: $userId) {
    userId
    channelId
    channelLiveNotificationEnabled
    ...OfflineChannelIndicatorFollowerNotificationSetting
  }
}
    ${OfflineChannelIndicatorFollowerNotificationSettingFragmentDoc}`;

/**
 * __useOfflineChannelIndicatorChannelNotificationSettingsQuery__
 *
 * To run a query within a React component, call `useOfflineChannelIndicatorChannelNotificationSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useOfflineChannelIndicatorChannelNotificationSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOfflineChannelIndicatorChannelNotificationSettingsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useOfflineChannelIndicatorChannelNotificationSettingsQuery(baseOptions: Apollo.QueryHookOptions<OfflineChannelIndicatorChannelNotificationSettingsQuery, OfflineChannelIndicatorChannelNotificationSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OfflineChannelIndicatorChannelNotificationSettingsQuery, OfflineChannelIndicatorChannelNotificationSettingsQueryVariables>(OfflineChannelIndicatorChannelNotificationSettingsDocument, options);
      }
export function useOfflineChannelIndicatorChannelNotificationSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OfflineChannelIndicatorChannelNotificationSettingsQuery, OfflineChannelIndicatorChannelNotificationSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OfflineChannelIndicatorChannelNotificationSettingsQuery, OfflineChannelIndicatorChannelNotificationSettingsQueryVariables>(OfflineChannelIndicatorChannelNotificationSettingsDocument, options);
        }
export type OfflineChannelIndicatorChannelNotificationSettingsQueryHookResult = ReturnType<typeof useOfflineChannelIndicatorChannelNotificationSettingsQuery>;
export type OfflineChannelIndicatorChannelNotificationSettingsLazyQueryHookResult = ReturnType<typeof useOfflineChannelIndicatorChannelNotificationSettingsLazyQuery>;
export type OfflineChannelIndicatorChannelNotificationSettingsQueryResult = Apollo.QueryResult<OfflineChannelIndicatorChannelNotificationSettingsQuery, OfflineChannelIndicatorChannelNotificationSettingsQueryVariables>;
export const ChannelSubscribeDocument = gql`
    subscription ChannelSubscribe($channelId: ID) {
  channelStreamDetailSubscribe(channelId: $channelId) {
    channelId
    liveStatus
    noicePredictionsEnabled
    streamId
    gameId
    matureRatedContent
  }
}
    `;

/**
 * __useChannelSubscribeSubscription__
 *
 * To run a query within a React component, call `useChannelSubscribeSubscription` and pass it any options that fit your needs.
 * When your component renders, `useChannelSubscribeSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelSubscribeSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelSubscribeSubscription(baseOptions?: Apollo.SubscriptionHookOptions<ChannelSubscribeSubscription, ChannelSubscribeSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ChannelSubscribeSubscription, ChannelSubscribeSubscriptionVariables>(ChannelSubscribeDocument, options);
      }
export type ChannelSubscribeSubscriptionHookResult = ReturnType<typeof useChannelSubscribeSubscription>;
export type ChannelSubscribeSubscriptionResult = Apollo.SubscriptionResult<ChannelSubscribeSubscription>;
export const ChannelStoreItemChannelDocument = gql`
    query ChannelStoreItemChannel($channelName: String!) {
  channelByName(name: $channelName) {
    id
    ...StoreItemPageChannel
  }
}
    ${StoreItemPageChannelFragmentDoc}`;

/**
 * __useChannelStoreItemChannelQuery__
 *
 * To run a query within a React component, call `useChannelStoreItemChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelStoreItemChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelStoreItemChannelQuery({
 *   variables: {
 *      channelName: // value for 'channelName'
 *   },
 * });
 */
export function useChannelStoreItemChannelQuery(baseOptions: Apollo.QueryHookOptions<ChannelStoreItemChannelQuery, ChannelStoreItemChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelStoreItemChannelQuery, ChannelStoreItemChannelQueryVariables>(ChannelStoreItemChannelDocument, options);
      }
export function useChannelStoreItemChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelStoreItemChannelQuery, ChannelStoreItemChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelStoreItemChannelQuery, ChannelStoreItemChannelQueryVariables>(ChannelStoreItemChannelDocument, options);
        }
export type ChannelStoreItemChannelQueryHookResult = ReturnType<typeof useChannelStoreItemChannelQuery>;
export type ChannelStoreItemChannelLazyQueryHookResult = ReturnType<typeof useChannelStoreItemChannelLazyQuery>;
export type ChannelStoreItemChannelQueryResult = Apollo.QueryResult<ChannelStoreItemChannelQuery, ChannelStoreItemChannelQueryVariables>;
export const ChannelBanDocument = gql`
    query ChannelBan($channelId: ID!) {
  channel(id: $channelId) {
    ...ChannelLogoChannel
    name
    userBanStatus {
      banned
      violation
      description
      appeal {
        status
        ...ChannelBanFormBanAppealInfo
      }
    }
  }
  channelModerationSettings(channelId: $channelId) {
    channelId
    banAppealsEnabled
  }
}
    ${ChannelLogoChannelFragmentDoc}
${ChannelBanFormBanAppealInfoFragmentDoc}`;

/**
 * __useChannelBanQuery__
 *
 * To run a query within a React component, call `useChannelBanQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelBanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelBanQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelBanQuery(baseOptions: Apollo.QueryHookOptions<ChannelBanQuery, ChannelBanQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelBanQuery, ChannelBanQueryVariables>(ChannelBanDocument, options);
      }
export function useChannelBanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelBanQuery, ChannelBanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelBanQuery, ChannelBanQueryVariables>(ChannelBanDocument, options);
        }
export type ChannelBanQueryHookResult = ReturnType<typeof useChannelBanQuery>;
export type ChannelBanLazyQueryHookResult = ReturnType<typeof useChannelBanLazyQuery>;
export type ChannelBanQueryResult = Apollo.QueryResult<ChannelBanQuery, ChannelBanQueryVariables>;
export const ChannelBanAppealFormDocument = gql`
    mutation ChannelBanAppealForm($channelId: ID, $text: String) {
  createChannelBanAppeal(channelId: $channelId, text: $text) {
    emptyTypeWorkaround
  }
}
    `;
export type ChannelBanAppealFormMutationFn = Apollo.MutationFunction<ChannelBanAppealFormMutation, ChannelBanAppealFormMutationVariables>;

/**
 * __useChannelBanAppealFormMutation__
 *
 * To run a mutation, you first call `useChannelBanAppealFormMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelBanAppealFormMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelBanAppealFormMutation, { data, loading, error }] = useChannelBanAppealFormMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      text: // value for 'text'
 *   },
 * });
 */
export function useChannelBanAppealFormMutation(baseOptions?: Apollo.MutationHookOptions<ChannelBanAppealFormMutation, ChannelBanAppealFormMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelBanAppealFormMutation, ChannelBanAppealFormMutationVariables>(ChannelBanAppealFormDocument, options);
      }
export type ChannelBanAppealFormMutationHookResult = ReturnType<typeof useChannelBanAppealFormMutation>;
export type ChannelBanAppealFormMutationResult = Apollo.MutationResult<ChannelBanAppealFormMutation>;
export type ChannelBanAppealFormMutationOptions = Apollo.BaseMutationOptions<ChannelBanAppealFormMutation, ChannelBanAppealFormMutationVariables>;
export const CollectionCardsUnlockedCountProfileDocument = gql`
    query CollectionCardsUnlockedCountProfile($userId: ID, $seasonId: ID) {
  seasonProgression(userId: $userId, seasonId: $seasonId) {
    seasonId
    level
  }
}
    `;

/**
 * __useCollectionCardsUnlockedCountProfileQuery__
 *
 * To run a query within a React component, call `useCollectionCardsUnlockedCountProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionCardsUnlockedCountProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionCardsUnlockedCountProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useCollectionCardsUnlockedCountProfileQuery(baseOptions?: Apollo.QueryHookOptions<CollectionCardsUnlockedCountProfileQuery, CollectionCardsUnlockedCountProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionCardsUnlockedCountProfileQuery, CollectionCardsUnlockedCountProfileQueryVariables>(CollectionCardsUnlockedCountProfileDocument, options);
      }
export function useCollectionCardsUnlockedCountProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionCardsUnlockedCountProfileQuery, CollectionCardsUnlockedCountProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionCardsUnlockedCountProfileQuery, CollectionCardsUnlockedCountProfileQueryVariables>(CollectionCardsUnlockedCountProfileDocument, options);
        }
export type CollectionCardsUnlockedCountProfileQueryHookResult = ReturnType<typeof useCollectionCardsUnlockedCountProfileQuery>;
export type CollectionCardsUnlockedCountProfileLazyQueryHookResult = ReturnType<typeof useCollectionCardsUnlockedCountProfileLazyQuery>;
export type CollectionCardsUnlockedCountProfileQueryResult = Apollo.QueryResult<CollectionCardsUnlockedCountProfileQuery, CollectionCardsUnlockedCountProfileQueryVariables>;
export const CollectionCardsUnlockedCountCardsDocument = gql`
    query CollectionCardsUnlockedCountCards($userId: ID, $inventoryFilters: [InventoryListUserInventoryRequestFilterInput!], $seasonId: ID, $minLevel: Int!) {
  inventory(userId: $userId, filters: $inventoryFilters) {
    items {
      itemId
      itemCount
      item {
        id
      }
    }
  }
  listLevelConfigs(minLevel: $minLevel, seasonId: $seasonId) {
    levelConfigs {
      number
      rewards {
        reward {
          ... on RewardRewardTypeItem {
            itemId
            item {
              id
              details {
                __typename
              }
            }
          }
        }
      }
    }
  }
  rewards(userId: $userId) {
    rewards {
      type {
        reward {
          ... on RewardRewardTypeItem {
            itemId
            item {
              gameId
              seasonId
              details {
                ... on GameLogicCard {
                  ...UseBaseCardsGameCard
                }
              }
            }
          }
        }
      }
    }
  }
}
    ${UseBaseCardsGameCardFragmentDoc}`;

/**
 * __useCollectionCardsUnlockedCountCardsQuery__
 *
 * To run a query within a React component, call `useCollectionCardsUnlockedCountCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionCardsUnlockedCountCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionCardsUnlockedCountCardsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      inventoryFilters: // value for 'inventoryFilters'
 *      seasonId: // value for 'seasonId'
 *      minLevel: // value for 'minLevel'
 *   },
 * });
 */
export function useCollectionCardsUnlockedCountCardsQuery(baseOptions: Apollo.QueryHookOptions<CollectionCardsUnlockedCountCardsQuery, CollectionCardsUnlockedCountCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionCardsUnlockedCountCardsQuery, CollectionCardsUnlockedCountCardsQueryVariables>(CollectionCardsUnlockedCountCardsDocument, options);
      }
export function useCollectionCardsUnlockedCountCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionCardsUnlockedCountCardsQuery, CollectionCardsUnlockedCountCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionCardsUnlockedCountCardsQuery, CollectionCardsUnlockedCountCardsQueryVariables>(CollectionCardsUnlockedCountCardsDocument, options);
        }
export type CollectionCardsUnlockedCountCardsQueryHookResult = ReturnType<typeof useCollectionCardsUnlockedCountCardsQuery>;
export type CollectionCardsUnlockedCountCardsLazyQueryHookResult = ReturnType<typeof useCollectionCardsUnlockedCountCardsLazyQuery>;
export type CollectionCardsUnlockedCountCardsQueryResult = Apollo.QueryResult<CollectionCardsUnlockedCountCardsQuery, CollectionCardsUnlockedCountCardsQueryVariables>;
export const UseBaseCardsSeasonProgressionDocument = gql`
    query UseBaseCardsSeasonProgression($userId: ID, $seasonId: ID) {
  seasonProgression(userId: $userId, seasonId: $seasonId) {
    seasonId
    level
  }
}
    `;

/**
 * __useUseBaseCardsSeasonProgressionQuery__
 *
 * To run a query within a React component, call `useUseBaseCardsSeasonProgressionQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseBaseCardsSeasonProgressionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseBaseCardsSeasonProgressionQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useUseBaseCardsSeasonProgressionQuery(baseOptions?: Apollo.QueryHookOptions<UseBaseCardsSeasonProgressionQuery, UseBaseCardsSeasonProgressionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseBaseCardsSeasonProgressionQuery, UseBaseCardsSeasonProgressionQueryVariables>(UseBaseCardsSeasonProgressionDocument, options);
      }
export function useUseBaseCardsSeasonProgressionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseBaseCardsSeasonProgressionQuery, UseBaseCardsSeasonProgressionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseBaseCardsSeasonProgressionQuery, UseBaseCardsSeasonProgressionQueryVariables>(UseBaseCardsSeasonProgressionDocument, options);
        }
export type UseBaseCardsSeasonProgressionQueryHookResult = ReturnType<typeof useUseBaseCardsSeasonProgressionQuery>;
export type UseBaseCardsSeasonProgressionLazyQueryHookResult = ReturnType<typeof useUseBaseCardsSeasonProgressionLazyQuery>;
export type UseBaseCardsSeasonProgressionQueryResult = Apollo.QueryResult<UseBaseCardsSeasonProgressionQuery, UseBaseCardsSeasonProgressionQueryVariables>;
export const UseBaseCardsDocument = gql`
    query UseBaseCards($seasonId: ID, $minLevel: Int!, $userId: ID!, $inventoryFilters: [InventoryListUserInventoryRequestFilterInput!]) {
  inventory(userId: $userId, filters: $inventoryFilters) {
    items {
      itemId
      item {
        id
        details {
          ... on GameLogicCard {
            ...UseBaseCardsGameCard
          }
        }
      }
    }
  }
  listLevelConfigs(minLevel: $minLevel, seasonId: $seasonId) {
    levelConfigs {
      number
      rewards {
        reward {
          ... on RewardRewardTypeItem {
            itemId
            item {
              id
              details {
                ... on GameLogicCard {
                  ...UseBaseCardsGameCard
                }
              }
            }
          }
        }
      }
    }
  }
  rewards(userId: $userId) {
    rewards {
      type {
        reward {
          ... on RewardRewardTypeItem {
            itemId
            item {
              gameId
              seasonId
              details {
                ... on GameLogicCard {
                  ...UseBaseCardsGameCard
                }
              }
            }
          }
        }
      }
    }
  }
}
    ${UseBaseCardsGameCardFragmentDoc}`;

/**
 * __useUseBaseCardsQuery__
 *
 * To run a query within a React component, call `useUseBaseCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseBaseCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseBaseCardsQuery({
 *   variables: {
 *      seasonId: // value for 'seasonId'
 *      minLevel: // value for 'minLevel'
 *      userId: // value for 'userId'
 *      inventoryFilters: // value for 'inventoryFilters'
 *   },
 * });
 */
export function useUseBaseCardsQuery(baseOptions: Apollo.QueryHookOptions<UseBaseCardsQuery, UseBaseCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseBaseCardsQuery, UseBaseCardsQueryVariables>(UseBaseCardsDocument, options);
      }
export function useUseBaseCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseBaseCardsQuery, UseBaseCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseBaseCardsQuery, UseBaseCardsQueryVariables>(UseBaseCardsDocument, options);
        }
export type UseBaseCardsQueryHookResult = ReturnType<typeof useUseBaseCardsQuery>;
export type UseBaseCardsLazyQueryHookResult = ReturnType<typeof useUseBaseCardsLazyQuery>;
export type UseBaseCardsQueryResult = Apollo.QueryResult<UseBaseCardsQuery, UseBaseCardsQueryVariables>;
export const CollectionChannelSelectorInventoryDocument = gql`
    query CollectionChannelSelectorInventory($userId: ID, $filters: [InventoryListUserInventoryRequestFilterInput!]) {
  inventory(filters: $filters, userId: $userId) {
    items {
      itemId
      item {
        id
        channelId
      }
    }
  }
}
    `;

/**
 * __useCollectionChannelSelectorInventoryQuery__
 *
 * To run a query within a React component, call `useCollectionChannelSelectorInventoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionChannelSelectorInventoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionChannelSelectorInventoryQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      filters: // value for 'filters'
 *   },
 * });
 */
export function useCollectionChannelSelectorInventoryQuery(baseOptions?: Apollo.QueryHookOptions<CollectionChannelSelectorInventoryQuery, CollectionChannelSelectorInventoryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionChannelSelectorInventoryQuery, CollectionChannelSelectorInventoryQueryVariables>(CollectionChannelSelectorInventoryDocument, options);
      }
export function useCollectionChannelSelectorInventoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionChannelSelectorInventoryQuery, CollectionChannelSelectorInventoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionChannelSelectorInventoryQuery, CollectionChannelSelectorInventoryQueryVariables>(CollectionChannelSelectorInventoryDocument, options);
        }
export type CollectionChannelSelectorInventoryQueryHookResult = ReturnType<typeof useCollectionChannelSelectorInventoryQuery>;
export type CollectionChannelSelectorInventoryLazyQueryHookResult = ReturnType<typeof useCollectionChannelSelectorInventoryLazyQuery>;
export type CollectionChannelSelectorInventoryQueryResult = Apollo.QueryResult<CollectionChannelSelectorInventoryQuery, CollectionChannelSelectorInventoryQueryVariables>;
export const CollectionChannelSelectorChannelsDocument = gql`
    query CollectionChannelSelectorChannels($channelIds: [String!]) {
  getChannels(channelIds: $channelIds) {
    channels {
      ...CollectionChannelSelectorChannel
    }
  }
}
    ${CollectionChannelSelectorChannelFragmentDoc}`;

/**
 * __useCollectionChannelSelectorChannelsQuery__
 *
 * To run a query within a React component, call `useCollectionChannelSelectorChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionChannelSelectorChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionChannelSelectorChannelsQuery({
 *   variables: {
 *      channelIds: // value for 'channelIds'
 *   },
 * });
 */
export function useCollectionChannelSelectorChannelsQuery(baseOptions?: Apollo.QueryHookOptions<CollectionChannelSelectorChannelsQuery, CollectionChannelSelectorChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionChannelSelectorChannelsQuery, CollectionChannelSelectorChannelsQueryVariables>(CollectionChannelSelectorChannelsDocument, options);
      }
export function useCollectionChannelSelectorChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionChannelSelectorChannelsQuery, CollectionChannelSelectorChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionChannelSelectorChannelsQuery, CollectionChannelSelectorChannelsQueryVariables>(CollectionChannelSelectorChannelsDocument, options);
        }
export type CollectionChannelSelectorChannelsQueryHookResult = ReturnType<typeof useCollectionChannelSelectorChannelsQuery>;
export type CollectionChannelSelectorChannelsLazyQueryHookResult = ReturnType<typeof useCollectionChannelSelectorChannelsLazyQuery>;
export type CollectionChannelSelectorChannelsQueryResult = Apollo.QueryResult<CollectionChannelSelectorChannelsQuery, CollectionChannelSelectorChannelsQueryVariables>;
export const CollectionPageDataDocument = gql`
    query CollectionPageData($userId: ID!, $inventoryFilters: [InventoryListUserInventoryRequestFilterInput!]) {
  inventory(userId: $userId, filters: $inventoryFilters) {
    items {
      itemId
      itemCount
      item {
        id
      }
    }
  }
  profile(userId: $userId) {
    userId
    playedGames {
      userId
      id
      game {
        id
      }
    }
  }
}
    `;

/**
 * __useCollectionPageDataQuery__
 *
 * To run a query within a React component, call `useCollectionPageDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionPageDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionPageDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      inventoryFilters: // value for 'inventoryFilters'
 *   },
 * });
 */
export function useCollectionPageDataQuery(baseOptions: Apollo.QueryHookOptions<CollectionPageDataQuery, CollectionPageDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionPageDataQuery, CollectionPageDataQueryVariables>(CollectionPageDataDocument, options);
      }
export function useCollectionPageDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionPageDataQuery, CollectionPageDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionPageDataQuery, CollectionPageDataQueryVariables>(CollectionPageDataDocument, options);
        }
export type CollectionPageDataQueryHookResult = ReturnType<typeof useCollectionPageDataQuery>;
export type CollectionPageDataLazyQueryHookResult = ReturnType<typeof useCollectionPageDataLazyQuery>;
export type CollectionPageDataQueryResult = Apollo.QueryResult<CollectionPageDataQuery, CollectionPageDataQueryVariables>;
export const CreatorCardModalItemDocument = gql`
    query CreatorCardModalItem($filters: [ItemListItemsRequestFilterInput!], $seasonId: String) {
  items(filters: $filters) {
    items {
      id
      details {
        ...CreatorCardModalCreatorCard
      }
    }
  }
}
    ${CreatorCardModalCreatorCardFragmentDoc}`;

/**
 * __useCreatorCardModalItemQuery__
 *
 * To run a query within a React component, call `useCreatorCardModalItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreatorCardModalItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreatorCardModalItemQuery({
 *   variables: {
 *      filters: // value for 'filters'
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useCreatorCardModalItemQuery(baseOptions?: Apollo.QueryHookOptions<CreatorCardModalItemQuery, CreatorCardModalItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreatorCardModalItemQuery, CreatorCardModalItemQueryVariables>(CreatorCardModalItemDocument, options);
      }
export function useCreatorCardModalItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreatorCardModalItemQuery, CreatorCardModalItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreatorCardModalItemQuery, CreatorCardModalItemQueryVariables>(CreatorCardModalItemDocument, options);
        }
export type CreatorCardModalItemQueryHookResult = ReturnType<typeof useCreatorCardModalItemQuery>;
export type CreatorCardModalItemLazyQueryHookResult = ReturnType<typeof useCreatorCardModalItemLazyQuery>;
export type CreatorCardModalItemQueryResult = Apollo.QueryResult<CreatorCardModalItemQuery, CreatorCardModalItemQueryVariables>;
export const CreatorCardsChannelDocument = gql`
    query CreatorCardsChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
    ...ChannelLogoChannel
  }
}
    ${ChannelLogoChannelFragmentDoc}`;

/**
 * __useCreatorCardsChannelQuery__
 *
 * To run a query within a React component, call `useCreatorCardsChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreatorCardsChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreatorCardsChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useCreatorCardsChannelQuery(baseOptions: Apollo.QueryHookOptions<CreatorCardsChannelQuery, CreatorCardsChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreatorCardsChannelQuery, CreatorCardsChannelQueryVariables>(CreatorCardsChannelDocument, options);
      }
export function useCreatorCardsChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreatorCardsChannelQuery, CreatorCardsChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreatorCardsChannelQuery, CreatorCardsChannelQueryVariables>(CreatorCardsChannelDocument, options);
        }
export type CreatorCardsChannelQueryHookResult = ReturnType<typeof useCreatorCardsChannelQuery>;
export type CreatorCardsChannelLazyQueryHookResult = ReturnType<typeof useCreatorCardsChannelLazyQuery>;
export type CreatorCardsChannelQueryResult = Apollo.QueryResult<CreatorCardsChannelQuery, CreatorCardsChannelQueryVariables>;
export const CollectionChannelCardGridGameDocument = gql`
    query CollectionChannelCardGridGame($gameId: ID!) {
  game(id: $gameId) {
    id
    activeSeason {
      id
    }
  }
}
    `;

/**
 * __useCollectionChannelCardGridGameQuery__
 *
 * To run a query within a React component, call `useCollectionChannelCardGridGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionChannelCardGridGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionChannelCardGridGameQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useCollectionChannelCardGridGameQuery(baseOptions: Apollo.QueryHookOptions<CollectionChannelCardGridGameQuery, CollectionChannelCardGridGameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionChannelCardGridGameQuery, CollectionChannelCardGridGameQueryVariables>(CollectionChannelCardGridGameDocument, options);
      }
export function useCollectionChannelCardGridGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionChannelCardGridGameQuery, CollectionChannelCardGridGameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionChannelCardGridGameQuery, CollectionChannelCardGridGameQueryVariables>(CollectionChannelCardGridGameDocument, options);
        }
export type CollectionChannelCardGridGameQueryHookResult = ReturnType<typeof useCollectionChannelCardGridGameQuery>;
export type CollectionChannelCardGridGameLazyQueryHookResult = ReturnType<typeof useCollectionChannelCardGridGameLazyQuery>;
export type CollectionChannelCardGridGameQueryResult = Apollo.QueryResult<CollectionChannelCardGridGameQuery, CollectionChannelCardGridGameQueryVariables>;
export const UseCreatorCardsItemsDocument = gql`
    query UseCreatorCardsItems($filters: [ItemListItemsRequestFilterInput!], $seasonId: String!, $userId: ID!) {
  items(filters: $filters) {
    items {
      id
      details {
        __typename
        ... on GameLogicStreamerCard {
          ...CreatorCardGridStreamerCard
          saleConfig {
            cardId
            channelId
            enabled
            period {
              from
              until
            }
          }
        }
      }
      inventoryItem(user_id: $userId) {
        itemId
        itemCount
        item {
          id
        }
      }
    }
  }
}
    ${CreatorCardGridStreamerCardFragmentDoc}`;

/**
 * __useUseCreatorCardsItemsQuery__
 *
 * To run a query within a React component, call `useUseCreatorCardsItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseCreatorCardsItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseCreatorCardsItemsQuery({
 *   variables: {
 *      filters: // value for 'filters'
 *      seasonId: // value for 'seasonId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUseCreatorCardsItemsQuery(baseOptions: Apollo.QueryHookOptions<UseCreatorCardsItemsQuery, UseCreatorCardsItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseCreatorCardsItemsQuery, UseCreatorCardsItemsQueryVariables>(UseCreatorCardsItemsDocument, options);
      }
export function useUseCreatorCardsItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseCreatorCardsItemsQuery, UseCreatorCardsItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseCreatorCardsItemsQuery, UseCreatorCardsItemsQueryVariables>(UseCreatorCardsItemsDocument, options);
        }
export type UseCreatorCardsItemsQueryHookResult = ReturnType<typeof useUseCreatorCardsItemsQuery>;
export type UseCreatorCardsItemsLazyQueryHookResult = ReturnType<typeof useUseCreatorCardsItemsLazyQuery>;
export type UseCreatorCardsItemsQueryResult = Apollo.QueryResult<UseCreatorCardsItemsQuery, UseCreatorCardsItemsQueryVariables>;
export const CollectionGameSelectorProfileDocument = gql`
    query CollectionGameSelectorProfile($userId: ID) {
  profile(userId: $userId) {
    userId
    playedGames {
      userId
      id
      game {
        id
        name
      }
    }
  }
}
    `;

/**
 * __useCollectionGameSelectorProfileQuery__
 *
 * To run a query within a React component, call `useCollectionGameSelectorProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionGameSelectorProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionGameSelectorProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useCollectionGameSelectorProfileQuery(baseOptions?: Apollo.QueryHookOptions<CollectionGameSelectorProfileQuery, CollectionGameSelectorProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionGameSelectorProfileQuery, CollectionGameSelectorProfileQueryVariables>(CollectionGameSelectorProfileDocument, options);
      }
export function useCollectionGameSelectorProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionGameSelectorProfileQuery, CollectionGameSelectorProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionGameSelectorProfileQuery, CollectionGameSelectorProfileQueryVariables>(CollectionGameSelectorProfileDocument, options);
        }
export type CollectionGameSelectorProfileQueryHookResult = ReturnType<typeof useCollectionGameSelectorProfileQuery>;
export type CollectionGameSelectorProfileLazyQueryHookResult = ReturnType<typeof useCollectionGameSelectorProfileLazyQuery>;
export type CollectionGameSelectorProfileQueryResult = Apollo.QueryResult<CollectionGameSelectorProfileQuery, CollectionGameSelectorProfileQueryVariables>;
export const UseCollectionSeasonIdGameDocument = gql`
    query UseCollectionSeasonIdGame($gameId: ID!) {
  game(id: $gameId) {
    id
    activeSeasonId
  }
}
    `;

/**
 * __useUseCollectionSeasonIdGameQuery__
 *
 * To run a query within a React component, call `useUseCollectionSeasonIdGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseCollectionSeasonIdGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseCollectionSeasonIdGameQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useUseCollectionSeasonIdGameQuery(baseOptions: Apollo.QueryHookOptions<UseCollectionSeasonIdGameQuery, UseCollectionSeasonIdGameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseCollectionSeasonIdGameQuery, UseCollectionSeasonIdGameQueryVariables>(UseCollectionSeasonIdGameDocument, options);
      }
export function useUseCollectionSeasonIdGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseCollectionSeasonIdGameQuery, UseCollectionSeasonIdGameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseCollectionSeasonIdGameQuery, UseCollectionSeasonIdGameQueryVariables>(UseCollectionSeasonIdGameDocument, options);
        }
export type UseCollectionSeasonIdGameQueryHookResult = ReturnType<typeof useUseCollectionSeasonIdGameQuery>;
export type UseCollectionSeasonIdGameLazyQueryHookResult = ReturnType<typeof useUseCollectionSeasonIdGameLazyQuery>;
export type UseCollectionSeasonIdGameQueryResult = Apollo.QueryResult<UseCollectionSeasonIdGameQuery, UseCollectionSeasonIdGameQueryVariables>;
export const DailyGoalSwitchOutConfirmationCardDocument = gql`
    query DailyGoalSwitchOutConfirmationCard($id: ID!) {
  goalCard(id: $id) {
    id
    ...GoalCardCard
  }
}
    ${GoalCardCardFragmentDoc}`;

/**
 * __useDailyGoalSwitchOutConfirmationCardQuery__
 *
 * To run a query within a React component, call `useDailyGoalSwitchOutConfirmationCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useDailyGoalSwitchOutConfirmationCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDailyGoalSwitchOutConfirmationCardQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDailyGoalSwitchOutConfirmationCardQuery(baseOptions: Apollo.QueryHookOptions<DailyGoalSwitchOutConfirmationCardQuery, DailyGoalSwitchOutConfirmationCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DailyGoalSwitchOutConfirmationCardQuery, DailyGoalSwitchOutConfirmationCardQueryVariables>(DailyGoalSwitchOutConfirmationCardDocument, options);
      }
export function useDailyGoalSwitchOutConfirmationCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DailyGoalSwitchOutConfirmationCardQuery, DailyGoalSwitchOutConfirmationCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DailyGoalSwitchOutConfirmationCardQuery, DailyGoalSwitchOutConfirmationCardQueryVariables>(DailyGoalSwitchOutConfirmationCardDocument, options);
        }
export type DailyGoalSwitchOutConfirmationCardQueryHookResult = ReturnType<typeof useDailyGoalSwitchOutConfirmationCardQuery>;
export type DailyGoalSwitchOutConfirmationCardLazyQueryHookResult = ReturnType<typeof useDailyGoalSwitchOutConfirmationCardLazyQuery>;
export type DailyGoalSwitchOutConfirmationCardQueryResult = Apollo.QueryResult<DailyGoalSwitchOutConfirmationCardQuery, DailyGoalSwitchOutConfirmationCardQueryVariables>;
export const DailyGoalSelectModalGoalCardOptionsDocument = gql`
    query DailyGoalSelectModalGoalCardOptions($slotId: ID!) {
  goalCardSlotOptions(slotId: $slotId) {
    cardOptions {
      id
      ...GoalCardCard
    }
  }
}
    ${GoalCardCardFragmentDoc}`;

/**
 * __useDailyGoalSelectModalGoalCardOptionsQuery__
 *
 * To run a query within a React component, call `useDailyGoalSelectModalGoalCardOptionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useDailyGoalSelectModalGoalCardOptionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDailyGoalSelectModalGoalCardOptionsQuery({
 *   variables: {
 *      slotId: // value for 'slotId'
 *   },
 * });
 */
export function useDailyGoalSelectModalGoalCardOptionsQuery(baseOptions: Apollo.QueryHookOptions<DailyGoalSelectModalGoalCardOptionsQuery, DailyGoalSelectModalGoalCardOptionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DailyGoalSelectModalGoalCardOptionsQuery, DailyGoalSelectModalGoalCardOptionsQueryVariables>(DailyGoalSelectModalGoalCardOptionsDocument, options);
      }
export function useDailyGoalSelectModalGoalCardOptionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DailyGoalSelectModalGoalCardOptionsQuery, DailyGoalSelectModalGoalCardOptionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DailyGoalSelectModalGoalCardOptionsQuery, DailyGoalSelectModalGoalCardOptionsQueryVariables>(DailyGoalSelectModalGoalCardOptionsDocument, options);
        }
export type DailyGoalSelectModalGoalCardOptionsQueryHookResult = ReturnType<typeof useDailyGoalSelectModalGoalCardOptionsQuery>;
export type DailyGoalSelectModalGoalCardOptionsLazyQueryHookResult = ReturnType<typeof useDailyGoalSelectModalGoalCardOptionsLazyQuery>;
export type DailyGoalSelectModalGoalCardOptionsQueryResult = Apollo.QueryResult<DailyGoalSelectModalGoalCardOptionsQuery, DailyGoalSelectModalGoalCardOptionsQueryVariables>;
export const DailyGoalsPageDataDocument = gql`
    query DailyGoalsPageData {
  goalCardSlots {
    slots {
      id
      ...GoalCardSlotsGoalSlot
      cardOptions {
        id
      }
    }
  }
  dailyParticipationLimit {
    remainingDailyParticipationMinutes
  }
}
    ${GoalCardSlotsGoalSlotFragmentDoc}`;

/**
 * __useDailyGoalsPageDataQuery__
 *
 * To run a query within a React component, call `useDailyGoalsPageDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useDailyGoalsPageDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDailyGoalsPageDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useDailyGoalsPageDataQuery(baseOptions?: Apollo.QueryHookOptions<DailyGoalsPageDataQuery, DailyGoalsPageDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DailyGoalsPageDataQuery, DailyGoalsPageDataQueryVariables>(DailyGoalsPageDataDocument, options);
      }
export function useDailyGoalsPageDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DailyGoalsPageDataQuery, DailyGoalsPageDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DailyGoalsPageDataQuery, DailyGoalsPageDataQueryVariables>(DailyGoalsPageDataDocument, options);
        }
export type DailyGoalsPageDataQueryHookResult = ReturnType<typeof useDailyGoalsPageDataQuery>;
export type DailyGoalsPageDataLazyQueryHookResult = ReturnType<typeof useDailyGoalsPageDataLazyQuery>;
export type DailyGoalsPageDataQueryResult = Apollo.QueryResult<DailyGoalsPageDataQuery, DailyGoalsPageDataQueryVariables>;
export const DailyGoalClaimRewardHookDocument = gql`
    mutation DailyGoalClaimRewardHook($rewardId: ID) {
  claimReward(rewardId: $rewardId) {
    emptyTypeWorkaround
  }
}
    `;
export type DailyGoalClaimRewardHookMutationFn = Apollo.MutationFunction<DailyGoalClaimRewardHookMutation, DailyGoalClaimRewardHookMutationVariables>;

/**
 * __useDailyGoalClaimRewardHookMutation__
 *
 * To run a mutation, you first call `useDailyGoalClaimRewardHookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDailyGoalClaimRewardHookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [dailyGoalClaimRewardHookMutation, { data, loading, error }] = useDailyGoalClaimRewardHookMutation({
 *   variables: {
 *      rewardId: // value for 'rewardId'
 *   },
 * });
 */
export function useDailyGoalClaimRewardHookMutation(baseOptions?: Apollo.MutationHookOptions<DailyGoalClaimRewardHookMutation, DailyGoalClaimRewardHookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DailyGoalClaimRewardHookMutation, DailyGoalClaimRewardHookMutationVariables>(DailyGoalClaimRewardHookDocument, options);
      }
export type DailyGoalClaimRewardHookMutationHookResult = ReturnType<typeof useDailyGoalClaimRewardHookMutation>;
export type DailyGoalClaimRewardHookMutationResult = Apollo.MutationResult<DailyGoalClaimRewardHookMutation>;
export type DailyGoalClaimRewardHookMutationOptions = Apollo.BaseMutationOptions<DailyGoalClaimRewardHookMutation, DailyGoalClaimRewardHookMutationVariables>;
export const DailyGoalReshuffleHookDocument = gql`
    mutation DailyGoalReshuffleHook($slotId: ID!) {
  reshuffleGoalCardSlot(slotId: $slotId) {
    cardOptions {
      id
    }
  }
}
    `;
export type DailyGoalReshuffleHookMutationFn = Apollo.MutationFunction<DailyGoalReshuffleHookMutation, DailyGoalReshuffleHookMutationVariables>;

/**
 * __useDailyGoalReshuffleHookMutation__
 *
 * To run a mutation, you first call `useDailyGoalReshuffleHookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDailyGoalReshuffleHookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [dailyGoalReshuffleHookMutation, { data, loading, error }] = useDailyGoalReshuffleHookMutation({
 *   variables: {
 *      slotId: // value for 'slotId'
 *   },
 * });
 */
export function useDailyGoalReshuffleHookMutation(baseOptions?: Apollo.MutationHookOptions<DailyGoalReshuffleHookMutation, DailyGoalReshuffleHookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DailyGoalReshuffleHookMutation, DailyGoalReshuffleHookMutationVariables>(DailyGoalReshuffleHookDocument, options);
      }
export type DailyGoalReshuffleHookMutationHookResult = ReturnType<typeof useDailyGoalReshuffleHookMutation>;
export type DailyGoalReshuffleHookMutationResult = Apollo.MutationResult<DailyGoalReshuffleHookMutation>;
export type DailyGoalReshuffleHookMutationOptions = Apollo.BaseMutationOptions<DailyGoalReshuffleHookMutation, DailyGoalReshuffleHookMutationVariables>;
export const DailyGoalSetGoalCardHookDocument = gql`
    mutation DailyGoalSetGoalCardHook($slotId: ID!, $cardId: ID!) {
  setGoalCardSlot(goalCardSlotId: $slotId, goalCardId: $cardId) {
    emptyTypeWorkaround
  }
}
    `;
export type DailyGoalSetGoalCardHookMutationFn = Apollo.MutationFunction<DailyGoalSetGoalCardHookMutation, DailyGoalSetGoalCardHookMutationVariables>;

/**
 * __useDailyGoalSetGoalCardHookMutation__
 *
 * To run a mutation, you first call `useDailyGoalSetGoalCardHookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDailyGoalSetGoalCardHookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [dailyGoalSetGoalCardHookMutation, { data, loading, error }] = useDailyGoalSetGoalCardHookMutation({
 *   variables: {
 *      slotId: // value for 'slotId'
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useDailyGoalSetGoalCardHookMutation(baseOptions?: Apollo.MutationHookOptions<DailyGoalSetGoalCardHookMutation, DailyGoalSetGoalCardHookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DailyGoalSetGoalCardHookMutation, DailyGoalSetGoalCardHookMutationVariables>(DailyGoalSetGoalCardHookDocument, options);
      }
export type DailyGoalSetGoalCardHookMutationHookResult = ReturnType<typeof useDailyGoalSetGoalCardHookMutation>;
export type DailyGoalSetGoalCardHookMutationResult = Apollo.MutationResult<DailyGoalSetGoalCardHookMutation>;
export type DailyGoalSetGoalCardHookMutationOptions = Apollo.BaseMutationOptions<DailyGoalSetGoalCardHookMutation, DailyGoalSetGoalCardHookMutationVariables>;
export const FollowingPageLiveChannelsDocument = gql`
    query FollowingPageLiveChannels($userId: ID!, $cursor: String, $skipUserFields: Boolean = false) {
  followedChannels(
    userId: $userId
    cursor: {first: 16, after: $cursor}
    liveStatus: LIVE_STATUS_LIVE
  ) {
    pageInfo {
      endCursor
      hasNextPage
    }
    channels {
      id
      ...LiveChannelPreviewChannel
    }
  }
}
    ${LiveChannelPreviewChannelFragmentDoc}`;

/**
 * __useFollowingPageLiveChannelsQuery__
 *
 * To run a query within a React component, call `useFollowingPageLiveChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFollowingPageLiveChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFollowingPageLiveChannelsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *      skipUserFields: // value for 'skipUserFields'
 *   },
 * });
 */
export function useFollowingPageLiveChannelsQuery(baseOptions: Apollo.QueryHookOptions<FollowingPageLiveChannelsQuery, FollowingPageLiveChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FollowingPageLiveChannelsQuery, FollowingPageLiveChannelsQueryVariables>(FollowingPageLiveChannelsDocument, options);
      }
export function useFollowingPageLiveChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FollowingPageLiveChannelsQuery, FollowingPageLiveChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FollowingPageLiveChannelsQuery, FollowingPageLiveChannelsQueryVariables>(FollowingPageLiveChannelsDocument, options);
        }
export type FollowingPageLiveChannelsQueryHookResult = ReturnType<typeof useFollowingPageLiveChannelsQuery>;
export type FollowingPageLiveChannelsLazyQueryHookResult = ReturnType<typeof useFollowingPageLiveChannelsLazyQuery>;
export type FollowingPageLiveChannelsQueryResult = Apollo.QueryResult<FollowingPageLiveChannelsQuery, FollowingPageLiveChannelsQueryVariables>;
export const FollowingPageOfflineChannelsDocument = gql`
    query FollowingPageOfflineChannels($userId: ID!, $cursor: String) {
  followedChannels(
    userId: $userId
    cursor: {first: 16, after: $cursor}
    liveStatus: LIVE_STATUS_OFFLINE
  ) {
    pageInfo {
      endCursor
      hasNextPage
    }
    channels {
      id
      ...OfflineChannelLinkChannel
    }
  }
}
    ${OfflineChannelLinkChannelFragmentDoc}`;

/**
 * __useFollowingPageOfflineChannelsQuery__
 *
 * To run a query within a React component, call `useFollowingPageOfflineChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFollowingPageOfflineChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFollowingPageOfflineChannelsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useFollowingPageOfflineChannelsQuery(baseOptions: Apollo.QueryHookOptions<FollowingPageOfflineChannelsQuery, FollowingPageOfflineChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FollowingPageOfflineChannelsQuery, FollowingPageOfflineChannelsQueryVariables>(FollowingPageOfflineChannelsDocument, options);
      }
export function useFollowingPageOfflineChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FollowingPageOfflineChannelsQuery, FollowingPageOfflineChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FollowingPageOfflineChannelsQuery, FollowingPageOfflineChannelsQueryVariables>(FollowingPageOfflineChannelsDocument, options);
        }
export type FollowingPageOfflineChannelsQueryHookResult = ReturnType<typeof useFollowingPageOfflineChannelsQuery>;
export type FollowingPageOfflineChannelsLazyQueryHookResult = ReturnType<typeof useFollowingPageOfflineChannelsLazyQuery>;
export type FollowingPageOfflineChannelsQueryResult = Apollo.QueryResult<FollowingPageOfflineChannelsQuery, FollowingPageOfflineChannelsQueryVariables>;
export const FollowingPageEmptyDocument = gql`
    query FollowingPageEmpty($skipUserFields: Boolean!) {
  channels(liveStatus: LIVE_STATUS_LIVE, cursor: {first: 8}) {
    channels {
      id
      ...LiveChannelPreviewChannel
    }
  }
}
    ${LiveChannelPreviewChannelFragmentDoc}`;

/**
 * __useFollowingPageEmptyQuery__
 *
 * To run a query within a React component, call `useFollowingPageEmptyQuery` and pass it any options that fit your needs.
 * When your component renders, `useFollowingPageEmptyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFollowingPageEmptyQuery({
 *   variables: {
 *      skipUserFields: // value for 'skipUserFields'
 *   },
 * });
 */
export function useFollowingPageEmptyQuery(baseOptions: Apollo.QueryHookOptions<FollowingPageEmptyQuery, FollowingPageEmptyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FollowingPageEmptyQuery, FollowingPageEmptyQueryVariables>(FollowingPageEmptyDocument, options);
      }
export function useFollowingPageEmptyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FollowingPageEmptyQuery, FollowingPageEmptyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FollowingPageEmptyQuery, FollowingPageEmptyQueryVariables>(FollowingPageEmptyDocument, options);
        }
export type FollowingPageEmptyQueryHookResult = ReturnType<typeof useFollowingPageEmptyQuery>;
export type FollowingPageEmptyLazyQueryHookResult = ReturnType<typeof useFollowingPageEmptyLazyQuery>;
export type FollowingPageEmptyQueryResult = Apollo.QueryResult<FollowingPageEmptyQuery, FollowingPageEmptyQueryVariables>;
export const HomeProfileDocument = gql`
    query HomeProfile($userId: ID!, $isImplicitAccount: Boolean!) {
  profile(userId: $userId) {
    userId
    ...HomeHeaderProfile
  }
  dailyXPBoostLimit {
    remainingDailyXpBoost
  }
  dailyXPEarningsLimit {
    remainingDailyXpEarningsMinutes
  }
}
    ${HomeHeaderProfileFragmentDoc}`;

/**
 * __useHomeProfileQuery__
 *
 * To run a query within a React component, call `useHomeProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useHomeProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHomeProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      isImplicitAccount: // value for 'isImplicitAccount'
 *   },
 * });
 */
export function useHomeProfileQuery(baseOptions: Apollo.QueryHookOptions<HomeProfileQuery, HomeProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HomeProfileQuery, HomeProfileQueryVariables>(HomeProfileDocument, options);
      }
export function useHomeProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HomeProfileQuery, HomeProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HomeProfileQuery, HomeProfileQueryVariables>(HomeProfileDocument, options);
        }
export type HomeProfileQueryHookResult = ReturnType<typeof useHomeProfileQuery>;
export type HomeProfileLazyQueryHookResult = ReturnType<typeof useHomeProfileLazyQuery>;
export type HomeProfileQueryResult = Apollo.QueryResult<HomeProfileQuery, HomeProfileQueryVariables>;
export const HomeHighlightedStreamDocument = gql`
    query HomeHighlightedStream {
  highlightedChannels(limit: 5) {
    channels {
      id
      ...HighlightedChannel
    }
  }
}
    ${HighlightedChannelFragmentDoc}`;

/**
 * __useHomeHighlightedStreamQuery__
 *
 * To run a query within a React component, call `useHomeHighlightedStreamQuery` and pass it any options that fit your needs.
 * When your component renders, `useHomeHighlightedStreamQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHomeHighlightedStreamQuery({
 *   variables: {
 *   },
 * });
 */
export function useHomeHighlightedStreamQuery(baseOptions?: Apollo.QueryHookOptions<HomeHighlightedStreamQuery, HomeHighlightedStreamQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HomeHighlightedStreamQuery, HomeHighlightedStreamQueryVariables>(HomeHighlightedStreamDocument, options);
      }
export function useHomeHighlightedStreamLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HomeHighlightedStreamQuery, HomeHighlightedStreamQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HomeHighlightedStreamQuery, HomeHighlightedStreamQueryVariables>(HomeHighlightedStreamDocument, options);
        }
export type HomeHighlightedStreamQueryHookResult = ReturnType<typeof useHomeHighlightedStreamQuery>;
export type HomeHighlightedStreamLazyQueryHookResult = ReturnType<typeof useHomeHighlightedStreamLazyQuery>;
export type HomeHighlightedStreamQueryResult = Apollo.QueryResult<HomeHighlightedStreamQuery, HomeHighlightedStreamQueryVariables>;
export const DailyGoalWidgetGoalCardSlotsDocument = gql`
    query DailyGoalWidgetGoalCardSlots {
  goalCardSlots {
    slots {
      id
      ...GoalCardSlotReadyForPickGoalCardCardSlot
      ...GoalCardSlotStateGoalCardSlot
    }
  }
}
    ${GoalCardSlotReadyForPickGoalCardCardSlotFragmentDoc}
${GoalCardSlotStateGoalCardSlotFragmentDoc}`;

/**
 * __useDailyGoalWidgetGoalCardSlotsQuery__
 *
 * To run a query within a React component, call `useDailyGoalWidgetGoalCardSlotsQuery` and pass it any options that fit your needs.
 * When your component renders, `useDailyGoalWidgetGoalCardSlotsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDailyGoalWidgetGoalCardSlotsQuery({
 *   variables: {
 *   },
 * });
 */
export function useDailyGoalWidgetGoalCardSlotsQuery(baseOptions?: Apollo.QueryHookOptions<DailyGoalWidgetGoalCardSlotsQuery, DailyGoalWidgetGoalCardSlotsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DailyGoalWidgetGoalCardSlotsQuery, DailyGoalWidgetGoalCardSlotsQueryVariables>(DailyGoalWidgetGoalCardSlotsDocument, options);
      }
export function useDailyGoalWidgetGoalCardSlotsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DailyGoalWidgetGoalCardSlotsQuery, DailyGoalWidgetGoalCardSlotsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DailyGoalWidgetGoalCardSlotsQuery, DailyGoalWidgetGoalCardSlotsQueryVariables>(DailyGoalWidgetGoalCardSlotsDocument, options);
        }
export type DailyGoalWidgetGoalCardSlotsQueryHookResult = ReturnType<typeof useDailyGoalWidgetGoalCardSlotsQuery>;
export type DailyGoalWidgetGoalCardSlotsLazyQueryHookResult = ReturnType<typeof useDailyGoalWidgetGoalCardSlotsLazyQuery>;
export type DailyGoalWidgetGoalCardSlotsQueryResult = Apollo.QueryResult<DailyGoalWidgetGoalCardSlotsQuery, DailyGoalWidgetGoalCardSlotsQueryVariables>;
export const HomeBackupOfflineChannelsDocument = gql`
    query HomeBackupOfflineChannels {
  channels(liveStatus: LIVE_STATUS_OFFLINE, cursor: {first: 12}) @connection(key: "homepage") {
    channels {
      id
      ...HomePageChannelListOfflineChannel
    }
  }
}
    ${HomePageChannelListOfflineChannelFragmentDoc}`;

/**
 * __useHomeBackupOfflineChannelsQuery__
 *
 * To run a query within a React component, call `useHomeBackupOfflineChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useHomeBackupOfflineChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHomeBackupOfflineChannelsQuery({
 *   variables: {
 *   },
 * });
 */
export function useHomeBackupOfflineChannelsQuery(baseOptions?: Apollo.QueryHookOptions<HomeBackupOfflineChannelsQuery, HomeBackupOfflineChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HomeBackupOfflineChannelsQuery, HomeBackupOfflineChannelsQueryVariables>(HomeBackupOfflineChannelsDocument, options);
      }
export function useHomeBackupOfflineChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HomeBackupOfflineChannelsQuery, HomeBackupOfflineChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HomeBackupOfflineChannelsQuery, HomeBackupOfflineChannelsQueryVariables>(HomeBackupOfflineChannelsDocument, options);
        }
export type HomeBackupOfflineChannelsQueryHookResult = ReturnType<typeof useHomeBackupOfflineChannelsQuery>;
export type HomeBackupOfflineChannelsLazyQueryHookResult = ReturnType<typeof useHomeBackupOfflineChannelsLazyQuery>;
export type HomeBackupOfflineChannelsQueryResult = Apollo.QueryResult<HomeBackupOfflineChannelsQuery, HomeBackupOfflineChannelsQueryVariables>;
export const HomeLiveChannelsDocument = gql`
    query HomeLiveChannels($cursor: String, $skipUserFields: Boolean!) {
  channels(liveStatus: LIVE_STATUS_LIVE, cursor: {first: 12, after: $cursor}) @connection(key: "homepage") {
    pageInfo {
      hasNextPage
      endCursor
    }
    channels {
      id
      ...HomePageChannelListLiveChannel
    }
  }
}
    ${HomePageChannelListLiveChannelFragmentDoc}`;

/**
 * __useHomeLiveChannelsQuery__
 *
 * To run a query within a React component, call `useHomeLiveChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useHomeLiveChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHomeLiveChannelsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      skipUserFields: // value for 'skipUserFields'
 *   },
 * });
 */
export function useHomeLiveChannelsQuery(baseOptions: Apollo.QueryHookOptions<HomeLiveChannelsQuery, HomeLiveChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HomeLiveChannelsQuery, HomeLiveChannelsQueryVariables>(HomeLiveChannelsDocument, options);
      }
export function useHomeLiveChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HomeLiveChannelsQuery, HomeLiveChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HomeLiveChannelsQuery, HomeLiveChannelsQueryVariables>(HomeLiveChannelsDocument, options);
        }
export type HomeLiveChannelsQueryHookResult = ReturnType<typeof useHomeLiveChannelsQuery>;
export type HomeLiveChannelsLazyQueryHookResult = ReturnType<typeof useHomeLiveChannelsLazyQuery>;
export type HomeLiveChannelsQueryResult = Apollo.QueryResult<HomeLiveChannelsQuery, HomeLiveChannelsQueryVariables>;
export const HomePageCategoryListDocument = gql`
    query HomePageCategoryList {
  channelGameStats(filters: [{live: true}], cursor: {first: 6}) @connection(key: "homepage") {
    games {
      gameId
      ...CategoryLinkGameStats
    }
  }
}
    ${CategoryLinkGameStatsFragmentDoc}`;

/**
 * __useHomePageCategoryListQuery__
 *
 * To run a query within a React component, call `useHomePageCategoryListQuery` and pass it any options that fit your needs.
 * When your component renders, `useHomePageCategoryListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHomePageCategoryListQuery({
 *   variables: {
 *   },
 * });
 */
export function useHomePageCategoryListQuery(baseOptions?: Apollo.QueryHookOptions<HomePageCategoryListQuery, HomePageCategoryListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HomePageCategoryListQuery, HomePageCategoryListQueryVariables>(HomePageCategoryListDocument, options);
      }
export function useHomePageCategoryListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HomePageCategoryListQuery, HomePageCategoryListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HomePageCategoryListQuery, HomePageCategoryListQueryVariables>(HomePageCategoryListDocument, options);
        }
export type HomePageCategoryListQueryHookResult = ReturnType<typeof useHomePageCategoryListQuery>;
export type HomePageCategoryListLazyQueryHookResult = ReturnType<typeof useHomePageCategoryListLazyQuery>;
export type HomePageCategoryListQueryResult = Apollo.QueryResult<HomePageCategoryListQuery, HomePageCategoryListQueryVariables>;
export const HomePageOfflineCategoryListDocument = gql`
    query HomePageOfflineCategoryList {
  channelGameStats(cursor: {first: 6}) @connection(key: "homepage") {
    games {
      gameId
      ...CategoryLinkGameStats
    }
  }
}
    ${CategoryLinkGameStatsFragmentDoc}`;

/**
 * __useHomePageOfflineCategoryListQuery__
 *
 * To run a query within a React component, call `useHomePageOfflineCategoryListQuery` and pass it any options that fit your needs.
 * When your component renders, `useHomePageOfflineCategoryListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHomePageOfflineCategoryListQuery({
 *   variables: {
 *   },
 * });
 */
export function useHomePageOfflineCategoryListQuery(baseOptions?: Apollo.QueryHookOptions<HomePageOfflineCategoryListQuery, HomePageOfflineCategoryListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HomePageOfflineCategoryListQuery, HomePageOfflineCategoryListQueryVariables>(HomePageOfflineCategoryListDocument, options);
      }
export function useHomePageOfflineCategoryListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HomePageOfflineCategoryListQuery, HomePageOfflineCategoryListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HomePageOfflineCategoryListQuery, HomePageOfflineCategoryListQueryVariables>(HomePageOfflineCategoryListDocument, options);
        }
export type HomePageOfflineCategoryListQueryHookResult = ReturnType<typeof useHomePageOfflineCategoryListQuery>;
export type HomePageOfflineCategoryListLazyQueryHookResult = ReturnType<typeof useHomePageOfflineCategoryListLazyQuery>;
export type HomePageOfflineCategoryListQueryResult = Apollo.QueryResult<HomePageOfflineCategoryListQuery, HomePageOfflineCategoryListQueryVariables>;
export const OAuthProfileDocument = gql`
    query OAuthProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    ...ProfileImageProfile
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useOAuthProfileQuery__
 *
 * To run a query within a React component, call `useOAuthProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useOAuthProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOAuthProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useOAuthProfileQuery(baseOptions: Apollo.QueryHookOptions<OAuthProfileQuery, OAuthProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OAuthProfileQuery, OAuthProfileQueryVariables>(OAuthProfileDocument, options);
      }
export function useOAuthProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OAuthProfileQuery, OAuthProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OAuthProfileQuery, OAuthProfileQueryVariables>(OAuthProfileDocument, options);
        }
export type OAuthProfileQueryHookResult = ReturnType<typeof useOAuthProfileQuery>;
export type OAuthProfileLazyQueryHookResult = ReturnType<typeof useOAuthProfileLazyQuery>;
export type OAuthProfileQueryResult = Apollo.QueryResult<OAuthProfileQuery, OAuthProfileQueryVariables>;
export const AddOAuthConsentDocument = gql`
    mutation AddOAuthConsent($clientId: ID!, $userId: ID!, $scopes: [String!]) {
  addOAuth2Consent(clientId: $clientId, userId: $userId, scopes: $scopes) {
    emptyTypeWorkaround
  }
}
    `;
export type AddOAuthConsentMutationFn = Apollo.MutationFunction<AddOAuthConsentMutation, AddOAuthConsentMutationVariables>;

/**
 * __useAddOAuthConsentMutation__
 *
 * To run a mutation, you first call `useAddOAuthConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddOAuthConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addOAuthConsentMutation, { data, loading, error }] = useAddOAuthConsentMutation({
 *   variables: {
 *      clientId: // value for 'clientId'
 *      userId: // value for 'userId'
 *      scopes: // value for 'scopes'
 *   },
 * });
 */
export function useAddOAuthConsentMutation(baseOptions?: Apollo.MutationHookOptions<AddOAuthConsentMutation, AddOAuthConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddOAuthConsentMutation, AddOAuthConsentMutationVariables>(AddOAuthConsentDocument, options);
      }
export type AddOAuthConsentMutationHookResult = ReturnType<typeof useAddOAuthConsentMutation>;
export type AddOAuthConsentMutationResult = Apollo.MutationResult<AddOAuthConsentMutation>;
export type AddOAuthConsentMutationOptions = Apollo.BaseMutationOptions<AddOAuthConsentMutation, AddOAuthConsentMutationVariables>;
export const UserTagDocument = gql`
    query UserTag($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    temporary
    account {
      uid
      pendingAgreements {
        name
        revision
        url
      }
      marketingConsent
    }
  }
}
    `;

/**
 * __useUserTagQuery__
 *
 * To run a query within a React component, call `useUserTagQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserTagQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserTagQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserTagQuery(baseOptions: Apollo.QueryHookOptions<UserTagQuery, UserTagQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserTagQuery, UserTagQueryVariables>(UserTagDocument, options);
      }
export function useUserTagLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserTagQuery, UserTagQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserTagQuery, UserTagQueryVariables>(UserTagDocument, options);
        }
export type UserTagQueryHookResult = ReturnType<typeof useUserTagQuery>;
export type UserTagLazyQueryHookResult = ReturnType<typeof useUserTagLazyQuery>;
export type UserTagQueryResult = Apollo.QueryResult<UserTagQuery, UserTagQueryVariables>;
export const SignAgreementDocument = gql`
    mutation SignAgreement($agreement: AuthTermsVersionInput!) {
  signAgreements(agreements: [$agreement]) {
    emptyTypeWorkaround
  }
}
    `;
export type SignAgreementMutationFn = Apollo.MutationFunction<SignAgreementMutation, SignAgreementMutationVariables>;

/**
 * __useSignAgreementMutation__
 *
 * To run a mutation, you first call `useSignAgreementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignAgreementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signAgreementMutation, { data, loading, error }] = useSignAgreementMutation({
 *   variables: {
 *      agreement: // value for 'agreement'
 *   },
 * });
 */
export function useSignAgreementMutation(baseOptions?: Apollo.MutationHookOptions<SignAgreementMutation, SignAgreementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignAgreementMutation, SignAgreementMutationVariables>(SignAgreementDocument, options);
      }
export type SignAgreementMutationHookResult = ReturnType<typeof useSignAgreementMutation>;
export type SignAgreementMutationResult = Apollo.MutationResult<SignAgreementMutation>;
export type SignAgreementMutationOptions = Apollo.BaseMutationOptions<SignAgreementMutation, SignAgreementMutationVariables>;
export const PlatformSuspensionDocument = gql`
    query PlatformSuspension($userId: ID) {
  platformBan(userId: $userId) {
    ...PlatformSuspensionStatus
    banId
  }
  profile(userId: $userId) {
    userId
    ...PlatformSuspensionProfile
  }
}
    ${PlatformSuspensionStatusFragmentDoc}
${PlatformSuspensionProfileFragmentDoc}`;

/**
 * __usePlatformSuspensionQuery__
 *
 * To run a query within a React component, call `usePlatformSuspensionQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlatformSuspensionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlatformSuspensionQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function usePlatformSuspensionQuery(baseOptions?: Apollo.QueryHookOptions<PlatformSuspensionQuery, PlatformSuspensionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlatformSuspensionQuery, PlatformSuspensionQueryVariables>(PlatformSuspensionDocument, options);
      }
export function usePlatformSuspensionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlatformSuspensionQuery, PlatformSuspensionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlatformSuspensionQuery, PlatformSuspensionQueryVariables>(PlatformSuspensionDocument, options);
        }
export type PlatformSuspensionQueryHookResult = ReturnType<typeof usePlatformSuspensionQuery>;
export type PlatformSuspensionLazyQueryHookResult = ReturnType<typeof usePlatformSuspensionLazyQuery>;
export type PlatformSuspensionQueryResult = Apollo.QueryResult<PlatformSuspensionQuery, PlatformSuspensionQueryVariables>;
export const CreatePlatformSuspensionAppealDocument = gql`
    mutation CreatePlatformSuspensionAppeal($userId: ID!, $appealText: String!) {
  createPlatformBanAppeal(userId: $userId, appealText: $appealText) {
    emptyTypeWorkaround
  }
}
    `;
export type CreatePlatformSuspensionAppealMutationFn = Apollo.MutationFunction<CreatePlatformSuspensionAppealMutation, CreatePlatformSuspensionAppealMutationVariables>;

/**
 * __useCreatePlatformSuspensionAppealMutation__
 *
 * To run a mutation, you first call `useCreatePlatformSuspensionAppealMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlatformSuspensionAppealMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlatformSuspensionAppealMutation, { data, loading, error }] = useCreatePlatformSuspensionAppealMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      appealText: // value for 'appealText'
 *   },
 * });
 */
export function useCreatePlatformSuspensionAppealMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlatformSuspensionAppealMutation, CreatePlatformSuspensionAppealMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePlatformSuspensionAppealMutation, CreatePlatformSuspensionAppealMutationVariables>(CreatePlatformSuspensionAppealDocument, options);
      }
export type CreatePlatformSuspensionAppealMutationHookResult = ReturnType<typeof useCreatePlatformSuspensionAppealMutation>;
export type CreatePlatformSuspensionAppealMutationResult = Apollo.MutationResult<CreatePlatformSuspensionAppealMutation>;
export type CreatePlatformSuspensionAppealMutationOptions = Apollo.BaseMutationOptions<CreatePlatformSuspensionAppealMutation, CreatePlatformSuspensionAppealMutationVariables>;
export const PrivateProfilePageDocument = gql`
    query PrivateProfilePage($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ProfilePageHeaderProfile
  }
}
    ${ProfilePageHeaderProfileFragmentDoc}`;

/**
 * __usePrivateProfilePageQuery__
 *
 * To run a query within a React component, call `usePrivateProfilePageQuery` and pass it any options that fit your needs.
 * When your component renders, `usePrivateProfilePageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePrivateProfilePageQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function usePrivateProfilePageQuery(baseOptions: Apollo.QueryHookOptions<PrivateProfilePageQuery, PrivateProfilePageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PrivateProfilePageQuery, PrivateProfilePageQueryVariables>(PrivateProfilePageDocument, options);
      }
export function usePrivateProfilePageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PrivateProfilePageQuery, PrivateProfilePageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PrivateProfilePageQuery, PrivateProfilePageQueryVariables>(PrivateProfilePageDocument, options);
        }
export type PrivateProfilePageQueryHookResult = ReturnType<typeof usePrivateProfilePageQuery>;
export type PrivateProfilePageLazyQueryHookResult = ReturnType<typeof usePrivateProfilePageLazyQuery>;
export type PrivateProfilePageQueryResult = Apollo.QueryResult<PrivateProfilePageQuery, PrivateProfilePageQueryVariables>;
export const ProfilePageDocument = gql`
    query ProfilePage($userTag: String!) {
  resolveUserTags(userTags: [$userTag]) {
    profiles {
      userId
      visibility
      temporary
    }
  }
}
    `;

/**
 * __useProfilePageQuery__
 *
 * To run a query within a React component, call `useProfilePageQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfilePageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfilePageQuery({
 *   variables: {
 *      userTag: // value for 'userTag'
 *   },
 * });
 */
export function useProfilePageQuery(baseOptions: Apollo.QueryHookOptions<ProfilePageQuery, ProfilePageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfilePageQuery, ProfilePageQueryVariables>(ProfilePageDocument, options);
      }
export function useProfilePageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfilePageQuery, ProfilePageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfilePageQuery, ProfilePageQueryVariables>(ProfilePageDocument, options);
        }
export type ProfilePageQueryHookResult = ReturnType<typeof useProfilePageQuery>;
export type ProfilePageLazyQueryHookResult = ReturnType<typeof useProfilePageLazyQuery>;
export type ProfilePageQueryResult = Apollo.QueryResult<ProfilePageQuery, ProfilePageQueryVariables>;
export const ProfileGamesPublicListDocument = gql`
    query ProfileGamesPublicList {
  listGames {
    games {
      id
    }
  }
}
    `;

/**
 * __useProfileGamesPublicListQuery__
 *
 * To run a query within a React component, call `useProfileGamesPublicListQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileGamesPublicListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileGamesPublicListQuery({
 *   variables: {
 *   },
 * });
 */
export function useProfileGamesPublicListQuery(baseOptions?: Apollo.QueryHookOptions<ProfileGamesPublicListQuery, ProfileGamesPublicListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileGamesPublicListQuery, ProfileGamesPublicListQueryVariables>(ProfileGamesPublicListDocument, options);
      }
export function useProfileGamesPublicListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileGamesPublicListQuery, ProfileGamesPublicListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileGamesPublicListQuery, ProfileGamesPublicListQueryVariables>(ProfileGamesPublicListDocument, options);
        }
export type ProfileGamesPublicListQueryHookResult = ReturnType<typeof useProfileGamesPublicListQuery>;
export type ProfileGamesPublicListLazyQueryHookResult = ReturnType<typeof useProfileGamesPublicListLazyQuery>;
export type ProfileGamesPublicListQueryResult = Apollo.QueryResult<ProfileGamesPublicListQuery, ProfileGamesPublicListQueryVariables>;
export const PublicProfilePageDocument = gql`
    query PublicProfilePage($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ProfilePageHeaderProfile
    ...ProfilePageLayoutProfile
    ...ProfileStats
    playedGames {
      userId
      id
      game {
        id
        ...ProfileGamesListItem
      }
    }
  }
  listGameCards(userId: $userId) {
    cards {
      id
      ...ProfileCardsCard
    }
  }
  friends(userId: $userId) {
    users {
      userId
      profile {
        userId
        ...ProfileFriendsProfile
      }
    }
  }
}
    ${ProfilePageHeaderProfileFragmentDoc}
${ProfilePageLayoutProfileFragmentDoc}
${ProfileStatsFragmentDoc}
${ProfileGamesListItemFragmentDoc}
${ProfileCardsCardFragmentDoc}
${ProfileFriendsProfileFragmentDoc}`;

/**
 * __usePublicProfilePageQuery__
 *
 * To run a query within a React component, call `usePublicProfilePageQuery` and pass it any options that fit your needs.
 * When your component renders, `usePublicProfilePageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePublicProfilePageQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function usePublicProfilePageQuery(baseOptions: Apollo.QueryHookOptions<PublicProfilePageQuery, PublicProfilePageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PublicProfilePageQuery, PublicProfilePageQueryVariables>(PublicProfilePageDocument, options);
      }
export function usePublicProfilePageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PublicProfilePageQuery, PublicProfilePageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PublicProfilePageQuery, PublicProfilePageQueryVariables>(PublicProfilePageDocument, options);
        }
export type PublicProfilePageQueryHookResult = ReturnType<typeof usePublicProfilePageQuery>;
export type PublicProfilePageLazyQueryHookResult = ReturnType<typeof usePublicProfilePageLazyQuery>;
export type PublicProfilePageQueryResult = Apollo.QueryResult<PublicProfilePageQuery, PublicProfilePageQueryVariables>;
export const SearchPageCategorySearchDocument = gql`
    query SearchPageCategorySearch($query: String, $cursor: String) {
  publicSearch(
    query: $query
    entityTypes: [ENTITY_TYPE_GAME]
    cursor: {first: 28, after: $cursor}
  ) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    resultItems {
      ...CategorySearchResult
    }
  }
}
    ${CategorySearchResultFragmentDoc}`;

/**
 * __useSearchPageCategorySearchQuery__
 *
 * To run a query within a React component, call `useSearchPageCategorySearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchPageCategorySearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchPageCategorySearchQuery({
 *   variables: {
 *      query: // value for 'query'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useSearchPageCategorySearchQuery(baseOptions?: Apollo.QueryHookOptions<SearchPageCategorySearchQuery, SearchPageCategorySearchQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchPageCategorySearchQuery, SearchPageCategorySearchQueryVariables>(SearchPageCategorySearchDocument, options);
      }
export function useSearchPageCategorySearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchPageCategorySearchQuery, SearchPageCategorySearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchPageCategorySearchQuery, SearchPageCategorySearchQueryVariables>(SearchPageCategorySearchDocument, options);
        }
export type SearchPageCategorySearchQueryHookResult = ReturnType<typeof useSearchPageCategorySearchQuery>;
export type SearchPageCategorySearchLazyQueryHookResult = ReturnType<typeof useSearchPageCategorySearchLazyQuery>;
export type SearchPageCategorySearchQueryResult = Apollo.QueryResult<SearchPageCategorySearchQuery, SearchPageCategorySearchQueryVariables>;
export const SearchPageChannelSearchDocument = gql`
    query SearchPageChannelSearch($query: String, $cursor: String) {
  publicSearch(
    query: $query
    entityTypes: [ENTITY_TYPE_CHANNEL]
    cursor: {first: 7, after: $cursor}
  ) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    resultItems {
      ...ChannelSearchResult
    }
  }
}
    ${ChannelSearchResultFragmentDoc}`;

/**
 * __useSearchPageChannelSearchQuery__
 *
 * To run a query within a React component, call `useSearchPageChannelSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchPageChannelSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchPageChannelSearchQuery({
 *   variables: {
 *      query: // value for 'query'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useSearchPageChannelSearchQuery(baseOptions?: Apollo.QueryHookOptions<SearchPageChannelSearchQuery, SearchPageChannelSearchQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchPageChannelSearchQuery, SearchPageChannelSearchQueryVariables>(SearchPageChannelSearchDocument, options);
      }
export function useSearchPageChannelSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchPageChannelSearchQuery, SearchPageChannelSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchPageChannelSearchQuery, SearchPageChannelSearchQueryVariables>(SearchPageChannelSearchDocument, options);
        }
export type SearchPageChannelSearchQueryHookResult = ReturnType<typeof useSearchPageChannelSearchQuery>;
export type SearchPageChannelSearchLazyQueryHookResult = ReturnType<typeof useSearchPageChannelSearchLazyQuery>;
export type SearchPageChannelSearchQueryResult = Apollo.QueryResult<SearchPageChannelSearchQuery, SearchPageChannelSearchQueryVariables>;
export const SeasonClaimRewardDocument = gql`
    mutation SeasonClaimReward($rewardId: ID) {
  claimReward(rewardId: $rewardId) {
    emptyTypeWorkaround
  }
}
    `;
export type SeasonClaimRewardMutationFn = Apollo.MutationFunction<SeasonClaimRewardMutation, SeasonClaimRewardMutationVariables>;

/**
 * __useSeasonClaimRewardMutation__
 *
 * To run a mutation, you first call `useSeasonClaimRewardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSeasonClaimRewardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [seasonClaimRewardMutation, { data, loading, error }] = useSeasonClaimRewardMutation({
 *   variables: {
 *      rewardId: // value for 'rewardId'
 *   },
 * });
 */
export function useSeasonClaimRewardMutation(baseOptions?: Apollo.MutationHookOptions<SeasonClaimRewardMutation, SeasonClaimRewardMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SeasonClaimRewardMutation, SeasonClaimRewardMutationVariables>(SeasonClaimRewardDocument, options);
      }
export type SeasonClaimRewardMutationHookResult = ReturnType<typeof useSeasonClaimRewardMutation>;
export type SeasonClaimRewardMutationResult = Apollo.MutationResult<SeasonClaimRewardMutation>;
export type SeasonClaimRewardMutationOptions = Apollo.BaseMutationOptions<SeasonClaimRewardMutation, SeasonClaimRewardMutationVariables>;
export const SeasonsHeaderGameDocument = gql`
    query SeasonsHeaderGame($gameId: ID!) {
  game(id: $gameId) {
    id
    name
    activeSeasonId
  }
}
    `;

/**
 * __useSeasonsHeaderGameQuery__
 *
 * To run a query within a React component, call `useSeasonsHeaderGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useSeasonsHeaderGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSeasonsHeaderGameQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useSeasonsHeaderGameQuery(baseOptions: Apollo.QueryHookOptions<SeasonsHeaderGameQuery, SeasonsHeaderGameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SeasonsHeaderGameQuery, SeasonsHeaderGameQueryVariables>(SeasonsHeaderGameDocument, options);
      }
export function useSeasonsHeaderGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SeasonsHeaderGameQuery, SeasonsHeaderGameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SeasonsHeaderGameQuery, SeasonsHeaderGameQueryVariables>(SeasonsHeaderGameDocument, options);
        }
export type SeasonsHeaderGameQueryHookResult = ReturnType<typeof useSeasonsHeaderGameQuery>;
export type SeasonsHeaderGameLazyQueryHookResult = ReturnType<typeof useSeasonsHeaderGameLazyQuery>;
export type SeasonsHeaderGameQueryResult = Apollo.QueryResult<SeasonsHeaderGameQuery, SeasonsHeaderGameQueryVariables>;
export const UseAllSeasonDataDocument = gql`
    query UseAllSeasonData($seasonId: ID, $userId: ID) {
  seasonProgression(userId: $userId, seasonId: $seasonId) {
    seasonId
    ...RewardTrackSeasonProgression
    ...SeasonsHeaderProgression
  }
  rewards(userId: $userId) {
    rewards {
      id
      ...RewardTrackRewards
    }
  }
  listLevelConfigs(seasonId: $seasonId) {
    levelConfigs {
      ...RewardTrackLevelConfig
      ...NextUnlockLevelConfig
    }
  }
}
    ${RewardTrackSeasonProgressionFragmentDoc}
${SeasonsHeaderProgressionFragmentDoc}
${RewardTrackRewardsFragmentDoc}
${RewardTrackLevelConfigFragmentDoc}
${NextUnlockLevelConfigFragmentDoc}`;

/**
 * __useUseAllSeasonDataQuery__
 *
 * To run a query within a React component, call `useUseAllSeasonDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseAllSeasonDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseAllSeasonDataQuery({
 *   variables: {
 *      seasonId: // value for 'seasonId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUseAllSeasonDataQuery(baseOptions?: Apollo.QueryHookOptions<UseAllSeasonDataQuery, UseAllSeasonDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseAllSeasonDataQuery, UseAllSeasonDataQueryVariables>(UseAllSeasonDataDocument, options);
      }
export function useUseAllSeasonDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseAllSeasonDataQuery, UseAllSeasonDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseAllSeasonDataQuery, UseAllSeasonDataQueryVariables>(UseAllSeasonDataDocument, options);
        }
export type UseAllSeasonDataQueryHookResult = ReturnType<typeof useUseAllSeasonDataQuery>;
export type UseAllSeasonDataLazyQueryHookResult = ReturnType<typeof useUseAllSeasonDataLazyQuery>;
export type UseAllSeasonDataQueryResult = Apollo.QueryResult<UseAllSeasonDataQuery, UseAllSeasonDataQueryVariables>;
export const SeasonsDataDailyXpBoostDocument = gql`
    query SeasonsDataDailyXPBoost {
  dailyXPBoostLimit {
    remainingDailyXpBoost
  }
}
    `;

/**
 * __useSeasonsDataDailyXpBoostQuery__
 *
 * To run a query within a React component, call `useSeasonsDataDailyXpBoostQuery` and pass it any options that fit your needs.
 * When your component renders, `useSeasonsDataDailyXpBoostQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSeasonsDataDailyXpBoostQuery({
 *   variables: {
 *   },
 * });
 */
export function useSeasonsDataDailyXpBoostQuery(baseOptions?: Apollo.QueryHookOptions<SeasonsDataDailyXpBoostQuery, SeasonsDataDailyXpBoostQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SeasonsDataDailyXpBoostQuery, SeasonsDataDailyXpBoostQueryVariables>(SeasonsDataDailyXpBoostDocument, options);
      }
export function useSeasonsDataDailyXpBoostLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SeasonsDataDailyXpBoostQuery, SeasonsDataDailyXpBoostQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SeasonsDataDailyXpBoostQuery, SeasonsDataDailyXpBoostQueryVariables>(SeasonsDataDailyXpBoostDocument, options);
        }
export type SeasonsDataDailyXpBoostQueryHookResult = ReturnType<typeof useSeasonsDataDailyXpBoostQuery>;
export type SeasonsDataDailyXpBoostLazyQueryHookResult = ReturnType<typeof useSeasonsDataDailyXpBoostLazyQuery>;
export type SeasonsDataDailyXpBoostQueryResult = Apollo.QueryResult<SeasonsDataDailyXpBoostQuery, SeasonsDataDailyXpBoostQueryVariables>;
export const UseSeasonsDataFilterIdsGamesDocument = gql`
    query UseSeasonsDataFilterIdsGames($userId: ID) {
  playedGames(userId: $userId) {
    games {
      userId
      id
      game {
        id
      }
    }
  }
}
    `;

/**
 * __useUseSeasonsDataFilterIdsGamesQuery__
 *
 * To run a query within a React component, call `useUseSeasonsDataFilterIdsGamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseSeasonsDataFilterIdsGamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseSeasonsDataFilterIdsGamesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUseSeasonsDataFilterIdsGamesQuery(baseOptions?: Apollo.QueryHookOptions<UseSeasonsDataFilterIdsGamesQuery, UseSeasonsDataFilterIdsGamesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseSeasonsDataFilterIdsGamesQuery, UseSeasonsDataFilterIdsGamesQueryVariables>(UseSeasonsDataFilterIdsGamesDocument, options);
      }
export function useUseSeasonsDataFilterIdsGamesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseSeasonsDataFilterIdsGamesQuery, UseSeasonsDataFilterIdsGamesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseSeasonsDataFilterIdsGamesQuery, UseSeasonsDataFilterIdsGamesQueryVariables>(UseSeasonsDataFilterIdsGamesDocument, options);
        }
export type UseSeasonsDataFilterIdsGamesQueryHookResult = ReturnType<typeof useUseSeasonsDataFilterIdsGamesQuery>;
export type UseSeasonsDataFilterIdsGamesLazyQueryHookResult = ReturnType<typeof useUseSeasonsDataFilterIdsGamesLazyQuery>;
export type UseSeasonsDataFilterIdsGamesQueryResult = Apollo.QueryResult<UseSeasonsDataFilterIdsGamesQuery, UseSeasonsDataFilterIdsGamesQueryVariables>;
export const ProfileAccountSettingsDocument = gql`
    query ProfileAccountSettings($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      email
    }
  }
}
    `;

/**
 * __useProfileAccountSettingsQuery__
 *
 * To run a query within a React component, call `useProfileAccountSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileAccountSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileAccountSettingsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useProfileAccountSettingsQuery(baseOptions: Apollo.QueryHookOptions<ProfileAccountSettingsQuery, ProfileAccountSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileAccountSettingsQuery, ProfileAccountSettingsQueryVariables>(ProfileAccountSettingsDocument, options);
      }
export function useProfileAccountSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileAccountSettingsQuery, ProfileAccountSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileAccountSettingsQuery, ProfileAccountSettingsQueryVariables>(ProfileAccountSettingsDocument, options);
        }
export type ProfileAccountSettingsQueryHookResult = ReturnType<typeof useProfileAccountSettingsQuery>;
export type ProfileAccountSettingsLazyQueryHookResult = ReturnType<typeof useProfileAccountSettingsLazyQuery>;
export type ProfileAccountSettingsQueryResult = Apollo.QueryResult<ProfileAccountSettingsQuery, ProfileAccountSettingsQueryVariables>;
export const DeleteOwnAccountDocument = gql`
    mutation DeleteOwnAccount {
  deleteUserData {
    taskId
  }
}
    `;
export type DeleteOwnAccountMutationFn = Apollo.MutationFunction<DeleteOwnAccountMutation, DeleteOwnAccountMutationVariables>;

/**
 * __useDeleteOwnAccountMutation__
 *
 * To run a mutation, you first call `useDeleteOwnAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOwnAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOwnAccountMutation, { data, loading, error }] = useDeleteOwnAccountMutation({
 *   variables: {
 *   },
 * });
 */
export function useDeleteOwnAccountMutation(baseOptions?: Apollo.MutationHookOptions<DeleteOwnAccountMutation, DeleteOwnAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteOwnAccountMutation, DeleteOwnAccountMutationVariables>(DeleteOwnAccountDocument, options);
      }
export type DeleteOwnAccountMutationHookResult = ReturnType<typeof useDeleteOwnAccountMutation>;
export type DeleteOwnAccountMutationResult = Apollo.MutationResult<DeleteOwnAccountMutation>;
export type DeleteOwnAccountMutationOptions = Apollo.BaseMutationOptions<DeleteOwnAccountMutation, DeleteOwnAccountMutationVariables>;
export const SettingsConnectionsDataDocument = gql`
    query SettingsConnectionsData($userId: ID!) {
  profile(userId: $userId) {
    userId
    discordUsername
    account {
      externalIds {
        type
      }
    }
  }
  oauth2Consent(clientId: "nightbot", userId: $userId) {
    clientId
    scopes
  }
}
    `;

/**
 * __useSettingsConnectionsDataQuery__
 *
 * To run a query within a React component, call `useSettingsConnectionsDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSettingsConnectionsDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSettingsConnectionsDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSettingsConnectionsDataQuery(baseOptions: Apollo.QueryHookOptions<SettingsConnectionsDataQuery, SettingsConnectionsDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SettingsConnectionsDataQuery, SettingsConnectionsDataQueryVariables>(SettingsConnectionsDataDocument, options);
      }
export function useSettingsConnectionsDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SettingsConnectionsDataQuery, SettingsConnectionsDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SettingsConnectionsDataQuery, SettingsConnectionsDataQueryVariables>(SettingsConnectionsDataDocument, options);
        }
export type SettingsConnectionsDataQueryHookResult = ReturnType<typeof useSettingsConnectionsDataQuery>;
export type SettingsConnectionsDataLazyQueryHookResult = ReturnType<typeof useSettingsConnectionsDataLazyQuery>;
export type SettingsConnectionsDataQueryResult = Apollo.QueryResult<SettingsConnectionsDataQuery, SettingsConnectionsDataQueryVariables>;
export const SettingsConnectionDeleteOAuth2ConsentDocument = gql`
    mutation SettingsConnectionDeleteOAuth2Consent($userId: ID!, $clientId: ID!) {
  deleteOAuth2Consent(userId: $userId, clientId: $clientId) {
    emptyTypeWorkaround
  }
}
    `;
export type SettingsConnectionDeleteOAuth2ConsentMutationFn = Apollo.MutationFunction<SettingsConnectionDeleteOAuth2ConsentMutation, SettingsConnectionDeleteOAuth2ConsentMutationVariables>;

/**
 * __useSettingsConnectionDeleteOAuth2ConsentMutation__
 *
 * To run a mutation, you first call `useSettingsConnectionDeleteOAuth2ConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSettingsConnectionDeleteOAuth2ConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [settingsConnectionDeleteOAuth2ConsentMutation, { data, loading, error }] = useSettingsConnectionDeleteOAuth2ConsentMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      clientId: // value for 'clientId'
 *   },
 * });
 */
export function useSettingsConnectionDeleteOAuth2ConsentMutation(baseOptions?: Apollo.MutationHookOptions<SettingsConnectionDeleteOAuth2ConsentMutation, SettingsConnectionDeleteOAuth2ConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SettingsConnectionDeleteOAuth2ConsentMutation, SettingsConnectionDeleteOAuth2ConsentMutationVariables>(SettingsConnectionDeleteOAuth2ConsentDocument, options);
      }
export type SettingsConnectionDeleteOAuth2ConsentMutationHookResult = ReturnType<typeof useSettingsConnectionDeleteOAuth2ConsentMutation>;
export type SettingsConnectionDeleteOAuth2ConsentMutationResult = Apollo.MutationResult<SettingsConnectionDeleteOAuth2ConsentMutation>;
export type SettingsConnectionDeleteOAuth2ConsentMutationOptions = Apollo.BaseMutationOptions<SettingsConnectionDeleteOAuth2ConsentMutation, SettingsConnectionDeleteOAuth2ConsentMutationVariables>;
export const SettingsConnectionDeleteExternalAccountDocument = gql`
    mutation SettingsConnectionDeleteExternalAccount($userId: ID!, $type: AuthIdentityType!) {
  deleteExternalAccount(userId: $userId, idType: $type) {
    emptyTypeWorkaround
  }
}
    `;
export type SettingsConnectionDeleteExternalAccountMutationFn = Apollo.MutationFunction<SettingsConnectionDeleteExternalAccountMutation, SettingsConnectionDeleteExternalAccountMutationVariables>;

/**
 * __useSettingsConnectionDeleteExternalAccountMutation__
 *
 * To run a mutation, you first call `useSettingsConnectionDeleteExternalAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSettingsConnectionDeleteExternalAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [settingsConnectionDeleteExternalAccountMutation, { data, loading, error }] = useSettingsConnectionDeleteExternalAccountMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useSettingsConnectionDeleteExternalAccountMutation(baseOptions?: Apollo.MutationHookOptions<SettingsConnectionDeleteExternalAccountMutation, SettingsConnectionDeleteExternalAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SettingsConnectionDeleteExternalAccountMutation, SettingsConnectionDeleteExternalAccountMutationVariables>(SettingsConnectionDeleteExternalAccountDocument, options);
      }
export type SettingsConnectionDeleteExternalAccountMutationHookResult = ReturnType<typeof useSettingsConnectionDeleteExternalAccountMutation>;
export type SettingsConnectionDeleteExternalAccountMutationResult = Apollo.MutationResult<SettingsConnectionDeleteExternalAccountMutation>;
export type SettingsConnectionDeleteExternalAccountMutationOptions = Apollo.BaseMutationOptions<SettingsConnectionDeleteExternalAccountMutation, SettingsConnectionDeleteExternalAccountMutationVariables>;
export const UpdateChannelNotificationSettingsDocument = gql`
    mutation UpdateChannelNotificationSettings($userId: ID!, $emailEnabled: Boolean!) {
  updateChannelNotificationSettings(
    body: {userId: $userId, channelLiveNotification: {emailEnabled: $emailEnabled}}
  ) {
    userId
    ...ChannelNotificationChannelNotificationSettings
  }
}
    ${ChannelNotificationChannelNotificationSettingsFragmentDoc}`;
export type UpdateChannelNotificationSettingsMutationFn = Apollo.MutationFunction<UpdateChannelNotificationSettingsMutation, UpdateChannelNotificationSettingsMutationVariables>;

/**
 * __useUpdateChannelNotificationSettingsMutation__
 *
 * To run a mutation, you first call `useUpdateChannelNotificationSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChannelNotificationSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChannelNotificationSettingsMutation, { data, loading, error }] = useUpdateChannelNotificationSettingsMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      emailEnabled: // value for 'emailEnabled'
 *   },
 * });
 */
export function useUpdateChannelNotificationSettingsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChannelNotificationSettingsMutation, UpdateChannelNotificationSettingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChannelNotificationSettingsMutation, UpdateChannelNotificationSettingsMutationVariables>(UpdateChannelNotificationSettingsDocument, options);
      }
export type UpdateChannelNotificationSettingsMutationHookResult = ReturnType<typeof useUpdateChannelNotificationSettingsMutation>;
export type UpdateChannelNotificationSettingsMutationResult = Apollo.MutationResult<UpdateChannelNotificationSettingsMutation>;
export type UpdateChannelNotificationSettingsMutationOptions = Apollo.BaseMutationOptions<UpdateChannelNotificationSettingsMutation, UpdateChannelNotificationSettingsMutationVariables>;
export const NotificationsSettingsDocument = gql`
    query NotificationsSettings($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...MarketingNotificationProfile
  }
  channelNotificationSettings(userId: $userId) {
    userId
    ...ChannelNotificationChannelNotificationSettings
  }
}
    ${MarketingNotificationProfileFragmentDoc}
${ChannelNotificationChannelNotificationSettingsFragmentDoc}`;

/**
 * __useNotificationsSettingsQuery__
 *
 * To run a query within a React component, call `useNotificationsSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationsSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationsSettingsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useNotificationsSettingsQuery(baseOptions: Apollo.QueryHookOptions<NotificationsSettingsQuery, NotificationsSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationsSettingsQuery, NotificationsSettingsQueryVariables>(NotificationsSettingsDocument, options);
      }
export function useNotificationsSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationsSettingsQuery, NotificationsSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationsSettingsQuery, NotificationsSettingsQueryVariables>(NotificationsSettingsDocument, options);
        }
export type NotificationsSettingsQueryHookResult = ReturnType<typeof useNotificationsSettingsQuery>;
export type NotificationsSettingsLazyQueryHookResult = ReturnType<typeof useNotificationsSettingsLazyQuery>;
export type NotificationsSettingsQueryResult = Apollo.QueryResult<NotificationsSettingsQuery, NotificationsSettingsQueryVariables>;
export const ProfilePrivacyChangeDiscordIdVisibilityDocument = gql`
    mutation ProfilePrivacyChangeDiscordIdVisibility($userId: ID, $discordUsernameVisibility: ProfilePrivacySettingsVisibility) {
  updatePrivacySettings(
    userId: $userId
    body: {discordUsernameVisibility: $discordUsernameVisibility}
  ) {
    discordUsernameVisibility
  }
}
    `;
export type ProfilePrivacyChangeDiscordIdVisibilityMutationFn = Apollo.MutationFunction<ProfilePrivacyChangeDiscordIdVisibilityMutation, ProfilePrivacyChangeDiscordIdVisibilityMutationVariables>;

/**
 * __useProfilePrivacyChangeDiscordIdVisibilityMutation__
 *
 * To run a mutation, you first call `useProfilePrivacyChangeDiscordIdVisibilityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfilePrivacyChangeDiscordIdVisibilityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profilePrivacyChangeDiscordIdVisibilityMutation, { data, loading, error }] = useProfilePrivacyChangeDiscordIdVisibilityMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      discordUsernameVisibility: // value for 'discordUsernameVisibility'
 *   },
 * });
 */
export function useProfilePrivacyChangeDiscordIdVisibilityMutation(baseOptions?: Apollo.MutationHookOptions<ProfilePrivacyChangeDiscordIdVisibilityMutation, ProfilePrivacyChangeDiscordIdVisibilityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProfilePrivacyChangeDiscordIdVisibilityMutation, ProfilePrivacyChangeDiscordIdVisibilityMutationVariables>(ProfilePrivacyChangeDiscordIdVisibilityDocument, options);
      }
export type ProfilePrivacyChangeDiscordIdVisibilityMutationHookResult = ReturnType<typeof useProfilePrivacyChangeDiscordIdVisibilityMutation>;
export type ProfilePrivacyChangeDiscordIdVisibilityMutationResult = Apollo.MutationResult<ProfilePrivacyChangeDiscordIdVisibilityMutation>;
export type ProfilePrivacyChangeDiscordIdVisibilityMutationOptions = Apollo.BaseMutationOptions<ProfilePrivacyChangeDiscordIdVisibilityMutation, ProfilePrivacyChangeDiscordIdVisibilityMutationVariables>;
export const ProfilePrivacyFriendSettingsDocument = gql`
    mutation ProfilePrivacyFriendSettings($userId: ID, $disableFriendRequests: Boolean) {
  updateFriendsSettings(
    userId: $userId
    body: {disableFriendRequests: $disableFriendRequests}
  ) {
    disableFriendRequests
  }
}
    `;
export type ProfilePrivacyFriendSettingsMutationFn = Apollo.MutationFunction<ProfilePrivacyFriendSettingsMutation, ProfilePrivacyFriendSettingsMutationVariables>;

/**
 * __useProfilePrivacyFriendSettingsMutation__
 *
 * To run a mutation, you first call `useProfilePrivacyFriendSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfilePrivacyFriendSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profilePrivacyFriendSettingsMutation, { data, loading, error }] = useProfilePrivacyFriendSettingsMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      disableFriendRequests: // value for 'disableFriendRequests'
 *   },
 * });
 */
export function useProfilePrivacyFriendSettingsMutation(baseOptions?: Apollo.MutationHookOptions<ProfilePrivacyFriendSettingsMutation, ProfilePrivacyFriendSettingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProfilePrivacyFriendSettingsMutation, ProfilePrivacyFriendSettingsMutationVariables>(ProfilePrivacyFriendSettingsDocument, options);
      }
export type ProfilePrivacyFriendSettingsMutationHookResult = ReturnType<typeof useProfilePrivacyFriendSettingsMutation>;
export type ProfilePrivacyFriendSettingsMutationResult = Apollo.MutationResult<ProfilePrivacyFriendSettingsMutation>;
export type ProfilePrivacyFriendSettingsMutationOptions = Apollo.BaseMutationOptions<ProfilePrivacyFriendSettingsMutation, ProfilePrivacyFriendSettingsMutationVariables>;
export const PrivacyConnectionsDataDocument = gql`
    query PrivacyConnectionsData($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ContentWarningSettingProfile
    ...PurchaseVisibilitySettingProfile
    ...DiscordUsernameSettingsProfile
    ...ProfilePageSettingsProfile
    ...FriendRequestSettingProfile
    ...OnlineStatusSettingProfile
  }
  blockedUsers(userId: $userId) {
    users {
      userId
      ...BlockedUsersFriendUser
    }
  }
}
    ${ContentWarningSettingProfileFragmentDoc}
${PurchaseVisibilitySettingProfileFragmentDoc}
${DiscordUsernameSettingsProfileFragmentDoc}
${ProfilePageSettingsProfileFragmentDoc}
${FriendRequestSettingProfileFragmentDoc}
${OnlineStatusSettingProfileFragmentDoc}
${BlockedUsersFriendUserFragmentDoc}`;

/**
 * __usePrivacyConnectionsDataQuery__
 *
 * To run a query within a React component, call `usePrivacyConnectionsDataQuery` and pass it any options that fit your needs.
 * When your component renders, `usePrivacyConnectionsDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePrivacyConnectionsDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function usePrivacyConnectionsDataQuery(baseOptions: Apollo.QueryHookOptions<PrivacyConnectionsDataQuery, PrivacyConnectionsDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PrivacyConnectionsDataQuery, PrivacyConnectionsDataQueryVariables>(PrivacyConnectionsDataDocument, options);
      }
export function usePrivacyConnectionsDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PrivacyConnectionsDataQuery, PrivacyConnectionsDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PrivacyConnectionsDataQuery, PrivacyConnectionsDataQueryVariables>(PrivacyConnectionsDataDocument, options);
        }
export type PrivacyConnectionsDataQueryHookResult = ReturnType<typeof usePrivacyConnectionsDataQuery>;
export type PrivacyConnectionsDataLazyQueryHookResult = ReturnType<typeof usePrivacyConnectionsDataLazyQuery>;
export type PrivacyConnectionsDataQueryResult = Apollo.QueryResult<PrivacyConnectionsDataQuery, PrivacyConnectionsDataQueryVariables>;
export const ProfilePrivacyChangeVisibilityDocument = gql`
    mutation ProfilePrivacyChangeVisibility($userId: ID, $visibility: ProfilePrivacySettingsVisibility) {
  updatePrivacySettings(userId: $userId, body: {visibility: $visibility}) {
    visibility
  }
}
    `;
export type ProfilePrivacyChangeVisibilityMutationFn = Apollo.MutationFunction<ProfilePrivacyChangeVisibilityMutation, ProfilePrivacyChangeVisibilityMutationVariables>;

/**
 * __useProfilePrivacyChangeVisibilityMutation__
 *
 * To run a mutation, you first call `useProfilePrivacyChangeVisibilityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfilePrivacyChangeVisibilityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profilePrivacyChangeVisibilityMutation, { data, loading, error }] = useProfilePrivacyChangeVisibilityMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      visibility: // value for 'visibility'
 *   },
 * });
 */
export function useProfilePrivacyChangeVisibilityMutation(baseOptions?: Apollo.MutationHookOptions<ProfilePrivacyChangeVisibilityMutation, ProfilePrivacyChangeVisibilityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProfilePrivacyChangeVisibilityMutation, ProfilePrivacyChangeVisibilityMutationVariables>(ProfilePrivacyChangeVisibilityDocument, options);
      }
export type ProfilePrivacyChangeVisibilityMutationHookResult = ReturnType<typeof useProfilePrivacyChangeVisibilityMutation>;
export type ProfilePrivacyChangeVisibilityMutationResult = Apollo.MutationResult<ProfilePrivacyChangeVisibilityMutation>;
export type ProfilePrivacyChangeVisibilityMutationOptions = Apollo.BaseMutationOptions<ProfilePrivacyChangeVisibilityMutation, ProfilePrivacyChangeVisibilityMutationVariables>;
export const ProfilePrivacyHidePurchaseVisibilityDocument = gql`
    mutation ProfilePrivacyHidePurchaseVisibility($userId: ID, $anonymisePurchaseHighlights: Boolean) {
  updatePrivacySettings(
    userId: $userId
    body: {anonymisePurchaseHighlights: $anonymisePurchaseHighlights}
  ) {
    anonymisePurchaseHighlights
  }
}
    `;
export type ProfilePrivacyHidePurchaseVisibilityMutationFn = Apollo.MutationFunction<ProfilePrivacyHidePurchaseVisibilityMutation, ProfilePrivacyHidePurchaseVisibilityMutationVariables>;

/**
 * __useProfilePrivacyHidePurchaseVisibilityMutation__
 *
 * To run a mutation, you first call `useProfilePrivacyHidePurchaseVisibilityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfilePrivacyHidePurchaseVisibilityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profilePrivacyHidePurchaseVisibilityMutation, { data, loading, error }] = useProfilePrivacyHidePurchaseVisibilityMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      anonymisePurchaseHighlights: // value for 'anonymisePurchaseHighlights'
 *   },
 * });
 */
export function useProfilePrivacyHidePurchaseVisibilityMutation(baseOptions?: Apollo.MutationHookOptions<ProfilePrivacyHidePurchaseVisibilityMutation, ProfilePrivacyHidePurchaseVisibilityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProfilePrivacyHidePurchaseVisibilityMutation, ProfilePrivacyHidePurchaseVisibilityMutationVariables>(ProfilePrivacyHidePurchaseVisibilityDocument, options);
      }
export type ProfilePrivacyHidePurchaseVisibilityMutationHookResult = ReturnType<typeof useProfilePrivacyHidePurchaseVisibilityMutation>;
export type ProfilePrivacyHidePurchaseVisibilityMutationResult = Apollo.MutationResult<ProfilePrivacyHidePurchaseVisibilityMutation>;
export type ProfilePrivacyHidePurchaseVisibilityMutationOptions = Apollo.BaseMutationOptions<ProfilePrivacyHidePurchaseVisibilityMutation, ProfilePrivacyHidePurchaseVisibilityMutationVariables>;
export const RequestOwnUserDataDocument = gql`
    mutation RequestOwnUserData {
  exportUserData {
    taskId
  }
}
    `;
export type RequestOwnUserDataMutationFn = Apollo.MutationFunction<RequestOwnUserDataMutation, RequestOwnUserDataMutationVariables>;

/**
 * __useRequestOwnUserDataMutation__
 *
 * To run a mutation, you first call `useRequestOwnUserDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRequestOwnUserDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [requestOwnUserDataMutation, { data, loading, error }] = useRequestOwnUserDataMutation({
 *   variables: {
 *   },
 * });
 */
export function useRequestOwnUserDataMutation(baseOptions?: Apollo.MutationHookOptions<RequestOwnUserDataMutation, RequestOwnUserDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RequestOwnUserDataMutation, RequestOwnUserDataMutationVariables>(RequestOwnUserDataDocument, options);
      }
export type RequestOwnUserDataMutationHookResult = ReturnType<typeof useRequestOwnUserDataMutation>;
export type RequestOwnUserDataMutationResult = Apollo.MutationResult<RequestOwnUserDataMutation>;
export type RequestOwnUserDataMutationOptions = Apollo.BaseMutationOptions<RequestOwnUserDataMutation, RequestOwnUserDataMutationVariables>;
export const ProfileInfoSettingsDocument = gql`
    query ProfileInfoSettings($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    canChangeUsernameAt
    usernameHistory(limit: 1) {
      reason
    }
  }
}
    `;

/**
 * __useProfileInfoSettingsQuery__
 *
 * To run a query within a React component, call `useProfileInfoSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileInfoSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileInfoSettingsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useProfileInfoSettingsQuery(baseOptions: Apollo.QueryHookOptions<ProfileInfoSettingsQuery, ProfileInfoSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileInfoSettingsQuery, ProfileInfoSettingsQueryVariables>(ProfileInfoSettingsDocument, options);
      }
export function useProfileInfoSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileInfoSettingsQuery, ProfileInfoSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileInfoSettingsQuery, ProfileInfoSettingsQueryVariables>(ProfileInfoSettingsDocument, options);
        }
export type ProfileInfoSettingsQueryHookResult = ReturnType<typeof useProfileInfoSettingsQuery>;
export type ProfileInfoSettingsLazyQueryHookResult = ReturnType<typeof useProfileInfoSettingsLazyQuery>;
export type ProfileInfoSettingsQueryResult = Apollo.QueryResult<ProfileInfoSettingsQuery, ProfileInfoSettingsQueryVariables>;
export const ProfileSettingUpdateUsernameDocument = gql`
    mutation ProfileSettingUpdateUsername($userId: ID!, $userTag: String!) {
  updateProfile(body: {userId: $userId, userTag: $userTag}) {
    userId
    userTag
    canChangeUsernameAt
    usernameHistory(limit: 1) {
      reason
    }
  }
}
    `;
export type ProfileSettingUpdateUsernameMutationFn = Apollo.MutationFunction<ProfileSettingUpdateUsernameMutation, ProfileSettingUpdateUsernameMutationVariables>;

/**
 * __useProfileSettingUpdateUsernameMutation__
 *
 * To run a mutation, you first call `useProfileSettingUpdateUsernameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfileSettingUpdateUsernameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profileSettingUpdateUsernameMutation, { data, loading, error }] = useProfileSettingUpdateUsernameMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      userTag: // value for 'userTag'
 *   },
 * });
 */
export function useProfileSettingUpdateUsernameMutation(baseOptions?: Apollo.MutationHookOptions<ProfileSettingUpdateUsernameMutation, ProfileSettingUpdateUsernameMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProfileSettingUpdateUsernameMutation, ProfileSettingUpdateUsernameMutationVariables>(ProfileSettingUpdateUsernameDocument, options);
      }
export type ProfileSettingUpdateUsernameMutationHookResult = ReturnType<typeof useProfileSettingUpdateUsernameMutation>;
export type ProfileSettingUpdateUsernameMutationResult = Apollo.MutationResult<ProfileSettingUpdateUsernameMutation>;
export type ProfileSettingUpdateUsernameMutationOptions = Apollo.BaseMutationOptions<ProfileSettingUpdateUsernameMutation, ProfileSettingUpdateUsernameMutationVariables>;
export const SubscriptionItemBadgeDocument = gql`
    query SubscriptionItemBadge($channelId: ID!, $userId: ID!) {
  profile(userId: $userId) {
    userId
    badges(channel_id: $channelId) {
      level
      ...UserBadge
    }
  }
}
    ${UserBadgeFragmentDoc}`;

/**
 * __useSubscriptionItemBadgeQuery__
 *
 * To run a query within a React component, call `useSubscriptionItemBadgeQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionItemBadgeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionItemBadgeQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSubscriptionItemBadgeQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionItemBadgeQuery, SubscriptionItemBadgeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionItemBadgeQuery, SubscriptionItemBadgeQueryVariables>(SubscriptionItemBadgeDocument, options);
      }
export function useSubscriptionItemBadgeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionItemBadgeQuery, SubscriptionItemBadgeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionItemBadgeQuery, SubscriptionItemBadgeQueryVariables>(SubscriptionItemBadgeDocument, options);
        }
export type SubscriptionItemBadgeQueryHookResult = ReturnType<typeof useSubscriptionItemBadgeQuery>;
export type SubscriptionItemBadgeLazyQueryHookResult = ReturnType<typeof useSubscriptionItemBadgeLazyQuery>;
export type SubscriptionItemBadgeQueryResult = Apollo.QueryResult<SubscriptionItemBadgeQuery, SubscriptionItemBadgeQueryVariables>;
export const SubscriptionsSettingListDocument = gql`
    query SubscriptionsSettingList($userId: ID!, $cursor: String) {
  userChannelSubscriptions(
    userId: $userId
    filters: [{state: STATE_ACTIVE}, {state: STATE_CANCELLED}]
    cursor: {first: 5, after: $cursor}
  ) {
    subscriptions {
      id
      ...SubscriptionSettingItemSubscription
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
    ${SubscriptionSettingItemSubscriptionFragmentDoc}`;

/**
 * __useSubscriptionsSettingListQuery__
 *
 * To run a query within a React component, call `useSubscriptionsSettingListQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionsSettingListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionsSettingListQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useSubscriptionsSettingListQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionsSettingListQuery, SubscriptionsSettingListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionsSettingListQuery, SubscriptionsSettingListQueryVariables>(SubscriptionsSettingListDocument, options);
      }
export function useSubscriptionsSettingListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionsSettingListQuery, SubscriptionsSettingListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionsSettingListQuery, SubscriptionsSettingListQueryVariables>(SubscriptionsSettingListDocument, options);
        }
export type SubscriptionsSettingListQueryHookResult = ReturnType<typeof useSubscriptionsSettingListQuery>;
export type SubscriptionsSettingListLazyQueryHookResult = ReturnType<typeof useSubscriptionsSettingListLazyQuery>;
export type SubscriptionsSettingListQueryResult = Apollo.QueryResult<SubscriptionsSettingListQuery, SubscriptionsSettingListQueryVariables>;
export const SubscriptionsSettingInactiveListDocument = gql`
    query SubscriptionsSettingInactiveList($userId: ID!, $cursor: String) {
  userChannelSubscriptions(
    userId: $userId
    filters: [{state: STATE_EXPIRED}]
    cursor: {first: 5, after: $cursor}
  ) {
    subscriptions {
      id
      ...SubscriptionSettingItemSubscription
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
    ${SubscriptionSettingItemSubscriptionFragmentDoc}`;

/**
 * __useSubscriptionsSettingInactiveListQuery__
 *
 * To run a query within a React component, call `useSubscriptionsSettingInactiveListQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionsSettingInactiveListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionsSettingInactiveListQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useSubscriptionsSettingInactiveListQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionsSettingInactiveListQuery, SubscriptionsSettingInactiveListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionsSettingInactiveListQuery, SubscriptionsSettingInactiveListQueryVariables>(SubscriptionsSettingInactiveListDocument, options);
      }
export function useSubscriptionsSettingInactiveListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionsSettingInactiveListQuery, SubscriptionsSettingInactiveListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionsSettingInactiveListQuery, SubscriptionsSettingInactiveListQueryVariables>(SubscriptionsSettingInactiveListDocument, options);
        }
export type SubscriptionsSettingInactiveListQueryHookResult = ReturnType<typeof useSubscriptionsSettingInactiveListQuery>;
export type SubscriptionsSettingInactiveListLazyQueryHookResult = ReturnType<typeof useSubscriptionsSettingInactiveListLazyQuery>;
export type SubscriptionsSettingInactiveListQueryResult = Apollo.QueryResult<SubscriptionsSettingInactiveListQuery, SubscriptionsSettingInactiveListQueryVariables>;
export const PaymentReceiptDocument = gql`
    query PaymentReceipt($paymentId: ID!) {
  payment(id: $paymentId) {
    id
    items {
      description
    }
    timestamp
    info {
      cardHolderName
      cardSummary
    }
    amount {
      currency
      value
    }
    tax {
      rate
      rateInBasisPoints
      amount {
        currency
        value
      }
    }
    status
  }
}
    `;

/**
 * __usePaymentReceiptQuery__
 *
 * To run a query within a React component, call `usePaymentReceiptQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentReceiptQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentReceiptQuery({
 *   variables: {
 *      paymentId: // value for 'paymentId'
 *   },
 * });
 */
export function usePaymentReceiptQuery(baseOptions: Apollo.QueryHookOptions<PaymentReceiptQuery, PaymentReceiptQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentReceiptQuery, PaymentReceiptQueryVariables>(PaymentReceiptDocument, options);
      }
export function usePaymentReceiptLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentReceiptQuery, PaymentReceiptQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentReceiptQuery, PaymentReceiptQueryVariables>(PaymentReceiptDocument, options);
        }
export type PaymentReceiptQueryHookResult = ReturnType<typeof usePaymentReceiptQuery>;
export type PaymentReceiptLazyQueryHookResult = ReturnType<typeof usePaymentReceiptLazyQuery>;
export type PaymentReceiptQueryResult = Apollo.QueryResult<PaymentReceiptQuery, PaymentReceiptQueryVariables>;
export const SettingsWalletPaymentsDocument = gql`
    query SettingsWalletPayments($userId: ID, $cursor: APICursorInput) {
  payments(
    userId: $userId
    cursor: $cursor
    filter: {statuses: [PAYMENT_STATUS_REVERSED, PAYMENT_STATUS_SUCCESS]}
  ) {
    pageInfo {
      endCursor
      hasNextPage
      hasPreviousPage
      startCursor
    }
    payments {
      id
      ...WalletPaymentsPayment
    }
  }
}
    ${WalletPaymentsPaymentFragmentDoc}`;

/**
 * __useSettingsWalletPaymentsQuery__
 *
 * To run a query within a React component, call `useSettingsWalletPaymentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSettingsWalletPaymentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSettingsWalletPaymentsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useSettingsWalletPaymentsQuery(baseOptions?: Apollo.QueryHookOptions<SettingsWalletPaymentsQuery, SettingsWalletPaymentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SettingsWalletPaymentsQuery, SettingsWalletPaymentsQueryVariables>(SettingsWalletPaymentsDocument, options);
      }
export function useSettingsWalletPaymentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SettingsWalletPaymentsQuery, SettingsWalletPaymentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SettingsWalletPaymentsQuery, SettingsWalletPaymentsQueryVariables>(SettingsWalletPaymentsDocument, options);
        }
export type SettingsWalletPaymentsQueryHookResult = ReturnType<typeof useSettingsWalletPaymentsQuery>;
export type SettingsWalletPaymentsLazyQueryHookResult = ReturnType<typeof useSettingsWalletPaymentsLazyQuery>;
export type SettingsWalletPaymentsQueryResult = Apollo.QueryResult<SettingsWalletPaymentsQuery, SettingsWalletPaymentsQueryVariables>;
export const ProfilePagePathDocument = gql`
    query ProfilePagePath($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
  }
}
    `;

/**
 * __useProfilePagePathQuery__
 *
 * To run a query within a React component, call `useProfilePagePathQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfilePagePathQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfilePagePathQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useProfilePagePathQuery(baseOptions: Apollo.QueryHookOptions<ProfilePagePathQuery, ProfilePagePathQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfilePagePathQuery, ProfilePagePathQueryVariables>(ProfilePagePathDocument, options);
      }
export function useProfilePagePathLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfilePagePathQuery, ProfilePagePathQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfilePagePathQuery, ProfilePagePathQueryVariables>(ProfilePagePathDocument, options);
        }
export type ProfilePagePathQueryHookResult = ReturnType<typeof useProfilePagePathQuery>;
export type ProfilePagePathLazyQueryHookResult = ReturnType<typeof useProfilePagePathLazyQuery>;
export type ProfilePagePathQueryResult = Apollo.QueryResult<ProfilePagePathQuery, ProfilePagePathQueryVariables>;
export const SignupStagesCompletedProfileDocument = gql`
    query SignupStagesCompletedProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...CompleteAccountCheckProfile
  }
}
    ${CompleteAccountCheckProfileFragmentDoc}`;

/**
 * __useSignupStagesCompletedProfileQuery__
 *
 * To run a query within a React component, call `useSignupStagesCompletedProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useSignupStagesCompletedProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSignupStagesCompletedProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSignupStagesCompletedProfileQuery(baseOptions: Apollo.QueryHookOptions<SignupStagesCompletedProfileQuery, SignupStagesCompletedProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SignupStagesCompletedProfileQuery, SignupStagesCompletedProfileQueryVariables>(SignupStagesCompletedProfileDocument, options);
      }
export function useSignupStagesCompletedProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SignupStagesCompletedProfileQuery, SignupStagesCompletedProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SignupStagesCompletedProfileQuery, SignupStagesCompletedProfileQueryVariables>(SignupStagesCompletedProfileDocument, options);
        }
export type SignupStagesCompletedProfileQueryHookResult = ReturnType<typeof useSignupStagesCompletedProfileQuery>;
export type SignupStagesCompletedProfileLazyQueryHookResult = ReturnType<typeof useSignupStagesCompletedProfileLazyQuery>;
export type SignupStagesCompletedProfileQueryResult = Apollo.QueryResult<SignupStagesCompletedProfileQuery, SignupStagesCompletedProfileQueryVariables>;
export const StorePageStoreFrontDocument = gql`
    query StorePageStoreFront($gameID: ID!) {
  platformStoreFront(gameId: $gameID) {
    id
    gameId
    categories {
      id
      ...StoreFrontCategoriesCategory
    }
  }
}
    ${StoreFrontCategoriesCategoryFragmentDoc}`;

/**
 * __useStorePageStoreFrontQuery__
 *
 * To run a query within a React component, call `useStorePageStoreFrontQuery` and pass it any options that fit your needs.
 * When your component renders, `useStorePageStoreFrontQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStorePageStoreFrontQuery({
 *   variables: {
 *      gameID: // value for 'gameID'
 *   },
 * });
 */
export function useStorePageStoreFrontQuery(baseOptions: Apollo.QueryHookOptions<StorePageStoreFrontQuery, StorePageStoreFrontQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StorePageStoreFrontQuery, StorePageStoreFrontQueryVariables>(StorePageStoreFrontDocument, options);
      }
export function useStorePageStoreFrontLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StorePageStoreFrontQuery, StorePageStoreFrontQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StorePageStoreFrontQuery, StorePageStoreFrontQueryVariables>(StorePageStoreFrontDocument, options);
        }
export type StorePageStoreFrontQueryHookResult = ReturnType<typeof useStorePageStoreFrontQuery>;
export type StorePageStoreFrontLazyQueryHookResult = ReturnType<typeof useStorePageStoreFrontLazyQuery>;
export type StorePageStoreFrontQueryResult = Apollo.QueryResult<StorePageStoreFrontQuery, StorePageStoreFrontQueryVariables>;
export const StorePageUserDataDocument = gql`
    query StorePageUserData($userId: ID!) {
  followedChannels(userId: $userId) {
    channels {
      id
      ...StoreChannelListChannel
    }
  }
  profile(userId: $userId) {
    userId
    ...StoreFrontCategoryProfile
  }
}
    ${StoreChannelListChannelFragmentDoc}
${StoreFrontCategoryProfileFragmentDoc}`;

/**
 * __useStorePageUserDataQuery__
 *
 * To run a query within a React component, call `useStorePageUserDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useStorePageUserDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStorePageUserDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useStorePageUserDataQuery(baseOptions: Apollo.QueryHookOptions<StorePageUserDataQuery, StorePageUserDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StorePageUserDataQuery, StorePageUserDataQueryVariables>(StorePageUserDataDocument, options);
      }
export function useStorePageUserDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StorePageUserDataQuery, StorePageUserDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StorePageUserDataQuery, StorePageUserDataQueryVariables>(StorePageUserDataDocument, options);
        }
export type StorePageUserDataQueryHookResult = ReturnType<typeof useStorePageUserDataQuery>;
export type StorePageUserDataLazyQueryHookResult = ReturnType<typeof useStorePageUserDataLazyQuery>;
export type StorePageUserDataQueryResult = Apollo.QueryResult<StorePageUserDataQuery, StorePageUserDataQueryVariables>;
export const StorePageCurrentChannelDocument = gql`
    query StorePageCurrentChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    ...StoreChannelListChannel
  }
}
    ${StoreChannelListChannelFragmentDoc}`;

/**
 * __useStorePageCurrentChannelQuery__
 *
 * To run a query within a React component, call `useStorePageCurrentChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useStorePageCurrentChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStorePageCurrentChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStorePageCurrentChannelQuery(baseOptions: Apollo.QueryHookOptions<StorePageCurrentChannelQuery, StorePageCurrentChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StorePageCurrentChannelQuery, StorePageCurrentChannelQueryVariables>(StorePageCurrentChannelDocument, options);
      }
export function useStorePageCurrentChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StorePageCurrentChannelQuery, StorePageCurrentChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StorePageCurrentChannelQuery, StorePageCurrentChannelQueryVariables>(StorePageCurrentChannelDocument, options);
        }
export type StorePageCurrentChannelQueryHookResult = ReturnType<typeof useStorePageCurrentChannelQuery>;
export type StorePageCurrentChannelLazyQueryHookResult = ReturnType<typeof useStorePageCurrentChannelLazyQuery>;
export type StorePageCurrentChannelQueryResult = Apollo.QueryResult<StorePageCurrentChannelQuery, StorePageCurrentChannelQueryVariables>;
export const PlatformStoreRedirectProfileDocument = gql`
    query PlatformStoreRedirectProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    playedGames {
      id
      userId
    }
  }
}
    `;

/**
 * __usePlatformStoreRedirectProfileQuery__
 *
 * To run a query within a React component, call `usePlatformStoreRedirectProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlatformStoreRedirectProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlatformStoreRedirectProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function usePlatformStoreRedirectProfileQuery(baseOptions: Apollo.QueryHookOptions<PlatformStoreRedirectProfileQuery, PlatformStoreRedirectProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlatformStoreRedirectProfileQuery, PlatformStoreRedirectProfileQueryVariables>(PlatformStoreRedirectProfileDocument, options);
      }
export function usePlatformStoreRedirectProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlatformStoreRedirectProfileQuery, PlatformStoreRedirectProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlatformStoreRedirectProfileQuery, PlatformStoreRedirectProfileQueryVariables>(PlatformStoreRedirectProfileDocument, options);
        }
export type PlatformStoreRedirectProfileQueryHookResult = ReturnType<typeof usePlatformStoreRedirectProfileQuery>;
export type PlatformStoreRedirectProfileLazyQueryHookResult = ReturnType<typeof usePlatformStoreRedirectProfileLazyQuery>;
export type PlatformStoreRedirectProfileQueryResult = Apollo.QueryResult<PlatformStoreRedirectProfileQuery, PlatformStoreRedirectProfileQueryVariables>;
export const GetMatchEndDailyBoostDocument = gql`
    query GetMatchEndDailyBoost {
  dailyXPBoostLimit {
    remainingDailyXpBoost
  }
}
    `;

/**
 * __useGetMatchEndDailyBoostQuery__
 *
 * To run a query within a React component, call `useGetMatchEndDailyBoostQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMatchEndDailyBoostQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMatchEndDailyBoostQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetMatchEndDailyBoostQuery(baseOptions?: Apollo.QueryHookOptions<GetMatchEndDailyBoostQuery, GetMatchEndDailyBoostQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMatchEndDailyBoostQuery, GetMatchEndDailyBoostQueryVariables>(GetMatchEndDailyBoostDocument, options);
      }
export function useGetMatchEndDailyBoostLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMatchEndDailyBoostQuery, GetMatchEndDailyBoostQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMatchEndDailyBoostQuery, GetMatchEndDailyBoostQueryVariables>(GetMatchEndDailyBoostDocument, options);
        }
export type GetMatchEndDailyBoostQueryHookResult = ReturnType<typeof useGetMatchEndDailyBoostQuery>;
export type GetMatchEndDailyBoostLazyQueryHookResult = ReturnType<typeof useGetMatchEndDailyBoostLazyQuery>;
export type GetMatchEndDailyBoostQueryResult = Apollo.QueryResult<GetMatchEndDailyBoostQuery, GetMatchEndDailyBoostQueryVariables>;
export const GetMatchEndLevelThresholdsDocument = gql`
    query GetMatchEndLevelThresholds($seasonId: ID!, $startLevel: Int!, $endLevel: Int!) {
  listLevelConfigs(
    seasonId: $seasonId
    minLevel: $startLevel
    maxLevel: $endLevel
  ) {
    levelConfigs {
      ...MatchEndLevelThresholds
    }
  }
}
    ${MatchEndLevelThresholdsFragmentDoc}`;

/**
 * __useGetMatchEndLevelThresholdsQuery__
 *
 * To run a query within a React component, call `useGetMatchEndLevelThresholdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMatchEndLevelThresholdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMatchEndLevelThresholdsQuery({
 *   variables: {
 *      seasonId: // value for 'seasonId'
 *      startLevel: // value for 'startLevel'
 *      endLevel: // value for 'endLevel'
 *   },
 * });
 */
export function useGetMatchEndLevelThresholdsQuery(baseOptions: Apollo.QueryHookOptions<GetMatchEndLevelThresholdsQuery, GetMatchEndLevelThresholdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMatchEndLevelThresholdsQuery, GetMatchEndLevelThresholdsQueryVariables>(GetMatchEndLevelThresholdsDocument, options);
      }
export function useGetMatchEndLevelThresholdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMatchEndLevelThresholdsQuery, GetMatchEndLevelThresholdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMatchEndLevelThresholdsQuery, GetMatchEndLevelThresholdsQueryVariables>(GetMatchEndLevelThresholdsDocument, options);
        }
export type GetMatchEndLevelThresholdsQueryHookResult = ReturnType<typeof useGetMatchEndLevelThresholdsQuery>;
export type GetMatchEndLevelThresholdsLazyQueryHookResult = ReturnType<typeof useGetMatchEndLevelThresholdsLazyQuery>;
export type GetMatchEndLevelThresholdsQueryResult = Apollo.QueryResult<GetMatchEndLevelThresholdsQuery, GetMatchEndLevelThresholdsQueryVariables>;
export const GetMatchEndPlayerLevelDocument = gql`
    query GetMatchEndPlayerLevel($userId: ID!, $seasonId: ID!) {
  seasonProgression(userId: $userId, seasonId: $seasonId) {
    ...MatchEndPlayerLevel
  }
}
    ${MatchEndPlayerLevelFragmentDoc}`;

/**
 * __useGetMatchEndPlayerLevelQuery__
 *
 * To run a query within a React component, call `useGetMatchEndPlayerLevelQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMatchEndPlayerLevelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMatchEndPlayerLevelQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useGetMatchEndPlayerLevelQuery(baseOptions: Apollo.QueryHookOptions<GetMatchEndPlayerLevelQuery, GetMatchEndPlayerLevelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMatchEndPlayerLevelQuery, GetMatchEndPlayerLevelQueryVariables>(GetMatchEndPlayerLevelDocument, options);
      }
export function useGetMatchEndPlayerLevelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMatchEndPlayerLevelQuery, GetMatchEndPlayerLevelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMatchEndPlayerLevelQuery, GetMatchEndPlayerLevelQueryVariables>(GetMatchEndPlayerLevelDocument, options);
        }
export type GetMatchEndPlayerLevelQueryHookResult = ReturnType<typeof useGetMatchEndPlayerLevelQuery>;
export type GetMatchEndPlayerLevelLazyQueryHookResult = ReturnType<typeof useGetMatchEndPlayerLevelLazyQuery>;
export type GetMatchEndPlayerLevelQueryResult = Apollo.QueryResult<GetMatchEndPlayerLevelQuery, GetMatchEndPlayerLevelQueryVariables>;
export const MatchResultsDialogBestPlayGameCardsDocument = gql`
    query MatchResultsDialogBestPlayGameCards($cardIds: [String!]) {
  gameCards(cardIds: $cardIds) {
    cards {
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useMatchResultsDialogBestPlayGameCardsQuery__
 *
 * To run a query within a React component, call `useMatchResultsDialogBestPlayGameCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchResultsDialogBestPlayGameCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchResultsDialogBestPlayGameCardsQuery({
 *   variables: {
 *      cardIds: // value for 'cardIds'
 *   },
 * });
 */
export function useMatchResultsDialogBestPlayGameCardsQuery(baseOptions?: Apollo.QueryHookOptions<MatchResultsDialogBestPlayGameCardsQuery, MatchResultsDialogBestPlayGameCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchResultsDialogBestPlayGameCardsQuery, MatchResultsDialogBestPlayGameCardsQueryVariables>(MatchResultsDialogBestPlayGameCardsDocument, options);
      }
export function useMatchResultsDialogBestPlayGameCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchResultsDialogBestPlayGameCardsQuery, MatchResultsDialogBestPlayGameCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchResultsDialogBestPlayGameCardsQuery, MatchResultsDialogBestPlayGameCardsQueryVariables>(MatchResultsDialogBestPlayGameCardsDocument, options);
        }
export type MatchResultsDialogBestPlayGameCardsQueryHookResult = ReturnType<typeof useMatchResultsDialogBestPlayGameCardsQuery>;
export type MatchResultsDialogBestPlayGameCardsLazyQueryHookResult = ReturnType<typeof useMatchResultsDialogBestPlayGameCardsLazyQuery>;
export type MatchResultsDialogBestPlayGameCardsQueryResult = Apollo.QueryResult<MatchResultsDialogBestPlayGameCardsQuery, MatchResultsDialogBestPlayGameCardsQueryVariables>;
export const MatchResultsDialogBestPlayProfilesDocument = gql`
    query MatchResultsDialogBestPlayProfiles($userIds: [String!]) {
  profileBatch(userIds: $userIds) {
    profiles {
      userId
      ...ProfileImageProfile
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useMatchResultsDialogBestPlayProfilesQuery__
 *
 * To run a query within a React component, call `useMatchResultsDialogBestPlayProfilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchResultsDialogBestPlayProfilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchResultsDialogBestPlayProfilesQuery({
 *   variables: {
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useMatchResultsDialogBestPlayProfilesQuery(baseOptions?: Apollo.QueryHookOptions<MatchResultsDialogBestPlayProfilesQuery, MatchResultsDialogBestPlayProfilesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchResultsDialogBestPlayProfilesQuery, MatchResultsDialogBestPlayProfilesQueryVariables>(MatchResultsDialogBestPlayProfilesDocument, options);
      }
export function useMatchResultsDialogBestPlayProfilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchResultsDialogBestPlayProfilesQuery, MatchResultsDialogBestPlayProfilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchResultsDialogBestPlayProfilesQuery, MatchResultsDialogBestPlayProfilesQueryVariables>(MatchResultsDialogBestPlayProfilesDocument, options);
        }
export type MatchResultsDialogBestPlayProfilesQueryHookResult = ReturnType<typeof useMatchResultsDialogBestPlayProfilesQuery>;
export type MatchResultsDialogBestPlayProfilesLazyQueryHookResult = ReturnType<typeof useMatchResultsDialogBestPlayProfilesLazyQuery>;
export type MatchResultsDialogBestPlayProfilesQueryResult = Apollo.QueryResult<MatchResultsDialogBestPlayProfilesQuery, MatchResultsDialogBestPlayProfilesQueryVariables>;
export const MatchResultsDialogPlayerScoresProfileDocument = gql`
    query MatchResultsDialogPlayerScoresProfile($userIds: [String!]) {
  profileBatch(userIds: $userIds) {
    profiles {
      userId
      ...ProfileImageProfile
      avatars {
        avatarFullbody
      }
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useMatchResultsDialogPlayerScoresProfileQuery__
 *
 * To run a query within a React component, call `useMatchResultsDialogPlayerScoresProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchResultsDialogPlayerScoresProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchResultsDialogPlayerScoresProfileQuery({
 *   variables: {
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useMatchResultsDialogPlayerScoresProfileQuery(baseOptions?: Apollo.QueryHookOptions<MatchResultsDialogPlayerScoresProfileQuery, MatchResultsDialogPlayerScoresProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchResultsDialogPlayerScoresProfileQuery, MatchResultsDialogPlayerScoresProfileQueryVariables>(MatchResultsDialogPlayerScoresProfileDocument, options);
      }
export function useMatchResultsDialogPlayerScoresProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchResultsDialogPlayerScoresProfileQuery, MatchResultsDialogPlayerScoresProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchResultsDialogPlayerScoresProfileQuery, MatchResultsDialogPlayerScoresProfileQueryVariables>(MatchResultsDialogPlayerScoresProfileDocument, options);
        }
export type MatchResultsDialogPlayerScoresProfileQueryHookResult = ReturnType<typeof useMatchResultsDialogPlayerScoresProfileQuery>;
export type MatchResultsDialogPlayerScoresProfileLazyQueryHookResult = ReturnType<typeof useMatchResultsDialogPlayerScoresProfileLazyQuery>;
export type MatchResultsDialogPlayerScoresProfileQueryResult = Apollo.QueryResult<MatchResultsDialogPlayerScoresProfileQuery, MatchResultsDialogPlayerScoresProfileQueryVariables>;
export const MatchResultsDialogRewardsGameDocument = gql`
    query MatchResultsDialogRewardsGame($gameId: ID, $userId: ID) {
  game(id: $gameId) {
    id
    name
    activeSeason {
      id
      name
      progression(user_id: $userId) {
        level
      }
    }
  }
}
    `;

/**
 * __useMatchResultsDialogRewardsGameQuery__
 *
 * To run a query within a React component, call `useMatchResultsDialogRewardsGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchResultsDialogRewardsGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchResultsDialogRewardsGameQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useMatchResultsDialogRewardsGameQuery(baseOptions?: Apollo.QueryHookOptions<MatchResultsDialogRewardsGameQuery, MatchResultsDialogRewardsGameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchResultsDialogRewardsGameQuery, MatchResultsDialogRewardsGameQueryVariables>(MatchResultsDialogRewardsGameDocument, options);
      }
export function useMatchResultsDialogRewardsGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchResultsDialogRewardsGameQuery, MatchResultsDialogRewardsGameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchResultsDialogRewardsGameQuery, MatchResultsDialogRewardsGameQueryVariables>(MatchResultsDialogRewardsGameDocument, options);
        }
export type MatchResultsDialogRewardsGameQueryHookResult = ReturnType<typeof useMatchResultsDialogRewardsGameQuery>;
export type MatchResultsDialogRewardsGameLazyQueryHookResult = ReturnType<typeof useMatchResultsDialogRewardsGameLazyQuery>;
export type MatchResultsDialogRewardsGameQueryResult = Apollo.QueryResult<MatchResultsDialogRewardsGameQuery, MatchResultsDialogRewardsGameQueryVariables>;
export const MatchResultsSummaryPlayerScoresProfileDocument = gql`
    query MatchResultsSummaryPlayerScoresProfile($userIds: [String!]) {
  profileBatch(userIds: $userIds) {
    profiles {
      userId
      ...MatchResultsSummaryPlayerScoreProfile
    }
  }
}
    ${MatchResultsSummaryPlayerScoreProfileFragmentDoc}`;

/**
 * __useMatchResultsSummaryPlayerScoresProfileQuery__
 *
 * To run a query within a React component, call `useMatchResultsSummaryPlayerScoresProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchResultsSummaryPlayerScoresProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchResultsSummaryPlayerScoresProfileQuery({
 *   variables: {
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useMatchResultsSummaryPlayerScoresProfileQuery(baseOptions?: Apollo.QueryHookOptions<MatchResultsSummaryPlayerScoresProfileQuery, MatchResultsSummaryPlayerScoresProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchResultsSummaryPlayerScoresProfileQuery, MatchResultsSummaryPlayerScoresProfileQueryVariables>(MatchResultsSummaryPlayerScoresProfileDocument, options);
      }
export function useMatchResultsSummaryPlayerScoresProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchResultsSummaryPlayerScoresProfileQuery, MatchResultsSummaryPlayerScoresProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchResultsSummaryPlayerScoresProfileQuery, MatchResultsSummaryPlayerScoresProfileQueryVariables>(MatchResultsSummaryPlayerScoresProfileDocument, options);
        }
export type MatchResultsSummaryPlayerScoresProfileQueryHookResult = ReturnType<typeof useMatchResultsSummaryPlayerScoresProfileQuery>;
export type MatchResultsSummaryPlayerScoresProfileLazyQueryHookResult = ReturnType<typeof useMatchResultsSummaryPlayerScoresProfileLazyQuery>;
export type MatchResultsSummaryPlayerScoresProfileQueryResult = Apollo.QueryResult<MatchResultsSummaryPlayerScoresProfileQuery, MatchResultsSummaryPlayerScoresProfileQueryVariables>;
export const MatchGroupWaitingLgPlayersDocument = gql`
    query MatchGroupWaitingLgPlayers($playerIds: [String!]!) {
  profileBatch(userIds: $playerIds) {
    profiles {
      userId
      ...CardRowAvatarProfile
    }
  }
}
    ${CardRowAvatarProfileFragmentDoc}`;

/**
 * __useMatchGroupWaitingLgPlayersQuery__
 *
 * To run a query within a React component, call `useMatchGroupWaitingLgPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchGroupWaitingLgPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchGroupWaitingLgPlayersQuery({
 *   variables: {
 *      playerIds: // value for 'playerIds'
 *   },
 * });
 */
export function useMatchGroupWaitingLgPlayersQuery(baseOptions: Apollo.QueryHookOptions<MatchGroupWaitingLgPlayersQuery, MatchGroupWaitingLgPlayersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchGroupWaitingLgPlayersQuery, MatchGroupWaitingLgPlayersQueryVariables>(MatchGroupWaitingLgPlayersDocument, options);
      }
export function useMatchGroupWaitingLgPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchGroupWaitingLgPlayersQuery, MatchGroupWaitingLgPlayersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchGroupWaitingLgPlayersQuery, MatchGroupWaitingLgPlayersQueryVariables>(MatchGroupWaitingLgPlayersDocument, options);
        }
export type MatchGroupWaitingLgPlayersQueryHookResult = ReturnType<typeof useMatchGroupWaitingLgPlayersQuery>;
export type MatchGroupWaitingLgPlayersLazyQueryHookResult = ReturnType<typeof useMatchGroupWaitingLgPlayersLazyQuery>;
export type MatchGroupWaitingLgPlayersQueryResult = Apollo.QueryResult<MatchGroupWaitingLgPlayersQuery, MatchGroupWaitingLgPlayersQueryVariables>;
export const BestPlaysDataDocument = gql`
    query BestPlaysData($cardIds: [String!]!, $userIds: [String!]!) {
  gameCards(cardIds: $cardIds) {
    cards {
      ...GameCard
    }
  }
  profileBatch(userIds: $userIds) {
    profiles {
      ...BestPlayProfile
    }
  }
}
    ${GameCardFragmentDoc}
${BestPlayProfileFragmentDoc}`;

/**
 * __useBestPlaysDataQuery__
 *
 * To run a query within a React component, call `useBestPlaysDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useBestPlaysDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBestPlaysDataQuery({
 *   variables: {
 *      cardIds: // value for 'cardIds'
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useBestPlaysDataQuery(baseOptions: Apollo.QueryHookOptions<BestPlaysDataQuery, BestPlaysDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BestPlaysDataQuery, BestPlaysDataQueryVariables>(BestPlaysDataDocument, options);
      }
export function useBestPlaysDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BestPlaysDataQuery, BestPlaysDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BestPlaysDataQuery, BestPlaysDataQueryVariables>(BestPlaysDataDocument, options);
        }
export type BestPlaysDataQueryHookResult = ReturnType<typeof useBestPlaysDataQuery>;
export type BestPlaysDataLazyQueryHookResult = ReturnType<typeof useBestPlaysDataLazyQuery>;
export type BestPlaysDataQueryResult = Apollo.QueryResult<BestPlaysDataQuery, BestPlaysDataQueryVariables>;
export const DisplayBottomLgPlayerDocument = gql`
    query DisplayBottomLgPlayer($playerId: ID!) {
  profile(userId: $playerId) {
    userId
    ...CardRowAvatarProfile
    ...PlayerScoreProfile
  }
}
    ${CardRowAvatarProfileFragmentDoc}
${PlayerScoreProfileFragmentDoc}`;

/**
 * __useDisplayBottomLgPlayerQuery__
 *
 * To run a query within a React component, call `useDisplayBottomLgPlayerQuery` and pass it any options that fit your needs.
 * When your component renders, `useDisplayBottomLgPlayerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDisplayBottomLgPlayerQuery({
 *   variables: {
 *      playerId: // value for 'playerId'
 *   },
 * });
 */
export function useDisplayBottomLgPlayerQuery(baseOptions: Apollo.QueryHookOptions<DisplayBottomLgPlayerQuery, DisplayBottomLgPlayerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DisplayBottomLgPlayerQuery, DisplayBottomLgPlayerQueryVariables>(DisplayBottomLgPlayerDocument, options);
      }
export function useDisplayBottomLgPlayerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DisplayBottomLgPlayerQuery, DisplayBottomLgPlayerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DisplayBottomLgPlayerQuery, DisplayBottomLgPlayerQueryVariables>(DisplayBottomLgPlayerDocument, options);
        }
export type DisplayBottomLgPlayerQueryHookResult = ReturnType<typeof useDisplayBottomLgPlayerQuery>;
export type DisplayBottomLgPlayerLazyQueryHookResult = ReturnType<typeof useDisplayBottomLgPlayerLazyQuery>;
export type DisplayBottomLgPlayerQueryResult = Apollo.QueryResult<DisplayBottomLgPlayerQuery, DisplayBottomLgPlayerQueryVariables>;
export const AllOrNothingDialogCardDocument = gql`
    query AllOrNothingDialogCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useAllOrNothingDialogCardQuery__
 *
 * To run a query within a React component, call `useAllOrNothingDialogCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllOrNothingDialogCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllOrNothingDialogCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useAllOrNothingDialogCardQuery(baseOptions: Apollo.QueryHookOptions<AllOrNothingDialogCardQuery, AllOrNothingDialogCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllOrNothingDialogCardQuery, AllOrNothingDialogCardQueryVariables>(AllOrNothingDialogCardDocument, options);
      }
export function useAllOrNothingDialogCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllOrNothingDialogCardQuery, AllOrNothingDialogCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllOrNothingDialogCardQuery, AllOrNothingDialogCardQueryVariables>(AllOrNothingDialogCardDocument, options);
        }
export type AllOrNothingDialogCardQueryHookResult = ReturnType<typeof useAllOrNothingDialogCardQuery>;
export type AllOrNothingDialogCardLazyQueryHookResult = ReturnType<typeof useAllOrNothingDialogCardLazyQuery>;
export type AllOrNothingDialogCardQueryResult = Apollo.QueryResult<AllOrNothingDialogCardQuery, AllOrNothingDialogCardQueryVariables>;
export const CardSelectCardsDocument = gql`
    query CardSelectCards($cardIds: [String!]!) {
  gameCards(cardIds: $cardIds) {
    cards {
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useCardSelectCardsQuery__
 *
 * To run a query within a React component, call `useCardSelectCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardSelectCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardSelectCardsQuery({
 *   variables: {
 *      cardIds: // value for 'cardIds'
 *   },
 * });
 */
export function useCardSelectCardsQuery(baseOptions: Apollo.QueryHookOptions<CardSelectCardsQuery, CardSelectCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardSelectCardsQuery, CardSelectCardsQueryVariables>(CardSelectCardsDocument, options);
      }
export function useCardSelectCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardSelectCardsQuery, CardSelectCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardSelectCardsQuery, CardSelectCardsQueryVariables>(CardSelectCardsDocument, options);
        }
export type CardSelectCardsQueryHookResult = ReturnType<typeof useCardSelectCardsQuery>;
export type CardSelectCardsLazyQueryHookResult = ReturnType<typeof useCardSelectCardsLazyQuery>;
export type CardSelectCardsQueryResult = Apollo.QueryResult<CardSelectCardsQuery, CardSelectCardsQueryVariables>;
export const CardSelectMatchCardsDocument = gql`
    query CardSelectMatchCards($cardIds: [String!]!) {
  gameCards(cardIds: $cardIds) {
    cards {
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useCardSelectMatchCardsQuery__
 *
 * To run a query within a React component, call `useCardSelectMatchCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardSelectMatchCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardSelectMatchCardsQuery({
 *   variables: {
 *      cardIds: // value for 'cardIds'
 *   },
 * });
 */
export function useCardSelectMatchCardsQuery(baseOptions: Apollo.QueryHookOptions<CardSelectMatchCardsQuery, CardSelectMatchCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardSelectMatchCardsQuery, CardSelectMatchCardsQueryVariables>(CardSelectMatchCardsDocument, options);
      }
export function useCardSelectMatchCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardSelectMatchCardsQuery, CardSelectMatchCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardSelectMatchCardsQuery, CardSelectMatchCardsQueryVariables>(CardSelectMatchCardsDocument, options);
        }
export type CardSelectMatchCardsQueryHookResult = ReturnType<typeof useCardSelectMatchCardsQuery>;
export type CardSelectMatchCardsLazyQueryHookResult = ReturnType<typeof useCardSelectMatchCardsLazyQuery>;
export type CardSelectMatchCardsQueryResult = Apollo.QueryResult<CardSelectMatchCardsQuery, CardSelectMatchCardsQueryVariables>;
export const HighScoringCardDataDocument = gql`
    query HighScoringCardData($cardId: String!, $playerId: ID!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      ...GameCard
    }
  }
  profile(userId: $playerId) {
    ...HighScoringCardPlayer
  }
}
    ${GameCardFragmentDoc}
${HighScoringCardPlayerFragmentDoc}`;

/**
 * __useHighScoringCardDataQuery__
 *
 * To run a query within a React component, call `useHighScoringCardDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useHighScoringCardDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHighScoringCardDataQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *      playerId: // value for 'playerId'
 *   },
 * });
 */
export function useHighScoringCardDataQuery(baseOptions: Apollo.QueryHookOptions<HighScoringCardDataQuery, HighScoringCardDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HighScoringCardDataQuery, HighScoringCardDataQueryVariables>(HighScoringCardDataDocument, options);
      }
export function useHighScoringCardDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HighScoringCardDataQuery, HighScoringCardDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HighScoringCardDataQuery, HighScoringCardDataQueryVariables>(HighScoringCardDataDocument, options);
        }
export type HighScoringCardDataQueryHookResult = ReturnType<typeof useHighScoringCardDataQuery>;
export type HighScoringCardDataLazyQueryHookResult = ReturnType<typeof useHighScoringCardDataLazyQuery>;
export type HighScoringCardDataQueryResult = Apollo.QueryResult<HighScoringCardDataQuery, HighScoringCardDataQueryVariables>;
export const SpectatorPlayerDisplayProfileDocument = gql`
    query SpectatorPlayerDisplayProfile($id: ID!) {
  profile(userId: $id) {
    ...SpectatorDisplayBottomProfile
  }
}
    ${SpectatorDisplayBottomProfileFragmentDoc}`;

/**
 * __useSpectatorPlayerDisplayProfileQuery__
 *
 * To run a query within a React component, call `useSpectatorPlayerDisplayProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useSpectatorPlayerDisplayProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSpectatorPlayerDisplayProfileQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSpectatorPlayerDisplayProfileQuery(baseOptions: Apollo.QueryHookOptions<SpectatorPlayerDisplayProfileQuery, SpectatorPlayerDisplayProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SpectatorPlayerDisplayProfileQuery, SpectatorPlayerDisplayProfileQueryVariables>(SpectatorPlayerDisplayProfileDocument, options);
      }
export function useSpectatorPlayerDisplayProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SpectatorPlayerDisplayProfileQuery, SpectatorPlayerDisplayProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SpectatorPlayerDisplayProfileQuery, SpectatorPlayerDisplayProfileQueryVariables>(SpectatorPlayerDisplayProfileDocument, options);
        }
export type SpectatorPlayerDisplayProfileQueryHookResult = ReturnType<typeof useSpectatorPlayerDisplayProfileQuery>;
export type SpectatorPlayerDisplayProfileLazyQueryHookResult = ReturnType<typeof useSpectatorPlayerDisplayProfileLazyQuery>;
export type SpectatorPlayerDisplayProfileQueryResult = Apollo.QueryResult<SpectatorPlayerDisplayProfileQuery, SpectatorPlayerDisplayProfileQueryVariables>;
export const DisplayBottomSmPlayerDocument = gql`
    query DisplayBottomSmPlayer($playerId: ID!) {
  profile(userId: $playerId) {
    userId
    ...CardRowAvatarProfile
  }
}
    ${CardRowAvatarProfileFragmentDoc}`;

/**
 * __useDisplayBottomSmPlayerQuery__
 *
 * To run a query within a React component, call `useDisplayBottomSmPlayerQuery` and pass it any options that fit your needs.
 * When your component renders, `useDisplayBottomSmPlayerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDisplayBottomSmPlayerQuery({
 *   variables: {
 *      playerId: // value for 'playerId'
 *   },
 * });
 */
export function useDisplayBottomSmPlayerQuery(baseOptions: Apollo.QueryHookOptions<DisplayBottomSmPlayerQuery, DisplayBottomSmPlayerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DisplayBottomSmPlayerQuery, DisplayBottomSmPlayerQueryVariables>(DisplayBottomSmPlayerDocument, options);
      }
export function useDisplayBottomSmPlayerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DisplayBottomSmPlayerQuery, DisplayBottomSmPlayerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DisplayBottomSmPlayerQuery, DisplayBottomSmPlayerQueryVariables>(DisplayBottomSmPlayerDocument, options);
        }
export type DisplayBottomSmPlayerQueryHookResult = ReturnType<typeof useDisplayBottomSmPlayerQuery>;
export type DisplayBottomSmPlayerLazyQueryHookResult = ReturnType<typeof useDisplayBottomSmPlayerLazyQuery>;
export type DisplayBottomSmPlayerQueryResult = Apollo.QueryResult<DisplayBottomSmPlayerQuery, DisplayBottomSmPlayerQueryVariables>;
export const PlayerScoreProfileDocument = gql`
    query PlayerScoreProfile($playerId: ID!) {
  profile(userId: $playerId) {
    userId
    userTag
  }
}
    `;

/**
 * __usePlayerScoreProfileQuery__
 *
 * To run a query within a React component, call `usePlayerScoreProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlayerScoreProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlayerScoreProfileQuery({
 *   variables: {
 *      playerId: // value for 'playerId'
 *   },
 * });
 */
export function usePlayerScoreProfileQuery(baseOptions: Apollo.QueryHookOptions<PlayerScoreProfileQuery, PlayerScoreProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlayerScoreProfileQuery, PlayerScoreProfileQueryVariables>(PlayerScoreProfileDocument, options);
      }
export function usePlayerScoreProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlayerScoreProfileQuery, PlayerScoreProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlayerScoreProfileQuery, PlayerScoreProfileQueryVariables>(PlayerScoreProfileDocument, options);
        }
export type PlayerScoreProfileQueryHookResult = ReturnType<typeof usePlayerScoreProfileQuery>;
export type PlayerScoreProfileLazyQueryHookResult = ReturnType<typeof usePlayerScoreProfileLazyQuery>;
export type PlayerScoreProfileQueryResult = Apollo.QueryResult<PlayerScoreProfileQuery, PlayerScoreProfileQueryVariables>;
export const CardSelectSmCardsDocument = gql`
    query CardSelectSmCards($cardIds: [String!]!) {
  gameCards(cardIds: $cardIds) {
    cards {
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useCardSelectSmCardsQuery__
 *
 * To run a query within a React component, call `useCardSelectSmCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardSelectSmCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardSelectSmCardsQuery({
 *   variables: {
 *      cardIds: // value for 'cardIds'
 *   },
 * });
 */
export function useCardSelectSmCardsQuery(baseOptions: Apollo.QueryHookOptions<CardSelectSmCardsQuery, CardSelectSmCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardSelectSmCardsQuery, CardSelectSmCardsQueryVariables>(CardSelectSmCardsDocument, options);
      }
export function useCardSelectSmCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardSelectSmCardsQuery, CardSelectSmCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardSelectSmCardsQuery, CardSelectSmCardsQueryVariables>(CardSelectSmCardsDocument, options);
        }
export type CardSelectSmCardsQueryHookResult = ReturnType<typeof useCardSelectSmCardsQuery>;
export type CardSelectSmCardsLazyQueryHookResult = ReturnType<typeof useCardSelectSmCardsLazyQuery>;
export type CardSelectSmCardsQueryResult = Apollo.QueryResult<CardSelectSmCardsQuery, CardSelectSmCardsQueryVariables>;
export const ProgressionPausedSeasonDocument = gql`
    query ProgressionPausedSeason($channelId: ID!) {
  channel(id: $channelId) {
    id
    game {
      id
      activeSeason {
        id
        progressionPaused
        progressionPauseReason
      }
    }
  }
}
    `;

/**
 * __useProgressionPausedSeasonQuery__
 *
 * To run a query within a React component, call `useProgressionPausedSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useProgressionPausedSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProgressionPausedSeasonQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useProgressionPausedSeasonQuery(baseOptions: Apollo.QueryHookOptions<ProgressionPausedSeasonQuery, ProgressionPausedSeasonQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProgressionPausedSeasonQuery, ProgressionPausedSeasonQueryVariables>(ProgressionPausedSeasonDocument, options);
      }
export function useProgressionPausedSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProgressionPausedSeasonQuery, ProgressionPausedSeasonQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProgressionPausedSeasonQuery, ProgressionPausedSeasonQueryVariables>(ProgressionPausedSeasonDocument, options);
        }
export type ProgressionPausedSeasonQueryHookResult = ReturnType<typeof useProgressionPausedSeasonQuery>;
export type ProgressionPausedSeasonLazyQueryHookResult = ReturnType<typeof useProgressionPausedSeasonLazyQuery>;
export type ProgressionPausedSeasonQueryResult = Apollo.QueryResult<ProgressionPausedSeasonQuery, ProgressionPausedSeasonQueryVariables>;
export const ActiveCardSoundsDocument = gql`
    query ActiveCardSounds($id: String!) {
  gameCards(cardIds: [$id]) {
    cards {
      ...GameCardSoundData
    }
  }
}
    ${GameCardSoundDataFragmentDoc}`;

/**
 * __useActiveCardSoundsQuery__
 *
 * To run a query within a React component, call `useActiveCardSoundsQuery` and pass it any options that fit your needs.
 * When your component renders, `useActiveCardSoundsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActiveCardSoundsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useActiveCardSoundsQuery(baseOptions: Apollo.QueryHookOptions<ActiveCardSoundsQuery, ActiveCardSoundsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActiveCardSoundsQuery, ActiveCardSoundsQueryVariables>(ActiveCardSoundsDocument, options);
      }
export function useActiveCardSoundsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActiveCardSoundsQuery, ActiveCardSoundsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActiveCardSoundsQuery, ActiveCardSoundsQueryVariables>(ActiveCardSoundsDocument, options);
        }
export type ActiveCardSoundsQueryHookResult = ReturnType<typeof useActiveCardSoundsQuery>;
export type ActiveCardSoundsLazyQueryHookResult = ReturnType<typeof useActiveCardSoundsLazyQuery>;
export type ActiveCardSoundsQueryResult = Apollo.QueryResult<ActiveCardSoundsQuery, ActiveCardSoundsQueryVariables>;
export const UseSpeedUpBoosterDurationDocument = gql`
    query useSpeedUpBoosterDuration($id: Int!) {
  booster(id: $id) {
    id
    timeActive
  }
}
    `;

/**
 * __useUseSpeedUpBoosterDurationQuery__
 *
 * To run a query within a React component, call `useUseSpeedUpBoosterDurationQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseSpeedUpBoosterDurationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseSpeedUpBoosterDurationQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUseSpeedUpBoosterDurationQuery(baseOptions: Apollo.QueryHookOptions<UseSpeedUpBoosterDurationQuery, UseSpeedUpBoosterDurationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseSpeedUpBoosterDurationQuery, UseSpeedUpBoosterDurationQueryVariables>(UseSpeedUpBoosterDurationDocument, options);
      }
export function useUseSpeedUpBoosterDurationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseSpeedUpBoosterDurationQuery, UseSpeedUpBoosterDurationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseSpeedUpBoosterDurationQuery, UseSpeedUpBoosterDurationQueryVariables>(UseSpeedUpBoosterDurationDocument, options);
        }
export type UseSpeedUpBoosterDurationQueryHookResult = ReturnType<typeof useUseSpeedUpBoosterDurationQuery>;
export type UseSpeedUpBoosterDurationLazyQueryHookResult = ReturnType<typeof useUseSpeedUpBoosterDurationLazyQuery>;
export type UseSpeedUpBoosterDurationQueryResult = Apollo.QueryResult<UseSpeedUpBoosterDurationQuery, UseSpeedUpBoosterDurationQueryVariables>;
export const GameCardBackgroundArtSeasonDocument = gql`
    query GameCardBackgroundArtSeason($seasonId: ID!) {
  season(id: $seasonId) {
    id
    cardBackgroundUrls {
      rarity
      url
    }
  }
}
    `;

/**
 * __useGameCardBackgroundArtSeasonQuery__
 *
 * To run a query within a React component, call `useGameCardBackgroundArtSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameCardBackgroundArtSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameCardBackgroundArtSeasonQuery({
 *   variables: {
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useGameCardBackgroundArtSeasonQuery(baseOptions: Apollo.QueryHookOptions<GameCardBackgroundArtSeasonQuery, GameCardBackgroundArtSeasonQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameCardBackgroundArtSeasonQuery, GameCardBackgroundArtSeasonQueryVariables>(GameCardBackgroundArtSeasonDocument, options);
      }
export function useGameCardBackgroundArtSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameCardBackgroundArtSeasonQuery, GameCardBackgroundArtSeasonQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameCardBackgroundArtSeasonQuery, GameCardBackgroundArtSeasonQueryVariables>(GameCardBackgroundArtSeasonDocument, options);
        }
export type GameCardBackgroundArtSeasonQueryHookResult = ReturnType<typeof useGameCardBackgroundArtSeasonQuery>;
export type GameCardBackgroundArtSeasonLazyQueryHookResult = ReturnType<typeof useGameCardBackgroundArtSeasonLazyQuery>;
export type GameCardBackgroundArtSeasonQueryResult = Apollo.QueryResult<GameCardBackgroundArtSeasonQuery, GameCardBackgroundArtSeasonQueryVariables>;
export const GameCardLevelSeasonDocument = gql`
    query GameCardLevelSeason($seasonId: ID!) {
  season(id: $seasonId) {
    id
    badgeUrl
  }
}
    `;

/**
 * __useGameCardLevelSeasonQuery__
 *
 * To run a query within a React component, call `useGameCardLevelSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameCardLevelSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameCardLevelSeasonQuery({
 *   variables: {
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useGameCardLevelSeasonQuery(baseOptions: Apollo.QueryHookOptions<GameCardLevelSeasonQuery, GameCardLevelSeasonQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameCardLevelSeasonQuery, GameCardLevelSeasonQueryVariables>(GameCardLevelSeasonDocument, options);
      }
export function useGameCardLevelSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameCardLevelSeasonQuery, GameCardLevelSeasonQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameCardLevelSeasonQuery, GameCardLevelSeasonQueryVariables>(GameCardLevelSeasonDocument, options);
        }
export type GameCardLevelSeasonQueryHookResult = ReturnType<typeof useGameCardLevelSeasonQuery>;
export type GameCardLevelSeasonLazyQueryHookResult = ReturnType<typeof useGameCardLevelSeasonLazyQuery>;
export type GameCardLevelSeasonQueryResult = Apollo.QueryResult<GameCardLevelSeasonQuery, GameCardLevelSeasonQueryVariables>;
export const LeaderboardItemPlayersDocument = gql`
    query LeaderboardItemPlayers($playerIds: [String!]!) {
  profileBatch(userIds: $playerIds) {
    profiles {
      userId
      userTag
      avatars {
        avatar2D
      }
    }
  }
}
    `;

/**
 * __useLeaderboardItemPlayersQuery__
 *
 * To run a query within a React component, call `useLeaderboardItemPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useLeaderboardItemPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLeaderboardItemPlayersQuery({
 *   variables: {
 *      playerIds: // value for 'playerIds'
 *   },
 * });
 */
export function useLeaderboardItemPlayersQuery(baseOptions: Apollo.QueryHookOptions<LeaderboardItemPlayersQuery, LeaderboardItemPlayersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LeaderboardItemPlayersQuery, LeaderboardItemPlayersQueryVariables>(LeaderboardItemPlayersDocument, options);
      }
export function useLeaderboardItemPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LeaderboardItemPlayersQuery, LeaderboardItemPlayersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LeaderboardItemPlayersQuery, LeaderboardItemPlayersQueryVariables>(LeaderboardItemPlayersDocument, options);
        }
export type LeaderboardItemPlayersQueryHookResult = ReturnType<typeof useLeaderboardItemPlayersQuery>;
export type LeaderboardItemPlayersLazyQueryHookResult = ReturnType<typeof useLeaderboardItemPlayersLazyQuery>;
export type LeaderboardItemPlayersQueryResult = Apollo.QueryResult<LeaderboardItemPlayersQuery, LeaderboardItemPlayersQueryVariables>;
export const AllOrNothingPendingCardDocument = gql`
    query AllOrNothingPendingCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useAllOrNothingPendingCardQuery__
 *
 * To run a query within a React component, call `useAllOrNothingPendingCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllOrNothingPendingCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllOrNothingPendingCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useAllOrNothingPendingCardQuery(baseOptions: Apollo.QueryHookOptions<AllOrNothingPendingCardQuery, AllOrNothingPendingCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllOrNothingPendingCardQuery, AllOrNothingPendingCardQueryVariables>(AllOrNothingPendingCardDocument, options);
      }
export function useAllOrNothingPendingCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllOrNothingPendingCardQuery, AllOrNothingPendingCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllOrNothingPendingCardQuery, AllOrNothingPendingCardQueryVariables>(AllOrNothingPendingCardDocument, options);
        }
export type AllOrNothingPendingCardQueryHookResult = ReturnType<typeof useAllOrNothingPendingCardQuery>;
export type AllOrNothingPendingCardLazyQueryHookResult = ReturnType<typeof useAllOrNothingPendingCardLazyQuery>;
export type AllOrNothingPendingCardQueryResult = Apollo.QueryResult<AllOrNothingPendingCardQuery, AllOrNothingPendingCardQueryVariables>;
export const CardWithHighlightStateCardDocument = gql`
    query CardWithHighlightStateCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useCardWithHighlightStateCardQuery__
 *
 * To run a query within a React component, call `useCardWithHighlightStateCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardWithHighlightStateCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardWithHighlightStateCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useCardWithHighlightStateCardQuery(baseOptions: Apollo.QueryHookOptions<CardWithHighlightStateCardQuery, CardWithHighlightStateCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardWithHighlightStateCardQuery, CardWithHighlightStateCardQueryVariables>(CardWithHighlightStateCardDocument, options);
      }
export function useCardWithHighlightStateCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardWithHighlightStateCardQuery, CardWithHighlightStateCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardWithHighlightStateCardQuery, CardWithHighlightStateCardQueryVariables>(CardWithHighlightStateCardDocument, options);
        }
export type CardWithHighlightStateCardQueryHookResult = ReturnType<typeof useCardWithHighlightStateCardQuery>;
export type CardWithHighlightStateCardLazyQueryHookResult = ReturnType<typeof useCardWithHighlightStateCardLazyQuery>;
export type CardWithHighlightStateCardQueryResult = Apollo.QueryResult<CardWithHighlightStateCardQuery, CardWithHighlightStateCardQueryVariables>;
export const SwitchOutCardDetailsDocument = gql`
    query SwitchOutCardDetails($activeCardId: String!) {
  gameCards(cardIds: [$activeCardId]) {
    cards {
      id
      isAllOrNothing
    }
  }
}
    `;

/**
 * __useSwitchOutCardDetailsQuery__
 *
 * To run a query within a React component, call `useSwitchOutCardDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSwitchOutCardDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSwitchOutCardDetailsQuery({
 *   variables: {
 *      activeCardId: // value for 'activeCardId'
 *   },
 * });
 */
export function useSwitchOutCardDetailsQuery(baseOptions: Apollo.QueryHookOptions<SwitchOutCardDetailsQuery, SwitchOutCardDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SwitchOutCardDetailsQuery, SwitchOutCardDetailsQueryVariables>(SwitchOutCardDetailsDocument, options);
      }
export function useSwitchOutCardDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SwitchOutCardDetailsQuery, SwitchOutCardDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SwitchOutCardDetailsQuery, SwitchOutCardDetailsQueryVariables>(SwitchOutCardDetailsDocument, options);
        }
export type SwitchOutCardDetailsQueryHookResult = ReturnType<typeof useSwitchOutCardDetailsQuery>;
export type SwitchOutCardDetailsLazyQueryHookResult = ReturnType<typeof useSwitchOutCardDetailsLazyQuery>;
export type SwitchOutCardDetailsQueryResult = Apollo.QueryResult<SwitchOutCardDetailsQuery, SwitchOutCardDetailsQueryVariables>;
export const ChallengesContentChallengesDocument = gql`
    query ChallengesContentChallenges($challengeIds: [String!]!) {
  challengesBatch(challengeIds: $challengeIds) {
    challenges {
      ...ChallengesContentChallenge
    }
  }
}
    ${ChallengesContentChallengeFragmentDoc}`;

/**
 * __useChallengesContentChallengesQuery__
 *
 * To run a query within a React component, call `useChallengesContentChallengesQuery` and pass it any options that fit your needs.
 * When your component renders, `useChallengesContentChallengesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChallengesContentChallengesQuery({
 *   variables: {
 *      challengeIds: // value for 'challengeIds'
 *   },
 * });
 */
export function useChallengesContentChallengesQuery(baseOptions: Apollo.QueryHookOptions<ChallengesContentChallengesQuery, ChallengesContentChallengesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChallengesContentChallengesQuery, ChallengesContentChallengesQueryVariables>(ChallengesContentChallengesDocument, options);
      }
export function useChallengesContentChallengesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChallengesContentChallengesQuery, ChallengesContentChallengesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChallengesContentChallengesQuery, ChallengesContentChallengesQueryVariables>(ChallengesContentChallengesDocument, options);
        }
export type ChallengesContentChallengesQueryHookResult = ReturnType<typeof useChallengesContentChallengesQuery>;
export type ChallengesContentChallengesLazyQueryHookResult = ReturnType<typeof useChallengesContentChallengesLazyQuery>;
export type ChallengesContentChallengesQueryResult = Apollo.QueryResult<ChallengesContentChallengesQuery, ChallengesContentChallengesQueryVariables>;
export const PickRateRewardsDocument = gql`
    query PickRateRewards($gameId: ID!) {
  challengeRewards(gameId: $gameId) {
    rewards {
      minPickRate
      maxPickRate
      reward {
        reward {
          ... on RewardRewardTypeCurrency {
            currencyId
            currencyAmount
          }
        }
      }
      gameId
    }
  }
}
    `;

/**
 * __usePickRateRewardsQuery__
 *
 * To run a query within a React component, call `usePickRateRewardsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePickRateRewardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePickRateRewardsQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function usePickRateRewardsQuery(baseOptions: Apollo.QueryHookOptions<PickRateRewardsQuery, PickRateRewardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PickRateRewardsQuery, PickRateRewardsQueryVariables>(PickRateRewardsDocument, options);
      }
export function usePickRateRewardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PickRateRewardsQuery, PickRateRewardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PickRateRewardsQuery, PickRateRewardsQueryVariables>(PickRateRewardsDocument, options);
        }
export type PickRateRewardsQueryHookResult = ReturnType<typeof usePickRateRewardsQuery>;
export type PickRateRewardsLazyQueryHookResult = ReturnType<typeof usePickRateRewardsLazyQuery>;
export type PickRateRewardsQueryResult = Apollo.QueryResult<PickRateRewardsQuery, PickRateRewardsQueryVariables>;
export const ActiveBoostersDataDocument = gql`
    query ActiveBoostersData($boosterId: Int!) {
  booster(id: $boosterId) {
    id
    ...ActiveBooster
  }
}
    ${ActiveBoosterFragmentDoc}`;

/**
 * __useActiveBoostersDataQuery__
 *
 * To run a query within a React component, call `useActiveBoostersDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useActiveBoostersDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActiveBoostersDataQuery({
 *   variables: {
 *      boosterId: // value for 'boosterId'
 *   },
 * });
 */
export function useActiveBoostersDataQuery(baseOptions: Apollo.QueryHookOptions<ActiveBoostersDataQuery, ActiveBoostersDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActiveBoostersDataQuery, ActiveBoostersDataQueryVariables>(ActiveBoostersDataDocument, options);
      }
export function useActiveBoostersDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActiveBoostersDataQuery, ActiveBoostersDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActiveBoostersDataQuery, ActiveBoostersDataQueryVariables>(ActiveBoostersDataDocument, options);
        }
export type ActiveBoostersDataQueryHookResult = ReturnType<typeof useActiveBoostersDataQuery>;
export type ActiveBoostersDataLazyQueryHookResult = ReturnType<typeof useActiveBoostersDataLazyQuery>;
export type ActiveBoostersDataQueryResult = Apollo.QueryResult<ActiveBoostersDataQuery, ActiveBoostersDataQueryVariables>;
export const ActiveBoostersProfileDataDocument = gql`
    query ActiveBoostersProfileData($userId: ID!) {
  profile(userId: $userId) {
    ...ActiveBoosterProfile
  }
}
    ${ActiveBoosterProfileFragmentDoc}`;

/**
 * __useActiveBoostersProfileDataQuery__
 *
 * To run a query within a React component, call `useActiveBoostersProfileDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useActiveBoostersProfileDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActiveBoostersProfileDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useActiveBoostersProfileDataQuery(baseOptions: Apollo.QueryHookOptions<ActiveBoostersProfileDataQuery, ActiveBoostersProfileDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActiveBoostersProfileDataQuery, ActiveBoostersProfileDataQueryVariables>(ActiveBoostersProfileDataDocument, options);
      }
export function useActiveBoostersProfileDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActiveBoostersProfileDataQuery, ActiveBoostersProfileDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActiveBoostersProfileDataQuery, ActiveBoostersProfileDataQueryVariables>(ActiveBoostersProfileDataDocument, options);
        }
export type ActiveBoostersProfileDataQueryHookResult = ReturnType<typeof useActiveBoostersProfileDataQuery>;
export type ActiveBoostersProfileDataLazyQueryHookResult = ReturnType<typeof useActiveBoostersProfileDataLazyQuery>;
export type ActiveBoostersProfileDataQueryResult = Apollo.QueryResult<ActiveBoostersProfileDataQuery, ActiveBoostersProfileDataQueryVariables>;
export const ReplacementBoosterDataDocument = gql`
    query ReplacementBoosterData($id: Int!) {
  booster(id: $id) {
    id
    ...ActiveBooster
  }
}
    ${ActiveBoosterFragmentDoc}`;

/**
 * __useReplacementBoosterDataQuery__
 *
 * To run a query within a React component, call `useReplacementBoosterDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useReplacementBoosterDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReplacementBoosterDataQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useReplacementBoosterDataQuery(baseOptions: Apollo.QueryHookOptions<ReplacementBoosterDataQuery, ReplacementBoosterDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReplacementBoosterDataQuery, ReplacementBoosterDataQueryVariables>(ReplacementBoosterDataDocument, options);
      }
export function useReplacementBoosterDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReplacementBoosterDataQuery, ReplacementBoosterDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReplacementBoosterDataQuery, ReplacementBoosterDataQueryVariables>(ReplacementBoosterDataDocument, options);
        }
export type ReplacementBoosterDataQueryHookResult = ReturnType<typeof useReplacementBoosterDataQuery>;
export type ReplacementBoosterDataLazyQueryHookResult = ReturnType<typeof useReplacementBoosterDataLazyQuery>;
export type ReplacementBoosterDataQueryResult = Apollo.QueryResult<ReplacementBoosterDataQuery, ReplacementBoosterDataQueryVariables>;
export const LocalPlayerBoosterDialogContentDocument = gql`
    query LocalPlayerBoosterDialogContent($boosterId: Int!) {
  booster(id: $boosterId) {
    id
    name
    descriptionCondition
    descriptionDefaultBenefit
    descriptionTargetNoneBenefit
  }
}
    `;

/**
 * __useLocalPlayerBoosterDialogContentQuery__
 *
 * To run a query within a React component, call `useLocalPlayerBoosterDialogContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useLocalPlayerBoosterDialogContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLocalPlayerBoosterDialogContentQuery({
 *   variables: {
 *      boosterId: // value for 'boosterId'
 *   },
 * });
 */
export function useLocalPlayerBoosterDialogContentQuery(baseOptions: Apollo.QueryHookOptions<LocalPlayerBoosterDialogContentQuery, LocalPlayerBoosterDialogContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LocalPlayerBoosterDialogContentQuery, LocalPlayerBoosterDialogContentQueryVariables>(LocalPlayerBoosterDialogContentDocument, options);
      }
export function useLocalPlayerBoosterDialogContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LocalPlayerBoosterDialogContentQuery, LocalPlayerBoosterDialogContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LocalPlayerBoosterDialogContentQuery, LocalPlayerBoosterDialogContentQueryVariables>(LocalPlayerBoosterDialogContentDocument, options);
        }
export type LocalPlayerBoosterDialogContentQueryHookResult = ReturnType<typeof useLocalPlayerBoosterDialogContentQuery>;
export type LocalPlayerBoosterDialogContentLazyQueryHookResult = ReturnType<typeof useLocalPlayerBoosterDialogContentLazyQuery>;
export type LocalPlayerBoosterDialogContentQueryResult = Apollo.QueryResult<LocalPlayerBoosterDialogContentQuery, LocalPlayerBoosterDialogContentQueryVariables>;
export const LocalPlayerBoosterTooltipContentDocument = gql`
    query LocalPlayerBoosterTooltipContent($boosterId: Int!) {
  booster(id: $boosterId) {
    id
    name
    descriptionCondition
    descriptionDefaultBenefit
    descriptionTargetNoneBenefit
  }
}
    `;

/**
 * __useLocalPlayerBoosterTooltipContentQuery__
 *
 * To run a query within a React component, call `useLocalPlayerBoosterTooltipContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useLocalPlayerBoosterTooltipContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLocalPlayerBoosterTooltipContentQuery({
 *   variables: {
 *      boosterId: // value for 'boosterId'
 *   },
 * });
 */
export function useLocalPlayerBoosterTooltipContentQuery(baseOptions: Apollo.QueryHookOptions<LocalPlayerBoosterTooltipContentQuery, LocalPlayerBoosterTooltipContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LocalPlayerBoosterTooltipContentQuery, LocalPlayerBoosterTooltipContentQueryVariables>(LocalPlayerBoosterTooltipContentDocument, options);
      }
export function useLocalPlayerBoosterTooltipContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LocalPlayerBoosterTooltipContentQuery, LocalPlayerBoosterTooltipContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LocalPlayerBoosterTooltipContentQuery, LocalPlayerBoosterTooltipContentQueryVariables>(LocalPlayerBoosterTooltipContentDocument, options);
        }
export type LocalPlayerBoosterTooltipContentQueryHookResult = ReturnType<typeof useLocalPlayerBoosterTooltipContentQuery>;
export type LocalPlayerBoosterTooltipContentLazyQueryHookResult = ReturnType<typeof useLocalPlayerBoosterTooltipContentLazyQuery>;
export type LocalPlayerBoosterTooltipContentQueryResult = Apollo.QueryResult<LocalPlayerBoosterTooltipContentQuery, LocalPlayerBoosterTooltipContentQueryVariables>;
export const BoosterRequestPreviewProfileDocument = gql`
    query BoosterRequestPreviewProfile($id: ID!) {
  profile(userId: $id) {
    userId
    avatars {
      avatar2D
    }
  }
}
    `;

/**
 * __useBoosterRequestPreviewProfileQuery__
 *
 * To run a query within a React component, call `useBoosterRequestPreviewProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useBoosterRequestPreviewProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBoosterRequestPreviewProfileQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBoosterRequestPreviewProfileQuery(baseOptions: Apollo.QueryHookOptions<BoosterRequestPreviewProfileQuery, BoosterRequestPreviewProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BoosterRequestPreviewProfileQuery, BoosterRequestPreviewProfileQueryVariables>(BoosterRequestPreviewProfileDocument, options);
      }
export function useBoosterRequestPreviewProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BoosterRequestPreviewProfileQuery, BoosterRequestPreviewProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BoosterRequestPreviewProfileQuery, BoosterRequestPreviewProfileQueryVariables>(BoosterRequestPreviewProfileDocument, options);
        }
export type BoosterRequestPreviewProfileQueryHookResult = ReturnType<typeof useBoosterRequestPreviewProfileQuery>;
export type BoosterRequestPreviewProfileLazyQueryHookResult = ReturnType<typeof useBoosterRequestPreviewProfileLazyQuery>;
export type BoosterRequestPreviewProfileQueryResult = Apollo.QueryResult<BoosterRequestPreviewProfileQuery, BoosterRequestPreviewProfileQueryVariables>;
export const PlayerActiveCardDocument = gql`
    query PlayerActiveCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      name
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __usePlayerActiveCardQuery__
 *
 * To run a query within a React component, call `usePlayerActiveCardQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlayerActiveCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlayerActiveCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function usePlayerActiveCardQuery(baseOptions: Apollo.QueryHookOptions<PlayerActiveCardQuery, PlayerActiveCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlayerActiveCardQuery, PlayerActiveCardQueryVariables>(PlayerActiveCardDocument, options);
      }
export function usePlayerActiveCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlayerActiveCardQuery, PlayerActiveCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlayerActiveCardQuery, PlayerActiveCardQueryVariables>(PlayerActiveCardDocument, options);
        }
export type PlayerActiveCardQueryHookResult = ReturnType<typeof usePlayerActiveCardQuery>;
export type PlayerActiveCardLazyQueryHookResult = ReturnType<typeof usePlayerActiveCardLazyQuery>;
export type PlayerActiveCardQueryResult = Apollo.QueryResult<PlayerActiveCardQuery, PlayerActiveCardQueryVariables>;
export const TeamMateBoosterDialogContentDocument = gql`
    query TeamMateBoosterDialogContent($boosterId: Int!) {
  booster(id: $boosterId) {
    id
    ...TeamMateBoosterDialogContentBooster
  }
}
    ${TeamMateBoosterDialogContentBoosterFragmentDoc}`;

/**
 * __useTeamMateBoosterDialogContentQuery__
 *
 * To run a query within a React component, call `useTeamMateBoosterDialogContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useTeamMateBoosterDialogContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTeamMateBoosterDialogContentQuery({
 *   variables: {
 *      boosterId: // value for 'boosterId'
 *   },
 * });
 */
export function useTeamMateBoosterDialogContentQuery(baseOptions: Apollo.QueryHookOptions<TeamMateBoosterDialogContentQuery, TeamMateBoosterDialogContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TeamMateBoosterDialogContentQuery, TeamMateBoosterDialogContentQueryVariables>(TeamMateBoosterDialogContentDocument, options);
      }
export function useTeamMateBoosterDialogContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TeamMateBoosterDialogContentQuery, TeamMateBoosterDialogContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TeamMateBoosterDialogContentQuery, TeamMateBoosterDialogContentQueryVariables>(TeamMateBoosterDialogContentDocument, options);
        }
export type TeamMateBoosterDialogContentQueryHookResult = ReturnType<typeof useTeamMateBoosterDialogContentQuery>;
export type TeamMateBoosterDialogContentLazyQueryHookResult = ReturnType<typeof useTeamMateBoosterDialogContentLazyQuery>;
export type TeamMateBoosterDialogContentQueryResult = Apollo.QueryResult<TeamMateBoosterDialogContentQuery, TeamMateBoosterDialogContentQueryVariables>;
export const TeamMateBoosterTooltipContentDocument = gql`
    query TeamMateBoosterTooltipContent($boosterId: Int!, $userId: ID!) {
  booster(id: $boosterId) {
    id
    ...TeamMateBoosterTooltipContentBooster
  }
  profile(userId: $userId) {
    userId
    userTag
  }
}
    ${TeamMateBoosterTooltipContentBoosterFragmentDoc}`;

/**
 * __useTeamMateBoosterTooltipContentQuery__
 *
 * To run a query within a React component, call `useTeamMateBoosterTooltipContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useTeamMateBoosterTooltipContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTeamMateBoosterTooltipContentQuery({
 *   variables: {
 *      boosterId: // value for 'boosterId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useTeamMateBoosterTooltipContentQuery(baseOptions: Apollo.QueryHookOptions<TeamMateBoosterTooltipContentQuery, TeamMateBoosterTooltipContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TeamMateBoosterTooltipContentQuery, TeamMateBoosterTooltipContentQueryVariables>(TeamMateBoosterTooltipContentDocument, options);
      }
export function useTeamMateBoosterTooltipContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TeamMateBoosterTooltipContentQuery, TeamMateBoosterTooltipContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TeamMateBoosterTooltipContentQuery, TeamMateBoosterTooltipContentQueryVariables>(TeamMateBoosterTooltipContentDocument, options);
        }
export type TeamMateBoosterTooltipContentQueryHookResult = ReturnType<typeof useTeamMateBoosterTooltipContentQuery>;
export type TeamMateBoosterTooltipContentLazyQueryHookResult = ReturnType<typeof useTeamMateBoosterTooltipContentLazyQuery>;
export type TeamMateBoosterTooltipContentQueryResult = Apollo.QueryResult<TeamMateBoosterTooltipContentQuery, TeamMateBoosterTooltipContentQueryVariables>;
export const CgChallengesSystemChallengesDocument = gql`
    query CGChallengesSystemChallenges($challengeIds: [String!]!) {
  challengesBatch(challengeIds: $challengeIds) {
    challenges {
      ...CGChallengesSystemChallenge
    }
  }
}
    ${CgChallengesSystemChallengeFragmentDoc}`;

/**
 * __useCgChallengesSystemChallengesQuery__
 *
 * To run a query within a React component, call `useCgChallengesSystemChallengesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCgChallengesSystemChallengesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCgChallengesSystemChallengesQuery({
 *   variables: {
 *      challengeIds: // value for 'challengeIds'
 *   },
 * });
 */
export function useCgChallengesSystemChallengesQuery(baseOptions: Apollo.QueryHookOptions<CgChallengesSystemChallengesQuery, CgChallengesSystemChallengesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CgChallengesSystemChallengesQuery, CgChallengesSystemChallengesQueryVariables>(CgChallengesSystemChallengesDocument, options);
      }
export function useCgChallengesSystemChallengesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CgChallengesSystemChallengesQuery, CgChallengesSystemChallengesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CgChallengesSystemChallengesQuery, CgChallengesSystemChallengesQueryVariables>(CgChallengesSystemChallengesDocument, options);
        }
export type CgChallengesSystemChallengesQueryHookResult = ReturnType<typeof useCgChallengesSystemChallengesQuery>;
export type CgChallengesSystemChallengesLazyQueryHookResult = ReturnType<typeof useCgChallengesSystemChallengesLazyQuery>;
export type CgChallengesSystemChallengesQueryResult = Apollo.QueryResult<CgChallengesSystemChallengesQuery, CgChallengesSystemChallengesQueryVariables>;
export const GameStateGameCardDocument = gql`
    query GameStateGameCard($ids: [String!]!) {
  gameCards(cardIds: $ids) {
    cards {
      ...GameStateCard
    }
  }
}
    ${GameStateCardFragmentDoc}`;

/**
 * __useGameStateGameCardQuery__
 *
 * To run a query within a React component, call `useGameStateGameCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameStateGameCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameStateGameCardQuery({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useGameStateGameCardQuery(baseOptions: Apollo.QueryHookOptions<GameStateGameCardQuery, GameStateGameCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameStateGameCardQuery, GameStateGameCardQueryVariables>(GameStateGameCardDocument, options);
      }
export function useGameStateGameCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameStateGameCardQuery, GameStateGameCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameStateGameCardQuery, GameStateGameCardQueryVariables>(GameStateGameCardDocument, options);
        }
export type GameStateGameCardQueryHookResult = ReturnType<typeof useGameStateGameCardQuery>;
export type GameStateGameCardLazyQueryHookResult = ReturnType<typeof useGameStateGameCardLazyQuery>;
export type GameStateGameCardQueryResult = Apollo.QueryResult<GameStateGameCardQuery, GameStateGameCardQueryVariables>;
export const GameStateBoostersDocument = gql`
    query GameStateBoosters($id: Int!) {
  booster(id: $id) {
    id
    ...CgAvailableBooster
    ...CgActiveBooster
  }
}
    ${CgAvailableBoosterFragmentDoc}
${CgActiveBoosterFragmentDoc}`;

/**
 * __useGameStateBoostersQuery__
 *
 * To run a query within a React component, call `useGameStateBoostersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameStateBoostersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameStateBoostersQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGameStateBoostersQuery(baseOptions: Apollo.QueryHookOptions<GameStateBoostersQuery, GameStateBoostersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameStateBoostersQuery, GameStateBoostersQueryVariables>(GameStateBoostersDocument, options);
      }
export function useGameStateBoostersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameStateBoostersQuery, GameStateBoostersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameStateBoostersQuery, GameStateBoostersQueryVariables>(GameStateBoostersDocument, options);
        }
export type GameStateBoostersQueryHookResult = ReturnType<typeof useGameStateBoostersQuery>;
export type GameStateBoostersLazyQueryHookResult = ReturnType<typeof useGameStateBoostersLazyQuery>;
export type GameStateBoostersQueryResult = Apollo.QueryResult<GameStateBoostersQuery, GameStateBoostersQueryVariables>;
export const StreamGameChannelDocument = gql`
    query StreamGameChannel($id: ID!) {
  stream(id: $id) {
    streamId
    channelId
  }
}
    `;

/**
 * __useStreamGameChannelQuery__
 *
 * To run a query within a React component, call `useStreamGameChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamGameChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamGameChannelQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStreamGameChannelQuery(baseOptions: Apollo.QueryHookOptions<StreamGameChannelQuery, StreamGameChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamGameChannelQuery, StreamGameChannelQueryVariables>(StreamGameChannelDocument, options);
      }
export function useStreamGameChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamGameChannelQuery, StreamGameChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamGameChannelQuery, StreamGameChannelQueryVariables>(StreamGameChannelDocument, options);
        }
export type StreamGameChannelQueryHookResult = ReturnType<typeof useStreamGameChannelQuery>;
export type StreamGameChannelLazyQueryHookResult = ReturnType<typeof useStreamGameChannelLazyQuery>;
export type StreamGameChannelQueryResult = Apollo.QueryResult<StreamGameChannelQuery, StreamGameChannelQueryVariables>;
export const ChatChannelEventsSubscriptionDocument = gql`
    subscription ChatChannelEventsSubscription($channelId: ID!) {
  channelEventsSubscribe(channelId: $channelId) {
    channelId
    createdAt
    id
    content {
      content {
        ... on ChannelAvatarItemPurchase {
          itemId
          item {
            ...ChannelEventAvatarItemPurchaseItem
          }
          user {
            userId
            ...ChannelEventContentProfile
          }
        }
        ... on ChannelSubscriptionPurchase {
          userId
          tier
          user {
            userId
            ...ChannelEventContentProfile
            ...ChannelEventSubscriptionContentProfile
          }
        }
        ... on ChannelBundlePurchase {
          bundleName
          userId
          streamerCards {
            id
            channelId
            baseCard {
              id
              name
            }
          }
          user {
            userId
            ...ChannelEventContentProfile
          }
        }
        ... on ChannelStreamerCardPurchase {
          streamerCard {
            id
            channelId
            baseCard {
              id
              name
            }
          }
          userId
          user {
            userId
            ...ChannelEventContentProfile
          }
        }
        ... on ChannelGiftSubscriptionPurchase {
          userId
          user {
            userId
            ...ChannelEventContentProfile
            ...ChannelEventSubscriptionContentProfile
          }
          recipients {
            userId
            ...ChannelEventContentProfile
            ...ChannelEventSubscriptionContentProfile
          }
        }
      }
    }
  }
}
    ${ChannelEventAvatarItemPurchaseItemFragmentDoc}
${ChannelEventContentProfileFragmentDoc}
${ChannelEventSubscriptionContentProfileFragmentDoc}`;

/**
 * __useChatChannelEventsSubscriptionSubscription__
 *
 * To run a query within a React component, call `useChatChannelEventsSubscriptionSubscription` and pass it any options that fit your needs.
 * When your component renders, `useChatChannelEventsSubscriptionSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatChannelEventsSubscriptionSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChatChannelEventsSubscriptionSubscription(baseOptions: Apollo.SubscriptionHookOptions<ChatChannelEventsSubscriptionSubscription, ChatChannelEventsSubscriptionSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ChatChannelEventsSubscriptionSubscription, ChatChannelEventsSubscriptionSubscriptionVariables>(ChatChannelEventsSubscriptionDocument, options);
      }
export type ChatChannelEventsSubscriptionSubscriptionHookResult = ReturnType<typeof useChatChannelEventsSubscriptionSubscription>;
export type ChatChannelEventsSubscriptionSubscriptionResult = Apollo.SubscriptionResult<ChatChannelEventsSubscriptionSubscription>;
export const InventoryEmojisDocument = gql`
    query InventoryEmojis($userId: ID) {
  inventory(userId: $userId, filters: {itemType: TYPE_EMOJI}) {
    items {
      itemId
      item {
        id
        details {
          ...InventoryEmoji
        }
      }
    }
  }
}
    ${InventoryEmojiFragmentDoc}`;

/**
 * __useInventoryEmojisQuery__
 *
 * To run a query within a React component, call `useInventoryEmojisQuery` and pass it any options that fit your needs.
 * When your component renders, `useInventoryEmojisQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInventoryEmojisQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useInventoryEmojisQuery(baseOptions?: Apollo.QueryHookOptions<InventoryEmojisQuery, InventoryEmojisQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InventoryEmojisQuery, InventoryEmojisQueryVariables>(InventoryEmojisDocument, options);
      }
export function useInventoryEmojisLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InventoryEmojisQuery, InventoryEmojisQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InventoryEmojisQuery, InventoryEmojisQueryVariables>(InventoryEmojisDocument, options);
        }
export type InventoryEmojisQueryHookResult = ReturnType<typeof useInventoryEmojisQuery>;
export type InventoryEmojisLazyQueryHookResult = ReturnType<typeof useInventoryEmojisLazyQuery>;
export type InventoryEmojisQueryResult = Apollo.QueryResult<InventoryEmojisQuery, InventoryEmojisQueryVariables>;
export const UpdateChatSettingsProfileDocument = gql`
    mutation UpdateChatSettingsProfile($userId: ID, $preferredColor: ProfileColor!) {
  updateProfile(body: {preferredColor: $preferredColor, userId: $userId}) {
    userId
    preferredColor
  }
}
    `;
export type UpdateChatSettingsProfileMutationFn = Apollo.MutationFunction<UpdateChatSettingsProfileMutation, UpdateChatSettingsProfileMutationVariables>;

/**
 * __useUpdateChatSettingsProfileMutation__
 *
 * To run a mutation, you first call `useUpdateChatSettingsProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChatSettingsProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChatSettingsProfileMutation, { data, loading, error }] = useUpdateChatSettingsProfileMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      preferredColor: // value for 'preferredColor'
 *   },
 * });
 */
export function useUpdateChatSettingsProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChatSettingsProfileMutation, UpdateChatSettingsProfileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChatSettingsProfileMutation, UpdateChatSettingsProfileMutationVariables>(UpdateChatSettingsProfileDocument, options);
      }
export type UpdateChatSettingsProfileMutationHookResult = ReturnType<typeof useUpdateChatSettingsProfileMutation>;
export type UpdateChatSettingsProfileMutationResult = Apollo.MutationResult<UpdateChatSettingsProfileMutation>;
export type UpdateChatSettingsProfileMutationOptions = Apollo.BaseMutationOptions<UpdateChatSettingsProfileMutation, UpdateChatSettingsProfileMutationVariables>;
export const ChatSettingsProfileDocument = gql`
    query ChatSettingsProfile($channelId: ID!, $userId: ID!) {
  profile(userId: $userId) {
    avatars {
      avatar2D
    }
    badges(channel_id: $channelId) {
      level
      type
    }
    userId
    preferredColor
    userTag
  }
}
    `;

/**
 * __useChatSettingsProfileQuery__
 *
 * To run a query within a React component, call `useChatSettingsProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatSettingsProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatSettingsProfileQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChatSettingsProfileQuery(baseOptions: Apollo.QueryHookOptions<ChatSettingsProfileQuery, ChatSettingsProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatSettingsProfileQuery, ChatSettingsProfileQueryVariables>(ChatSettingsProfileDocument, options);
      }
export function useChatSettingsProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatSettingsProfileQuery, ChatSettingsProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatSettingsProfileQuery, ChatSettingsProfileQueryVariables>(ChatSettingsProfileDocument, options);
        }
export type ChatSettingsProfileQueryHookResult = ReturnType<typeof useChatSettingsProfileQuery>;
export type ChatSettingsProfileLazyQueryHookResult = ReturnType<typeof useChatSettingsProfileLazyQuery>;
export type ChatSettingsProfileQueryResult = Apollo.QueryResult<ChatSettingsProfileQuery, ChatSettingsProfileQueryVariables>;
export const AvatarMovementsDocument = gql`
    query AvatarMovements($userId: ID) {
  inventory(userId: $userId, filters: {itemType: TYPE_EMOTE}) {
    items {
      itemId
      item {
        id
        details {
          ... on AvatarAnimation {
            ...EmoteAvatarAnimation
          }
        }
      }
    }
  }
}
    ${EmoteAvatarAnimationFragmentDoc}`;

/**
 * __useAvatarMovementsQuery__
 *
 * To run a query within a React component, call `useAvatarMovementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAvatarMovementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAvatarMovementsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useAvatarMovementsQuery(baseOptions?: Apollo.QueryHookOptions<AvatarMovementsQuery, AvatarMovementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AvatarMovementsQuery, AvatarMovementsQueryVariables>(AvatarMovementsDocument, options);
      }
export function useAvatarMovementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AvatarMovementsQuery, AvatarMovementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AvatarMovementsQuery, AvatarMovementsQueryVariables>(AvatarMovementsDocument, options);
        }
export type AvatarMovementsQueryHookResult = ReturnType<typeof useAvatarMovementsQuery>;
export type AvatarMovementsLazyQueryHookResult = ReturnType<typeof useAvatarMovementsLazyQuery>;
export type AvatarMovementsQueryResult = Apollo.QueryResult<AvatarMovementsQuery, AvatarMovementsQueryVariables>;
export const HideChatMessageDocument = gql`
    mutation HideChatMessage($chatId: ID!, $messageId: ID!) {
  hideChatMessage(chatId: $chatId, messageId: $messageId) {
    emptyTypeWorkaround
  }
}
    `;
export type HideChatMessageMutationFn = Apollo.MutationFunction<HideChatMessageMutation, HideChatMessageMutationVariables>;

/**
 * __useHideChatMessageMutation__
 *
 * To run a mutation, you first call `useHideChatMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useHideChatMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [hideChatMessageMutation, { data, loading, error }] = useHideChatMessageMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      messageId: // value for 'messageId'
 *   },
 * });
 */
export function useHideChatMessageMutation(baseOptions?: Apollo.MutationHookOptions<HideChatMessageMutation, HideChatMessageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<HideChatMessageMutation, HideChatMessageMutationVariables>(HideChatMessageDocument, options);
      }
export type HideChatMessageMutationHookResult = ReturnType<typeof useHideChatMessageMutation>;
export type HideChatMessageMutationResult = Apollo.MutationResult<HideChatMessageMutation>;
export type HideChatMessageMutationOptions = Apollo.BaseMutationOptions<HideChatMessageMutation, HideChatMessageMutationVariables>;
export const ChatMeProfileDocument = gql`
    query ChatMeProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ChatMessagesProfile
  }
}
    ${ChatMessagesProfileFragmentDoc}`;

/**
 * __useChatMeProfileQuery__
 *
 * To run a query within a React component, call `useChatMeProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatMeProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatMeProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChatMeProfileQuery(baseOptions: Apollo.QueryHookOptions<ChatMeProfileQuery, ChatMeProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatMeProfileQuery, ChatMeProfileQueryVariables>(ChatMeProfileDocument, options);
      }
export function useChatMeProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatMeProfileQuery, ChatMeProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatMeProfileQuery, ChatMeProfileQueryVariables>(ChatMeProfileDocument, options);
        }
export type ChatMeProfileQueryHookResult = ReturnType<typeof useChatMeProfileQuery>;
export type ChatMeProfileLazyQueryHookResult = ReturnType<typeof useChatMeProfileLazyQuery>;
export type ChatMeProfileQueryResult = Apollo.QueryResult<ChatMeProfileQuery, ChatMeProfileQueryVariables>;
export const UserInventoryEmojisDocument = gql`
    query UserInventoryEmojis($userId: ID) {
  inventory(userId: $userId, filters: {itemType: TYPE_EMOJI}) {
    items {
      itemId
      item {
        id
        details {
          ...InventoryEmoji
        }
      }
    }
  }
}
    ${InventoryEmojiFragmentDoc}`;

/**
 * __useUserInventoryEmojisQuery__
 *
 * To run a query within a React component, call `useUserInventoryEmojisQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserInventoryEmojisQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserInventoryEmojisQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserInventoryEmojisQuery(baseOptions?: Apollo.QueryHookOptions<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>(UserInventoryEmojisDocument, options);
      }
export function useUserInventoryEmojisLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>(UserInventoryEmojisDocument, options);
        }
export type UserInventoryEmojisQueryHookResult = ReturnType<typeof useUserInventoryEmojisQuery>;
export type UserInventoryEmojisLazyQueryHookResult = ReturnType<typeof useUserInventoryEmojisLazyQuery>;
export type UserInventoryEmojisQueryResult = Apollo.QueryResult<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>;
export const UserInventoryEmojisChannelsDocument = gql`
    query UserInventoryEmojisChannels($channelIds: [String!]) {
  getChannels(channelIds: $channelIds) {
    channels {
      id
      ...EmojiDrawerChannel
    }
  }
}
    ${EmojiDrawerChannelFragmentDoc}`;

/**
 * __useUserInventoryEmojisChannelsQuery__
 *
 * To run a query within a React component, call `useUserInventoryEmojisChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserInventoryEmojisChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserInventoryEmojisChannelsQuery({
 *   variables: {
 *      channelIds: // value for 'channelIds'
 *   },
 * });
 */
export function useUserInventoryEmojisChannelsQuery(baseOptions?: Apollo.QueryHookOptions<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>(UserInventoryEmojisChannelsDocument, options);
      }
export function useUserInventoryEmojisChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>(UserInventoryEmojisChannelsDocument, options);
        }
export type UserInventoryEmojisChannelsQueryHookResult = ReturnType<typeof useUserInventoryEmojisChannelsQuery>;
export type UserInventoryEmojisChannelsLazyQueryHookResult = ReturnType<typeof useUserInventoryEmojisChannelsLazyQuery>;
export type UserInventoryEmojisChannelsQueryResult = Apollo.QueryResult<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>;
export const ReceivedBoosterRequestMessageProfileDocument = gql`
    query ReceivedBoosterRequestMessageProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    ...ProfileImageProfile
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useReceivedBoosterRequestMessageProfileQuery__
 *
 * To run a query within a React component, call `useReceivedBoosterRequestMessageProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useReceivedBoosterRequestMessageProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReceivedBoosterRequestMessageProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useReceivedBoosterRequestMessageProfileQuery(baseOptions: Apollo.QueryHookOptions<ReceivedBoosterRequestMessageProfileQuery, ReceivedBoosterRequestMessageProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReceivedBoosterRequestMessageProfileQuery, ReceivedBoosterRequestMessageProfileQueryVariables>(ReceivedBoosterRequestMessageProfileDocument, options);
      }
export function useReceivedBoosterRequestMessageProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReceivedBoosterRequestMessageProfileQuery, ReceivedBoosterRequestMessageProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReceivedBoosterRequestMessageProfileQuery, ReceivedBoosterRequestMessageProfileQueryVariables>(ReceivedBoosterRequestMessageProfileDocument, options);
        }
export type ReceivedBoosterRequestMessageProfileQueryHookResult = ReturnType<typeof useReceivedBoosterRequestMessageProfileQuery>;
export type ReceivedBoosterRequestMessageProfileLazyQueryHookResult = ReturnType<typeof useReceivedBoosterRequestMessageProfileLazyQuery>;
export type ReceivedBoosterRequestMessageProfileQueryResult = Apollo.QueryResult<ReceivedBoosterRequestMessageProfileQuery, ReceivedBoosterRequestMessageProfileQueryVariables>;
export const SentBoosterRequestMessageProfileDocument = gql`
    query SentBoosterRequestMessageProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
  }
}
    `;

/**
 * __useSentBoosterRequestMessageProfileQuery__
 *
 * To run a query within a React component, call `useSentBoosterRequestMessageProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useSentBoosterRequestMessageProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSentBoosterRequestMessageProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSentBoosterRequestMessageProfileQuery(baseOptions: Apollo.QueryHookOptions<SentBoosterRequestMessageProfileQuery, SentBoosterRequestMessageProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SentBoosterRequestMessageProfileQuery, SentBoosterRequestMessageProfileQueryVariables>(SentBoosterRequestMessageProfileDocument, options);
      }
export function useSentBoosterRequestMessageProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SentBoosterRequestMessageProfileQuery, SentBoosterRequestMessageProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SentBoosterRequestMessageProfileQuery, SentBoosterRequestMessageProfileQueryVariables>(SentBoosterRequestMessageProfileDocument, options);
        }
export type SentBoosterRequestMessageProfileQueryHookResult = ReturnType<typeof useSentBoosterRequestMessageProfileQuery>;
export type SentBoosterRequestMessageProfileLazyQueryHookResult = ReturnType<typeof useSentBoosterRequestMessageProfileLazyQuery>;
export type SentBoosterRequestMessageProfileQueryResult = Apollo.QueryResult<SentBoosterRequestMessageProfileQuery, SentBoosterRequestMessageProfileQueryVariables>;
export const ChatProviderDataDocument = gql`
    query ChatProviderData($userId: ID!, $chatId: ID!, $channelId: ID!) {
  chatUserStatus(chatId: $chatId, userId: $userId) {
    muted
    muteDuration
  }
  userChannelRoles(userId: $userId, channelId: $channelId) {
    roles
  }
  profile(userId: $userId) {
    userId
    ...ChatMessagesHookProfile
  }
}
    ${ChatMessagesHookProfileFragmentDoc}`;

/**
 * __useChatProviderDataQuery__
 *
 * To run a query within a React component, call `useChatProviderDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatProviderDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatProviderDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      chatId: // value for 'chatId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChatProviderDataQuery(baseOptions: Apollo.QueryHookOptions<ChatProviderDataQuery, ChatProviderDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatProviderDataQuery, ChatProviderDataQueryVariables>(ChatProviderDataDocument, options);
      }
export function useChatProviderDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatProviderDataQuery, ChatProviderDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatProviderDataQuery, ChatProviderDataQueryVariables>(ChatProviderDataDocument, options);
        }
export type ChatProviderDataQueryHookResult = ReturnType<typeof useChatProviderDataQuery>;
export type ChatProviderDataLazyQueryHookResult = ReturnType<typeof useChatProviderDataLazyQuery>;
export type ChatProviderDataQueryResult = Apollo.QueryResult<ChatProviderDataQuery, ChatProviderDataQueryVariables>;
export const OwnChatSenderInfoProfileDocument = gql`
    query OwnChatSenderInfoProfile($userId: ID!, $channelId: ID) {
  profile(userId: $userId) {
    userId
    userTag
    avatars {
      avatar2D
    }
    preferredColor
    badges(channel_id: $channelId) {
      ...UserBadge
    }
  }
}
    ${UserBadgeFragmentDoc}`;

/**
 * __useOwnChatSenderInfoProfileQuery__
 *
 * To run a query within a React component, call `useOwnChatSenderInfoProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useOwnChatSenderInfoProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOwnChatSenderInfoProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useOwnChatSenderInfoProfileQuery(baseOptions: Apollo.QueryHookOptions<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>(OwnChatSenderInfoProfileDocument, options);
      }
export function useOwnChatSenderInfoProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>(OwnChatSenderInfoProfileDocument, options);
        }
export type OwnChatSenderInfoProfileQueryHookResult = ReturnType<typeof useOwnChatSenderInfoProfileQuery>;
export type OwnChatSenderInfoProfileLazyQueryHookResult = ReturnType<typeof useOwnChatSenderInfoProfileLazyQuery>;
export type OwnChatSenderInfoProfileQueryResult = Apollo.QueryResult<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>;
export const ReportUserDocument = gql`
    mutation ReportUser($reason: SupportReportReason!, $description: String, $context: SupportReportContextInput!) {
  createReport(reason: $reason, description: $description, context: $context) {
    createdAt
  }
}
    `;
export type ReportUserMutationFn = Apollo.MutationFunction<ReportUserMutation, ReportUserMutationVariables>;

/**
 * __useReportUserMutation__
 *
 * To run a mutation, you first call `useReportUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReportUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [reportUserMutation, { data, loading, error }] = useReportUserMutation({
 *   variables: {
 *      reason: // value for 'reason'
 *      description: // value for 'description'
 *      context: // value for 'context'
 *   },
 * });
 */
export function useReportUserMutation(baseOptions?: Apollo.MutationHookOptions<ReportUserMutation, ReportUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReportUserMutation, ReportUserMutationVariables>(ReportUserDocument, options);
      }
export type ReportUserMutationHookResult = ReturnType<typeof useReportUserMutation>;
export type ReportUserMutationResult = Apollo.MutationResult<ReportUserMutation>;
export type ReportUserMutationOptions = Apollo.BaseMutationOptions<ReportUserMutation, ReportUserMutationVariables>;
export const ReportedUserProfileDocument = gql`
    query ReportedUserProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ReportedUserProfile
    ...ReasonSelectProfile
  }
}
    ${ReportedUserProfileFragmentDoc}
${ReasonSelectProfileFragmentDoc}`;

/**
 * __useReportedUserProfileQuery__
 *
 * To run a query within a React component, call `useReportedUserProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportedUserProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportedUserProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useReportedUserProfileQuery(baseOptions: Apollo.QueryHookOptions<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>(ReportedUserProfileDocument, options);
      }
export function useReportedUserProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>(ReportedUserProfileDocument, options);
        }
export type ReportedUserProfileQueryHookResult = ReturnType<typeof useReportedUserProfileQuery>;
export type ReportedUserProfileLazyQueryHookResult = ReturnType<typeof useReportedUserProfileLazyQuery>;
export type ReportedUserProfileQueryResult = Apollo.QueryResult<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>;
export const ReportedChannelDocument = gql`
    query ReportedChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    ...ReasonSelectChannel
    ...ReportedChannel
  }
}
    ${ReasonSelectChannelFragmentDoc}
${ReportedChannelFragmentDoc}`;

/**
 * __useReportedChannelQuery__
 *
 * To run a query within a React component, call `useReportedChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportedChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportedChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useReportedChannelQuery(baseOptions: Apollo.QueryHookOptions<ReportedChannelQuery, ReportedChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportedChannelQuery, ReportedChannelQueryVariables>(ReportedChannelDocument, options);
      }
export function useReportedChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportedChannelQuery, ReportedChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportedChannelQuery, ReportedChannelQueryVariables>(ReportedChannelDocument, options);
        }
export type ReportedChannelQueryHookResult = ReturnType<typeof useReportedChannelQuery>;
export type ReportedChannelLazyQueryHookResult = ReturnType<typeof useReportedChannelLazyQuery>;
export type ReportedChannelQueryResult = Apollo.QueryResult<ReportedChannelQuery, ReportedChannelQueryVariables>;
export const ReportStreamTimestampDocument = gql`
    query ReportStreamTimestamp($streamId: ID!) {
  stream(id: $streamId) {
    streamId
    segments {
      startTime
    }
  }
}
    `;

/**
 * __useReportStreamTimestampQuery__
 *
 * To run a query within a React component, call `useReportStreamTimestampQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportStreamTimestampQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportStreamTimestampQuery({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useReportStreamTimestampQuery(baseOptions: Apollo.QueryHookOptions<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>(ReportStreamTimestampDocument, options);
      }
export function useReportStreamTimestampLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>(ReportStreamTimestampDocument, options);
        }
export type ReportStreamTimestampQueryHookResult = ReturnType<typeof useReportStreamTimestampQuery>;
export type ReportStreamTimestampLazyQueryHookResult = ReturnType<typeof useReportStreamTimestampLazyQuery>;
export type ReportStreamTimestampQueryResult = Apollo.QueryResult<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>;
export const SignupFlowChannelDocument = gql`
    query SignupFlowChannel($channelName: String!) {
  channelByName(name: $channelName) {
    id
    ...SignupFlowChannel
  }
}
    ${SignupFlowChannelFragmentDoc}`;

/**
 * __useSignupFlowChannelQuery__
 *
 * To run a query within a React component, call `useSignupFlowChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useSignupFlowChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSignupFlowChannelQuery({
 *   variables: {
 *      channelName: // value for 'channelName'
 *   },
 * });
 */
export function useSignupFlowChannelQuery(baseOptions: Apollo.QueryHookOptions<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>(SignupFlowChannelDocument, options);
      }
export function useSignupFlowChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>(SignupFlowChannelDocument, options);
        }
export type SignupFlowChannelQueryHookResult = ReturnType<typeof useSignupFlowChannelQuery>;
export type SignupFlowChannelLazyQueryHookResult = ReturnType<typeof useSignupFlowChannelLazyQuery>;
export type SignupFlowChannelQueryResult = Apollo.QueryResult<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>;
export const ChannelAssetCreateTokenDocument = gql`
    mutation ChannelAssetCreateToken($channelId: ID, $assetType: ChannelAssetType) {
  createChannelAssetUploadToken(channelId: $channelId, assetType: $assetType) {
    token
  }
}
    `;
export type ChannelAssetCreateTokenMutationFn = Apollo.MutationFunction<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>;

/**
 * __useChannelAssetCreateTokenMutation__
 *
 * To run a mutation, you first call `useChannelAssetCreateTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelAssetCreateTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelAssetCreateTokenMutation, { data, loading, error }] = useChannelAssetCreateTokenMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      assetType: // value for 'assetType'
 *   },
 * });
 */
export function useChannelAssetCreateTokenMutation(baseOptions?: Apollo.MutationHookOptions<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>(ChannelAssetCreateTokenDocument, options);
      }
export type ChannelAssetCreateTokenMutationHookResult = ReturnType<typeof useChannelAssetCreateTokenMutation>;
export type ChannelAssetCreateTokenMutationResult = Apollo.MutationResult<ChannelAssetCreateTokenMutation>;
export type ChannelAssetCreateTokenMutationOptions = Apollo.BaseMutationOptions<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>;
export const EmojiAssetCreateTokenDocument = gql`
    mutation EmojiAssetCreateToken($itemId: ID!) {
  createEmojiUploadToken(itemId: $itemId) {
    token
  }
}
    `;
export type EmojiAssetCreateTokenMutationFn = Apollo.MutationFunction<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>;

/**
 * __useEmojiAssetCreateTokenMutation__
 *
 * To run a mutation, you first call `useEmojiAssetCreateTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEmojiAssetCreateTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [emojiAssetCreateTokenMutation, { data, loading, error }] = useEmojiAssetCreateTokenMutation({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useEmojiAssetCreateTokenMutation(baseOptions?: Apollo.MutationHookOptions<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>(EmojiAssetCreateTokenDocument, options);
      }
export type EmojiAssetCreateTokenMutationHookResult = ReturnType<typeof useEmojiAssetCreateTokenMutation>;
export type EmojiAssetCreateTokenMutationResult = Apollo.MutationResult<EmojiAssetCreateTokenMutation>;
export type EmojiAssetCreateTokenMutationOptions = Apollo.BaseMutationOptions<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>;
export const WalletDocument = gql`
    query Wallet($userId: ID!) {
  wallet(userId: $userId) {
    wallet {
      currencies {
        ...WalletCurrency
      }
    }
  }
}
    ${WalletCurrencyFragmentDoc}`;

/**
 * __useWalletQuery__
 *
 * To run a query within a React component, call `useWalletQuery` and pass it any options that fit your needs.
 * When your component renders, `useWalletQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useWalletQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useWalletQuery(baseOptions: Apollo.QueryHookOptions<WalletQuery, WalletQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<WalletQuery, WalletQueryVariables>(WalletDocument, options);
      }
export function useWalletLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<WalletQuery, WalletQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<WalletQuery, WalletQueryVariables>(WalletDocument, options);
        }
export type WalletQueryHookResult = ReturnType<typeof useWalletQuery>;
export type WalletLazyQueryHookResult = ReturnType<typeof useWalletLazyQuery>;
export type WalletQueryResult = Apollo.QueryResult<WalletQuery, WalletQueryVariables>;
export const StreamSpectatorCoordinationSubscribeDocument = gql`
    subscription StreamSpectatorCoordinationSubscribe($streamId: ID!) {
  streamSpectatorCoordinationEventsSubscribe(streamId: $streamId) {
    event {
      ... on MatchStreamSpectatorChangeGroupEvent {
        groupId
      }
    }
  }
}
    `;

/**
 * __useStreamSpectatorCoordinationSubscribeSubscription__
 *
 * To run a query within a React component, call `useStreamSpectatorCoordinationSubscribeSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStreamSpectatorCoordinationSubscribeSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamSpectatorCoordinationSubscribeSubscription({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useStreamSpectatorCoordinationSubscribeSubscription(baseOptions: Apollo.SubscriptionHookOptions<StreamSpectatorCoordinationSubscribeSubscription, StreamSpectatorCoordinationSubscribeSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StreamSpectatorCoordinationSubscribeSubscription, StreamSpectatorCoordinationSubscribeSubscriptionVariables>(StreamSpectatorCoordinationSubscribeDocument, options);
      }
export type StreamSpectatorCoordinationSubscribeSubscriptionHookResult = ReturnType<typeof useStreamSpectatorCoordinationSubscribeSubscription>;
export type StreamSpectatorCoordinationSubscribeSubscriptionResult = Apollo.SubscriptionResult<StreamSpectatorCoordinationSubscribeSubscription>;
export const UpdateAvatarDocument = gql`
    mutation UpdateAvatar($avatarId: ID!) {
  updateProfileAvatar(modelId: $avatarId) {
    emptyTypeWorkaround
  }
}
    `;
export type UpdateAvatarMutationFn = Apollo.MutationFunction<UpdateAvatarMutation, UpdateAvatarMutationVariables>;

/**
 * __useUpdateAvatarMutation__
 *
 * To run a mutation, you first call `useUpdateAvatarMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAvatarMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAvatarMutation, { data, loading, error }] = useUpdateAvatarMutation({
 *   variables: {
 *      avatarId: // value for 'avatarId'
 *   },
 * });
 */
export function useUpdateAvatarMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAvatarMutation, UpdateAvatarMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAvatarMutation, UpdateAvatarMutationVariables>(UpdateAvatarDocument, options);
      }
export type UpdateAvatarMutationHookResult = ReturnType<typeof useUpdateAvatarMutation>;
export type UpdateAvatarMutationResult = Apollo.MutationResult<UpdateAvatarMutation>;
export type UpdateAvatarMutationOptions = Apollo.BaseMutationOptions<UpdateAvatarMutation, UpdateAvatarMutationVariables>;
export const SocialChannelBanDocument = gql`
    mutation SocialChannelBan($userId: ID!, $channelId: ID!, $violation: ChannelViolation, $description: String, $keepRecentMessages: Boolean) {
  banChannelUser(
    userId: $userId
    channelId: $channelId
    violation: $violation
    description: $description
    keepRecentMessages: $keepRecentMessages
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialChannelBanMutationFn = Apollo.MutationFunction<SocialChannelBanMutation, SocialChannelBanMutationVariables>;

/**
 * __useSocialChannelBanMutation__
 *
 * To run a mutation, you first call `useSocialChannelBanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialChannelBanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialChannelBanMutation, { data, loading, error }] = useSocialChannelBanMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *      violation: // value for 'violation'
 *      description: // value for 'description'
 *      keepRecentMessages: // value for 'keepRecentMessages'
 *   },
 * });
 */
export function useSocialChannelBanMutation(baseOptions?: Apollo.MutationHookOptions<SocialChannelBanMutation, SocialChannelBanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialChannelBanMutation, SocialChannelBanMutationVariables>(SocialChannelBanDocument, options);
      }
export type SocialChannelBanMutationHookResult = ReturnType<typeof useSocialChannelBanMutation>;
export type SocialChannelBanMutationResult = Apollo.MutationResult<SocialChannelBanMutation>;
export type SocialChannelBanMutationOptions = Apollo.BaseMutationOptions<SocialChannelBanMutation, SocialChannelBanMutationVariables>;
export const SocialChannelUnbanDocument = gql`
    mutation SocialChannelUnban($userId: ID!, $channelId: ID!) {
  unbanChannelUser(userId: $userId, channelId: $channelId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialChannelUnbanMutationFn = Apollo.MutationFunction<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>;

/**
 * __useSocialChannelUnbanMutation__
 *
 * To run a mutation, you first call `useSocialChannelUnbanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialChannelUnbanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialChannelUnbanMutation, { data, loading, error }] = useSocialChannelUnbanMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSocialChannelUnbanMutation(baseOptions?: Apollo.MutationHookOptions<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>(SocialChannelUnbanDocument, options);
      }
export type SocialChannelUnbanMutationHookResult = ReturnType<typeof useSocialChannelUnbanMutation>;
export type SocialChannelUnbanMutationResult = Apollo.MutationResult<SocialChannelUnbanMutation>;
export type SocialChannelUnbanMutationOptions = Apollo.BaseMutationOptions<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>;
export const BlockedUserProfileDocument = gql`
    query BlockedUserProfile($userId: ID!) {
  profile(userId: $userId) {
    ...BlockUserProfile
    userId
  }
}
    ${BlockUserProfileFragmentDoc}`;

/**
 * __useBlockedUserProfileQuery__
 *
 * To run a query within a React component, call `useBlockedUserProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlockedUserProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlockedUserProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useBlockedUserProfileQuery(baseOptions: Apollo.QueryHookOptions<BlockedUserProfileQuery, BlockedUserProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BlockedUserProfileQuery, BlockedUserProfileQueryVariables>(BlockedUserProfileDocument, options);
      }
export function useBlockedUserProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BlockedUserProfileQuery, BlockedUserProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BlockedUserProfileQuery, BlockedUserProfileQueryVariables>(BlockedUserProfileDocument, options);
        }
export type BlockedUserProfileQueryHookResult = ReturnType<typeof useBlockedUserProfileQuery>;
export type BlockedUserProfileLazyQueryHookResult = ReturnType<typeof useBlockedUserProfileLazyQuery>;
export type BlockedUserProfileQueryResult = Apollo.QueryResult<BlockedUserProfileQuery, BlockedUserProfileQueryVariables>;
export const MuteUserDocument = gql`
    mutation MuteUser($chatId: ID!, $userId: ID!, $duration: Duration!, $reason: ChatReason!, $description: String!) {
  muteChatUser(
    chatId: $chatId
    userId: $userId
    duration: $duration
    reason: $reason
    description: $description
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type MuteUserMutationFn = Apollo.MutationFunction<MuteUserMutation, MuteUserMutationVariables>;

/**
 * __useMuteUserMutation__
 *
 * To run a mutation, you first call `useMuteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMuteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [muteUserMutation, { data, loading, error }] = useMuteUserMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      userId: // value for 'userId'
 *      duration: // value for 'duration'
 *      reason: // value for 'reason'
 *      description: // value for 'description'
 *   },
 * });
 */
export function useMuteUserMutation(baseOptions?: Apollo.MutationHookOptions<MuteUserMutation, MuteUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<MuteUserMutation, MuteUserMutationVariables>(MuteUserDocument, options);
      }
export type MuteUserMutationHookResult = ReturnType<typeof useMuteUserMutation>;
export type MuteUserMutationResult = Apollo.MutationResult<MuteUserMutation>;
export type MuteUserMutationOptions = Apollo.BaseMutationOptions<MuteUserMutation, MuteUserMutationVariables>;
export const UnmuteUserDocument = gql`
    mutation UnmuteUser($chatId: ID!, $userId: ID!) {
  unmuteChatUser(chatId: $chatId, userId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type UnmuteUserMutationFn = Apollo.MutationFunction<UnmuteUserMutation, UnmuteUserMutationVariables>;

/**
 * __useUnmuteUserMutation__
 *
 * To run a mutation, you first call `useUnmuteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnmuteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unmuteUserMutation, { data, loading, error }] = useUnmuteUserMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUnmuteUserMutation(baseOptions?: Apollo.MutationHookOptions<UnmuteUserMutation, UnmuteUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnmuteUserMutation, UnmuteUserMutationVariables>(UnmuteUserDocument, options);
      }
export type UnmuteUserMutationHookResult = ReturnType<typeof useUnmuteUserMutation>;
export type UnmuteUserMutationResult = Apollo.MutationResult<UnmuteUserMutation>;
export type UnmuteUserMutationOptions = Apollo.BaseMutationOptions<UnmuteUserMutation, UnmuteUserMutationVariables>;
export const ResolvedAddFriendUserTagDocument = gql`
    query ResolvedAddFriendUserTag($userTag: String!) {
  resolveUserTags(userTags: [$userTag]) {
    userIds {
      key
      value
    }
  }
}
    `;

/**
 * __useResolvedAddFriendUserTagQuery__
 *
 * To run a query within a React component, call `useResolvedAddFriendUserTagQuery` and pass it any options that fit your needs.
 * When your component renders, `useResolvedAddFriendUserTagQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useResolvedAddFriendUserTagQuery({
 *   variables: {
 *      userTag: // value for 'userTag'
 *   },
 * });
 */
export function useResolvedAddFriendUserTagQuery(baseOptions: Apollo.QueryHookOptions<ResolvedAddFriendUserTagQuery, ResolvedAddFriendUserTagQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ResolvedAddFriendUserTagQuery, ResolvedAddFriendUserTagQueryVariables>(ResolvedAddFriendUserTagDocument, options);
      }
export function useResolvedAddFriendUserTagLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ResolvedAddFriendUserTagQuery, ResolvedAddFriendUserTagQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ResolvedAddFriendUserTagQuery, ResolvedAddFriendUserTagQueryVariables>(ResolvedAddFriendUserTagDocument, options);
        }
export type ResolvedAddFriendUserTagQueryHookResult = ReturnType<typeof useResolvedAddFriendUserTagQuery>;
export type ResolvedAddFriendUserTagLazyQueryHookResult = ReturnType<typeof useResolvedAddFriendUserTagLazyQuery>;
export type ResolvedAddFriendUserTagQueryResult = Apollo.QueryResult<ResolvedAddFriendUserTagQuery, ResolvedAddFriendUserTagQueryVariables>;
export const FriendSidebarFriendsDocument = gql`
    query FriendSidebarFriends($userId: ID!, $cursor: String, $pageSize: Int! = 25) {
  friends(
    userId: $userId
    cursor: {first: $pageSize, after: $cursor}
    priorityOrder: true
  ) {
    pageInfo {
      endCursor
      hasNextPage
    }
    users {
      userId
      ...FriendsSidebarFriendListFriend
      ...FriendsSidebarPartyFriend
    }
  }
}
    ${FriendsSidebarFriendListFriendFragmentDoc}
${FriendsSidebarPartyFriendFragmentDoc}`;

/**
 * __useFriendSidebarFriendsQuery__
 *
 * To run a query within a React component, call `useFriendSidebarFriendsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendSidebarFriendsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendSidebarFriendsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useFriendSidebarFriendsQuery(baseOptions: Apollo.QueryHookOptions<FriendSidebarFriendsQuery, FriendSidebarFriendsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendSidebarFriendsQuery, FriendSidebarFriendsQueryVariables>(FriendSidebarFriendsDocument, options);
      }
export function useFriendSidebarFriendsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendSidebarFriendsQuery, FriendSidebarFriendsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendSidebarFriendsQuery, FriendSidebarFriendsQueryVariables>(FriendSidebarFriendsDocument, options);
        }
export type FriendSidebarFriendsQueryHookResult = ReturnType<typeof useFriendSidebarFriendsQuery>;
export type FriendSidebarFriendsLazyQueryHookResult = ReturnType<typeof useFriendSidebarFriendsLazyQuery>;
export type FriendSidebarFriendsQueryResult = Apollo.QueryResult<FriendSidebarFriendsQuery, FriendSidebarFriendsQueryVariables>;
export const FriendsSidebarFriendsViewDataDocument = gql`
    query FriendsSidebarFriendsViewData($userId: ID!) {
  receivedFriendRequests(userId: $userId) {
    users {
      userId
      profile {
        userId
      }
    }
  }
}
    `;

/**
 * __useFriendsSidebarFriendsViewDataQuery__
 *
 * To run a query within a React component, call `useFriendsSidebarFriendsViewDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendsSidebarFriendsViewDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendsSidebarFriendsViewDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFriendsSidebarFriendsViewDataQuery(baseOptions: Apollo.QueryHookOptions<FriendsSidebarFriendsViewDataQuery, FriendsSidebarFriendsViewDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendsSidebarFriendsViewDataQuery, FriendsSidebarFriendsViewDataQueryVariables>(FriendsSidebarFriendsViewDataDocument, options);
      }
export function useFriendsSidebarFriendsViewDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendsSidebarFriendsViewDataQuery, FriendsSidebarFriendsViewDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendsSidebarFriendsViewDataQuery, FriendsSidebarFriendsViewDataQueryVariables>(FriendsSidebarFriendsViewDataDocument, options);
        }
export type FriendsSidebarFriendsViewDataQueryHookResult = ReturnType<typeof useFriendsSidebarFriendsViewDataQuery>;
export type FriendsSidebarFriendsViewDataLazyQueryHookResult = ReturnType<typeof useFriendsSidebarFriendsViewDataLazyQuery>;
export type FriendsSidebarFriendsViewDataQueryResult = Apollo.QueryResult<FriendsSidebarFriendsViewDataQuery, FriendsSidebarFriendsViewDataQueryVariables>;
export const FriendsSidebarPartyDocument = gql`
    query FriendsSidebarParty($partyId: ID!) {
  party(partyId: $partyId) {
    id
    leaderId
    members {
      userId
      profile {
        ...FriendsSidebarFriendListProfile
        ...FriendsSidebarPartyProfile
      }
    }
    channel {
      id
      currentStreamId
      name
      game {
        id
        name
      }
    }
  }
}
    ${FriendsSidebarFriendListProfileFragmentDoc}
${FriendsSidebarPartyProfileFragmentDoc}`;

/**
 * __useFriendsSidebarPartyQuery__
 *
 * To run a query within a React component, call `useFriendsSidebarPartyQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendsSidebarPartyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendsSidebarPartyQuery({
 *   variables: {
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function useFriendsSidebarPartyQuery(baseOptions: Apollo.QueryHookOptions<FriendsSidebarPartyQuery, FriendsSidebarPartyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendsSidebarPartyQuery, FriendsSidebarPartyQueryVariables>(FriendsSidebarPartyDocument, options);
      }
export function useFriendsSidebarPartyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendsSidebarPartyQuery, FriendsSidebarPartyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendsSidebarPartyQuery, FriendsSidebarPartyQueryVariables>(FriendsSidebarPartyDocument, options);
        }
export type FriendsSidebarPartyQueryHookResult = ReturnType<typeof useFriendsSidebarPartyQuery>;
export type FriendsSidebarPartyLazyQueryHookResult = ReturnType<typeof useFriendsSidebarPartyLazyQuery>;
export type FriendsSidebarPartyQueryResult = Apollo.QueryResult<FriendsSidebarPartyQuery, FriendsSidebarPartyQueryVariables>;
export const FriendsSidebarMenuPendingRequestsDocument = gql`
    query FriendsSidebarMenuPendingRequests($userId: ID!) {
  receivedFriendRequests(userId: $userId) {
    users {
      userId
    }
  }
}
    `;

/**
 * __useFriendsSidebarMenuPendingRequestsQuery__
 *
 * To run a query within a React component, call `useFriendsSidebarMenuPendingRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendsSidebarMenuPendingRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendsSidebarMenuPendingRequestsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFriendsSidebarMenuPendingRequestsQuery(baseOptions: Apollo.QueryHookOptions<FriendsSidebarMenuPendingRequestsQuery, FriendsSidebarMenuPendingRequestsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendsSidebarMenuPendingRequestsQuery, FriendsSidebarMenuPendingRequestsQueryVariables>(FriendsSidebarMenuPendingRequestsDocument, options);
      }
export function useFriendsSidebarMenuPendingRequestsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendsSidebarMenuPendingRequestsQuery, FriendsSidebarMenuPendingRequestsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendsSidebarMenuPendingRequestsQuery, FriendsSidebarMenuPendingRequestsQueryVariables>(FriendsSidebarMenuPendingRequestsDocument, options);
        }
export type FriendsSidebarMenuPendingRequestsQueryHookResult = ReturnType<typeof useFriendsSidebarMenuPendingRequestsQuery>;
export type FriendsSidebarMenuPendingRequestsLazyQueryHookResult = ReturnType<typeof useFriendsSidebarMenuPendingRequestsLazyQuery>;
export type FriendsSidebarMenuPendingRequestsQueryResult = Apollo.QueryResult<FriendsSidebarMenuPendingRequestsQuery, FriendsSidebarMenuPendingRequestsQueryVariables>;
export const FriendsSidebarPendingViewDataDocument = gql`
    query FriendsSidebarPendingViewData($userId: ID!) {
  receivedFriendRequests(userId: $userId) {
    users {
      userId
      ...FriendsSidebarFriendListFriend
    }
  }
  sentFriendRequests(userId: $userId) {
    users {
      userId
      ...FriendsSidebarFriendListFriend
    }
  }
}
    ${FriendsSidebarFriendListFriendFragmentDoc}`;

/**
 * __useFriendsSidebarPendingViewDataQuery__
 *
 * To run a query within a React component, call `useFriendsSidebarPendingViewDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendsSidebarPendingViewDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendsSidebarPendingViewDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFriendsSidebarPendingViewDataQuery(baseOptions: Apollo.QueryHookOptions<FriendsSidebarPendingViewDataQuery, FriendsSidebarPendingViewDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendsSidebarPendingViewDataQuery, FriendsSidebarPendingViewDataQueryVariables>(FriendsSidebarPendingViewDataDocument, options);
      }
export function useFriendsSidebarPendingViewDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendsSidebarPendingViewDataQuery, FriendsSidebarPendingViewDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendsSidebarPendingViewDataQuery, FriendsSidebarPendingViewDataQueryVariables>(FriendsSidebarPendingViewDataDocument, options);
        }
export type FriendsSidebarPendingViewDataQueryHookResult = ReturnType<typeof useFriendsSidebarPendingViewDataQuery>;
export type FriendsSidebarPendingViewDataLazyQueryHookResult = ReturnType<typeof useFriendsSidebarPendingViewDataLazyQuery>;
export type FriendsSidebarPendingViewDataQueryResult = Apollo.QueryResult<FriendsSidebarPendingViewDataQuery, FriendsSidebarPendingViewDataQueryVariables>;
export const GiftSubscriptionToCommunityButtonRolesDocument = gql`
    query GiftSubscriptionToCommunityButtonRoles($userId: ID!, $channelId: ID!) {
  userChannelRoles(userId: $userId, channelId: $channelId) {
    roles
  }
}
    `;

/**
 * __useGiftSubscriptionToCommunityButtonRolesQuery__
 *
 * To run a query within a React component, call `useGiftSubscriptionToCommunityButtonRolesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGiftSubscriptionToCommunityButtonRolesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGiftSubscriptionToCommunityButtonRolesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useGiftSubscriptionToCommunityButtonRolesQuery(baseOptions: Apollo.QueryHookOptions<GiftSubscriptionToCommunityButtonRolesQuery, GiftSubscriptionToCommunityButtonRolesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GiftSubscriptionToCommunityButtonRolesQuery, GiftSubscriptionToCommunityButtonRolesQueryVariables>(GiftSubscriptionToCommunityButtonRolesDocument, options);
      }
export function useGiftSubscriptionToCommunityButtonRolesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GiftSubscriptionToCommunityButtonRolesQuery, GiftSubscriptionToCommunityButtonRolesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GiftSubscriptionToCommunityButtonRolesQuery, GiftSubscriptionToCommunityButtonRolesQueryVariables>(GiftSubscriptionToCommunityButtonRolesDocument, options);
        }
export type GiftSubscriptionToCommunityButtonRolesQueryHookResult = ReturnType<typeof useGiftSubscriptionToCommunityButtonRolesQuery>;
export type GiftSubscriptionToCommunityButtonRolesLazyQueryHookResult = ReturnType<typeof useGiftSubscriptionToCommunityButtonRolesLazyQuery>;
export type GiftSubscriptionToCommunityButtonRolesQueryResult = Apollo.QueryResult<GiftSubscriptionToCommunityButtonRolesQuery, GiftSubscriptionToCommunityButtonRolesQueryVariables>;
export const MiniProfileFollowingStateDocument = gql`
    query MiniProfileFollowingState($userId: ID!, $channelId: ID!) {
  channelFollowerStatus(userId: $userId, channelId: $channelId) {
    following
    followedAt
  }
}
    `;

/**
 * __useMiniProfileFollowingStateQuery__
 *
 * To run a query within a React component, call `useMiniProfileFollowingStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useMiniProfileFollowingStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMiniProfileFollowingStateQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useMiniProfileFollowingStateQuery(baseOptions: Apollo.QueryHookOptions<MiniProfileFollowingStateQuery, MiniProfileFollowingStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MiniProfileFollowingStateQuery, MiniProfileFollowingStateQueryVariables>(MiniProfileFollowingStateDocument, options);
      }
export function useMiniProfileFollowingStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MiniProfileFollowingStateQuery, MiniProfileFollowingStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MiniProfileFollowingStateQuery, MiniProfileFollowingStateQueryVariables>(MiniProfileFollowingStateDocument, options);
        }
export type MiniProfileFollowingStateQueryHookResult = ReturnType<typeof useMiniProfileFollowingStateQuery>;
export type MiniProfileFollowingStateLazyQueryHookResult = ReturnType<typeof useMiniProfileFollowingStateLazyQuery>;
export type MiniProfileFollowingStateQueryResult = Apollo.QueryResult<MiniProfileFollowingStateQuery, MiniProfileFollowingStateQueryVariables>;
export const MiniProfileGameRankChannelDocument = gql`
    query MiniProfileGameRankChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    gameId
    game {
      id
      activeSeasonId
    }
  }
}
    `;

/**
 * __useMiniProfileGameRankChannelQuery__
 *
 * To run a query within a React component, call `useMiniProfileGameRankChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useMiniProfileGameRankChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMiniProfileGameRankChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useMiniProfileGameRankChannelQuery(baseOptions: Apollo.QueryHookOptions<MiniProfileGameRankChannelQuery, MiniProfileGameRankChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MiniProfileGameRankChannelQuery, MiniProfileGameRankChannelQueryVariables>(MiniProfileGameRankChannelDocument, options);
      }
export function useMiniProfileGameRankChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MiniProfileGameRankChannelQuery, MiniProfileGameRankChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MiniProfileGameRankChannelQuery, MiniProfileGameRankChannelQueryVariables>(MiniProfileGameRankChannelDocument, options);
        }
export type MiniProfileGameRankChannelQueryHookResult = ReturnType<typeof useMiniProfileGameRankChannelQuery>;
export type MiniProfileGameRankChannelLazyQueryHookResult = ReturnType<typeof useMiniProfileGameRankChannelLazyQuery>;
export type MiniProfileGameRankChannelQueryResult = Apollo.QueryResult<MiniProfileGameRankChannelQuery, MiniProfileGameRankChannelQueryVariables>;
export const MiniProfileDocument = gql`
    query MiniProfile($userId: ID!, $channelId: ID) {
  profile(userId: $userId) {
    userId
    friendshipStatus {
      status
    }
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    ...MiniProfile
    ...ChannelBanModalProfile
    ...ChannelUnbanModalProfile
    ...ChannelMuteModalProfile
    ...ChannelUnmuteModalProfile
  }
}
    ${UserBadgeFragmentDoc}
${MiniProfileFragmentDoc}
${ChannelBanModalProfileFragmentDoc}
${ChannelUnbanModalProfileFragmentDoc}
${ChannelMuteModalProfileFragmentDoc}
${ChannelUnmuteModalProfileFragmentDoc}`;

/**
 * __useMiniProfileQuery__
 *
 * To run a query within a React component, call `useMiniProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useMiniProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMiniProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useMiniProfileQuery(baseOptions: Apollo.QueryHookOptions<MiniProfileQuery, MiniProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MiniProfileQuery, MiniProfileQueryVariables>(MiniProfileDocument, options);
      }
export function useMiniProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MiniProfileQuery, MiniProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MiniProfileQuery, MiniProfileQueryVariables>(MiniProfileDocument, options);
        }
export type MiniProfileQueryHookResult = ReturnType<typeof useMiniProfileQuery>;
export type MiniProfileLazyQueryHookResult = ReturnType<typeof useMiniProfileLazyQuery>;
export type MiniProfileQueryResult = Apollo.QueryResult<MiniProfileQuery, MiniProfileQueryVariables>;
export const MiniProfileModeratorStatusDocument = gql`
    query MiniProfileModeratorStatus($userId: ID!, $channelId: ID!, $chatId: ID, $skipChatModerationData: Boolean!) {
  channelBanUserStatus(userId: $userId, channelId: $channelId) {
    userId
    channelId
    banned
    ...MiniProfilePortalChannelBan
  }
  chatUserStatus(userId: $userId, chatId: $chatId) @skip(if: $skipChatModerationData) {
    ...MiniProfilePortalChatStaus
  }
}
    ${MiniProfilePortalChannelBanFragmentDoc}
${MiniProfilePortalChatStausFragmentDoc}`;

/**
 * __useMiniProfileModeratorStatusQuery__
 *
 * To run a query within a React component, call `useMiniProfileModeratorStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `useMiniProfileModeratorStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMiniProfileModeratorStatusQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *      chatId: // value for 'chatId'
 *      skipChatModerationData: // value for 'skipChatModerationData'
 *   },
 * });
 */
export function useMiniProfileModeratorStatusQuery(baseOptions: Apollo.QueryHookOptions<MiniProfileModeratorStatusQuery, MiniProfileModeratorStatusQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MiniProfileModeratorStatusQuery, MiniProfileModeratorStatusQueryVariables>(MiniProfileModeratorStatusDocument, options);
      }
export function useMiniProfileModeratorStatusLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MiniProfileModeratorStatusQuery, MiniProfileModeratorStatusQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MiniProfileModeratorStatusQuery, MiniProfileModeratorStatusQueryVariables>(MiniProfileModeratorStatusDocument, options);
        }
export type MiniProfileModeratorStatusQueryHookResult = ReturnType<typeof useMiniProfileModeratorStatusQuery>;
export type MiniProfileModeratorStatusLazyQueryHookResult = ReturnType<typeof useMiniProfileModeratorStatusLazyQuery>;
export type MiniProfileModeratorStatusQueryResult = Apollo.QueryResult<MiniProfileModeratorStatusQuery, MiniProfileModeratorStatusQueryVariables>;
export const UserChannelRolesDocument = gql`
    query UserChannelRoles($userId: ID, $channelId: ID!, $skipRoles: Boolean!) {
  userChannelRoles(userId: $userId, channelId: $channelId) @skip(if: $skipRoles) {
    roles
  }
  channel(id: $channelId) {
    id
    currentChatId
  }
}
    `;

/**
 * __useUserChannelRolesQuery__
 *
 * To run a query within a React component, call `useUserChannelRolesQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserChannelRolesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserChannelRolesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *      skipRoles: // value for 'skipRoles'
 *   },
 * });
 */
export function useUserChannelRolesQuery(baseOptions: Apollo.QueryHookOptions<UserChannelRolesQuery, UserChannelRolesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserChannelRolesQuery, UserChannelRolesQueryVariables>(UserChannelRolesDocument, options);
      }
export function useUserChannelRolesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserChannelRolesQuery, UserChannelRolesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserChannelRolesQuery, UserChannelRolesQueryVariables>(UserChannelRolesDocument, options);
        }
export type UserChannelRolesQueryHookResult = ReturnType<typeof useUserChannelRolesQuery>;
export type UserChannelRolesLazyQueryHookResult = ReturnType<typeof useUserChannelRolesLazyQuery>;
export type UserChannelRolesQueryResult = Apollo.QueryResult<UserChannelRolesQuery, UserChannelRolesQueryVariables>;
export const LeavePartyDocument = gql`
    mutation LeaveParty($userId: ID!, $partyId: ID!) {
  deletePartyMember(userId: $userId, partyId: $partyId) {
    emptyTypeWorkaround
  }
}
    `;
export type LeavePartyMutationFn = Apollo.MutationFunction<LeavePartyMutation, LeavePartyMutationVariables>;

/**
 * __useLeavePartyMutation__
 *
 * To run a mutation, you first call `useLeavePartyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLeavePartyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [leavePartyMutation, { data, loading, error }] = useLeavePartyMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function useLeavePartyMutation(baseOptions?: Apollo.MutationHookOptions<LeavePartyMutation, LeavePartyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LeavePartyMutation, LeavePartyMutationVariables>(LeavePartyDocument, options);
      }
export type LeavePartyMutationHookResult = ReturnType<typeof useLeavePartyMutation>;
export type LeavePartyMutationResult = Apollo.MutationResult<LeavePartyMutation>;
export type LeavePartyMutationOptions = Apollo.BaseMutationOptions<LeavePartyMutation, LeavePartyMutationVariables>;
export const CreatePartyDocument = gql`
    mutation CreateParty {
  createParty {
    id
  }
}
    `;
export type CreatePartyMutationFn = Apollo.MutationFunction<CreatePartyMutation, CreatePartyMutationVariables>;

/**
 * __useCreatePartyMutation__
 *
 * To run a mutation, you first call `useCreatePartyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePartyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPartyMutation, { data, loading, error }] = useCreatePartyMutation({
 *   variables: {
 *   },
 * });
 */
export function useCreatePartyMutation(baseOptions?: Apollo.MutationHookOptions<CreatePartyMutation, CreatePartyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePartyMutation, CreatePartyMutationVariables>(CreatePartyDocument, options);
      }
export type CreatePartyMutationHookResult = ReturnType<typeof useCreatePartyMutation>;
export type CreatePartyMutationResult = Apollo.MutationResult<CreatePartyMutation>;
export type CreatePartyMutationOptions = Apollo.BaseMutationOptions<CreatePartyMutation, CreatePartyMutationVariables>;
export const CreatePartyInvitationDocument = gql`
    mutation CreatePartyInvitation($inviterId: ID!, $inviteeId: ID!, $partyId: ID!) {
  createPartyInvitation(
    inviterId: $inviterId
    inviteeId: $inviteeId
    partyId: $partyId
  ) {
    partyId
  }
}
    `;
export type CreatePartyInvitationMutationFn = Apollo.MutationFunction<CreatePartyInvitationMutation, CreatePartyInvitationMutationVariables>;

/**
 * __useCreatePartyInvitationMutation__
 *
 * To run a mutation, you first call `useCreatePartyInvitationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePartyInvitationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPartyInvitationMutation, { data, loading, error }] = useCreatePartyInvitationMutation({
 *   variables: {
 *      inviterId: // value for 'inviterId'
 *      inviteeId: // value for 'inviteeId'
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function useCreatePartyInvitationMutation(baseOptions?: Apollo.MutationHookOptions<CreatePartyInvitationMutation, CreatePartyInvitationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePartyInvitationMutation, CreatePartyInvitationMutationVariables>(CreatePartyInvitationDocument, options);
      }
export type CreatePartyInvitationMutationHookResult = ReturnType<typeof useCreatePartyInvitationMutation>;
export type CreatePartyInvitationMutationResult = Apollo.MutationResult<CreatePartyInvitationMutation>;
export type CreatePartyInvitationMutationOptions = Apollo.BaseMutationOptions<CreatePartyInvitationMutation, CreatePartyInvitationMutationVariables>;
export const PartyInvitesCreatePartyMemberDocument = gql`
    mutation PartyInvitesCreatePartyMember($userId: ID!, $partyId: ID!) {
  createPartyMember(userId: $userId, partyId: $partyId) {
    emptyTypeWorkaround
  }
}
    `;
export type PartyInvitesCreatePartyMemberMutationFn = Apollo.MutationFunction<PartyInvitesCreatePartyMemberMutation, PartyInvitesCreatePartyMemberMutationVariables>;

/**
 * __usePartyInvitesCreatePartyMemberMutation__
 *
 * To run a mutation, you first call `usePartyInvitesCreatePartyMemberMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePartyInvitesCreatePartyMemberMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [partyInvitesCreatePartyMemberMutation, { data, loading, error }] = usePartyInvitesCreatePartyMemberMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function usePartyInvitesCreatePartyMemberMutation(baseOptions?: Apollo.MutationHookOptions<PartyInvitesCreatePartyMemberMutation, PartyInvitesCreatePartyMemberMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PartyInvitesCreatePartyMemberMutation, PartyInvitesCreatePartyMemberMutationVariables>(PartyInvitesCreatePartyMemberDocument, options);
      }
export type PartyInvitesCreatePartyMemberMutationHookResult = ReturnType<typeof usePartyInvitesCreatePartyMemberMutation>;
export type PartyInvitesCreatePartyMemberMutationResult = Apollo.MutationResult<PartyInvitesCreatePartyMemberMutation>;
export type PartyInvitesCreatePartyMemberMutationOptions = Apollo.BaseMutationOptions<PartyInvitesCreatePartyMemberMutation, PartyInvitesCreatePartyMemberMutationVariables>;
export const PartyInvitesDeletePartyInviteDocument = gql`
    mutation PartyInvitesDeletePartyInvite($userId: ID!, $partyId: ID!) {
  deletePartyInvitation(userId: $userId, partyId: $partyId) {
    emptyTypeWorkaround
  }
}
    `;
export type PartyInvitesDeletePartyInviteMutationFn = Apollo.MutationFunction<PartyInvitesDeletePartyInviteMutation, PartyInvitesDeletePartyInviteMutationVariables>;

/**
 * __usePartyInvitesDeletePartyInviteMutation__
 *
 * To run a mutation, you first call `usePartyInvitesDeletePartyInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePartyInvitesDeletePartyInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [partyInvitesDeletePartyInviteMutation, { data, loading, error }] = usePartyInvitesDeletePartyInviteMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function usePartyInvitesDeletePartyInviteMutation(baseOptions?: Apollo.MutationHookOptions<PartyInvitesDeletePartyInviteMutation, PartyInvitesDeletePartyInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PartyInvitesDeletePartyInviteMutation, PartyInvitesDeletePartyInviteMutationVariables>(PartyInvitesDeletePartyInviteDocument, options);
      }
export type PartyInvitesDeletePartyInviteMutationHookResult = ReturnType<typeof usePartyInvitesDeletePartyInviteMutation>;
export type PartyInvitesDeletePartyInviteMutationResult = Apollo.MutationResult<PartyInvitesDeletePartyInviteMutation>;
export type PartyInvitesDeletePartyInviteMutationOptions = Apollo.BaseMutationOptions<PartyInvitesDeletePartyInviteMutation, PartyInvitesDeletePartyInviteMutationVariables>;
export const PartyInvitesCurrentPartyDocument = gql`
    query PartyInvitesCurrentParty($userId: ID!) {
  userParty(userId: $userId) {
    id
    leaderId
    streamId
    members {
      userId
    }
  }
}
    `;

/**
 * __usePartyInvitesCurrentPartyQuery__
 *
 * To run a query within a React component, call `usePartyInvitesCurrentPartyQuery` and pass it any options that fit your needs.
 * When your component renders, `usePartyInvitesCurrentPartyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePartyInvitesCurrentPartyQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function usePartyInvitesCurrentPartyQuery(baseOptions: Apollo.QueryHookOptions<PartyInvitesCurrentPartyQuery, PartyInvitesCurrentPartyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PartyInvitesCurrentPartyQuery, PartyInvitesCurrentPartyQueryVariables>(PartyInvitesCurrentPartyDocument, options);
      }
export function usePartyInvitesCurrentPartyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PartyInvitesCurrentPartyQuery, PartyInvitesCurrentPartyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PartyInvitesCurrentPartyQuery, PartyInvitesCurrentPartyQueryVariables>(PartyInvitesCurrentPartyDocument, options);
        }
export type PartyInvitesCurrentPartyQueryHookResult = ReturnType<typeof usePartyInvitesCurrentPartyQuery>;
export type PartyInvitesCurrentPartyLazyQueryHookResult = ReturnType<typeof usePartyInvitesCurrentPartyLazyQuery>;
export type PartyInvitesCurrentPartyQueryResult = Apollo.QueryResult<PartyInvitesCurrentPartyQuery, PartyInvitesCurrentPartyQueryVariables>;
export const PartyInvitesPartyUpdatesDocument = gql`
    subscription PartyInvitesPartyUpdates($partyId: ID!) {
  partyUpdateSubscribe(partyId: $partyId) {
    party {
      id
      streamId
      leaderId
      members {
        userId
        profile {
          userId
        }
      }
      channel {
        id
      }
    }
  }
}
    `;

/**
 * __usePartyInvitesPartyUpdatesSubscription__
 *
 * To run a query within a React component, call `usePartyInvitesPartyUpdatesSubscription` and pass it any options that fit your needs.
 * When your component renders, `usePartyInvitesPartyUpdatesSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePartyInvitesPartyUpdatesSubscription({
 *   variables: {
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function usePartyInvitesPartyUpdatesSubscription(baseOptions: Apollo.SubscriptionHookOptions<PartyInvitesPartyUpdatesSubscription, PartyInvitesPartyUpdatesSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<PartyInvitesPartyUpdatesSubscription, PartyInvitesPartyUpdatesSubscriptionVariables>(PartyInvitesPartyUpdatesDocument, options);
      }
export type PartyInvitesPartyUpdatesSubscriptionHookResult = ReturnType<typeof usePartyInvitesPartyUpdatesSubscription>;
export type PartyInvitesPartyUpdatesSubscriptionResult = Apollo.SubscriptionResult<PartyInvitesPartyUpdatesSubscription>;
export const SocialAcceptFriendRequestDocument = gql`
    mutation SocialAcceptFriendRequest($userId: ID!, $friendId: ID!) {
  acceptFriendRequest(userId: $userId, friendId: $friendId) {
    friendId
    friend {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialAcceptFriendRequestMutationFn = Apollo.MutationFunction<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>;

/**
 * __useSocialAcceptFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialAcceptFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialAcceptFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialAcceptFriendRequestMutation, { data, loading, error }] = useSocialAcceptFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialAcceptFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>(SocialAcceptFriendRequestDocument, options);
      }
export type SocialAcceptFriendRequestMutationHookResult = ReturnType<typeof useSocialAcceptFriendRequestMutation>;
export type SocialAcceptFriendRequestMutationResult = Apollo.MutationResult<SocialAcceptFriendRequestMutation>;
export type SocialAcceptFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>;
export const SocialBlockUserDocument = gql`
    mutation SocialBlockUser($userId: ID!, $blockedUserId: ID!) {
  blockUser(userId: $userId, blockedUserId: $blockedUserId) {
    blockedUserId
    blockedUser {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialBlockUserMutationFn = Apollo.MutationFunction<SocialBlockUserMutation, SocialBlockUserMutationVariables>;

/**
 * __useSocialBlockUserMutation__
 *
 * To run a mutation, you first call `useSocialBlockUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialBlockUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialBlockUserMutation, { data, loading, error }] = useSocialBlockUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      blockedUserId: // value for 'blockedUserId'
 *   },
 * });
 */
export function useSocialBlockUserMutation(baseOptions?: Apollo.MutationHookOptions<SocialBlockUserMutation, SocialBlockUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialBlockUserMutation, SocialBlockUserMutationVariables>(SocialBlockUserDocument, options);
      }
export type SocialBlockUserMutationHookResult = ReturnType<typeof useSocialBlockUserMutation>;
export type SocialBlockUserMutationResult = Apollo.MutationResult<SocialBlockUserMutation>;
export type SocialBlockUserMutationOptions = Apollo.BaseMutationOptions<SocialBlockUserMutation, SocialBlockUserMutationVariables>;
export const SocialRemoveFriendDocument = gql`
    mutation SocialRemoveFriend($userId: ID!, $friendId: ID!) {
  removeFriend(userId: $userId, friendId: $friendId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialRemoveFriendMutationFn = Apollo.MutationFunction<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>;

/**
 * __useSocialRemoveFriendMutation__
 *
 * To run a mutation, you first call `useSocialRemoveFriendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialRemoveFriendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialRemoveFriendMutation, { data, loading, error }] = useSocialRemoveFriendMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialRemoveFriendMutation(baseOptions?: Apollo.MutationHookOptions<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>(SocialRemoveFriendDocument, options);
      }
export type SocialRemoveFriendMutationHookResult = ReturnType<typeof useSocialRemoveFriendMutation>;
export type SocialRemoveFriendMutationResult = Apollo.MutationResult<SocialRemoveFriendMutation>;
export type SocialRemoveFriendMutationOptions = Apollo.BaseMutationOptions<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>;
export const SocialRemoveReceivedFriendRequestDocument = gql`
    mutation SocialRemoveReceivedFriendRequest($userId: ID!, $friendId: ID!) {
  removeFriendRequest(userId: $userId, friendId: $friendId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialRemoveReceivedFriendRequestMutationFn = Apollo.MutationFunction<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>;

/**
 * __useSocialRemoveReceivedFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialRemoveReceivedFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialRemoveReceivedFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialRemoveReceivedFriendRequestMutation, { data, loading, error }] = useSocialRemoveReceivedFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialRemoveReceivedFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>(SocialRemoveReceivedFriendRequestDocument, options);
      }
export type SocialRemoveReceivedFriendRequestMutationHookResult = ReturnType<typeof useSocialRemoveReceivedFriendRequestMutation>;
export type SocialRemoveReceivedFriendRequestMutationResult = Apollo.MutationResult<SocialRemoveReceivedFriendRequestMutation>;
export type SocialRemoveReceivedFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>;
export const SocialRemoveSentFriendRequestDocument = gql`
    mutation SocialRemoveSentFriendRequest($userId: ID!, $friendId: ID!) {
  removeFriendRequest(userId: $friendId, friendId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialRemoveSentFriendRequestMutationFn = Apollo.MutationFunction<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>;

/**
 * __useSocialRemoveSentFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialRemoveSentFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialRemoveSentFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialRemoveSentFriendRequestMutation, { data, loading, error }] = useSocialRemoveSentFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialRemoveSentFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>(SocialRemoveSentFriendRequestDocument, options);
      }
export type SocialRemoveSentFriendRequestMutationHookResult = ReturnType<typeof useSocialRemoveSentFriendRequestMutation>;
export type SocialRemoveSentFriendRequestMutationResult = Apollo.MutationResult<SocialRemoveSentFriendRequestMutation>;
export type SocialRemoveSentFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>;
export const SocialSendFriendRequestDocument = gql`
    mutation SocialSendFriendRequest($userId: ID!, $friendId: ID!) {
  sendFriendRequest(userId: $userId, friendId: $friendId) {
    friendId
    friend {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialSendFriendRequestMutationFn = Apollo.MutationFunction<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>;

/**
 * __useSocialSendFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialSendFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialSendFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialSendFriendRequestMutation, { data, loading, error }] = useSocialSendFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialSendFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>(SocialSendFriendRequestDocument, options);
      }
export type SocialSendFriendRequestMutationHookResult = ReturnType<typeof useSocialSendFriendRequestMutation>;
export type SocialSendFriendRequestMutationResult = Apollo.MutationResult<SocialSendFriendRequestMutation>;
export type SocialSendFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>;
export const SocialUnblockUserDocument = gql`
    mutation SocialUnblockUser($userId: ID!, $blockedUserId: ID!) {
  unblockUser(userId: $userId, blockedUserId: $blockedUserId) {
    unblockedUserId
    unblockedUser {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialUnblockUserMutationFn = Apollo.MutationFunction<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>;

/**
 * __useSocialUnblockUserMutation__
 *
 * To run a mutation, you first call `useSocialUnblockUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialUnblockUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialUnblockUserMutation, { data, loading, error }] = useSocialUnblockUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      blockedUserId: // value for 'blockedUserId'
 *   },
 * });
 */
export function useSocialUnblockUserMutation(baseOptions?: Apollo.MutationHookOptions<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>(SocialUnblockUserDocument, options);
      }
export type SocialUnblockUserMutationHookResult = ReturnType<typeof useSocialUnblockUserMutation>;
export type SocialUnblockUserMutationResult = Apollo.MutationResult<SocialUnblockUserMutation>;
export type SocialUnblockUserMutationOptions = Apollo.BaseMutationOptions<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>;
export const SpotlightBestGroupDataDocument = gql`
    query SpotlightBestGroupData($userIds: [String!]) {
  profileBatch(userIds: $userIds) {
    profiles {
      ...SpotlightBestGroupProfile
    }
  }
}
    ${SpotlightBestGroupProfileFragmentDoc}`;

/**
 * __useSpotlightBestGroupDataQuery__
 *
 * To run a query within a React component, call `useSpotlightBestGroupDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSpotlightBestGroupDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSpotlightBestGroupDataQuery({
 *   variables: {
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useSpotlightBestGroupDataQuery(baseOptions?: Apollo.QueryHookOptions<SpotlightBestGroupDataQuery, SpotlightBestGroupDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SpotlightBestGroupDataQuery, SpotlightBestGroupDataQueryVariables>(SpotlightBestGroupDataDocument, options);
      }
export function useSpotlightBestGroupDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SpotlightBestGroupDataQuery, SpotlightBestGroupDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SpotlightBestGroupDataQuery, SpotlightBestGroupDataQueryVariables>(SpotlightBestGroupDataDocument, options);
        }
export type SpotlightBestGroupDataQueryHookResult = ReturnType<typeof useSpotlightBestGroupDataQuery>;
export type SpotlightBestGroupDataLazyQueryHookResult = ReturnType<typeof useSpotlightBestGroupDataLazyQuery>;
export type SpotlightBestGroupDataQueryResult = Apollo.QueryResult<SpotlightBestGroupDataQuery, SpotlightBestGroupDataQueryVariables>;
export const SpotlightBestPlayDataDocument = gql`
    query SpotlightBestPlayData($cardIds: [String!], $userId: ID) {
  gameCards(cardIds: $cardIds) {
    cards {
      ...SpotlightBestPlayCard
    }
  }
  profile(userId: $userId) {
    ...SpotlightBestPlayProfile
  }
}
    ${SpotlightBestPlayCardFragmentDoc}
${SpotlightBestPlayProfileFragmentDoc}`;

/**
 * __useSpotlightBestPlayDataQuery__
 *
 * To run a query within a React component, call `useSpotlightBestPlayDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSpotlightBestPlayDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSpotlightBestPlayDataQuery({
 *   variables: {
 *      cardIds: // value for 'cardIds'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSpotlightBestPlayDataQuery(baseOptions?: Apollo.QueryHookOptions<SpotlightBestPlayDataQuery, SpotlightBestPlayDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SpotlightBestPlayDataQuery, SpotlightBestPlayDataQueryVariables>(SpotlightBestPlayDataDocument, options);
      }
export function useSpotlightBestPlayDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SpotlightBestPlayDataQuery, SpotlightBestPlayDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SpotlightBestPlayDataQuery, SpotlightBestPlayDataQueryVariables>(SpotlightBestPlayDataDocument, options);
        }
export type SpotlightBestPlayDataQueryHookResult = ReturnType<typeof useSpotlightBestPlayDataQuery>;
export type SpotlightBestPlayDataLazyQueryHookResult = ReturnType<typeof useSpotlightBestPlayDataLazyQuery>;
export type SpotlightBestPlayDataQueryResult = Apollo.QueryResult<SpotlightBestPlayDataQuery, SpotlightBestPlayDataQueryVariables>;
export const SpotlightBestPlayerDataDocument = gql`
    query SpotlightBestPlayerData($userId: ID) {
  profile(userId: $userId) {
    ...SpotlightBestPlayerProfile
  }
}
    ${SpotlightBestPlayerProfileFragmentDoc}`;

/**
 * __useSpotlightBestPlayerDataQuery__
 *
 * To run a query within a React component, call `useSpotlightBestPlayerDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSpotlightBestPlayerDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSpotlightBestPlayerDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSpotlightBestPlayerDataQuery(baseOptions?: Apollo.QueryHookOptions<SpotlightBestPlayerDataQuery, SpotlightBestPlayerDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SpotlightBestPlayerDataQuery, SpotlightBestPlayerDataQueryVariables>(SpotlightBestPlayerDataDocument, options);
      }
export function useSpotlightBestPlayerDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SpotlightBestPlayerDataQuery, SpotlightBestPlayerDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SpotlightBestPlayerDataQuery, SpotlightBestPlayerDataQueryVariables>(SpotlightBestPlayerDataDocument, options);
        }
export type SpotlightBestPlayerDataQueryHookResult = ReturnType<typeof useSpotlightBestPlayerDataQuery>;
export type SpotlightBestPlayerDataLazyQueryHookResult = ReturnType<typeof useSpotlightBestPlayerDataLazyQuery>;
export type SpotlightBestPlayerDataQueryResult = Apollo.QueryResult<SpotlightBestPlayerDataQuery, SpotlightBestPlayerDataQueryVariables>;
export const UseStreamAvatarEmotesDocument = gql`
    query UseStreamAvatarEmotes($userId: ID) {
  inventory(userId: $userId, filters: [{itemType: TYPE_EMOTE}]) {
    items {
      itemId
      item {
        id
        type
        details {
          __typename
          ... on AvatarAnimation {
            name
            iconUrl
            id
          }
        }
      }
    }
  }
}
    `;

/**
 * __useUseStreamAvatarEmotesQuery__
 *
 * To run a query within a React component, call `useUseStreamAvatarEmotesQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseStreamAvatarEmotesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseStreamAvatarEmotesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUseStreamAvatarEmotesQuery(baseOptions?: Apollo.QueryHookOptions<UseStreamAvatarEmotesQuery, UseStreamAvatarEmotesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseStreamAvatarEmotesQuery, UseStreamAvatarEmotesQueryVariables>(UseStreamAvatarEmotesDocument, options);
      }
export function useUseStreamAvatarEmotesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseStreamAvatarEmotesQuery, UseStreamAvatarEmotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseStreamAvatarEmotesQuery, UseStreamAvatarEmotesQueryVariables>(UseStreamAvatarEmotesDocument, options);
        }
export type UseStreamAvatarEmotesQueryHookResult = ReturnType<typeof useUseStreamAvatarEmotesQuery>;
export type UseStreamAvatarEmotesLazyQueryHookResult = ReturnType<typeof useUseStreamAvatarEmotesLazyQuery>;
export type UseStreamAvatarEmotesQueryResult = Apollo.QueryResult<UseStreamAvatarEmotesQuery, UseStreamAvatarEmotesQueryVariables>;