// THIS FILE IS GENERATED BY graphql-codegen, DO NOT EDIT!
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Duration: string;
  InputTimestamp: string;
  Timestamp: string;
};

export type ApiAddressInput = {
  address?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  zip?: InputMaybe<Scalars['String']>;
};

export type ApiCursorInput = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type ApiDateInput = {
  day?: InputMaybe<Scalars['Int']>;
  month?: InputMaybe<Scalars['Int']>;
  year?: InputMaybe<Scalars['Int']>;
};

export type ApiPageInfo = {
  __typename?: 'APIPageInfo';
  endCursor: Scalars['String'];
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor: Scalars['String'];
};

export type AdsGetPlacementResponse = {
  __typename?: 'AdsGetPlacementResponse';
  placementId: Scalars['ID'];
  referenceId: Scalars['ID'];
  /** TODO: Kept while migrating and set to the first item in rewards */
  reward: AdsRewardDescription;
  rewards: Array<AdsRewardDescription>;
  state: AdsPlacementState;
  updatesAt: Scalars['Timestamp'];
};

export enum AdsPlacementState {
  PlacementStateNotReady = 'PLACEMENT_STATE_NOT_READY',
  PlacementStateReady = 'PLACEMENT_STATE_READY',
  PlacementStateUnspecified = 'PLACEMENT_STATE_UNSPECIFIED'
}

export type AdsPlacementStateEvent = {
  __typename?: 'AdsPlacementStateEvent';
  placementId: Scalars['ID'];
  referenceId: Scalars['ID'];
  state: AdsPlacementState;
  userId: Scalars['ID'];
};

export type AdsRewardDescription = {
  __typename?: 'AdsRewardDescription';
  prizes: Array<AdsRewardDescriptionPrizeDescription>;
  rarity: RarityRarity;
  readyAt: Scalars['Timestamp'];
};

export type AdsRewardDescriptionPrizeDescription = {
  __typename?: 'AdsRewardDescriptionPrizeDescription';
  amount: Scalars['Int'];
  kind: AdsRewardDescriptionPrizeDescriptionKind;
  max: Scalars['Int'];
  min: Scalars['Int'];
  value: Scalars['String'];
};

export enum AdsRewardDescriptionPrizeDescriptionKind {
  KindCurrency = 'KIND_CURRENCY',
  KindExperiencePoints = 'KIND_EXPERIENCE_POINTS',
  KindUnspecified = 'KIND_UNSPECIFIED'
}

export type AdyenAmount = {
  __typename?: 'AdyenAmount';
  currency: Scalars['String'];
  value: Scalars['Int'];
};

export type AdyenSession = {
  __typename?: 'AdyenSession';
  amount: AdyenAmount;
  id: Scalars['ID'];
  reference: Scalars['String'];
  returnUrl: Scalars['String'];
  sessionData: Scalars['String'];
};

export type AgreementAgreementRevision = {
  __typename?: 'AgreementAgreementRevision';
  name: Scalars['String'];
  revision: Scalars['String'];
  url: Scalars['String'];
};

export type AgreementListAgreementResponse = {
  __typename?: 'AgreementListAgreementResponse';
  agreements: Array<AgreementAgreementRevision>;
};

export type AnnouncementAnnouncement = {
  __typename?: 'AnnouncementAnnouncement';
  category: AnnouncementAnnouncementCategory;
  createdAt: Scalars['Timestamp'];
  creator: ProfileProfile;
  creatorId: Scalars['ID'];
  endTime?: Maybe<Scalars['Timestamp']>;
  id: Scalars['ID'];
  image: Scalars['String'];
  imageUrl: Scalars['String'];
  published: Scalars['Boolean'];
  startTime?: Maybe<Scalars['Timestamp']>;
  status: AnnouncementAnnouncementStatus;
  targets: AnnouncementTargets;
  text: Scalars['String'];
  title: Scalars['String'];
};

export enum AnnouncementAnnouncementCategory {
  AnnouncementCategoryGameApexLegends = 'ANNOUNCEMENT_CATEGORY_GAME_APEX_LEGENDS',
  AnnouncementCategoryGameDbd = 'ANNOUNCEMENT_CATEGORY_GAME_DBD',
  AnnouncementCategoryGameDota2 = 'ANNOUNCEMENT_CATEGORY_GAME_DOTA2',
  AnnouncementCategoryGameFortnite = 'ANNOUNCEMENT_CATEGORY_GAME_FORTNITE',
  AnnouncementCategoryGameLeagueOfLegends = 'ANNOUNCEMENT_CATEGORY_GAME_LEAGUE_OF_LEGENDS',
  AnnouncementCategoryPlatform = 'ANNOUNCEMENT_CATEGORY_PLATFORM',
  AnnouncementCategorySystem = 'ANNOUNCEMENT_CATEGORY_SYSTEM',
  AnnouncementCategoryUnspecified = 'ANNOUNCEMENT_CATEGORY_UNSPECIFIED'
}

export type AnnouncementAnnouncementFilterInput = {
  statuses?: InputMaybe<Array<AnnouncementAnnouncementStatus>>;
  targets?: InputMaybe<Array<AnnouncementAnnouncementTarget>>;
};

export type AnnouncementAnnouncementInput = {
  category?: InputMaybe<AnnouncementAnnouncementCategory>;
  createdAt?: InputMaybe<Scalars['InputTimestamp']>;
  creatorId?: InputMaybe<Scalars['ID']>;
  endTime?: InputMaybe<Scalars['InputTimestamp']>;
  id?: InputMaybe<Scalars['ID']>;
  imageUrl?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  startTime?: InputMaybe<Scalars['InputTimestamp']>;
  status?: InputMaybe<AnnouncementAnnouncementStatus>;
  targets?: InputMaybe<AnnouncementTargetsInput>;
  text?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export enum AnnouncementAnnouncementStatus {
  AnnouncementStatusActive = 'ANNOUNCEMENT_STATUS_ACTIVE',
  AnnouncementStatusDraft = 'ANNOUNCEMENT_STATUS_DRAFT',
  AnnouncementStatusPast = 'ANNOUNCEMENT_STATUS_PAST',
  AnnouncementStatusScheduled = 'ANNOUNCEMENT_STATUS_SCHEDULED',
  AnnouncementStatusUnspecified = 'ANNOUNCEMENT_STATUS_UNSPECIFIED'
}

export enum AnnouncementAnnouncementTarget {
  AnnouncementTargetMobile = 'ANNOUNCEMENT_TARGET_MOBILE',
  AnnouncementTargetStudio = 'ANNOUNCEMENT_TARGET_STUDIO',
  AnnouncementTargetUnspecified = 'ANNOUNCEMENT_TARGET_UNSPECIFIED',
  AnnouncementTargetWeb = 'ANNOUNCEMENT_TARGET_WEB'
}

export type AnnouncementCreateAnnouncementImageUploadTokenResponse = {
  __typename?: 'AnnouncementCreateAnnouncementImageUploadTokenResponse';
  token: Scalars['String'];
};

export type AnnouncementListAnnouncementsResponse = {
  __typename?: 'AnnouncementListAnnouncementsResponse';
  announcements: Array<AnnouncementAnnouncement>;
  pageInfo: ApiPageInfo;
  totalCount: Scalars['Int'];
};

export type AnnouncementListUserAnnouncementsResponse = {
  __typename?: 'AnnouncementListUserAnnouncementsResponse';
  announcements: Array<AnnouncementAnnouncement>;
  pageInfo: ApiPageInfo;
};

export type AnnouncementTargets = {
  __typename?: 'AnnouncementTargets';
  mobile: Scalars['Boolean'];
  studio: Scalars['Boolean'];
  web: Scalars['Boolean'];
};

export type AnnouncementTargetsInput = {
  mobile?: InputMaybe<Scalars['Boolean']>;
  studio?: InputMaybe<Scalars['Boolean']>;
  web?: InputMaybe<Scalars['Boolean']>;
};

export enum ApiEntityState {
  EntityStateBlocked = 'ENTITY_STATE_BLOCKED',
  EntityStateDeleted = 'ENTITY_STATE_DELETED',
  EntityStateUnspecified = 'ENTITY_STATE_UNSPECIFIED'
}

export type ArenaArena = {
  __typename?: 'ArenaArena';
  config?: Maybe<ArenaArenaConfigUnion>;
  enabled: Scalars['Boolean'];
  id: Scalars['ID'];
  name: Scalars['String'];
  thumbnailUrl: Scalars['String'];
};

export type ArenaArenaConfigUnion = ArenaServerSideArenaConfig;

export type ArenaClientSideArena = {
  __typename?: 'ArenaClientSideArena';
  enabled: Scalars['Boolean'];
  environmentUrl: Scalars['String'];
  glbUrl: Scalars['String'];
  id: Scalars['ID'];
  lightmapUrl: Scalars['String'];
  name: Scalars['String'];
  thumbnailUrl: Scalars['String'];
  version: Scalars['String'];
};

export type ArenaListArenasResponse = {
  __typename?: 'ArenaListArenasResponse';
  arenas: Array<ArenaArena>;
  pageInfo: ApiPageInfo;
};

export type ArenaListClientSideArenasResponse = {
  __typename?: 'ArenaListClientSideArenasResponse';
  arenas: Array<ArenaClientSideArena>;
};

export type ArenaServerSideArenaConfig = {
  __typename?: 'ArenaServerSideArenaConfig';
  arenaConfigUrl: Scalars['String'];
  contentCatalogUrl: Scalars['String'];
  gameViewScreenshotUrl: Scalars['String'];
};

export type AttributeAttribute = {
  __typename?: 'AttributeAttribute';
  value?: Maybe<AttributeAttributeValueUnion>;
};

export type AttributeAttributeBoolArray = {
  __typename?: 'AttributeAttributeBoolArray';
  value: Array<Scalars['Boolean']>;
};

export type AttributeAttributeBoolArrayInput = {
  value?: InputMaybe<Array<Scalars['Boolean']>>;
};

export type AttributeAttributeFloatArray = {
  __typename?: 'AttributeAttributeFloatArray';
  value: Array<Scalars['Float']>;
};

export type AttributeAttributeFloatArrayInput = {
  value?: InputMaybe<Array<Scalars['Float']>>;
};

export type AttributeAttributeInput = {
  boolArrayValue?: InputMaybe<AttributeAttributeBoolArrayInput>;
  boolValue?: InputMaybe<Scalars['Boolean']>;
  floatArrayValue?: InputMaybe<AttributeAttributeFloatArrayInput>;
  floatValue?: InputMaybe<Scalars['Float']>;
  intArrayValue?: InputMaybe<AttributeAttributeIntArrayInput>;
  intValue?: InputMaybe<Scalars['Int']>;
  mapValue?: InputMaybe<AttributeAttributeMapInput>;
  stringArrayValue?: InputMaybe<AttributeAttributeStringArrayInput>;
  stringValue?: InputMaybe<Scalars['String']>;
};

export type AttributeAttributeIntArray = {
  __typename?: 'AttributeAttributeIntArray';
  value: Array<Scalars['Int']>;
};

export type AttributeAttributeIntArrayInput = {
  value?: InputMaybe<Array<Scalars['Int']>>;
};

export type AttributeAttributeMap = {
  __typename?: 'AttributeAttributeMap';
  value: Array<AttributeAttributeMapValueEntry>;
};

export type AttributeAttributeMapInput = {
  value?: InputMaybe<Array<AttributeAttributeMapValueEntryInput>>;
};

export type AttributeAttributeMapValueEntry = {
  __typename?: 'AttributeAttributeMapValueEntry';
  key: Scalars['String'];
  value: AttributeAttribute;
};

export type AttributeAttributeMapValueEntryInput = {
  key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type AttributeAttributeStringArray = {
  __typename?: 'AttributeAttributeStringArray';
  value: Array<Scalars['String']>;
};

export type AttributeAttributeStringArrayInput = {
  value?: InputMaybe<Array<Scalars['String']>>;
};

export type AttributeAttributeValueUnion = AttributeAttributeBoolArray | AttributeAttributeFloatArray | AttributeAttributeIntArray | AttributeAttributeMap | AttributeAttributeStringArray | BooleanType | FloatType | IntType | StringType;

export type AuthAccount = {
  __typename?: 'AuthAccount';
  acceptedTerms: Array<AuthTermsVersion>;
  birthday?: Maybe<AuthDate>;
  channelCreationEligibility: ChannelChannelCreationEligibility;
  createdAt: Scalars['Timestamp'];
  email: Scalars['String'];
  emailVerifiedAt?: Maybe<Scalars['Timestamp']>;
  externalIds: Array<AuthIdentity>;
  flags: Array<AuthAccountStatusFlag>;
  isBot: Scalars['Boolean'];
  labels: Array<Scalars['String']>;
  marketingConsent: AuthConsentStatus;
  matureRatedContentAllowed: Scalars['Boolean'];
  pendingAgreements: Array<AgreementAgreementRevision>;
  roles: Array<AuthPlatformRole>;
  signupLocation: Scalars['String'];
  signupOrigin?: Maybe<AuthSignupOrigin>;
  staff: Scalars['Boolean'];
  state: ApiEntityState;
  temporary: Scalars['Boolean'];
  uid: Scalars['String'];
};

export enum AuthAccountStatusFlag {
  StatusFlagBanned = 'STATUS_FLAG_BANNED',
  StatusFlagDeletionScheduled = 'STATUS_FLAG_DELETION_SCHEDULED',
  StatusFlagUnspecified = 'STATUS_FLAG_UNSPECIFIED',
  StatusFlagWaitlist = 'STATUS_FLAG_WAITLIST'
}

export type AuthAccountUpdateInput = {
  roles?: InputMaybe<Array<AuthPlatformRole>>;
  userId?: InputMaybe<Scalars['ID']>;
};

export enum AuthConsentStatus {
  ConsentStatusAccepted = 'CONSENT_STATUS_ACCEPTED',
  ConsentStatusDeclined = 'CONSENT_STATUS_DECLINED',
  ConsentStatusUnspecified = 'CONSENT_STATUS_UNSPECIFIED'
}

export type AuthDate = {
  __typename?: 'AuthDate';
  day: Scalars['Int'];
  month: Scalars['Int'];
  year: Scalars['Int'];
};

export type AuthDateInput = {
  day?: InputMaybe<Scalars['Int']>;
  month?: InputMaybe<Scalars['Int']>;
  year?: InputMaybe<Scalars['Int']>;
};

export type AuthIdentity = {
  __typename?: 'AuthIdentity';
  id: Scalars['ID'];
  type: AuthIdentityType;
};

export enum AuthIdentityType {
  IdentityTypeApple = 'IDENTITY_TYPE_APPLE',
  IdentityTypeDiscord = 'IDENTITY_TYPE_DISCORD',
  IdentityTypeEmail = 'IDENTITY_TYPE_EMAIL',
  IdentityTypeUnspecified = 'IDENTITY_TYPE_UNSPECIFIED'
}

export enum AuthPlatformRole {
  PlatformRoleAdmin = 'PLATFORM_ROLE_ADMIN',
  PlatformRoleBot = 'PLATFORM_ROLE_BOT',
  PlatformRoleFullUser = 'PLATFORM_ROLE_FULL_USER',
  PlatformRoleGuest = 'PLATFORM_ROLE_GUEST',
  PlatformRoleModerator = 'PLATFORM_ROLE_MODERATOR',
  PlatformRolePxAgent = 'PLATFORM_ROLE_PX_AGENT',
  PlatformRoleRoot = 'PLATFORM_ROLE_ROOT',
  PlatformRoleStreamerTooling = 'PLATFORM_ROLE_STREAMER_TOOLING',
  PlatformRoleUnspecified = 'PLATFORM_ROLE_UNSPECIFIED',
  PlatformRoleUser = 'PLATFORM_ROLE_USER'
}

export type AuthSignupOrigin = {
  __typename?: 'AuthSignupOrigin';
  origin?: Maybe<AuthSignupOriginOriginUnion>;
};

export type AuthSignupOriginCampaign = {
  __typename?: 'AuthSignupOriginCampaign';
  campaign: Scalars['String'];
  content: Scalars['String'];
  creator: Scalars['String'];
  format: Scalars['String'];
  medium: Scalars['String'];
  source: Scalars['String'];
  term: Scalars['String'];
};

export type AuthSignupOriginChannel = {
  __typename?: 'AuthSignupOriginChannel';
  channel: ChannelChannel;
  channelId: Scalars['ID'];
};

export type AuthSignupOriginOriginUnion = AuthSignupOriginCampaign | AuthSignupOriginChannel | AuthSignupOriginPage;

export type AuthSignupOriginPage = {
  __typename?: 'AuthSignupOriginPage';
  url: Scalars['String'];
};

export type AuthTermsVersion = {
  __typename?: 'AuthTermsVersion';
  name: Scalars['String'];
  revision: Scalars['String'];
  signature: Scalars['String'];
};

export type AuthTermsVersionInput = {
  name?: InputMaybe<Scalars['String']>;
  revision?: InputMaybe<Scalars['String']>;
  signature?: InputMaybe<Scalars['String']>;
};

export type AuthV4GetOAuth2ConsentResponse = {
  __typename?: 'AuthV4GetOAuth2ConsentResponse';
  clientId: Scalars['ID'];
  clientName: Scalars['String'];
  scopes: Array<Scalars['String']>;
};

export type AvatarAnimation = {
  __typename?: 'AvatarAnimation';
  category: Array<AvatarAnimationCategory>;
  chatCommand: Scalars['String'];
  config: AvatarAnimationConfig;
  enabled: Scalars['Boolean'];
  glbUrl: Scalars['String'];
  iconUrl: Scalars['String'];
  id: Scalars['ID'];
  mirroredGlbUrl: Scalars['String'];
  name: Scalars['String'];
};

export enum AvatarAnimationCategory {
  CategoryAngry = 'CATEGORY_ANGRY',
  CategoryBoosterReceived = 'CATEGORY_BOOSTER_RECEIVED',
  CategoryBoosterRequested = 'CATEGORY_BOOSTER_REQUESTED',
  CategoryBoosterSent = 'CATEGORY_BOOSTER_SENT',
  CategoryCameraDrive = 'CATEGORY_CAMERA_DRIVE',
  CategoryCameraDriveExcited = 'CATEGORY_CAMERA_DRIVE_EXCITED',
  CategoryCardFailure = 'CATEGORY_CARD_FAILURE',
  CategoryCardMaxedOut = 'CATEGORY_CARD_MAXED_OUT',
  CategoryCardSuccess = 'CATEGORY_CARD_SUCCESS',
  CategoryChatMessage = 'CATEGORY_CHAT_MESSAGE',
  CategoryCheer = 'CATEGORY_CHEER',
  CategoryDance = 'CATEGORY_DANCE',
  CategoryDefeat = 'CATEGORY_DEFEAT',
  CategoryEditorIdle = 'CATEGORY_EDITOR_IDLE',
  CategoryEditorPickBody = 'CATEGORY_EDITOR_PICK_BODY',
  CategoryEditorPickFace = 'CATEGORY_EDITOR_PICK_FACE',
  CategoryEditorPickGloves = 'CATEGORY_EDITOR_PICK_GLOVES',
  CategoryEditorPickHat = 'CATEGORY_EDITOR_PICK_HAT',
  CategoryEditorPickJacket = 'CATEGORY_EDITOR_PICK_JACKET',
  CategoryEditorPickPants = 'CATEGORY_EDITOR_PICK_PANTS',
  CategoryEditorPickShoes = 'CATEGORY_EDITOR_PICK_SHOES',
  CategoryEmoji = 'CATEGORY_EMOJI',
  CategoryEmote = 'CATEGORY_EMOTE',
  CategoryExcited = 'CATEGORY_EXCITED',
  CategoryFsInChat = 'CATEGORY_FS_IN_CHAT',
  CategoryIdle = 'CATEGORY_IDLE',
  CategoryMessage = 'CATEGORY_MESSAGE',
  CategoryPhotoPoses = 'CATEGORY_PHOTO_POSES',
  CategoryPlayerExit = 'CATEGORY_PLAYER_EXIT',
  CategoryPlayerJoin = 'CATEGORY_PLAYER_JOIN',
  CategoryPlayerPickCard = 'CATEGORY_PLAYER_PICK_CARD',
  CategoryPlayerSwapCard = 'CATEGORY_PLAYER_SWAP_CARD',
  CategoryPoseConfused = 'CATEGORY_POSE_CONFUSED',
  CategoryPoseCool = 'CATEGORY_POSE_COOL',
  CategoryPoseCrying = 'CATEGORY_POSE_CRYING',
  CategoryPoseDefault = 'CATEGORY_POSE_DEFAULT',
  CategoryPoseJustJoking = 'CATEGORY_POSE_JUST_JOKING',
  CategoryPoseLol = 'CATEGORY_POSE_LOL',
  CategoryPoseLove = 'CATEGORY_POSE_LOVE',
  CategoryPoseNoice = 'CATEGORY_POSE_NOICE',
  CategoryPoseOhno = 'CATEGORY_POSE_OHNO',
  CategoryPoseParty = 'CATEGORY_POSE_PARTY',
  CategoryPoseRage = 'CATEGORY_POSE_RAGE',
  CategoryPoseSad = 'CATEGORY_POSE_SAD',
  CategoryPoseShocked = 'CATEGORY_POSE_SHOCKED',
  CategoryPoseSick = 'CATEGORY_POSE_SICK',
  CategoryPoseSmile = 'CATEGORY_POSE_SMILE',
  CategoryPoseSurprised = 'CATEGORY_POSE_SURPRISED',
  CategoryPoseSweat = 'CATEGORY_POSE_SWEAT',
  CategoryPoseWhoa = 'CATEGORY_POSE_WHOA',
  CategorySad = 'CATEGORY_SAD',
  CategorySpotlightCrowd = 'CATEGORY_SPOTLIGHT_CROWD',
  CategorySpotlightPodium = 'CATEGORY_SPOTLIGHT_PODIUM',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED',
  CategoryVictory = 'CATEGORY_VICTORY',
  CategoryWsInChat = 'CATEGORY_WS_IN_CHAT'
}

export type AvatarAnimationConfig = {
  __typename?: 'AvatarAnimationConfig';
  clamp: Scalars['Boolean'];
  fadeInTimeSec: Scalars['Float'];
  handedness: AvatarAnimationHandedness;
  interruptible: Scalars['Boolean'];
  maxLoops: Scalars['Int'];
  randomizeLoops: Scalars['Boolean'];
};

export enum AvatarAnimationHandedness {
  HandednessBoth = 'HANDEDNESS_BOTH',
  HandednessLeft = 'HANDEDNESS_LEFT',
  HandednessRight = 'HANDEDNESS_RIGHT',
  HandednessUnspecified = 'HANDEDNESS_UNSPECIFIED'
}

export type AvatarAvatar = {
  __typename?: 'AvatarAvatar';
  assets: AvatarAvatarAssets;
  avatar3D: Scalars['String'];
  avatarComposition: AvatarAvatarComposition;
  avatarLods: Array<Scalars['String']>;
  body: Scalars['String'];
  face: Scalars['String'];
  /** todo: remove or use Gender instead */
  gender: Scalars['String'];
  id: Scalars['ID'];
  /** selectable is used to determine if the avatar is shown in the avatar picker */
  selectable: Scalars['Boolean'];
};

export type AvatarAvatarAssets = {
  __typename?: 'AvatarAvatarAssets';
  images: Array<AvatarAvatarAssetsImage>;
  lods: Array<AvatarAvatarAssetsLod>;
};

export type AvatarAvatarAssetsImage = {
  __typename?: 'AvatarAvatarAssetsImage';
  category: AvatarAvatarAssetsImageCategory;
  url: Scalars['String'];
};

export enum AvatarAvatarAssetsImageCategory {
  CategoryPoseConfused = 'CATEGORY_POSE_CONFUSED',
  CategoryPoseCool = 'CATEGORY_POSE_COOL',
  CategoryPoseCrying = 'CATEGORY_POSE_CRYING',
  CategoryPoseJustJoking = 'CATEGORY_POSE_JUST_JOKING',
  CategoryPoseLol = 'CATEGORY_POSE_LOL',
  CategoryPoseLove = 'CATEGORY_POSE_LOVE',
  CategoryPoseNoice = 'CATEGORY_POSE_NOICE',
  CategoryPoseOhno = 'CATEGORY_POSE_OHNO',
  CategoryPoseParty = 'CATEGORY_POSE_PARTY',
  CategoryPoseRage = 'CATEGORY_POSE_RAGE',
  CategoryPoseSad = 'CATEGORY_POSE_SAD',
  CategoryPoseShocked = 'CATEGORY_POSE_SHOCKED',
  CategoryPoseSick = 'CATEGORY_POSE_SICK',
  CategoryPoseSmile = 'CATEGORY_POSE_SMILE',
  CategoryPoseSurprised = 'CATEGORY_POSE_SURPRISED',
  CategoryPoseSweat = 'CATEGORY_POSE_SWEAT',
  CategoryPoseWhoa = 'CATEGORY_POSE_WHOA',
  CategoryProfileBody = 'CATEGORY_PROFILE_BODY',
  CategoryProfileFace = 'CATEGORY_PROFILE_FACE',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED'
}

export type AvatarAvatarAssetsImageInput = {
  category?: InputMaybe<AvatarAvatarAssetsImageCategory>;
  url?: InputMaybe<Scalars['String']>;
};

export type AvatarAvatarAssetsInput = {
  images?: InputMaybe<Array<AvatarAvatarAssetsImageInput>>;
  lods?: InputMaybe<Array<AvatarAvatarAssetsLodInput>>;
};

export type AvatarAvatarAssetsLod = {
  __typename?: 'AvatarAvatarAssetsLod';
  glbUrl: Scalars['String'];
  skeletonType: AvatarAvatarAssetsLodSkeletonType;
};

export type AvatarAvatarAssetsLodInput = {
  glbUrl?: InputMaybe<Scalars['String']>;
  skeletonType?: InputMaybe<AvatarAvatarAssetsLodSkeletonType>;
};

export enum AvatarAvatarAssetsLodSkeletonType {
  SkeletonTypeComplex = 'SKELETON_TYPE_COMPLEX',
  SkeletonTypeSimple = 'SKELETON_TYPE_SIMPLE',
  SkeletonTypeUnspecified = 'SKELETON_TYPE_UNSPECIFIED'
}

export type AvatarAvatarComposition = {
  __typename?: 'AvatarAvatarComposition';
  generatorVersion: Scalars['String'];
  partCustomizations: Array<AvatarAvatarPartCustomization>;
  partIds: Array<Scalars['String']>;
};

export type AvatarAvatarCompositionInput = {
  generatorVersion?: InputMaybe<Scalars['String']>;
  partCustomizations?: InputMaybe<Array<AvatarAvatarPartCustomizationInput>>;
  partIds?: InputMaybe<Array<Scalars['String']>>;
};

export type AvatarAvatarInput = {
  assets?: InputMaybe<AvatarAvatarAssetsInput>;
  avatar3D?: InputMaybe<Scalars['String']>;
  avatarComposition?: InputMaybe<AvatarAvatarCompositionInput>;
  avatarLods?: InputMaybe<Array<Scalars['String']>>;
  body?: InputMaybe<Scalars['String']>;
  face?: InputMaybe<Scalars['String']>;
  /** todo: remove or use Gender instead */
  gender?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** selectable is used to determine if the avatar is shown in the avatar picker */
  selectable?: InputMaybe<Scalars['Boolean']>;
};

export type AvatarAvatarPart = {
  __typename?: 'AvatarAvatarPart';
  category: AvatarAvatarPartCategory;
  categoryOverride: Array<AvatarAvatarPartCategory>;
  channelId: Scalars['ID'];
  clothingSet: Scalars['String'];
  color: Scalars['String'];
  colorPresetOptions: Array<Scalars['String']>;
  colors: Array<Scalars['String']>;
  default: Scalars['Boolean'];
  enabled: Scalars['Boolean'];
  experimental: Scalars['Boolean'];
  gender: AvatarGender;
  glbUrl: Scalars['String'];
  glbUrlOverride?: Maybe<AvatarAvatarPartGlbUrlOverride>;
  id: Scalars['ID'];
  name: Scalars['String'];
  previewImgUrl: Scalars['String'];
  sellable: Scalars['Boolean'];
  skinData?: Maybe<AvatarAvatarPartSkinData>;
  skinOptions: Array<Scalars['String']>;
  uniqueBootstrap: Scalars['Boolean'];
  url: Scalars['String'];
  userDefault: Scalars['Boolean'];
};

export enum AvatarAvatarPartCategory {
  CategoryBeard = 'CATEGORY_BEARD',
  CategoryBody = 'CATEGORY_BODY',
  CategoryColorPreset = 'CATEGORY_COLOR_PRESET',
  CategoryEyebrows = 'CATEGORY_EYEBROWS',
  CategoryEyebrowsColor = 'CATEGORY_EYEBROWS_COLOR',
  CategoryEyelashes = 'CATEGORY_EYELASHES',
  CategoryEyelashesColor = 'CATEGORY_EYELASHES_COLOR',
  CategoryEyes = 'CATEGORY_EYES',
  CategoryFaceItem = 'CATEGORY_FACE_ITEM',
  CategoryHair = 'CATEGORY_HAIR',
  CategoryHairColor = 'CATEGORY_HAIR_COLOR',
  CategoryHands = 'CATEGORY_HANDS',
  CategoryHead = 'CATEGORY_HEAD',
  CategoryHeadItem = 'CATEGORY_HEAD_ITEM',
  CategoryLegs = 'CATEGORY_LEGS',
  CategoryShoes = 'CATEGORY_SHOES',
  CategorySkin = 'CATEGORY_SKIN',
  CategorySkinColor = 'CATEGORY_SKIN_COLOR',
  CategoryTeeth = 'CATEGORY_TEETH',
  CategoryTorso = 'CATEGORY_TORSO',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED'
}

export type AvatarAvatarPartCustomization = {
  __typename?: 'AvatarAvatarPartCustomization';
  colorPreset: Scalars['String'];
  partId: Scalars['ID'];
  skin: Scalars['String'];
};

export type AvatarAvatarPartCustomizationInput = {
  colorPreset?: InputMaybe<Scalars['String']>;
  partId?: InputMaybe<Scalars['ID']>;
  skin?: InputMaybe<Scalars['String']>;
};

export type AvatarAvatarPartGlbUrlOverride = {
  __typename?: 'AvatarAvatarPartGlbURLOverride';
  category: AvatarAvatarPartCategory;
  glbUrl: Scalars['String'];
};

export type AvatarAvatarPartSkinData = {
  __typename?: 'AvatarAvatarPartSkinData';
  baseMapUrl: Scalars['String'];
  emissionMapUrl: Scalars['String'];
  normalMapUrl: Scalars['String'];
  ormMapUrl: Scalars['String'];
};

export type AvatarBatchGetAnimationsResponse = {
  __typename?: 'AvatarBatchGetAnimationsResponse';
  animations: Array<AvatarAnimation>;
};

export type AvatarBatchGetAvatarPartsResponse = {
  __typename?: 'AvatarBatchGetAvatarPartsResponse';
  avatarParts: Array<AvatarAvatarPart>;
};

export type AvatarBatchGetAvatarsResponse = {
  __typename?: 'AvatarBatchGetAvatarsResponse';
  avatars: Array<AvatarAvatar>;
};

export enum AvatarGender {
  GenderFemale = 'GENDER_FEMALE',
  GenderMale = 'GENDER_MALE',
  GenderUnspecified = 'GENDER_UNSPECIFIED'
}

export type AvatarListAnimationsResponse = {
  __typename?: 'AvatarListAnimationsResponse';
  animations: Array<AvatarAnimation>;
};

export type AvatarListAvatarPartsResponse = {
  __typename?: 'AvatarListAvatarPartsResponse';
  avatarParts: Array<AvatarAvatarPart>;
};

export type AvatarListAvatarsResponse = {
  __typename?: 'AvatarListAvatarsResponse';
  avatars: Array<AvatarAvatar>;
  pageInfo: ApiPageInfo;
};

export type AvatarValidateAvatarCompositionResponse = {
  __typename?: 'AvatarValidateAvatarCompositionResponse';
  changes: Array<AvatarValidateAvatarCompositionResponseChange>;
  composition: AvatarAvatarComposition;
  /** @deprecated field is deprecated */
  duplicatePartIds: Array<Scalars['String']>;
  isDefault: Scalars['Boolean'];
  /** @deprecated field is deprecated */
  missingPartCategories: Array<AvatarAvatarPartCategory>;
  /** @deprecated field is deprecated */
  missingPartIds: Array<Scalars['String']>;
};

export type AvatarValidateAvatarCompositionResponseChange = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChange';
  action?: Maybe<AvatarValidateAvatarCompositionResponseChangeActionUnion>;
};

export type AvatarValidateAvatarCompositionResponseChangeActionUnion = AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded | AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved | AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced;

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded';
  id: Scalars['ID'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
};

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved';
  id: Scalars['ID'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
};

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced';
  id: Scalars['ID'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
  replacementId: Scalars['ID'];
};

export enum AvatarValidateAvatarCompositionResponseChangeReason {
  ReasonAvatarPartBodyRequired = 'REASON_AVATAR_PART_BODY_REQUIRED',
  ReasonAvatarPartEyesRequired = 'REASON_AVATAR_PART_EYES_REQUIRED',
  ReasonAvatarPartHeadRequired = 'REASON_AVATAR_PART_HEAD_REQUIRED',
  ReasonAvatarPartLegsRequired = 'REASON_AVATAR_PART_LEGS_REQUIRED',
  ReasonAvatarPartTorsoRequired = 'REASON_AVATAR_PART_TORSO_REQUIRED',
  ReasonAvatarPartUnavailable = 'REASON_AVATAR_PART_UNAVAILABLE',
  ReasonAvatarPartUnknown = 'REASON_AVATAR_PART_UNKNOWN',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type BadgeBadge = {
  __typename?: 'BadgeBadge';
  level: Scalars['Int'];
  nextLevelAt: Scalars['Timestamp'];
  type: BadgeBadgeType;
};

export enum BadgeBadgeType {
  TypeChannelModerator = 'TYPE_CHANNEL_MODERATOR',
  TypeChannelSubscriber = 'TYPE_CHANNEL_SUBSCRIBER',
  TypeClosedBetaCreator = 'TYPE_CLOSED_BETA_CREATOR',
  TypeNoiceStaff = 'TYPE_NOICE_STAFF',
  TypeStreamer = 'TYPE_STREAMER',
  TypeSubsGifter = 'TYPE_SUBS_GIFTER',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type BadgeBatchGetUserBadgesResponse = {
  __typename?: 'BadgeBatchGetUserBadgesResponse';
  badges: Array<BadgeUserBadges>;
};

export type BadgeGetUserBadgesResponse = {
  __typename?: 'BadgeGetUserBadgesResponse';
  badges: Array<BadgeBadge>;
};

export type BadgeUserBadges = {
  __typename?: 'BadgeUserBadges';
  badges: Array<BadgeBadge>;
  userId: Scalars['ID'];
};

export type BooleanType = {
  __typename?: 'BooleanType';
  /** The wrapped value of type Boolean */
  value: Scalars['Boolean'];
};

export type ChallengeChallengeReward = {
  __typename?: 'ChallengeChallengeReward';
  gameId: Scalars['ID'];
  maxPickRate: Scalars['Int'];
  minPickRate: Scalars['Int'];
  reward: RewardRewardType;
};

export type ChallengeChallengeUpdateInput = {
  challengeId?: InputMaybe<Scalars['ID']>;
  channelId?: InputMaybe<Scalars['ID']>;
  description?: InputMaybe<Scalars['String']>;
  disabled?: InputMaybe<Scalars['Boolean']>;
  gameId?: InputMaybe<Scalars['ID']>;
};

export type ChallengeGetChallengeRewardsResponse = {
  __typename?: 'ChallengeGetChallengeRewardsResponse';
  rewards: Array<ChallengeChallengeReward>;
};

export type ChallengeListChallengesResponse = {
  __typename?: 'ChallengeListChallengesResponse';
  challenges: Array<GameLogicChallenge>;
};

export type ChallengesessionChallenge = {
  __typename?: 'ChallengesessionChallenge';
  description: Scalars['String'];
  id: Scalars['ID'];
  sessionId: Scalars['ID'];
  state: ChallengesessionChallengeChallengeState;
};

export enum ChallengesessionChallengeChallengeState {
  ChallengeStateFailed = 'CHALLENGE_STATE_FAILED',
  ChallengeStateSucceeded = 'CHALLENGE_STATE_SUCCEEDED',
  ChallengeStateUnresolved = 'CHALLENGE_STATE_UNRESOLVED',
  ChallengeStateUnspecified = 'CHALLENGE_STATE_UNSPECIFIED'
}

export type ChallengesessionChallengeInput = {
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  sessionId?: InputMaybe<Scalars['ID']>;
  state?: InputMaybe<ChallengesessionChallengeChallengeState>;
};

export type ChallengesessionChallengePick = {
  __typename?: 'ChallengesessionChallengePick';
  challengeId: Scalars['ID'];
  sessionId: Scalars['ID'];
  stake: ChallengesessionStake;
  userId: Scalars['ID'];
};

export type ChallengesessionChallengeSession = {
  __typename?: 'ChallengesessionChallengeSession';
  challenges: Array<ChallengesessionChallenge>;
  gameId: Scalars['ID'];
  id: Scalars['ID'];
  phase: ChallengesessionChallengeSessionPhase;
  streamId: Scalars['ID'];
  submissionDeadline: Scalars['Timestamp'];
  submissionWindowLength: Scalars['Int'];
};

export type ChallengesessionChallengeSessionEvent = {
  __typename?: 'ChallengesessionChallengeSessionEvent';
  event?: Maybe<ChallengesessionChallengeSessionEventEventUnion>;
  streamId: Scalars['ID'];
};

export type ChallengesessionChallengeSessionEventChallengeStatusChange = {
  __typename?: 'ChallengesessionChallengeSessionEventChallengeStatusChange';
  challenge: ChallengesessionChallenge;
  sessionId: Scalars['ID'];
};

export type ChallengesessionChallengeSessionEventEventUnion = ChallengesessionChallengeSessionEventChallengeStatusChange | ChallengesessionChallengeSessionEventInitial | ChallengesessionChallengeSessionEventPhaseChange | ChallengesessionChallengeSessionEventStakeChange;

export type ChallengesessionChallengeSessionEventInitial = {
  __typename?: 'ChallengesessionChallengeSessionEventInitial';
  session: ChallengesessionChallengeSession;
  stats: Array<ChallengesessionChallengeStats>;
  userPick: ChallengesessionChallengePick;
};

export type ChallengesessionChallengeSessionEventPhaseChange = {
  __typename?: 'ChallengesessionChallengeSessionEventPhaseChange';
  session: ChallengesessionChallengeSession;
};

export type ChallengesessionChallengeSessionEventStakeChange = {
  __typename?: 'ChallengesessionChallengeSessionEventStakeChange';
  sessionId: Scalars['ID'];
  stats: Array<ChallengesessionChallengeStats>;
};

export enum ChallengesessionChallengeSessionPhase {
  PhaseActive = 'PHASE_ACTIVE',
  PhaseCancelled = 'PHASE_CANCELLED',
  PhaseCompleted = 'PHASE_COMPLETED',
  PhaseDraft = 'PHASE_DRAFT',
  PhaseSubmission = 'PHASE_SUBMISSION',
  PhaseUnspecified = 'PHASE_UNSPECIFIED'
}

export type ChallengesessionChallengeSessionUpdateInput = {
  challenges?: InputMaybe<Array<ChallengesessionChallengeInput>>;
  gameId?: InputMaybe<Scalars['ID']>;
  streamId?: InputMaybe<Scalars['ID']>;
  submissionWindowLength?: InputMaybe<Scalars['Int']>;
};

export type ChallengesessionChallengeStats = {
  __typename?: 'ChallengesessionChallengeStats';
  challengeId: Scalars['ID'];
  highestStakePick: ChallengesessionChallengePick;
  sessionId: Scalars['ID'];
  totalPicks: Scalars['Int'];
  totalStake: ChallengesessionStake;
};

export type ChallengesessionStake = {
  __typename?: 'ChallengesessionStake';
  currencyAmount: Scalars['Int'];
  currencyId: Scalars['ID'];
};

export type ChallengesessionStakeInput = {
  currencyAmount?: InputMaybe<Scalars['Int']>;
  currencyId?: InputMaybe<Scalars['ID']>;
};

export enum ChannelAppealStatus {
  AppealStatusAccepted = 'APPEAL_STATUS_ACCEPTED',
  AppealStatusDeclined = 'APPEAL_STATUS_DECLINED',
  AppealStatusPending = 'APPEAL_STATUS_PENDING',
  AppealStatusUnspecified = 'APPEAL_STATUS_UNSPECIFIED'
}

export enum ChannelAssetType {
  AssetTypeBanner = 'ASSET_TYPE_BANNER',
  AssetTypeLogo = 'ASSET_TYPE_LOGO',
  AssetTypeUnspecified = 'ASSET_TYPE_UNSPECIFIED'
}

export type ChannelAutomodItemAccepted = {
  __typename?: 'ChannelAutomodItemAccepted';
  message: ChatMessageContent;
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type ChannelAutomodItemRejected = {
  __typename?: 'ChannelAutomodItemRejected';
  message: ChatMessageContent;
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type ChannelAutomodSettings = {
  __typename?: 'ChannelAutomodSettings';
  defaultDecision: ChatAutomodDecision;
  level: ChatAutomodLevel;
};

export type ChannelAutomodSettingsInput = {
  defaultDecision?: InputMaybe<ChatAutomodDecision>;
  level?: InputMaybe<ChatAutomodLevel>;
};

export type ChannelAvatarItemPurchase = {
  __typename?: 'ChannelAvatarItemPurchase';
  item: ItemItem;
  itemId: Scalars['ID'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type ChannelBanAppeal = {
  __typename?: 'ChannelBanAppeal';
  appealText: Scalars['String'];
  bannedAt: Scalars['Timestamp'];
  channelId: Scalars['ID'];
  createdAt: Scalars['Timestamp'];
  description: Scalars['String'];
  moderatorId: Scalars['ID'];
  reviewerComment: Scalars['String'];
  reviewerId: Scalars['ID'];
  status: ChannelAppealStatus;
  userId: Scalars['ID'];
  violation: ChannelViolation;
};

export type ChannelBanAppealAccepted = {
  __typename?: 'ChannelBanAppealAccepted';
  comment: Scalars['String'];
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type ChannelBanAppealInfo = {
  __typename?: 'ChannelBanAppealInfo';
  appealText: Scalars['String'];
  channelId: Scalars['ID'];
  createdAt: Scalars['Timestamp'];
  reviewer: ProfileProfile;
  reviewerComment: Scalars['String'];
  reviewerId: Scalars['ID'];
  status: ChannelAppealStatus;
  userId: Scalars['ID'];
};

export type ChannelBanAppealRejected = {
  __typename?: 'ChannelBanAppealRejected';
  comment: Scalars['String'];
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type ChannelBannedUser = {
  __typename?: 'ChannelBannedUser';
  appeal?: Maybe<ChannelBanAppealInfo>;
  bannedAt: Scalars['Timestamp'];
  channel: ChannelChannel;
  channelId: Scalars['ID'];
  description: Scalars['String'];
  keepRecentMessages: Scalars['Boolean'];
  moderator: ProfileProfile;
  moderatorId: Scalars['ID'];
  user: ProfileProfile;
  userId: Scalars['ID'];
  violation: ChannelViolation;
};

export type ChannelBatchGetChannelsResponse = {
  __typename?: 'ChannelBatchGetChannelsResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelBatchGetGameStatsResponse = {
  __typename?: 'ChannelBatchGetGameStatsResponse';
  gameStats: Array<ChannelGameStats>;
};

export type ChannelBatchGetStreamSummaryResponse = {
  __typename?: 'ChannelBatchGetStreamSummaryResponse';
  summaries: Array<ChannelStreamSummary>;
};

export type ChannelBatchGetUserBanStatusResponse = {
  __typename?: 'ChannelBatchGetUserBanStatusResponse';
  statuses: Array<ChannelUserBanStatus>;
};

export type ChannelBatchStreamGetChannelResponse = {
  __typename?: 'ChannelBatchStreamGetChannelResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelBundlePurchase = {
  __typename?: 'ChannelBundlePurchase';
  bundleName: Scalars['String'];
  streamerCardIds: Array<Scalars['String']>;
  streamerCards?: Maybe<Array<GameLogicStreamerCard>>;
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type ChannelChallengesFeatureStatus = {
  __typename?: 'ChannelChallengesFeatureStatus';
  enabled: Scalars['Boolean'];
};

/** Public channel information */
export type ChannelChannel = {
  __typename?: 'ChannelChannel';
  activeStream?: Maybe<ChannelStreamSummary>;
  channelFriends: FriendsChannelFriends;
  createdAt: Scalars['Timestamp'];
  currentChatId?: Maybe<Scalars['String']>;
  currentStream?: Maybe<ChannelStream>;
  currentStreamId: Scalars['ID'];
  description: Scalars['String'];
  features: ChannelChannelFeatures;
  followerCount: Scalars['Int'];
  following: Scalars['Boolean'];
  game: GameGame;
  gameId: Scalars['ID'];
  id: Scalars['ID'];
  isPublic: Scalars['Boolean'];
  itemStats: Array<ItemItemStat>;
  links: Array<ChannelChannelLink>;
  liveStatus: ChannelLiveStatus;
  logo: Scalars['String'];
  matchOngoing: Scalars['Boolean'];
  matureRatedContent: Scalars['Boolean'];
  monetizationSettings: ChannelMonetizationSettings;
  name: Scalars['String'];
  offlineBanner: Scalars['String'];
  offlineBannerUrl: Scalars['String'];
  playedGameIds: Array<Scalars['String']>;
  priority: Scalars['Int'];
  reportingId: Scalars['ID'];
  riskTier: ChannelRiskTier;
  state: ApiEntityState;
  streamedGames?: Maybe<Array<GameGame>>;
  streamer: ProfileProfile;
  streamerId: Scalars['ID'];
  subscriberCount: Scalars['Int'];
  subscription?: Maybe<SubscriptionChannelSubscription>;
  subscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  suspension: ChannelSuspension;
  thumbnail: Scalars['String'];
  title: Scalars['String'];
  userBanStatus: ChannelUserBanStatus;
  viewerCount: Scalars['Int'];
};

export type ChannelChannelCreationEligibility = {
  __typename?: 'ChannelChannelCreationEligibility';
  canCreateChannel: Scalars['Boolean'];
};

export type ChannelChannelDetailsUpdateInput = {
  description?: InputMaybe<Scalars['String']>;
  featureChallengesEnabled?: InputMaybe<Scalars['Boolean']>;
  featureNoicePredictionsEnabled?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['ID']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  links?: InputMaybe<Array<ChannelChannelLinkInput>>;
  matureRatedContent?: InputMaybe<Scalars['Boolean']>;
  priority?: InputMaybe<Scalars['Int']>;
  riskTier?: InputMaybe<ChannelRiskTier>;
  title?: InputMaybe<Scalars['String']>;
};

export type ChannelChannelEvent = {
  __typename?: 'ChannelChannelEvent';
  channelId: Scalars['ID'];
  content: ChannelChannelEventContent;
  createdAt: Scalars['Timestamp'];
  id: Scalars['ID'];
};

export type ChannelChannelEventContent = {
  __typename?: 'ChannelChannelEventContent';
  content?: Maybe<ChannelChannelEventContentContentUnion>;
};

export type ChannelChannelEventContentContentUnion = ChannelAvatarItemPurchase | ChannelBundlePurchase | ChannelGiftSubscriptionPurchase | ChannelStreamerCardPurchase | ChannelSubscriptionPurchase | ChannelSubscriptionRenewal;

export enum ChannelChannelFeature {
  ChannelFeatureChallenges = 'CHANNEL_FEATURE_CHALLENGES',
  ChannelFeatureNoicePredictions = 'CHANNEL_FEATURE_NOICE_PREDICTIONS',
  ChannelFeatureStreaming = 'CHANNEL_FEATURE_STREAMING',
  ChannelFeatureUnspecified = 'CHANNEL_FEATURE_UNSPECIFIED'
}

export type ChannelChannelFeatures = {
  __typename?: 'ChannelChannelFeatures';
  challenges: ChannelChallengesFeatureStatus;
  noicePredictions: ChannelNoicePredictionsFeatureStatus;
  streaming: ChannelStreamingFeatureStatus;
};

export type ChannelChannelLink = {
  __typename?: 'ChannelChannelLink';
  name: Scalars['String'];
  type: ChannelChannelLinkLinkType;
  url: Scalars['String'];
};

export type ChannelChannelLinkInput = {
  name?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<ChannelChannelLinkLinkType>;
  url?: InputMaybe<Scalars['String']>;
};

export enum ChannelChannelLinkLinkType {
  LinkTypeCustom = 'LINK_TYPE_CUSTOM',
  LinkTypeDiscord = 'LINK_TYPE_DISCORD',
  LinkTypeFacebook = 'LINK_TYPE_FACEBOOK',
  LinkTypeInstagram = 'LINK_TYPE_INSTAGRAM',
  LinkTypeTiktok = 'LINK_TYPE_TIKTOK',
  LinkTypeTwitter = 'LINK_TYPE_TWITTER',
  LinkTypeUnspecified = 'LINK_TYPE_UNSPECIFIED',
  LinkTypeYoutube = 'LINK_TYPE_YOUTUBE'
}

export enum ChannelChannelRole {
  ChannelRoleModerator = 'CHANNEL_ROLE_MODERATOR',
  ChannelRolePlatformModerator = 'CHANNEL_ROLE_PLATFORM_MODERATOR',
  ChannelRoleStreamer = 'CHANNEL_ROLE_STREAMER',
  ChannelRoleUnspecified = 'CHANNEL_ROLE_UNSPECIFIED'
}

export type ChannelChannelRoles = {
  __typename?: 'ChannelChannelRoles';
  channel: ChannelChannel;
  channelId: Scalars['ID'];
  roles: Array<ChannelChannelRole>;
};

export type ChannelChannelStreamDetailEvent = {
  __typename?: 'ChannelChannelStreamDetailEvent';
  challengesEnabled: Scalars['Boolean'];
  channelId: Scalars['ID'];
  gameId: Scalars['ID'];
  liveStatus: ChannelLiveStatus;
  matureRatedContent: Scalars['Boolean'];
  noicePredictionsEnabled: Scalars['Boolean'];
  serverRenderingEnabled: Scalars['Boolean'];
  streamId: Scalars['ID'];
  transcodingEnabled: Scalars['Boolean'];
};

export type ChannelContentRendererConfig = {
  __typename?: 'ChannelContentRendererConfig';
  arenaId: Scalars['ID'];
  containerImage: Scalars['String'];
  controllerContainerImage: Scalars['String'];
};

export type ChannelContentRendererConfigInput = {
  arenaId?: InputMaybe<Scalars['ID']>;
  containerImage?: InputMaybe<Scalars['String']>;
  controllerContainerImage?: InputMaybe<Scalars['String']>;
};

export type ChannelCreateChannelAssetUploadTokenResponse = {
  __typename?: 'ChannelCreateChannelAssetUploadTokenResponse';
  token: Scalars['String'];
};

export type ChannelFollowerCountEvent = {
  __typename?: 'ChannelFollowerCountEvent';
  channelId: Scalars['ID'];
  followerCount: Scalars['Int'];
};

export type ChannelFollowerNotificationSettings = {
  __typename?: 'ChannelFollowerNotificationSettings';
  channelId: Scalars['ID'];
  channelLiveNotificationEnabled: Scalars['Boolean'];
  userId: Scalars['ID'];
};

export type ChannelGameStats = {
  __typename?: 'ChannelGameStats';
  game: GameGame;
  gameId: Scalars['ID'];
  liveStreams: Scalars['Int'];
};

export enum ChannelGender {
  GenderFemale = 'GENDER_FEMALE',
  GenderMale = 'GENDER_MALE',
  GenderUnspecified = 'GENDER_UNSPECIFIED'
}

export type ChannelGetChannelFollowerStatusResponse = {
  __typename?: 'ChannelGetChannelFollowerStatusResponse';
  followedAt?: Maybe<Scalars['Timestamp']>;
  following: Scalars['Boolean'];
};

export type ChannelGetFollowStatusResponse = {
  __typename?: 'ChannelGetFollowStatusResponse';
  following: Array<Scalars['Boolean']>;
};

export type ChannelGetUserFollowedChannelsResponse = {
  __typename?: 'ChannelGetUserFollowedChannelsResponse';
  channels: Array<ChannelChannel>;
  pageInfo: ApiPageInfo;
};

export type ChannelGiftSubscriptionPurchase = {
  __typename?: 'ChannelGiftSubscriptionPurchase';
  recipientUserIds: Array<Scalars['String']>;
  recipients?: Maybe<Array<ProfileProfile>>;
  tier: Scalars['Int'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type ChannelIngestStatsEvent = {
  __typename?: 'ChannelIngestStatsEvent';
  audioChannelCnt: Scalars['Int'];
  audioSampleRate: Scalars['Int'];
  bSlices: Scalars['Int'];
  bitrate: Scalars['Int'];
  channelId: Scalars['ID'];
  framerate: Scalars['Int'];
  height: Scalars['Int'];
  streamId: Scalars['ID'];
  width: Scalars['Int'];
};

export type ChannelListBanAppealsResponse = {
  __typename?: 'ChannelListBanAppealsResponse';
  appeals: Array<ChannelBanAppeal>;
  pageInfo: ApiPageInfo;
};

export type ChannelListBannedUsersResponse = {
  __typename?: 'ChannelListBannedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<ChannelBannedUser>;
};

export type ChannelListChannelPrivilegedUsersResponse = {
  __typename?: 'ChannelListChannelPrivilegedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<ChannelPrivilegedUser>;
};

export type ChannelListChannelsResponse = {
  __typename?: 'ChannelListChannelsResponse';
  channels: Array<ChannelChannel>;
  pageInfo: ApiPageInfo;
};

export type ChannelListGameStatsRequestFilterInput = {
  live?: InputMaybe<Scalars['Boolean']>;
};

export type ChannelListGameStatsResponse = {
  __typename?: 'ChannelListGameStatsResponse';
  games: Array<ChannelGameStats>;
  pageInfo: ApiPageInfo;
};

export type ChannelListHighlightedChannelsResponse = {
  __typename?: 'ChannelListHighlightedChannelsResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelListModerationEventsResponse = {
  __typename?: 'ChannelListModerationEventsResponse';
  events: Array<ChannelModerationEvent>;
  pageInfo: ApiPageInfo;
};

export type ChannelListStreamBackendConfigsResponse = {
  __typename?: 'ChannelListStreamBackendConfigsResponse';
  configs: Array<ChannelStreamBackendConfig>;
};

export type ChannelListStreamsResponse = {
  __typename?: 'ChannelListStreamsResponse';
  pageInfo: ApiPageInfo;
  streams: Array<ChannelStream>;
};

export type ChannelListUserChannelBansResponse = {
  __typename?: 'ChannelListUserChannelBansResponse';
  bans: Array<ChannelBannedUser>;
  pageInfo: ApiPageInfo;
};

export type ChannelListUserChannelRolesResponse = {
  __typename?: 'ChannelListUserChannelRolesResponse';
  roles: Array<ChannelChannelRole>;
};

export type ChannelListUserPrivilegedChannelsResponse = {
  __typename?: 'ChannelListUserPrivilegedChannelsResponse';
  channels: Array<ChannelChannelRoles>;
};

export enum ChannelLiveStatus {
  LiveStatusLive = 'LIVE_STATUS_LIVE',
  LiveStatusOffline = 'LIVE_STATUS_OFFLINE',
  LiveStatusUnlisted = 'LIVE_STATUS_UNLISTED',
  LiveStatusUnspecified = 'LIVE_STATUS_UNSPECIFIED'
}

export type ChannelLiveStatusEvent = {
  __typename?: 'ChannelLiveStatusEvent';
  channelId: Scalars['ID'];
  liveStatus: ChannelLiveStatus;
  streamId: Scalars['ID'];
};

export type ChannelMachineLearningConfig = {
  __typename?: 'ChannelMachineLearningConfig';
  containerImage: Scalars['String'];
  disabled: Scalars['Boolean'];
};

export type ChannelMachineLearningConfigInput = {
  containerImage?: InputMaybe<Scalars['String']>;
  disabled?: InputMaybe<Scalars['Boolean']>;
};

export type ChannelModerationEvent = {
  __typename?: 'ChannelModerationEvent';
  channel: ChannelChannel;
  channelId: Scalars['ID'];
  content: ChannelModerationEventContent;
  id: Scalars['ID'];
  moderator?: Maybe<ProfileProfile>;
  moderatorId: Scalars['ID'];
  timestamp: Scalars['Timestamp'];
};

export type ChannelModerationEventContent = {
  __typename?: 'ChannelModerationEventContent';
  content?: Maybe<ChannelModerationEventContentContentUnion>;
};

export type ChannelModerationEventContentContentUnion = ChannelAutomodItemAccepted | ChannelAutomodItemRejected | ChannelBanAppealAccepted | ChannelBanAppealRejected | ChannelUserBanned | ChannelUserMuted | ChannelUserUnbanned;

export enum ChannelModerationEventType {
  ModerationEventTypeAutomodItemAccepted = 'MODERATION_EVENT_TYPE_AUTOMOD_ITEM_ACCEPTED',
  ModerationEventTypeAutomodItemRejected = 'MODERATION_EVENT_TYPE_AUTOMOD_ITEM_REJECTED',
  ModerationEventTypeBanAppealAccepted = 'MODERATION_EVENT_TYPE_BAN_APPEAL_ACCEPTED',
  ModerationEventTypeBanAppealRejected = 'MODERATION_EVENT_TYPE_BAN_APPEAL_REJECTED',
  ModerationEventTypeUnspecified = 'MODERATION_EVENT_TYPE_UNSPECIFIED',
  ModerationEventTypeUserBanned = 'MODERATION_EVENT_TYPE_USER_BANNED',
  ModerationEventTypeUserMuted = 'MODERATION_EVENT_TYPE_USER_MUTED',
  ModerationEventTypeUserUnbanned = 'MODERATION_EVENT_TYPE_USER_UNBANNED'
}

export type ChannelModerationEventsFilterInput = {
  eventTypes?: InputMaybe<Array<ChannelModerationEventType>>;
};

export type ChannelModerationSettings = {
  __typename?: 'ChannelModerationSettings';
  automod: ChannelAutomodSettings;
  banAppealsEnabled: Scalars['Boolean'];
  channelId: Scalars['ID'];
};

export type ChannelModerationSettingsInput = {
  automod?: InputMaybe<ChannelAutomodSettingsInput>;
  banAppealsEnabled?: InputMaybe<Scalars['Boolean']>;
  channelId?: InputMaybe<Scalars['ID']>;
};

export type ChannelMonetizationSettings = {
  __typename?: 'ChannelMonetizationSettings';
  channelId: Scalars['ID'];
  eligible: Scalars['Boolean'];
  enabled: Scalars['Boolean'];
};

export type ChannelMonetizationSettingsInput = {
  channelId?: InputMaybe<Scalars['ID']>;
  eligible?: InputMaybe<Scalars['Boolean']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ChannelNoicePredictionsFeatureStatus = {
  __typename?: 'ChannelNoicePredictionsFeatureStatus';
  enabled: Scalars['Boolean'];
};

export type ChannelNotificationSettings = {
  __typename?: 'ChannelNotificationSettings';
  channelLiveNotification: ChannelNotificationStatus;
  userId: Scalars['ID'];
};

export type ChannelNotificationStatus = {
  __typename?: 'ChannelNotificationStatus';
  emailEnabled: Scalars['Boolean'];
  pushEnabled: Scalars['Boolean'];
};

export type ChannelNotificationStatusInput = {
  emailEnabled?: InputMaybe<Scalars['Boolean']>;
  pushEnabled?: InputMaybe<Scalars['Boolean']>;
};

export type ChannelPrivilegedUser = {
  __typename?: 'ChannelPrivilegedUser';
  roles: Array<ChannelChannelRole>;
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type ChannelRestreamingConfig = {
  __typename?: 'ChannelRestreamingConfig';
  bitrate: Scalars['Int'];
  channelId: Scalars['ID'];
  enabled: Scalars['Boolean'];
  rtmpEndpoint: Scalars['String'];
  rtmpKey: Scalars['String'];
};

export type ChannelRestreamingConfigInput = {
  bitrate?: InputMaybe<Scalars['Int']>;
  channelId?: InputMaybe<Scalars['ID']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  rtmpEndpoint?: InputMaybe<Scalars['String']>;
  rtmpKey?: InputMaybe<Scalars['String']>;
};

export enum ChannelRiskTier {
  RiskTier_0 = 'RISK_TIER_0',
  RiskTier_1 = 'RISK_TIER_1',
  RiskTier_2 = 'RISK_TIER_2',
  RiskTierUnspecified = 'RISK_TIER_UNSPECIFIED'
}

export type ChannelStream = {
  __typename?: 'ChannelStream';
  challengesEnabled: Scalars['Boolean'];
  channelId: Scalars['ID'];
  matureRatedContent: Scalars['Boolean'];
  noicePredictionsEnabled: Scalars['Boolean'];
  segments: Array<ChannelStreamSegment>;
  serverRenderingEnabled: Scalars['Boolean'];
  streamId: Scalars['ID'];
  transcodingEnabled: Scalars['Boolean'];
};

export type ChannelStreamBackendConfig = {
  __typename?: 'ChannelStreamBackendConfig';
  channelId: Scalars['ID'];
  crConfig?: Maybe<ChannelContentRendererConfig>;
  game: GameGame;
  gameId: Scalars['ID'];
  id: Scalars['ID'];
  mlConfig?: Maybe<ChannelMachineLearningConfig>;
  recConfig?: Maybe<ChannelStreamRecorderConfig>;
  transcoderConfig?: Maybe<ChannelStreamTranscoderConfig>;
};

export type ChannelStreamBackendConfigInput = {
  channelId?: InputMaybe<Scalars['ID']>;
  crConfig?: InputMaybe<ChannelContentRendererConfigInput>;
  gameId?: InputMaybe<Scalars['ID']>;
  id?: InputMaybe<Scalars['ID']>;
  mlConfig?: InputMaybe<ChannelMachineLearningConfigInput>;
  recConfig?: InputMaybe<ChannelStreamRecorderConfigInput>;
  transcoderConfig?: InputMaybe<ChannelStreamTranscoderConfigInput>;
};

export type ChannelStreamRecorderConfig = {
  __typename?: 'ChannelStreamRecorderConfig';
  containerImage: Scalars['String'];
};

export type ChannelStreamRecorderConfigInput = {
  containerImage?: InputMaybe<Scalars['String']>;
};

export type ChannelStreamSegment = {
  __typename?: 'ChannelStreamSegment';
  crConfig: ChannelContentRendererConfig;
  endTime?: Maybe<Scalars['Timestamp']>;
  gameId: Scalars['ID'];
  mlConfig: ChannelMachineLearningConfig;
  segmentId: Scalars['ID'];
  startTime: Scalars['Timestamp'];
  title: Scalars['String'];
};

export type ChannelStreamStatusEvent = {
  __typename?: 'ChannelStreamStatusEvent';
  channelId: Scalars['ID'];
  crStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  egressStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  gameRunnerStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  liveStatus: ChannelLiveStatus;
  mlStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  recStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  restreamingStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  streamId: Scalars['ID'];
  transcoderStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
};

export type ChannelStreamSummary = {
  __typename?: 'ChannelStreamSummary';
  challengesEnabled: Scalars['Boolean'];
  channelId: Scalars['ID'];
  endTime?: Maybe<Scalars['Timestamp']>;
  gameId: Scalars['ID'];
  matureRatedContent: Scalars['Boolean'];
  noicePredictionsEnabled: Scalars['Boolean'];
  serverRenderingEnabled: Scalars['Boolean'];
  startTime: Scalars['Timestamp'];
  streamId: Scalars['ID'];
  transcodingEnabled: Scalars['Boolean'];
};

export type ChannelStreamTranscoderConfig = {
  __typename?: 'ChannelStreamTranscoderConfig';
  containerImage: Scalars['String'];
};

export type ChannelStreamTranscoderConfigInput = {
  containerImage?: InputMaybe<Scalars['String']>;
};

export type ChannelStreamerCardPurchase = {
  __typename?: 'ChannelStreamerCardPurchase';
  streamerCard: GameLogicStreamerCard;
  streamerCardId: Scalars['ID'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type ChannelStreamingFeatureStatus = {
  __typename?: 'ChannelStreamingFeatureStatus';
  enabled: Scalars['Boolean'];
  suspension?: Maybe<ChannelSuspension>;
};

export type ChannelSubscriptionPurchase = {
  __typename?: 'ChannelSubscriptionPurchase';
  tier: Scalars['Int'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type ChannelSubscriptionRenewal = {
  __typename?: 'ChannelSubscriptionRenewal';
  tier: Scalars['Int'];
  userId: Scalars['ID'];
};

export type ChannelSuspension = {
  __typename?: 'ChannelSuspension';
  description: Scalars['String'];
  moderator?: Maybe<ProfileProfile>;
  reason: ChannelSuspensionReason;
  suspendedAt: Scalars['Timestamp'];
  suspendedBy: Scalars['String'];
  until?: Maybe<Scalars['Timestamp']>;
};

export enum ChannelSuspensionReason {
  ReasonChannelDeleted = 'REASON_CHANNEL_DELETED',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type ChannelUpdateFollowerNotificationSettingsParamsInput = {
  channelId?: InputMaybe<Scalars['ID']>;
  channelLiveNotificationEnabled?: InputMaybe<Scalars['Boolean']>;
  userId?: InputMaybe<Scalars['ID']>;
};

export type ChannelUpdateNotificationSettingsParamsInput = {
  channelLiveNotification?: InputMaybe<ChannelNotificationStatusInput>;
  userId?: InputMaybe<Scalars['ID']>;
};

export type ChannelUserBanStatus = {
  __typename?: 'ChannelUserBanStatus';
  appeal?: Maybe<ChannelBanAppealInfo>;
  banned: Scalars['Boolean'];
  bannedAt?: Maybe<Scalars['Timestamp']>;
  channel: ChannelChannel;
  channelId: Scalars['ID'];
  description: Scalars['String'];
  moderator?: Maybe<ProfileProfile>;
  moderatorId: Scalars['ID'];
  user: ProfileProfile;
  userId: Scalars['ID'];
  violation: ChannelViolation;
};

export type ChannelUserBanned = {
  __typename?: 'ChannelUserBanned';
  description: Scalars['String'];
  user: ProfileProfile;
  userId: Scalars['ID'];
  violation: ChannelViolation;
};

export type ChannelUserBannedNotification = {
  __typename?: 'ChannelUserBannedNotification';
  channelId: Scalars['ID'];
  description: Scalars['String'];
  moderatorId: Scalars['ID'];
  userId: Scalars['ID'];
  violation: ChannelViolation;
};

export type ChannelUserMuted = {
  __typename?: 'ChannelUserMuted';
  description: Scalars['String'];
  duration: Scalars['Duration'];
  reason: ChatReason;
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type ChannelUserUnbanned = {
  __typename?: 'ChannelUserUnbanned';
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type ChannelViewerCountEvent = {
  __typename?: 'ChannelViewerCountEvent';
  channelId: Scalars['ID'];
  viewerCount: Scalars['Int'];
};

export enum ChannelViolation {
  ViolationOther = 'VIOLATION_OTHER',
  ViolationSpam = 'VIOLATION_SPAM',
  ViolationUnspecified = 'VIOLATION_UNSPECIFIED'
}

export type ChatAutoModQueueEvent = {
  __typename?: 'ChatAutoModQueueEvent';
  event?: Maybe<ChatAutoModQueueEventEventUnion>;
};

export type ChatAutoModQueueEventAdd = {
  __typename?: 'ChatAutoModQueueEventAdd';
  item: ChatModerationItem;
};

export type ChatAutoModQueueEventEventUnion = ChatAutoModQueueEventAdd | ChatAutoModQueueEventRemove | ChatAutoModQueueEventUpdate;

export type ChatAutoModQueueEventRemove = {
  __typename?: 'ChatAutoModQueueEventRemove';
  id: Scalars['ID'];
};

export type ChatAutoModQueueEventUpdate = {
  __typename?: 'ChatAutoModQueueEventUpdate';
  item: ChatModerationItem;
};

export enum ChatAutomodDecision {
  AutomodDecisionAccepted = 'AUTOMOD_DECISION_ACCEPTED',
  AutomodDecisionRejected = 'AUTOMOD_DECISION_REJECTED',
  AutomodDecisionUnspecified = 'AUTOMOD_DECISION_UNSPECIFIED'
}

export enum ChatAutomodLevel {
  AutomodLevelHigh = 'AUTOMOD_LEVEL_HIGH',
  AutomodLevelLow = 'AUTOMOD_LEVEL_LOW',
  AutomodLevelUnspecified = 'AUTOMOD_LEVEL_UNSPECIFIED'
}

export type ChatChatDetails = {
  __typename?: 'ChatChatDetails';
  chatId: Scalars['ID'];
  roles: Array<ChatChatRole>;
};

export type ChatChatEvent = {
  __typename?: 'ChatChatEvent';
  chatId: Scalars['ID'];
  cid: Scalars['Int'];
  event?: Maybe<ChatChatEventEventUnion>;
};

export type ChatChatEventEventUnion = ChatChatDetails | ChatChatMessage | ChatHideMessage | ChatMessageDenied | ChatPing | ChatUserBanned | ChatUserMuted | ChatUserUnmuted;

export type ChatChatMessage = {
  __typename?: 'ChatChatMessage';
  chatId: Scalars['ID'];
  content: ChatMessageContent;
  createdAt: Scalars['Timestamp'];
  messageId: Scalars['ID'];
  moderationStatus: ChatModerationStatus;
  sender: ProfileProfile;
  senderId: Scalars['ID'];
  senderInfo: ChatSenderInfo;
  state: ApiEntityState;
  textClassification: ClassificationTextClassification;
  username: Scalars['String'];
};

export enum ChatChatRole {
  ChatRoleMember = 'CHAT_ROLE_MEMBER',
  ChatRoleModerator = 'CHAT_ROLE_MODERATOR',
  ChatRolePlatformModerator = 'CHAT_ROLE_PLATFORM_MODERATOR',
  ChatRoleStreamer = 'CHAT_ROLE_STREAMER',
  ChatRoleUnspecified = 'CHAT_ROLE_UNSPECIFIED'
}

export type ChatChatUser = {
  __typename?: 'ChatChatUser';
  label: ChatUserLabel;
  senderInfo: ChatSenderInfo;
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type ChatGetChatUserStatusResponse = {
  __typename?: 'ChatGetChatUserStatusResponse';
  muteDuration?: Maybe<Scalars['Duration']>;
  muted: Scalars['Boolean'];
};

export type ChatHideMessage = {
  __typename?: 'ChatHideMessage';
  chatId: Scalars['ID'];
  messageId: Scalars['ID'];
};

export type ChatListChatUsersResponse = {
  __typename?: 'ChatListChatUsersResponse';
  users: Array<ChatChatUser>;
};

export type ChatListMessagesResponse = {
  __typename?: 'ChatListMessagesResponse';
  messages: Array<ChatChatMessage>;
  pageInfo: ApiPageInfo;
};

export type ChatMessageContent = {
  __typename?: 'ChatMessageContent';
  content?: Maybe<ChatMessageContentContentUnion>;
};

export type ChatMessageContentContentUnion = ChatTextMessage | ChatTombstone;

export type ChatMessageContentInput = {
  textContent?: InputMaybe<ChatTextMessageInput>;
  tombstone?: InputMaybe<ChatTombstoneInput>;
};

export type ChatMessageDenied = {
  __typename?: 'ChatMessageDenied';
  chatId: Scalars['ID'];
  messageId: Scalars['ID'];
  userId: Scalars['ID'];
};

export type ChatModerationItem = {
  __typename?: 'ChatModerationItem';
  chatMessage: ChatChatMessage;
  expired: Scalars['Boolean'];
  expiresAt: Scalars['Timestamp'];
  id: Scalars['ID'];
  reviewer?: Maybe<ProfileProfile>;
  reviewerId?: Maybe<Scalars['ID']>;
  status: ChatModerationItemStatus;
};

export enum ChatModerationItemStatus {
  StatusAllowed = 'STATUS_ALLOWED',
  StatusDenied = 'STATUS_DENIED',
  StatusPending = 'STATUS_PENDING',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export enum ChatModerationStatus {
  ModerationStatusApproved = 'MODERATION_STATUS_APPROVED',
  ModerationStatusUnspecified = 'MODERATION_STATUS_UNSPECIFIED'
}

export type ChatPing = {
  __typename?: 'ChatPing';
  seq: Scalars['Int'];
};

export enum ChatReason {
  ReasonOther = 'REASON_OTHER',
  ReasonSpam = 'REASON_SPAM',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type ChatSendMessageResponse = {
  __typename?: 'ChatSendMessageResponse';
  messageId: Scalars['ID'];
};

export type ChatSenderInfo = {
  __typename?: 'ChatSenderInfo';
  avatar2D: Scalars['String'];
  badges: Array<BadgeBadge>;
  label: ChatUserLabel;
  preferredColor: ProfileColor;
  roles: Array<ChatChatRole>;
  userId: Scalars['ID'];
  username: Scalars['String'];
};

export type ChatTextMessage = {
  __typename?: 'ChatTextMessage';
  attachments: Array<ChatTextMessageAttachment>;
  links: Array<ChatTextMessageLink>;
  text: Scalars['String'];
};

export type ChatTextMessageAttachment = {
  __typename?: 'ChatTextMessageAttachment';
  endIndex: Scalars['Int'];
  itemId: Scalars['ID'];
  label: Scalars['String'];
  source: Scalars['String'];
  startIndex: Scalars['Int'];
};

export type ChatTextMessageAttachmentInput = {
  endIndex?: InputMaybe<Scalars['Int']>;
  itemId?: InputMaybe<Scalars['ID']>;
  label?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  startIndex?: InputMaybe<Scalars['Int']>;
};

export type ChatTextMessageInput = {
  attachments?: InputMaybe<Array<ChatTextMessageAttachmentInput>>;
  links?: InputMaybe<Array<ChatTextMessageLinkInput>>;
  text?: InputMaybe<Scalars['String']>;
};

export type ChatTextMessageLink = {
  __typename?: 'ChatTextMessageLink';
  endIndex: Scalars['Int'];
  startIndex: Scalars['Int'];
  url: Scalars['String'];
};

export type ChatTextMessageLinkInput = {
  endIndex?: InputMaybe<Scalars['Int']>;
  startIndex?: InputMaybe<Scalars['Int']>;
  url?: InputMaybe<Scalars['String']>;
};

export type ChatTombstone = {
  __typename?: 'ChatTombstone';
  emptyTypeWorkaround: Scalars['Boolean'];
};

export type ChatTombstoneInput = {
  emptyTypeWorkaround: Scalars['Boolean'];
};

export type ChatUserBanned = {
  __typename?: 'ChatUserBanned';
  chatId: Scalars['ID'];
  moderatorId: Scalars['ID'];
  userId: Scalars['ID'];
};

export enum ChatUserLabel {
  UserLabelModerator = 'USER_LABEL_MODERATOR',
  UserLabelStaff = 'USER_LABEL_STAFF',
  UserLabelStreamer = 'USER_LABEL_STREAMER',
  UserLabelUnspecified = 'USER_LABEL_UNSPECIFIED',
  UserLabelViewer = 'USER_LABEL_VIEWER'
}

export type ChatUserMuted = {
  __typename?: 'ChatUserMuted';
  chatId: Scalars['ID'];
  description: Scalars['String'];
  duration: Scalars['Duration'];
  moderatorId: Scalars['ID'];
  reason: ChatReason;
  userId: Scalars['ID'];
};

export type ChatUserUnmuted = {
  __typename?: 'ChatUserUnmuted';
  chatId: Scalars['ID'];
  moderatorId: Scalars['ID'];
  userId: Scalars['ID'];
};

export type ClassificationEvent = {
  __typename?: 'ClassificationEvent';
  event?: Maybe<ClassificationEventEventUnion>;
};

export type ClassificationEventCustomEvent = {
  __typename?: 'ClassificationEventCustomEvent';
  id: Scalars['ID'];
  message: Scalars['String'];
};

export type ClassificationEventEventFlooding = {
  __typename?: 'ClassificationEventEventFlooding';
  count: Scalars['Int'];
  id: Scalars['ID'];
  limit: Scalars['Int'];
};

export type ClassificationEventEventTrustChanged = {
  __typename?: 'ClassificationEventEventTrustChanged';
  id: Scalars['ID'];
  message: Scalars['String'];
  oldTrustLevel: ClassificationTrustLevel;
  trustLevel: ClassificationTrustLevel;
};

export type ClassificationEventEventUnion = ClassificationEventCustomEvent | ClassificationEventEventFlooding | ClassificationEventEventTrustChanged;

export type ClassificationTextClassification = {
  __typename?: 'ClassificationTextClassification';
  escalations: Array<Scalars['String']>;
  events: Array<ClassificationEvent>;
  hashed: Scalars['String'];
  hashes: Array<Scalars['Int']>;
  highRiskLanguage: Scalars['String'];
  notableIndexes: Array<Scalars['Int']>;
  response: Scalars['Boolean'];
  risk: ClassificationTextRisk;
  topics: Array<ClassificationTextClassificationTopicTextRiskLevel>;
  trust: ClassificationTrustLevel;
};

export type ClassificationTextClassificationTopicTextRiskLevel = {
  __typename?: 'ClassificationTextClassificationTopicTextRiskLevel';
  risk: ClassificationTextRisk;
  topic: ClassificationTopic;
};

export enum ClassificationTextRisk {
  TextRiskDangerous = 'TEXT_RISK_DANGEROUS',
  TextRiskExplicit = 'TEXT_RISK_EXPLICIT',
  TextRiskLow = 'TEXT_RISK_LOW',
  TextRiskMature = 'TEXT_RISK_MATURE',
  TextRiskNotable = 'TEXT_RISK_NOTABLE',
  TextRiskQuestionable = 'TEXT_RISK_QUESTIONABLE',
  TextRiskSafe = 'TEXT_RISK_SAFE',
  TextRiskUnknown = 'TEXT_RISK_UNKNOWN',
  TextRiskUnspecified = 'TEXT_RISK_UNSPECIFIED'
}

export enum ClassificationTopic {
  TopicAlarm = 'TOPIC_ALARM',
  TopicBullying = 'TOPIC_BULLYING',
  TopicChildGrooming = 'TOPIC_CHILD_GROOMING',
  TopicDrugsAndAlcohol = 'TOPIC_DRUGS_AND_ALCOHOL',
  TopicExtremism = 'TOPIC_EXTREMISM',
  TopicFraud = 'TOPIC_FRAUD',
  TopicGeneralRisk = 'TOPIC_GENERAL_RISK',
  TopicHateSpeech = 'TOPIC_HATE_SPEECH',
  TopicInApp = 'TOPIC_IN_APP',
  TopicJunk = 'TOPIC_JUNK',
  TopicPersonalIdentifyingInfo = 'TOPIC_PERSONAL_IDENTIFYING_INFO',
  TopicPolitics = 'TOPIC_POLITICS',
  TopicPublicThreat = 'TOPIC_PUBLIC_THREAT',
  TopicRealName = 'TOPIC_REAL_NAME',
  TopicRelationshipAndSexualContent = 'TOPIC_RELATIONSHIP_AND_SEXUAL_CONTENT',
  TopicReligious = 'TOPIC_RELIGIOUS',
  TopicSentiment = 'TOPIC_SENTIMENT',
  TopicSubversive = 'TOPIC_SUBVERSIVE',
  TopicUnspecified = 'TOPIC_UNSPECIFIED',
  TopicViolence = 'TOPIC_VIOLENCE',
  TopicVulgarity = 'TOPIC_VULGARITY',
  TopicWebsite = 'TOPIC_WEBSITE'
}

export enum ClassificationTrustLevel {
  TrustLevelDefault = 'TRUST_LEVEL_DEFAULT',
  TrustLevelMute = 'TRUST_LEVEL_MUTE',
  TrustLevelNotTrusted = 'TRUST_LEVEL_NOT_TRUSTED',
  TrustLevelSuperuser = 'TRUST_LEVEL_SUPERUSER',
  TrustLevelTrusted = 'TRUST_LEVEL_TRUSTED',
  TrustLevelUnspecified = 'TRUST_LEVEL_UNSPECIFIED'
}

export type ConfigMetagameConfigInactivityTimeouts = {
  __typename?: 'ConfigMetagameConfigInactivityTimeouts';
  enabled: Scalars['Boolean'];
  idleTimeoutSec: Scalars['Int'];
  implicitOfflineTimeoutSec: Scalars['Int'];
  offlineTimeoutSec: Scalars['Int'];
};

export type ConfigMetagameConfigUiTimings = {
  __typename?: 'ConfigMetagameConfigUITimings';
  teamActionTimeout: Scalars['Int'];
};

export type EmojiBatchGetEmojisResponse = {
  __typename?: 'EmojiBatchGetEmojisResponse';
  emojis: Array<EmojiEmoji>;
};

export type EmojiCreateEmojiUploadTokenResponse = {
  __typename?: 'EmojiCreateEmojiUploadTokenResponse';
  token: Scalars['String'];
};

export type EmojiEmoji = {
  __typename?: 'EmojiEmoji';
  channelId: Scalars['ID'];
  disabled: Scalars['Boolean'];
  id: Scalars['ID'];
  image: Scalars['String'];
  imageUrl: Scalars['String'];
  label: Scalars['String'];
  name: Scalars['String'];
  prefabName: Scalars['String'];
};

export type EmojiListChannelEmojisResponse = {
  __typename?: 'EmojiListChannelEmojisResponse';
  count?: Maybe<ItemItemTotalCount>;
  emojis: Array<EmojiEmoji>;
  pageInfo: ApiPageInfo;
};

export type EmojiListPlatformEmojisResponse = {
  __typename?: 'EmojiListPlatformEmojisResponse';
  count?: Maybe<ItemItemTotalCount>;
  emojis: Array<EmojiEmoji>;
  pageInfo: ApiPageInfo;
};

export type EmojiUpdateChannelEmojiParamsInput = {
  channelId?: InputMaybe<Scalars['ID']>;
  disabled?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['ID']>;
  label?: InputMaybe<Scalars['String']>;
};

export type EmojiUpdatePlatformEmojiParamsInput = {
  disabled?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['ID']>;
  label?: InputMaybe<Scalars['String']>;
};

export type FlagFeatureFlag = {
  __typename?: 'FlagFeatureFlag';
  description: Scalars['String'];
  enabled: Scalars['Boolean'];
  groups: Array<FlagFeatureFlagGroup>;
  name: Scalars['String'];
};

export type FlagFeatureFlagConfig = {
  __typename?: 'FlagFeatureFlagConfig';
  channelFlags: FlagFeatureFlagList;
  createdAt: Scalars['Timestamp'];
  revision: Scalars['String'];
  userFlags: FlagFeatureFlagList;
};

export type FlagFeatureFlagConfigInput = {
  channelFlags?: InputMaybe<FlagFeatureFlagListInput>;
  createdAt?: InputMaybe<Scalars['InputTimestamp']>;
  revision?: InputMaybe<Scalars['String']>;
  userFlags?: InputMaybe<FlagFeatureFlagListInput>;
};

export type FlagFeatureFlagGroup = {
  __typename?: 'FlagFeatureFlagGroup';
  conditions: Array<FlagFeatureFlagGroupCondition>;
  default: Scalars['Boolean'];
  enabled: Scalars['Boolean'];
  id: Scalars['ID'];
  values: Array<FlagFeatureFlagGroupValue>;
};

export type FlagFeatureFlagGroupCondition = {
  __typename?: 'FlagFeatureFlagGroupCondition';
  rule?: Maybe<FlagFeatureFlagGroupConditionRuleUnion>;
};

export type FlagFeatureFlagGroupConditionAny = {
  __typename?: 'FlagFeatureFlagGroupConditionAny';
  field: Scalars['String'];
  values: Array<Scalars['String']>;
};

export type FlagFeatureFlagGroupConditionAnyInput = {
  field?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<Scalars['String']>>;
};

export type FlagFeatureFlagGroupConditionEq = {
  __typename?: 'FlagFeatureFlagGroupConditionEq';
  field: Scalars['String'];
  value: Scalars['String'];
};

export type FlagFeatureFlagGroupConditionEqInput = {
  field?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export type FlagFeatureFlagGroupConditionGte = {
  __typename?: 'FlagFeatureFlagGroupConditionGte';
  field: Scalars['String'];
  value: Scalars['String'];
};

export type FlagFeatureFlagGroupConditionGteInput = {
  field?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export type FlagFeatureFlagGroupConditionInput = {
  any?: InputMaybe<FlagFeatureFlagGroupConditionAnyInput>;
  eq?: InputMaybe<FlagFeatureFlagGroupConditionEqInput>;
  gte?: InputMaybe<FlagFeatureFlagGroupConditionGteInput>;
  lte?: InputMaybe<FlagFeatureFlagGroupConditionLteInput>;
};

export type FlagFeatureFlagGroupConditionLte = {
  __typename?: 'FlagFeatureFlagGroupConditionLte';
  field: Scalars['String'];
  value: Scalars['String'];
};

export type FlagFeatureFlagGroupConditionLteInput = {
  field?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export type FlagFeatureFlagGroupConditionRuleUnion = FlagFeatureFlagGroupConditionAny | FlagFeatureFlagGroupConditionEq | FlagFeatureFlagGroupConditionGte | FlagFeatureFlagGroupConditionLte;

export type FlagFeatureFlagGroupInput = {
  conditions?: InputMaybe<Array<FlagFeatureFlagGroupConditionInput>>;
  default?: InputMaybe<Scalars['Boolean']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['ID']>;
  values?: InputMaybe<Array<FlagFeatureFlagGroupValueInput>>;
};

export type FlagFeatureFlagGroupValue = {
  __typename?: 'FlagFeatureFlagGroupValue';
  value: Scalars['String'];
  weight: Scalars['Int'];
};

export type FlagFeatureFlagGroupValueInput = {
  value?: InputMaybe<Scalars['String']>;
  weight?: InputMaybe<Scalars['Int']>;
};

export type FlagFeatureFlagInput = {
  description?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  groups?: InputMaybe<Array<FlagFeatureFlagGroupInput>>;
  name?: InputMaybe<Scalars['String']>;
};

export type FlagFeatureFlagList = {
  __typename?: 'FlagFeatureFlagList';
  flags: Array<FlagFeatureFlag>;
};

export type FlagFeatureFlagListInput = {
  flags?: InputMaybe<Array<FlagFeatureFlagInput>>;
};

export type FlagFeatureFlagSchema = {
  __typename?: 'FlagFeatureFlagSchema';
  flags: Array<FlagFeatureFlagSchemaFlagsEntry>;
};

export type FlagFeatureFlagSchemaFlagsEntry = {
  __typename?: 'FlagFeatureFlagSchemaFlagsEntry';
  key: Scalars['String'];
  value: FlagJsonSchema;
};

export type FlagFeatureFlagState = {
  __typename?: 'FlagFeatureFlagState';
  name: Scalars['String'];
  revision: Scalars['String'];
  value: Scalars['String'];
};

export type FlagJsonSchema = {
  __typename?: 'FlagJSONSchema';
  description: Scalars['String'];
  enum: Array<Scalars['String']>;
  items: FlagJsonSchema;
  maximum: Scalars['Float'];
  minimum: Scalars['Float'];
  multipleOf: Scalars['Float'];
  pattern: Scalars['String'];
  patternProperties: Array<FlagJsonSchemaPatternPropertiesEntry>;
  properties: Array<FlagJsonSchemaPropertiesEntry>;
  type: Scalars['String'];
};

export type FlagJsonSchemaPatternPropertiesEntry = {
  __typename?: 'FlagJSONSchemaPatternPropertiesEntry';
  key: Scalars['String'];
  value: FlagJsonSchema;
};

export type FlagJsonSchemaPropertiesEntry = {
  __typename?: 'FlagJSONSchemaPropertiesEntry';
  key: Scalars['String'];
  value: FlagJsonSchema;
};

export type FlagListChannelFeatureFlagsResponse = {
  __typename?: 'FlagListChannelFeatureFlagsResponse';
  flags: Array<FlagFeatureFlagState>;
};

export type FlagListUserFeatureFlagsResponse = {
  __typename?: 'FlagListUserFeatureFlagsResponse';
  flags: Array<FlagFeatureFlagState>;
};

export type FloatType = {
  __typename?: 'FloatType';
  /** The wrapped value of type Float */
  value: Scalars['Float'];
};

export type FriendsAcceptFriendRequestResponse = {
  __typename?: 'FriendsAcceptFriendRequestResponse';
  friend: ProfileProfile;
  friendId: Scalars['ID'];
};

export type FriendsActivity = {
  __typename?: 'FriendsActivity';
  channel?: Maybe<ChannelChannel>;
  channelId: Scalars['ID'];
  isOnline: Scalars['Boolean'];
  streamId: Scalars['ID'];
};

export type FriendsBlockUserResponse = {
  __typename?: 'FriendsBlockUserResponse';
  blockedUser: ProfileProfile;
  blockedUserId: Scalars['ID'];
};

export type FriendsChannelFriends = {
  __typename?: 'FriendsChannelFriends';
  channelId: Scalars['ID'];
  totalCount: Scalars['Int'];
  users: Array<FriendsUser>;
};

export type FriendsFriendStatusUpdateEvent = {
  __typename?: 'FriendsFriendStatusUpdateEvent';
  actorProfile: ProfileProfile;
  actorUserId: Scalars['ID'];
  targetProfile: ProfileProfile;
  targetUserId: Scalars['ID'];
  type: FriendsFriendStatusUpdateEventUpdateType;
};

export enum FriendsFriendStatusUpdateEventUpdateType {
  UpdateTypeFriendInvitation = 'UPDATE_TYPE_FRIEND_INVITATION',
  UpdateTypeInvitationAccepted = 'UPDATE_TYPE_INVITATION_ACCEPTED',
  UpdateTypeInvitationCancelled = 'UPDATE_TYPE_INVITATION_CANCELLED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUserBlocked = 'UPDATE_TYPE_USER_BLOCKED',
  UpdateTypeUserUnblocked = 'UPDATE_TYPE_USER_UNBLOCKED',
  UpdateTypeUserUnfriended = 'UPDATE_TYPE_USER_UNFRIENDED'
}

export type FriendsFriendsSettings = {
  __typename?: 'FriendsFriendsSettings';
  disableFriendRequests: Scalars['Boolean'];
};

export type FriendsFriendsSettingsInput = {
  disableFriendRequests?: InputMaybe<Scalars['Boolean']>;
};

export type FriendsFriendshipStatus = {
  __typename?: 'FriendsFriendshipStatus';
  activity?: Maybe<FriendsActivity>;
  lastStatusChange: Scalars['Timestamp'];
  status: FriendsFriendshipStatusStatus;
};

export enum FriendsFriendshipStatusStatus {
  StatusBlocked = 'STATUS_BLOCKED',
  StatusBlockedBy = 'STATUS_BLOCKED_BY',
  StatusFriend = 'STATUS_FRIEND',
  StatusFriendRequestReceived = 'STATUS_FRIEND_REQUEST_RECEIVED',
  StatusFriendRequestSent = 'STATUS_FRIEND_REQUEST_SENT',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export type FriendsGetChannelActiveFriendsResponse = {
  __typename?: 'FriendsGetChannelActiveFriendsResponse';
  channelFriends: Array<FriendsChannelFriends>;
};

export type FriendsGetFriendshipStatusResponse = {
  __typename?: 'FriendsGetFriendshipStatusResponse';
  statuses: Array<FriendsFriendshipStatus>;
};

export type FriendsListBlockedUsersResponse = {
  __typename?: 'FriendsListBlockedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListFriendsRequestFilterInput = {
  channelId?: InputMaybe<Scalars['ID']>;
  isOnline?: InputMaybe<Scalars['Boolean']>;
  streamId?: InputMaybe<Scalars['ID']>;
};

export type FriendsListFriendsResponse = {
  __typename?: 'FriendsListFriendsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListReceivedFriendRequestsResponse = {
  __typename?: 'FriendsListReceivedFriendRequestsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListSentFriendRequestsResponse = {
  __typename?: 'FriendsListSentFriendRequestsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsSendFriendRequestResponse = {
  __typename?: 'FriendsSendFriendRequestResponse';
  friend: ProfileProfile;
  friendId: Scalars['ID'];
};

export type FriendsUnblockUserResponse = {
  __typename?: 'FriendsUnblockUserResponse';
  unblockedUser: ProfileProfile;
  unblockedUserId: Scalars['ID'];
};

export type FriendsUser = {
  __typename?: 'FriendsUser';
  activity?: Maybe<FriendsActivity>;
  lastStatusChange: Scalars['Timestamp'];
  profile: ProfileProfile;
  userId: Scalars['ID'];
};

export enum FtueDismissalType {
  DismissalTypeActionTaken = 'DISMISSAL_TYPE_ACTION_TAKEN',
  DismissalTypeClosed = 'DISMISSAL_TYPE_CLOSED',
  DismissalTypeUnspecified = 'DISMISSAL_TYPE_UNSPECIFIED'
}

export type FtueListDismissedTooltipsResponse = {
  __typename?: 'FtueListDismissedTooltipsResponse';
  tooltipIds: Array<Scalars['String']>;
};

export type GameBatchGetGamesResponse = {
  __typename?: 'GameBatchGetGamesResponse';
  games: Array<GameGame>;
};

export type GameBatchGetSeasonsResponse = {
  __typename?: 'GameBatchGetSeasonsResponse';
  seasons: Array<GameSeason>;
};

export enum GameCardAssetType {
  AssetTypeThumbnail = 'ASSET_TYPE_THUMBNAIL',
  AssetTypeUnspecified = 'ASSET_TYPE_UNSPECIFIED',
  AssetTypeVideo = 'ASSET_TYPE_VIDEO'
}

export type GameCardBatchGetGameCardsResponse = {
  __typename?: 'GameCardBatchGetGameCardsResponse';
  cards: Array<GameLogicCard>;
};

export type GameCardBatchGetStreamerCardsResponse = {
  __typename?: 'GameCardBatchGetStreamerCardsResponse';
  cards: Array<GameLogicStreamerCard>;
};

export type GameCardCreateStreamerCardAssetUploadTokenResponse = {
  __typename?: 'GameCardCreateStreamerCardAssetUploadTokenResponse';
  token: Scalars['String'];
};

export type GameCardHighScoringCardConfig = {
  __typename?: 'GameCardHighScoringCardConfig';
  cardRarity: RarityRarity;
  percentageOfMaxRequired: Scalars['Float'];
  soloMultiplier: Scalars['Float'];
  streamerCardPercentageOfMaxRequired: Scalars['Float'];
};

export type GameCardHighScoringCardTimings = {
  __typename?: 'GameCardHighScoringCardTimings';
  cooldownBetweenCardScores: Scalars['Int'];
  ghostWaitTime: Scalars['Int'];
  speed: GameCardHighScoringCardTimingsSpeed;
};

export enum GameCardHighScoringCardTimingsSpeed {
  SpeedDefault = 'SPEED_DEFAULT',
  SpeedFast = 'SPEED_FAST',
  SpeedFastest = 'SPEED_FASTEST',
  SpeedSlow = 'SPEED_SLOW',
  SpeedSlowest = 'SPEED_SLOWEST',
  SpeedUnspecified = 'SPEED_UNSPECIFIED'
}

export type GameCardListBoostersResponse = {
  __typename?: 'GameCardListBoostersResponse';
  boosters: Array<GameLogicBooster>;
};

/** TODO: add game/stream based filtering */
export type GameCardListGameCardsResponse = {
  __typename?: 'GameCardListGameCardsResponse';
  cards: Array<GameLogicCard>;
};

export type GameCardListStreamerCardDraftsRequestFilterInput = {
  familyId?: InputMaybe<Scalars['ID']>;
  gameId?: InputMaybe<Scalars['ID']>;
};

export type GameCardListStreamerCardDraftsResponse = {
  __typename?: 'GameCardListStreamerCardDraftsResponse';
  cards: Array<GameLogicStreamerCard>;
  pageInfo: ApiPageInfo;
};

export type GameCardListStreamerCardsRequestFilterInput = {
  channelId?: InputMaybe<Scalars['ID']>;
  familyId?: InputMaybe<Scalars['ID']>;
  gameId?: InputMaybe<Scalars['ID']>;
};

export type GameCardListStreamerCardsResponse = {
  __typename?: 'GameCardListStreamerCardsResponse';
  cards: Array<GameLogicStreamerCard>;
  pageInfo: ApiPageInfo;
};

export type GameCardStreamerCardDraftUpdateInput = {
  cardId?: InputMaybe<Scalars['ID']>;
  channelId?: InputMaybe<Scalars['ID']>;
  familyId?: InputMaybe<Scalars['ID']>;
  gameId?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
};

export type GameGame = {
  __typename?: 'GameGame';
  activeSeason: GameSeason;
  activeSeasonId: Scalars['ID'];
  backdropUrl: Scalars['String'];
  challengesEnabled: Scalars['Boolean'];
  coverImageUrl: Scalars['String'];
  gameEventsSource: GameGameEventsSource;
  iconUrl: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  noicePredictionsEnabled: Scalars['Boolean'];
  otherNames: Array<Scalars['String']>;
  progression: GameUserProgression;
  publicAccess: Scalars['Boolean'];
};

export enum GameGameEventsSource {
  GameEventsSourceGameIntegration = 'GAME_EVENTS_SOURCE_GAME_INTEGRATION',
  GameEventsSourceMl = 'GAME_EVENTS_SOURCE_ML',
  GameEventsSourceUnspecified = 'GAME_EVENTS_SOURCE_UNSPECIFIED'
}

export type GameListGamesResponse = {
  __typename?: 'GameListGamesResponse';
  games: Array<GameGame>;
};

export type GameListSeasonsResponse = {
  __typename?: 'GameListSeasonsResponse';
  seasons: Array<GameSeason>;
};

export type GameLogicActiveBooster = {
  __typename?: 'GameLogicActiveBooster';
  activationTime: Scalars['Int'];
  activatorUserId: Scalars['ID'];
  boosterId: Scalars['Int'];
};

export type GameLogicActiveCard = {
  __typename?: 'GameLogicActiveCard';
  activeBoosters: Array<GameLogicActiveCardActiveBoostersEntry>;
  cardId: Scalars['ID'];
  failureTargetValue: Scalars['Int'];
  points: Scalars['Int'];
  pointsMax: Scalars['Int'];
  pointsMin: Scalars['Int'];
  pointsTimeTarget: Scalars['Int'];
  pointsUpdateTime: Scalars['Int'];
  pointsUpdateTimer: GameLogicTimer;
  setTime: Scalars['Int'];
  targetValue: Scalars['Int'];
  targetValues: Array<GameLogicActiveCardTargetValuesEntry>;
  timerDuration: Scalars['Int'];
};

export type GameLogicActiveCardActiveBoostersEntry = {
  __typename?: 'GameLogicActiveCardActiveBoostersEntry';
  key: Scalars['String'];
  value: GameLogicActiveBooster;
};

export type GameLogicActiveCardSucceededMsg = {
  __typename?: 'GameLogicActiveCardSucceededMsg';
  allOrNothing: GameLogicAllOrNothing;
  bestPlay: GameLogicBestPlay;
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  card: GameLogicCard;
  cardId: Scalars['ID'];
  groupId: Scalars['ID'];
  points: Scalars['Int'];
  streamId: Scalars['ID'];
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type GameLogicActiveCardTargetValuesEntry = {
  __typename?: 'GameLogicActiveCardTargetValuesEntry';
  key: Scalars['String'];
  value: Scalars['Int'];
};

export type GameLogicAllOrNothing = {
  __typename?: 'GameLogicAllOrNothing';
  bestPlay: GameLogicBestPlay;
  cardActivations: Array<GameLogicCardActivationResult>;
  cardId: Scalars['ID'];
  nextPoints: Scalars['Int'];
  round: Scalars['Int'];
  totalPoints: Scalars['Int'];
  totalRounds: Scalars['Int'];
};

export type GameLogicBestPlay = {
  __typename?: 'GameLogicBestPlay';
  activeBoosters: Array<GameLogicActiveBooster>;
  cardId: Scalars['ID'];
  points: Scalars['Int'];
};

export type GameLogicBooster = {
  __typename?: 'GameLogicBooster';
  canTargetSelf: Scalars['Boolean'];
  description: Scalars['String'];
  descriptionCondition: Scalars['String'];
  descriptionDefaultBenefit: Scalars['String'];
  descriptionOtherBenefit: Scalars['String'];
  descriptionTargetNoneBenefit: Scalars['String'];
  descriptionTargetSelf: Scalars['String'];
  id: Scalars['Int'];
  image: Scalars['String'];
  isAvailableSolo: Scalars['Boolean'];
  isSelfAndOtherEffect: Scalars['Boolean'];
  name: Scalars['String'];
  removeOn: Array<Scalars['String']>;
  timeActive: Scalars['Int'];
  triggersOn: Array<Scalars['String']>;
  valueOther: Scalars['Int'];
  valueSelf: Scalars['Int'];
};

export type GameLogicCard = {
  __typename?: 'GameLogicCard';
  activeStreamerCard?: Maybe<GameLogicStreamerCard>;
  activeStreamerCards: Array<GameLogicStreamerCard>;
  availableStreamerCards: Array<GameLogicStreamerCard>;
  backImage: Scalars['String'];
  dealingModules: Array<Scalars['String']>;
  description: Scalars['String'];
  failureModules: Array<Scalars['String']>;
  failureTargetValue: Scalars['Int'];
  familyId: Scalars['ID'];
  frontImage: Scalars['String'];
  gameModes: Array<Scalars['String']>;
  icon: Scalars['String'];
  id: Scalars['ID'];
  isAllOrNothing: Scalars['Boolean'];
  isDealtAtStart: Scalars['Boolean'];
  isEnabled: Scalars['Boolean'];
  isMatchCard: Scalars['Boolean'];
  leveling: GameLogicCardLeveling;
  matchCardId: Scalars['Int'];
  name: Scalars['String'];
  pointsMax: Scalars['Int'];
  pointsMin: Scalars['Int'];
  pointsTimeTarget: Scalars['Int'];
  rarity: RarityRarity;
  roleCharacters: Array<Scalars['String']>;
  scoredCounterIds: Array<Scalars['String']>;
  season: GameSeason;
  seasonId: Scalars['ID'];
  sides: Array<Scalars['String']>;
  successModules: Array<Scalars['String']>;
  targetValue: Scalars['Int'];
  targetValues: Array<GameLogicTargetValue>;
  timerDuration: Scalars['Int'];
  unlockLevel: Scalars['Int'];
};


export type GameLogicCardAvailableStreamerCardsArgs = {
  channel_id?: InputMaybe<Scalars['ID']>;
};

export type GameLogicCardActivationResult = {
  __typename?: 'GameLogicCardActivationResult';
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  cardId: Scalars['ID'];
  points: Scalars['Int'];
};

export type GameLogicCardDetails = {
  __typename?: 'GameLogicCardDetails';
  groupName: Scalars['String'];
  succeedingCard: GameLogicActiveCardSucceededMsg;
};

export type GameLogicCardLeveling = {
  __typename?: 'GameLogicCardLeveling';
  currentLevel: Scalars['Int'];
  nextLevelLimit: Scalars['Int'];
  progressToNextLevel: Scalars['Int'];
};

export type GameLogicChallenge = {
  __typename?: 'GameLogicChallenge';
  channelId: Scalars['ID'];
  description: Scalars['String'];
  disabled: Scalars['Boolean'];
  failureModule: Scalars['String'];
  gameId: Scalars['ID'];
  id: Scalars['ID'];
  name: Scalars['String'];
  successModule: Scalars['String'];
  targetValues: Array<GameLogicTargetValue>;
};

export enum GameLogicChallengeState {
  ChallengeStateFailure = 'CHALLENGE_STATE_FAILURE',
  ChallengeStateSuccess = 'CHALLENGE_STATE_SUCCESS',
  ChallengeStateUnresolved = 'CHALLENGE_STATE_UNRESOLVED',
  ChallengeStateUnspecified = 'CHALLENGE_STATE_UNSPECIFIED'
}

export type GameLogicChallengeStatus = {
  __typename?: 'GameLogicChallengeStatus';
  challenge: GameLogicChallenge;
  challengeId: Scalars['ID'];
  challengeState: GameLogicChallengeState;
  pickRate: Scalars['Float'];
  targetValues: Array<GameLogicTargetValue>;
};

export enum GameLogicContextualTeamActionStatus {
  ContextualTeamActionStatusFailed = 'CONTEXTUAL_TEAM_ACTION_STATUS_FAILED',
  ContextualTeamActionStatusOngoing = 'CONTEXTUAL_TEAM_ACTION_STATUS_ONGOING',
  ContextualTeamActionStatusSucceeded = 'CONTEXTUAL_TEAM_ACTION_STATUS_SUCCEEDED',
  ContextualTeamActionStatusUnspecified = 'CONTEXTUAL_TEAM_ACTION_STATUS_UNSPECIFIED'
}

export enum GameLogicContextualTeamActionType {
  ContextualTeamActionTypeHighScoringCardPromoted = 'CONTEXTUAL_TEAM_ACTION_TYPE_HIGH_SCORING_CARD_PROMOTED',
  ContextualTeamActionTypeStreamerActivated = 'CONTEXTUAL_TEAM_ACTION_TYPE_STREAMER_ACTIVATED',
  ContextualTeamActionTypeUnspecified = 'CONTEXTUAL_TEAM_ACTION_TYPE_UNSPECIFIED'
}

export type GameLogicGroup = {
  __typename?: 'GameLogicGroup';
  id: Scalars['ID'];
  isParty: Scalars['Boolean'];
  isSolo: Scalars['Boolean'];
  name: Scalars['String'];
  points: Scalars['Int'];
};

export type GameLogicGroupDetails = {
  __typename?: 'GameLogicGroupDetails';
  group: GameLogicGroup;
  players: Array<GameLogicPlayerDetails>;
  streamId: Scalars['ID'];
};

export type GameLogicHand = {
  __typename?: 'GameLogicHand';
  cardIds: Array<Scalars['String']>;
  matchEndCardIds: Array<Scalars['String']>;
  previousCardIds: Array<Scalars['String']>;
  votes: Array<GameLogicVote>;
};

export type GameLogicHighScoringCard = {
  __typename?: 'GameLogicHighScoringCard';
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  card: GameLogicCard;
  cardId: Scalars['ID'];
  points: Scalars['Int'];
};

export type GameLogicHighScoringCardPromotedMsg = {
  __typename?: 'GameLogicHighScoringCardPromotedMsg';
  card: GameLogicHighScoringCard;
  groupId: Scalars['ID'];
  groupName: Scalars['String'];
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type GameLogicLastActiveCard = {
  __typename?: 'GameLogicLastActiveCard';
  activeCard: GameLogicActiveCard;
  status: GameLogicLastActiveCardStatus;
};

export enum GameLogicLastActiveCardStatus {
  StatusFailed = 'STATUS_FAILED',
  StatusSucceeded = 'STATUS_SUCCEEDED',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export enum GameLogicMatchBonusType {
  MatchBonusTypeUnspecified = 'MATCH_BONUS_TYPE_UNSPECIFIED',
  MatchBonusTypeVictoryRoyal = 'MATCH_BONUS_TYPE_VICTORY_ROYAL'
}

export type GameLogicMatchConfiguration = {
  __typename?: 'GameLogicMatchConfiguration';
  aonPointMultipliers: Array<Scalars['Float']>;
  boosterCooldowns: Array<Scalars['Int']>;
  cardGlobalRefs: Array<Scalars['String']>;
  cardSwitchOutTimerDuration: Scalars['Int'];
  freeReshuffleCount: Scalars['Int'];
  gameId: Scalars['ID'];
  handSize: Scalars['Int'];
  matchBonusActivationRule: Scalars['String'];
  matchBonusPoints: Scalars['Int'];
  matchBonusType: GameLogicMatchBonusType;
  matchType: GameLogicStreamStateMatchType;
  pointsGainTime: Scalars['Int'];
  reshuffleBaseCost: Scalars['Int'];
  reshuffleCostMultiplier: Scalars['Float'];
  seasonId: Scalars['ID'];
};

export type GameLogicMatchEndedMsg = {
  __typename?: 'GameLogicMatchEndedMsg';
  bestCard?: Maybe<GameLogicCardDetails>;
  bestGroup?: Maybe<GameLogicGroupDetails>;
  bestPlayer?: Maybe<GameLogicPlayerDetails>;
  challengeStatuses: Array<GameLogicChallengeStatus>;
  channelId: Scalars['ID'];
  gameId: Scalars['ID'];
  group: GameLogicGroup;
  groupId: Scalars['ID'];
  matchId: Scalars['ID'];
  players: Array<GameLogicPlayer>;
  streamId: Scalars['ID'];
};

export type GameLogicMatchPauseStateChangedMsg = {
  __typename?: 'GameLogicMatchPauseStateChangedMsg';
  groupId: Scalars['ID'];
  matchId: Scalars['ID'];
  paused: Scalars['Boolean'];
  streamId: Scalars['ID'];
};

export type GameLogicMatchStartedMsg = {
  __typename?: 'GameLogicMatchStartedMsg';
  groupId: Scalars['ID'];
  matchId: Scalars['ID'];
  streamId: Scalars['ID'];
};

export type GameLogicPlayer = {
  __typename?: 'GameLogicPlayer';
  activeCard: GameLogicActiveCard;
  activeChallengeId: Scalars['ID'];
  allOrNothing: GameLogicAllOrNothing;
  bestPlay: GameLogicBestPlay;
  boosterCooldownTimer: GameLogicTimer;
  cardSwitchOutTimer: GameLogicTimer;
  fullUser: Scalars['Boolean'];
  hand: GameLogicHand;
  heldBoosterId: Scalars['Int'];
  inactivityWarningOn: Scalars['Boolean'];
  isOnline: Scalars['Boolean'];
  lastActiveCard: GameLogicLastActiveCard;
  name: Scalars['String'];
  points: Scalars['Int'];
  remainingInactiveSeconds: Scalars['Int'];
  reshuffleCount: Scalars['Int'];
  selfUsedBoosterCount: Scalars['Int'];
  usedBoosterCount: Scalars['Int'];
  usedMatchCards: Array<GameLogicPlayerUsedMatchCardsEntry>;
  userId: Scalars['ID'];
  userName: Scalars['String'];
};

export type GameLogicPlayerBoosterPoints = {
  __typename?: 'GameLogicPlayerBoosterPoints';
  boosterId: Scalars['Int'];
  cardUserId: Scalars['ID'];
  donatorUserId: Scalars['ID'];
  points: Scalars['Int'];
  userId: Scalars['ID'];
};

export type GameLogicPlayerDetails = {
  __typename?: 'GameLogicPlayerDetails';
  groupName: Scalars['String'];
  id: Scalars['ID'];
  points: Scalars['Int'];
  user: ProfileProfile;
};

export type GameLogicPlayerJoinedMsg = {
  __typename?: 'GameLogicPlayerJoinedMsg';
  groupId: Scalars['ID'];
  player: GameLogicPlayer;
  playerCardIds: Array<Scalars['String']>;
  serverTime: Scalars['Int'];
  streamId: Scalars['ID'];
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type GameLogicPlayerUsedMatchCardsEntry = {
  __typename?: 'GameLogicPlayerUsedMatchCardsEntry';
  key: Scalars['Int'];
  value: Scalars['Boolean'];
};

export type GameLogicStreamState = {
  __typename?: 'GameLogicStreamState';
  matchSeqNum: Scalars['Int'];
  matchState: GameLogicStreamStateMatchState;
  matchType: GameLogicStreamStateMatchType;
  roundNumber: Scalars['Int'];
  roundPhase: GameLogicStreamStateRoundPhase;
  roundPhaseDeadline: Scalars['Int'];
};

export enum GameLogicStreamStateMatchState {
  MatchStateActive = 'MATCH_STATE_ACTIVE',
  MatchStateEnded = 'MATCH_STATE_ENDED',
  MatchStatePaused = 'MATCH_STATE_PAUSED',
  MatchStateUnspecified = 'MATCH_STATE_UNSPECIFIED'
}

export enum GameLogicStreamStateMatchType {
  MatchTypeMultiRound = 'MATCH_TYPE_MULTI_ROUND',
  MatchTypeSingleRound = 'MATCH_TYPE_SINGLE_ROUND',
  MatchTypeUnspecified = 'MATCH_TYPE_UNSPECIFIED'
}

export enum GameLogicStreamStateRoundPhase {
  RoundPhaseCompetition = 'ROUND_PHASE_COMPETITION',
  RoundPhaseEnded = 'ROUND_PHASE_ENDED',
  RoundPhasePreparation = 'ROUND_PHASE_PREPARATION',
  RoundPhaseUnspecified = 'ROUND_PHASE_UNSPECIFIED'
}

export type GameLogicStreamerCard = {
  __typename?: 'GameLogicStreamerCard';
  baseCard: GameLogicCard;
  channel: ChannelChannel;
  channelId: Scalars['ID'];
  draft: Scalars['Boolean'];
  facecam: Scalars['String'];
  facecamUrl: Scalars['String'];
  familyId: Scalars['ID'];
  gameId: Scalars['ID'];
  id: Scalars['ID'];
  image: Scalars['String'];
  imageUrl: Scalars['String'];
  name: Scalars['String'];
  saleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  video: Scalars['String'];
  videoUrl: Scalars['String'];
};


export type GameLogicStreamerCardBaseCardArgs = {
  season_id?: InputMaybe<Scalars['String']>;
};

export type GameLogicTargetValue = {
  __typename?: 'GameLogicTargetValue';
  label: Scalars['String'];
  selector?: Maybe<GameLogicTargetValueSelector>;
  value: Scalars['Int'];
};

export type GameLogicTargetValueSelector = {
  __typename?: 'GameLogicTargetValueSelector';
  attribute: Scalars['String'];
  value?: Maybe<GameLogicTargetValueSelectorValueUnion>;
};

export type GameLogicTargetValueSelectorDefaultValue = {
  __typename?: 'GameLogicTargetValueSelectorDefaultValue';
  emptyTypeWorkaround: Scalars['Boolean'];
};

export type GameLogicTargetValueSelectorValueUnion = BooleanType | GameLogicTargetValueSelectorDefaultValue | IntType | StringType;

export type GameLogicTimer = {
  __typename?: 'GameLogicTimer';
  endTime: Scalars['Int'];
  startTime: Scalars['Int'];
};

export type GameLogicVote = {
  __typename?: 'GameLogicVote';
  cardId: Scalars['ID'];
  userId: Scalars['ID'];
};

export type GameSeason = {
  __typename?: 'GameSeason';
  badgeUrl: Scalars['String'];
  cardBackgroundUrls: Array<GameSeasonCardBackgroundAsset>;
  endTime: Scalars['Timestamp'];
  game: GameGame;
  gameId: Scalars['ID'];
  id: Scalars['ID'];
  name: Scalars['String'];
  progression: ProgressionSeasonProgression;
  progressionPauseReason: Scalars['String'];
  progressionPaused: Scalars['Boolean'];
  seasonBreak: Scalars['Boolean'];
  seasonBreakReason: Scalars['String'];
  /** @deprecated field is deprecated */
  seasonPauseReason: Scalars['String'];
  /** @deprecated field is deprecated */
  seasonPaused: Scalars['Boolean'];
  startTime: Scalars['Timestamp'];
};


export type GameSeasonProgressionArgs = {
  user_id?: InputMaybe<Scalars['ID']>;
};

export type GameSeasonCardBackgroundAsset = {
  __typename?: 'GameSeasonCardBackgroundAsset';
  rarity: RarityRarity;
  url: Scalars['String'];
};

export type GameStateAttributesState = {
  __typename?: 'GameStateAttributesState';
  boolAttributes: Array<GameStateAttributesStateBoolAttributesEntry>;
  intAttributes: Array<GameStateAttributesStateIntAttributesEntry>;
  stringAttributes: Array<GameStateAttributesStateStringAttributesEntry>;
};

export type GameStateAttributesStateBoolAttributesEntry = {
  __typename?: 'GameStateAttributesStateBoolAttributesEntry';
  key: Scalars['String'];
  value: Scalars['Boolean'];
};

export type GameStateAttributesStateIntAttributesEntry = {
  __typename?: 'GameStateAttributesStateIntAttributesEntry';
  key: Scalars['String'];
  value: Scalars['Int'];
};

export type GameStateAttributesStateStringAttributesEntry = {
  __typename?: 'GameStateAttributesStateStringAttributesEntry';
  key: Scalars['String'];
  value: Scalars['String'];
};

export type GameStateBoosterState = {
  __typename?: 'GameStateBoosterState';
  activeBooster: GameLogicActiveBooster;
  booster: GameLogicBooster;
  sourcePlayerId: Scalars['ID'];
  targetPlayerId: Scalars['ID'];
};

export type GameStateCalModule = {
  __typename?: 'GameStateCALModule';
  expression: GameStateCalModuleExpression;
};

export type GameStateCalModuleBinaryExpression = {
  __typename?: 'GameStateCALModuleBinaryExpression';
  left: GameStateCalModuleExpression;
  op: GameStateCalModuleBinaryOp;
  right: GameStateCalModuleExpression;
};

export enum GameStateCalModuleBinaryOp {
  BinaryOpAnd = 'BINARY_OP_AND',
  BinaryOpOr = 'BINARY_OP_OR',
  BinaryOpUnspecified = 'BINARY_OP_UNSPECIFIED'
}

export type GameStateCalModuleBinding = {
  __typename?: 'GameStateCALModuleBinding';
  ident: Scalars['String'];
  selector: GameStateCalModuleBinding;
};

export type GameStateCalModuleCheck = {
  __typename?: 'GameStateCALModuleCheck';
  check?: Maybe<GameStateCalModuleCheckCheckUnion>;
  label: Scalars['String'];
};

export type GameStateCalModuleCheckCheckUnion = GameStateCalModuleCountEventIntAttributeCheck | GameStateCalModuleEventBoolAttributeCheck | GameStateCalModuleEventIntAttributeCheck | GameStateCalModuleEventStringAttributeCheck | GameStateCalModuleEventTypeCheck | GameStateCalModuleEventTypeCheckAfterEventIntAttributeCheck | GameStateCalModuleGlobalAnyBoolAttributeCheck | GameStateCalModuleGlobalBoolAttributeCheck | GameStateCalModuleGlobalIntAttributeCheck | GameStateCalModuleGlobalIntAttributeSumCheck | GameStateCalModuleGlobalStringAttributeCheck | GameStateCalModuleIs | GameStateCalModuleRepeatedEventBoolAttributeCheck | GameStateCalModuleRepeatedEventIntAttributeCheck | GameStateCalModuleRepeatedEventStringAttributeCheck | GameStateCalModuleRepeatedEventTypeCheck | GameStateCalModuleTimeoutCheck;

export type GameStateCalModuleCheckParam = {
  __typename?: 'GameStateCALModuleCheckParam';
  value?: Maybe<GameStateCalModuleCheckParamValueUnion>;
};

export type GameStateCalModuleCheckParamValueUnion = BooleanType | GameStateCalModuleBinding | IntType | StringType;

export type GameStateCalModuleCheckSequence = {
  __typename?: 'GameStateCALModuleCheckSequence';
  activationTimes: Array<Scalars['Int']>;
  expressions: Array<GameStateCalModuleExpression>;
  intervals: Array<Scalars['Int']>;
  label: Scalars['String'];
};

export type GameStateCalModuleCountEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleCountEventIntAttributeCheck';
  attributes: Array<Scalars['String']>;
  calculateNegative: Scalars['Boolean'];
  eventName: Scalars['String'];
  initialValue: Scalars['Int'];
  targetValue: Scalars['Int'];
};

export type GameStateCalModuleEventBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleEventBoolAttributeCheck';
  attribute: Scalars['String'];
  eventName: Scalars['String'];
  value: Scalars['Boolean'];
};

export type GameStateCalModuleEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleEventIntAttributeCheck';
  attribute: Scalars['String'];
  eventName: Scalars['String'];
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int'];
};

export type GameStateCalModuleEventStringAttributeCheck = {
  __typename?: 'GameStateCALModuleEventStringAttributeCheck';
  attribute: Scalars['String'];
  eventName: Scalars['String'];
  operator: GameStateStringComparisonOperator;
  values: Array<Scalars['String']>;
};

export type GameStateCalModuleEventTypeCheck = {
  __typename?: 'GameStateCALModuleEventTypeCheck';
  eventNames: Array<Scalars['String']>;
};

export type GameStateCalModuleEventTypeCheckAfterEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleEventTypeCheckAfterEventIntAttributeCheck';
  firstCheck: GameStateCalModuleEventIntAttributeCheck;
  firstCheckSuccessTime: Scalars['Int'];
  secondCheck: GameStateCalModuleEventTypeCheck;
  timerDuration: Scalars['Int'];
};

export type GameStateCalModuleExpression = {
  __typename?: 'GameStateCALModuleExpression';
  expression?: Maybe<GameStateCalModuleExpressionExpressionUnion>;
};

export type GameStateCalModuleExpressionExpressionUnion = GameStateCalModuleBinaryExpression | GameStateCalModuleCheck | GameStateCalModuleCheckSequence | GameStateCalModuleForDuration | GameStateCalModuleGroup | GameStateCalModuleRepeat | GameStateCalModuleUnaryExpression | GameStateCalModuleWhen;

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type GameStateCalModuleForDuration = {
  __typename?: 'GameStateCALModuleForDuration';
  expression: GameStateCalModuleExpression;
  resetting: Scalars['Boolean'];
  timeout: GameStateCalModuleExpression;
};

export type GameStateCalModuleGlobalAnyBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalAnyBoolAttributeCheck';
  attributes: Array<Scalars['String']>;
  value: Scalars['Boolean'];
};

export type GameStateCalModuleGlobalBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalBoolAttributeCheck';
  attribute: Scalars['String'];
  value: Scalars['Boolean'];
};

export type GameStateCalModuleGlobalIntAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalIntAttributeCheck';
  attribute: Scalars['String'];
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int'];
};

export type GameStateCalModuleGlobalIntAttributeSumCheck = {
  __typename?: 'GameStateCALModuleGlobalIntAttributeSumCheck';
  attributes: Array<Scalars['String']>;
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int'];
};

export type GameStateCalModuleGlobalStringAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalStringAttributeCheck';
  attribute: Scalars['String'];
  operator: GameStateStringComparisonOperator;
  values: Array<Scalars['String']>;
};

export type GameStateCalModuleGroup = {
  __typename?: 'GameStateCALModuleGroup';
  expression: GameStateCalModuleExpression;
};

export type GameStateCalModuleIs = {
  __typename?: 'GameStateCALModuleIs';
  checkParams: Array<GameStateCalModuleCheckParam>;
  op: GameStateComparisonOperator;
};

export type GameStateCalModuleRepeat = {
  __typename?: 'GameStateCALModuleRepeat';
  expression: GameStateCalModuleExpression;
  initialValue: Scalars['Int'];
  label: Scalars['String'];
  targetValue: Scalars['Int'];
};

export type GameStateCalModuleRepeatedEventBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventBoolAttributeCheck';
  check: GameStateCalModuleEventBoolAttributeCheck;
  initialValue: Scalars['Int'];
  targetValue: Scalars['Int'];
};

export type GameStateCalModuleRepeatedEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventIntAttributeCheck';
  check: GameStateCalModuleEventIntAttributeCheck;
  initialValue: Scalars['Int'];
  targetValue: Scalars['Int'];
};

export type GameStateCalModuleRepeatedEventStringAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventStringAttributeCheck';
  check: GameStateCalModuleEventStringAttributeCheck;
  initialValue: Scalars['Int'];
  targetValue: Scalars['Int'];
};

export type GameStateCalModuleRepeatedEventTypeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventTypeCheck';
  check: GameStateCalModuleEventTypeCheck;
  initialValue: Scalars['Int'];
  targetValue: Scalars['Int'];
};

export type GameStateCalModuleTimeoutCheck = {
  __typename?: 'GameStateCALModuleTimeoutCheck';
  duration: Scalars['Int'];
  lastStateChangeTimestamp: Scalars['Int'];
  lastTimestamp: Scalars['Int'];
  timeLeft: Scalars['Int'];
};

export type GameStateCalModuleUnaryExpression = {
  __typename?: 'GameStateCALModuleUnaryExpression';
  expression: GameStateCalModuleExpression;
  op: GameStateCalModuleUnaryOp;
};

export enum GameStateCalModuleUnaryOp {
  UnaryOpNot = 'UNARY_OP_NOT',
  UnaryOpUnspecified = 'UNARY_OP_UNSPECIFIED'
}

export type GameStateCalModuleWhen = {
  __typename?: 'GameStateCALModuleWhen';
  attribute: Scalars['String'];
  cases: Array<GameStateCalModuleWhenCase>;
};

export type GameStateCalModuleWhenCase = {
  __typename?: 'GameStateCALModuleWhenCase';
  expression: GameStateCalModuleExpression;
  value?: Maybe<GameStateCalModuleWhenCaseValueUnion>;
};

export type GameStateCalModuleWhenCaseDefault = {
  __typename?: 'GameStateCALModuleWhenCaseDefault';
  emptyTypeWorkaround: Scalars['Boolean'];
};

export type GameStateCalModuleWhenCaseValueUnion = BooleanType | GameStateCalModuleWhenCaseDefault | IntType | StringType;

export type GameStateCardDealingState = {
  __typename?: 'GameStateCardDealingState';
  cardAvailability: Array<GameStateCardDealingStateCardAvailabilityEntry>;
  cardDealingModules: Array<GameStateCardDealingStateCardDealingModulesEntry>;
  cards: Array<GameStateCardDealingStateCardsEntry>;
};

export type GameStateCardDealingStateCalModulesList = {
  __typename?: 'GameStateCardDealingStateCALModulesList';
  modules: Array<GameStateCalModule>;
};

export type GameStateCardDealingStateCardAvailabilityEntry = {
  __typename?: 'GameStateCardDealingStateCardAvailabilityEntry';
  key: Scalars['String'];
  value: Scalars['Boolean'];
};

export type GameStateCardDealingStateCardDealingModulesEntry = {
  __typename?: 'GameStateCardDealingStateCardDealingModulesEntry';
  key: Scalars['String'];
  value: GameStateCardDealingStateCalModulesList;
};

export type GameStateCardDealingStateCardsEntry = {
  __typename?: 'GameStateCardDealingStateCardsEntry';
  key: Scalars['String'];
  value: GameLogicCard;
};

export type GameStateCardState = {
  __typename?: 'GameStateCardState';
  failureModules: Array<GameStateCalModule>;
  successModules: Array<GameStateCalModule>;
};

export type GameStateChallengeState = {
  __typename?: 'GameStateChallengeState';
  challengeId: Scalars['ID'];
  challengeState: GameLogicChallengeState;
  failureModule: GameStateCalModule;
  pickRate: Scalars['Float'];
  successModule: GameStateCalModule;
  targetValues: Array<GameStateChallengeStateTargetValuesEntry>;
};

export type GameStateChallengeStateTargetValuesEntry = {
  __typename?: 'GameStateChallengeStateTargetValuesEntry';
  key: Scalars['String'];
  value: Scalars['Int'];
};

export type GameStateClientSession = {
  __typename?: 'GameStateClientSession';
  mailbox: Scalars['String'];
  timestamp: Scalars['Int'];
  token: Scalars['String'];
};

export type GameStateClientSessionList = {
  __typename?: 'GameStateClientSessionList';
  sessions: Array<GameStateClientSession>;
};

export enum GameStateComparisonOperator {
  ComparisonOperatorEqual = 'COMPARISON_OPERATOR_EQUAL',
  ComparisonOperatorExists = 'COMPARISON_OPERATOR_EXISTS',
  ComparisonOperatorGreater = 'COMPARISON_OPERATOR_GREATER',
  ComparisonOperatorGreaterOrEqual = 'COMPARISON_OPERATOR_GREATER_OR_EQUAL',
  ComparisonOperatorIn = 'COMPARISON_OPERATOR_IN',
  ComparisonOperatorLess = 'COMPARISON_OPERATOR_LESS',
  ComparisonOperatorLessOrEqual = 'COMPARISON_OPERATOR_LESS_OR_EQUAL',
  ComparisonOperatorNotEqual = 'COMPARISON_OPERATOR_NOT_EQUAL',
  ComparisonOperatorNotExists = 'COMPARISON_OPERATOR_NOT_EXISTS',
  ComparisonOperatorNotIn = 'COMPARISON_OPERATOR_NOT_IN',
  ComparisonOperatorUnspecified = 'COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateContextualTeamActionState = {
  __typename?: 'GameStateContextualTeamActionState';
  deadlineMs: Scalars['Int'];
  participants: Array<GameStateContextualTeamActionStateParticipantsEntry>;
  status: GameLogicContextualTeamActionStatus;
  type: GameLogicContextualTeamActionType;
};

export type GameStateContextualTeamActionStateParticipantsEntry = {
  __typename?: 'GameStateContextualTeamActionStateParticipantsEntry';
  key: Scalars['String'];
  value: Scalars['Boolean'];
};

export type GameStateGameConfig = {
  __typename?: 'GameStateGameConfig';
  boosters: Array<GameStateGameConfigBoostersEntry>;
  challengeConfig: GameStateGameConfigChallengeConfig;
  featureFlags: Array<GameStateGameConfigFeatureFlagsEntry>;
  highScoringCardConfig: GameStateGameConfigHighScoringCardConfig;
  inactivityTimeouts: ConfigMetagameConfigInactivityTimeouts;
  matchConfiguration: GameLogicMatchConfiguration;
  uiTimings: ConfigMetagameConfigUiTimings;
};

export type GameStateGameConfigBoostersEntry = {
  __typename?: 'GameStateGameConfigBoostersEntry';
  key: Scalars['Int'];
  value: GameLogicBooster;
};

export type GameStateGameConfigChallengeConfig = {
  __typename?: 'GameStateGameConfigChallengeConfig';
  availableChallengesCount: Scalars['Int'];
  challenges: Array<GameStateGameConfigChallengeConfigChallengesEntry>;
  isEnabled: Scalars['Boolean'];
};

export type GameStateGameConfigChallengeConfigChallengesEntry = {
  __typename?: 'GameStateGameConfigChallengeConfigChallengesEntry';
  key: Scalars['String'];
  value: GameLogicChallenge;
};

export type GameStateGameConfigFeatureFlagsEntry = {
  __typename?: 'GameStateGameConfigFeatureFlagsEntry';
  key: Scalars['String'];
  value: Scalars['String'];
};

export type GameStateGameConfigHighScoringCardConfig = {
  __typename?: 'GameStateGameConfigHighScoringCardConfig';
  highScoringCardConfigs: Array<GameCardHighScoringCardConfig>;
  highScoringCardTimings: Array<GameCardHighScoringCardTimings>;
};

export type GameStateGroupRunnerState = {
  __typename?: 'GameStateGroupRunnerState';
  gameConfig: GameStateGameConfig;
  groupStartTime: Scalars['Int'];
  groupState: GameStateGroupState;
  matchEndTime: Scalars['Int'];
  matchPauseStartTime: Scalars['Int'];
  matchPauseTimeTotal: Scalars['Int'];
  matchTimeTrackerState: GameStateMatchTimeTrackerState;
  players: Array<GameStateGroupRunnerStatePlayersEntry>;
  randomState: GameStateRandomState;
  sessionTrackerState: GameStateSessionTrackerState;
  started: Scalars['Boolean'];
  stepTimestamp: Scalars['Int'];
  streamTrackerState: GameStateStreamTrackerState;
  timeOffset: Scalars['Int'];
  timer: GameStateTimerState;
};

export type GameStateGroupRunnerStatePlayersEntry = {
  __typename?: 'GameStateGroupRunnerStatePlayersEntry';
  key: Scalars['String'];
  value: Scalars['Boolean'];
};

export type GameStateGroupState = {
  __typename?: 'GameStateGroupState';
  activeChallenges: Array<GameStateChallengeState>;
  addedPlayers: Array<GameStateGroupStateAddedPlayersEntry>;
  boosterUsages: Array<GameStateGroupStateBoosterUsage>;
  contextualTeamActionState: GameStateContextualTeamActionState;
  group: GameLogicGroup;
  matchBonusActivationRule: GameStateCalModule;
  players: Array<GameStateGroupStatePlayersEntry>;
  removedPlayers: Array<GameStatePlayerState>;
  streamInfo: StreamInfoStreamInfo;
  timeTrackerState: GameStateTimeTrackerState;
};

export type GameStateGroupStateAddedPlayersEntry = {
  __typename?: 'GameStateGroupStateAddedPlayersEntry';
  key: Scalars['String'];
  value: GameStatePlayerState;
};

export type GameStateGroupStateBoosterUsage = {
  __typename?: 'GameStateGroupStateBoosterUsage';
  boosterState: GameStateBoosterState;
  sourcePlayerId: Scalars['ID'];
  targetPlayerId: Scalars['ID'];
};

export type GameStateGroupStatePlayersEntry = {
  __typename?: 'GameStateGroupStatePlayersEntry';
  key: Scalars['String'];
  value: GameStatePlayerState;
};

export type GameStateHighScoringCardState = {
  __typename?: 'GameStateHighScoringCardState';
  activeGroups: Array<GameStateHighScoringCardStateActiveGroupsEntry>;
  card: GameLogicHighScoringCard;
  deadline: Scalars['Int'];
  groupId: Scalars['ID'];
  userId: Scalars['ID'];
};

export type GameStateHighScoringCardStateActiveGroupsEntry = {
  __typename?: 'GameStateHighScoringCardStateActiveGroupsEntry';
  key: Scalars['String'];
  value: Scalars['Boolean'];
};

export enum GameStateIntComparisonOperator {
  IntComparisonOperatorEqual = 'INT_COMPARISON_OPERATOR_EQUAL',
  IntComparisonOperatorGreater = 'INT_COMPARISON_OPERATOR_GREATER',
  IntComparisonOperatorGreaterOrEqual = 'INT_COMPARISON_OPERATOR_GREATER_OR_EQUAL',
  IntComparisonOperatorLess = 'INT_COMPARISON_OPERATOR_LESS',
  IntComparisonOperatorLessOrEqual = 'INT_COMPARISON_OPERATOR_LESS_OR_EQUAL',
  IntComparisonOperatorNotEqual = 'INT_COMPARISON_OPERATOR_NOT_EQUAL',
  IntComparisonOperatorUnspecified = 'INT_COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateMatchTimeTrackerState = {
  __typename?: 'GameStateMatchTimeTrackerState';
  time: Scalars['Int'];
  timeOffset: Scalars['Int'];
  timer: GameStateTimerState;
};

export type GameStatePlayerState = {
  __typename?: 'GameStatePlayerState';
  cardDealingState: GameStateCardDealingState;
  cardState: GameStateCardState;
  debugEvents: Scalars['Boolean'];
  groupId: Scalars['ID'];
  lastHeldBoosterId: Scalars['Int'];
  player: GameLogicPlayer;
  streamId: Scalars['ID'];
};

export type GameStateRandomState = {
  __typename?: 'GameStateRandomState';
  seed: Scalars['Int'];
};

export type GameStateSessionTrackerState = {
  __typename?: 'GameStateSessionTrackerState';
  playerSessions: Array<GameStateSessionTrackerStatePlayerSessionsEntry>;
  spectatorSessions: Array<GameStateSessionTrackerStateSpectatorSessionsEntry>;
};

export type GameStateSessionTrackerStatePlayerSessionsEntry = {
  __typename?: 'GameStateSessionTrackerStatePlayerSessionsEntry';
  key: Scalars['String'];
  value: GameStateClientSessionList;
};

export type GameStateSessionTrackerStateSpectatorSessionsEntry = {
  __typename?: 'GameStateSessionTrackerStateSpectatorSessionsEntry';
  key: Scalars['String'];
  value: GameStateClientSessionList;
};

export type GameStateStreamGroupsTrackerState = {
  __typename?: 'GameStateStreamGroupsTrackerState';
  bestCard: GameLogicCardDetails;
  bestGroup: GameLogicGroupDetails;
  bestPlayer: GameLogicPlayerDetails;
};

export type GameStateStreamState = {
  __typename?: 'GameStateStreamState';
  groups: Array<Scalars['String']>;
  streamGroupsTracker: GameStateStreamGroupsTrackerState;
  streamInfo: StreamInfoStreamInfo;
  streamTracker: GameStateStreamTrackerState;
};

export type GameStateStreamTrackerState = {
  __typename?: 'GameStateStreamTrackerState';
  globalAttributes: GameStateAttributesState;
  globalAttributesHash: Scalars['Int'];
  globalsChanged: Scalars['Boolean'];
  matchEndTime: Scalars['Int'];
  matchPauseStartTime: Scalars['Int'];
  matchPauseTimeTotal: Scalars['Int'];
  matchStartTime: Scalars['Int'];
  matchStateChanged: Scalars['Boolean'];
  previousMatchState: GameLogicStreamStateMatchState;
  roundPhaseChanged: Scalars['Boolean'];
  streamState: GameLogicStreamState;
};

export enum GameStateStringComparisonOperator {
  StringComparisonOperatorEqual = 'STRING_COMPARISON_OPERATOR_EQUAL',
  StringComparisonOperatorIn = 'STRING_COMPARISON_OPERATOR_IN',
  StringComparisonOperatorNotEqual = 'STRING_COMPARISON_OPERATOR_NOT_EQUAL',
  StringComparisonOperatorNotIn = 'STRING_COMPARISON_OPERATOR_NOT_IN',
  StringComparisonOperatorUnspecified = 'STRING_COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateTimeTrackerState = {
  __typename?: 'GameStateTimeTrackerState';
  entries: Array<GameStateTimeTrackerStateEntriesEntry>;
  matchActive: Scalars['Boolean'];
};

export type GameStateTimeTrackerStateEntriesEntry = {
  __typename?: 'GameStateTimeTrackerStateEntriesEntry';
  key: Scalars['String'];
  value: GameStateTimeTrackerStateTimeTrackerEntry;
};

export type GameStateTimeTrackerStateTimeTrackerEntry = {
  __typename?: 'GameStateTimeTrackerStateTimeTrackerEntry';
  disconnectedTimestamp: Scalars['Int'];
  idle: Scalars['Boolean'];
  idleTimestamp: Scalars['Int'];
  lastOnlineTimestamp: Scalars['Int'];
  online: Scalars['Boolean'];
  totalIdleTime: Scalars['Int'];
  totalTime: Scalars['Int'];
};

export type GameStateTimerState = {
  __typename?: 'GameStateTimerState';
  activeTimeout: GameStateTimerStateTimeout;
  /** @deprecated field is deprecated */
  activeTimerDeadline: Scalars['Int'];
  /** @deprecated field is deprecated */
  timeouts: Array<Scalars['Int']>;
  timeoutsWithMetadata: Array<GameStateTimerStateTimeout>;
};

export type GameStateTimerStateMetadata = {
  __typename?: 'GameStateTimerStateMetadata';
  source: Scalars['String'];
};

export type GameStateTimerStateTimeout = {
  __typename?: 'GameStateTimerStateTimeout';
  expirationTimestamp: Scalars['Int'];
  metadata: GameStateTimerStateMetadata;
};

export type GameUserProgression = {
  __typename?: 'GameUserProgression';
  experiencePoints: Scalars['Int'];
  level: Scalars['Int'];
  userId: Scalars['ID'];
};

export type GoalCardBatchGetGoalCardsResponse = {
  __typename?: 'GoalCardBatchGetGoalCardsResponse';
  goalCards: Array<GoalCardGoalCard>;
};

export type GoalCardGetSlotOptionsResponse = {
  __typename?: 'GoalCardGetSlotOptionsResponse';
  cardOptions: Array<GoalCardGoalCard>;
};

export type GoalCardGoalCard = {
  __typename?: 'GoalCardGoalCard';
  cardGoalGroup: Scalars['String'];
  /** counter_config_ids defines which counters the goal card is tracking */
  counterConfigIds: Array<Scalars['String']>;
  description: Scalars['String'];
  disabled: Scalars['Boolean'];
  game?: Maybe<GameGame>;
  gameId: Scalars['ID'];
  id: Scalars['ID'];
  rarity: RarityRarity;
  requiredItemIds: Array<Scalars['String']>;
  requiresTeam: Scalars['Boolean'];
  reward: RewardRewardType;
  /**
   * target is the target value for the counter where an award is awarded to
   *  the user
   */
  target: Scalars['Float'];
  targetType: GoalCardGoalCardTargetType;
};

export type GoalCardGoalCardSlot = {
  __typename?: 'GoalCardGoalCardSlot';
  cardOptions?: Maybe<Array<GoalCardGoalCard>>;
  goalCard?: Maybe<GoalCardGoalCard>;
  goalCardId: Scalars['ID'];
  id: Scalars['ID'];
  progress?: Maybe<GoalCardGoalCardSlotProgress>;
  resetTime?: Maybe<Scalars['Timestamp']>;
  reward?: Maybe<RewardReward>;
};

export type GoalCardGoalCardSlotProgress = {
  __typename?: 'GoalCardGoalCardSlotProgress';
  completed: Scalars['Boolean'];
  percentage: Scalars['Float'];
  value: Scalars['Float'];
};

export enum GoalCardGoalCardTargetType {
  TargetTypeSingleUpdate = 'TARGET_TYPE_SINGLE_UPDATE',
  TargetTypeTotal = 'TARGET_TYPE_TOTAL',
  TargetTypeUnspecified = 'TARGET_TYPE_UNSPECIFIED',
  TargetTypeUpdateCount = 'TARGET_TYPE_UPDATE_COUNT'
}

export type GoalCardListGoalCardSlotsResponse = {
  __typename?: 'GoalCardListGoalCardSlotsResponse';
  slots: Array<GoalCardGoalCardSlot>;
};

export type GoalCardReshuffleSlotResponse = {
  __typename?: 'GoalCardReshuffleSlotResponse';
  cardOptions: Array<GoalCardGoalCard>;
};

export type GoalCardSetGoalCardSlotResponse = {
  __typename?: 'GoalCardSetGoalCardSlotResponse';
  emptyTypeWorkaround: Scalars['Boolean'];
};

/**
 * A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *
 *      service Foo {
 *        rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *      }
 *
 *  The JSON representation for `Empty` is empty JSON object `{}`.
 */
export type GoogleProtobufEmpty = {
  __typename?: 'GoogleProtobufEmpty';
  emptyTypeWorkaround: Scalars['Boolean'];
};

/**
 * `FieldMask` represents a set of symbolic field paths, for example:
 *
 *      paths: "f.a"
 *      paths: "f.b.d"
 *
 *  Here `f` represents a field in some root message, `a` and `b`
 *  fields in the message found in `f`, and `d` a field found in the
 *  message in `f.b`.
 *
 *  Field masks are used to specify a subset of fields that should be
 *  returned by a get operation or modified by an update operation.
 *  Field masks also have a custom JSON encoding (see below).
 *
 *  # Field Masks in Projections
 *
 *  When used in the context of a projection, a response message or
 *  sub-message is filtered by the API to only contain those fields as
 *  specified in the mask. For example, if the mask in the previous
 *  example is applied to a response message as follows:
 *
 *      f {
 *        a : 22
 *        b {
 *          d : 1
 *          x : 2
 *        }
 *        y : 13
 *      }
 *      z: 8
 *
 *  The result will not contain specific values for fields x,y and z
 *  (their value will be set to the default, and omitted in proto text
 *  output):
 *
 *
 *      f {
 *        a : 22
 *        b {
 *          d : 1
 *        }
 *      }
 *
 *  A repeated field is not allowed except at the last position of a
 *  paths string.
 *
 *  If a FieldMask object is not present in a get operation, the
 *  operation applies to all fields (as if a FieldMask of all fields
 *  had been specified).
 *
 *  Note that a field mask does not necessarily apply to the
 *  top-level response message. In case of a REST get operation, the
 *  field mask applies directly to the response, but in case of a REST
 *  list operation, the mask instead applies to each individual message
 *  in the returned resource list. In case of a REST custom method,
 *  other definitions may be used. Where the mask applies will be
 *  clearly documented together with its declaration in the API.  In
 *  any case, the effect on the returned resource/resources is required
 *  behavior for APIs.
 *
 *  # Field Masks in Update Operations
 *
 *  A field mask in update operations specifies which fields of the
 *  targeted resource are going to be updated. The API is required
 *  to only change the values of the fields as specified in the mask
 *  and leave the others untouched. If a resource is passed in to
 *  describe the updated values, the API ignores the values of all
 *  fields not covered by the mask.
 *
 *  If a repeated field is specified for an update operation, new values will
 *  be appended to the existing repeated field in the target resource. Note that
 *  a repeated field is only allowed in the last position of a `paths` string.
 *
 *  If a sub-message is specified in the last position of the field mask for an
 *  update operation, then new value will be merged into the existing sub-message
 *  in the target resource.
 *
 *  For example, given the target message:
 *
 *      f {
 *        b {
 *          d: 1
 *          x: 2
 *        }
 *        c: [1]
 *      }
 *
 *  And an update message:
 *
 *      f {
 *        b {
 *          d: 10
 *        }
 *        c: [2]
 *      }
 *
 *  then if the field mask is:
 *
 *   paths: ["f.b", "f.c"]
 *
 *  then the result will be:
 *
 *      f {
 *        b {
 *          d: 10
 *          x: 2
 *        }
 *        c: [1, 2]
 *      }
 *
 *  An implementation may provide options to override this default behavior for
 *  repeated and message fields.
 *
 *  In order to reset a field's value to the default, the field must
 *  be in the mask and set to the default value in the provided resource.
 *  Hence, in order to reset all fields of a resource, provide a default
 *  instance of the resource and set all fields in the mask, or do
 *  not provide a mask as described below.
 *
 *  If a field mask is not present on update, the operation applies to
 *  all fields (as if a field mask of all fields has been specified).
 *  Note that in the presence of schema evolution, this may mean that
 *  fields the client does not know and has therefore not filled into
 *  the request will be reset to their default. If this is unwanted
 *  behavior, a specific service may require a client to always specify
 *  a field mask, producing an error if not.
 *
 *  As with get operations, the location of the resource which
 *  describes the updated values in the request message depends on the
 *  operation kind. In any case, the effect of the field mask is
 *  required to be honored by the API.
 *
 *  ## Considerations for HTTP REST
 *
 *  The HTTP kind of an update operation which uses a field mask must
 *  be set to PATCH instead of PUT in order to satisfy HTTP semantics
 *  (PUT must only be used for full updates).
 *
 *  # JSON Encoding of Field Masks
 *
 *  In JSON, a field mask is encoded as a single string where paths are
 *  separated by a comma. Fields name in each path are converted
 *  to/from lower-camel naming conventions.
 *
 *  As an example, consider the following message declarations:
 *
 *      message Profile {
 *        User user = 1;
 *        Photo photo = 2;
 *      }
 *      message User {
 *        string display_name = 1;
 *        string address = 2;
 *      }
 *
 *  In proto a field mask for `Profile` may look as such:
 *
 *      mask {
 *        paths: "user.display_name"
 *        paths: "photo"
 *      }
 *
 *  In JSON, the same mask is represented as below:
 *
 *      {
 *        mask: "user.displayName,photo"
 *      }
 *
 *  # Field Masks and Oneof Fields
 *
 *  Field masks treat fields in oneofs just as regular fields. Consider the
 *  following message:
 *
 *      message SampleMessage {
 *        oneof test_oneof {
 *          string name = 4;
 *          SubMessage sub_message = 9;
 *        }
 *      }
 *
 *  The field mask can be:
 *
 *      mask {
 *        paths: "name"
 *      }
 *
 *  Or:
 *
 *      mask {
 *        paths: "sub_message"
 *      }
 *
 *  Note that oneof type names ("test_oneof" in this case) cannot be used in
 *  paths.
 *
 *  ## Field Mask Verification
 *
 *  The implementation of any API method which has a FieldMask type field in the
 *  request should verify the included field paths, and return an
 *  `INVALID_ARGUMENT` error if any path is unmappable.
 */
export type GoogleProtobufFieldMaskInput = {
  /** The set of field mask paths. */
  paths?: InputMaybe<Array<Scalars['String']>>;
};

export type IntType = {
  __typename?: 'IntType';
  /** The wrapped value of type Int */
  value: Scalars['Int'];
};

export type InventoryAddEntitlementsResponse = {
  __typename?: 'InventoryAddEntitlementsResponse';
  items: Array<InventoryInventoryItem>;
};

export type InventoryConsumeItemResponse = {
  __typename?: 'InventoryConsumeItemResponse';
  items: Array<InventoryInventoryItem>;
};

export type InventoryInventoryEvent = {
  __typename?: 'InventoryInventoryEvent';
  event?: Maybe<InventoryInventoryEventEventUnion>;
  id: Scalars['ID'];
  reason: ReasonReason;
  userId: Scalars['ID'];
};

export type InventoryInventoryEventEventUnion = InventoryItemConsumption | InventoryItemEntitlement;

export type InventoryInventoryItem = {
  __typename?: 'InventoryInventoryItem';
  item: ItemItem;
  itemCount: Scalars['Int'];
  itemId: Scalars['ID'];
};

export type InventoryInventoryUpdateEvent = {
  __typename?: 'InventoryInventoryUpdateEvent';
  events: Array<InventoryInventoryEvent>;
};

export type InventoryItemConsumption = {
  __typename?: 'InventoryItemConsumption';
  item: ItemItem;
  itemCount: Scalars['Int'];
  itemId: Scalars['ID'];
};

export type InventoryItemConsumptionInput = {
  itemCount?: InputMaybe<Scalars['Int']>;
  itemId?: InputMaybe<Scalars['ID']>;
};

export type InventoryItemEntitlement = {
  __typename?: 'InventoryItemEntitlement';
  item: ItemItem;
  itemCount: Scalars['Int'];
  itemId: Scalars['ID'];
};

export type InventoryItemEntitlementInput = {
  itemCount?: InputMaybe<Scalars['Int']>;
  itemId?: InputMaybe<Scalars['ID']>;
};

export type InventoryListUserInventoryRequestFilterAttributeFilterInput = {
  key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type InventoryListUserInventoryRequestFilterInput = {
  /** attribute optional attribute filter */
  attribute?: InputMaybe<InventoryListUserInventoryRequestFilterAttributeFilterInput>;
  /** game_id optional game filter */
  gameId?: InputMaybe<Scalars['ID']>;
  /** item_type optional item type filter */
  itemType?: InputMaybe<ItemItemType>;
  /** season_id optional season filter */
  seasonId?: InputMaybe<Scalars['ID']>;
};

export type InventoryListUserInventoryResponse = {
  __typename?: 'InventoryListUserInventoryResponse';
  items: Array<InventoryInventoryItem>;
  pageInfo: ApiPageInfo;
};

export type InvitationCreateInvitationCodesResponse = {
  __typename?: 'InvitationCreateInvitationCodesResponse';
  codes: Array<InvitationInvitationCode>;
};

export type InvitationInvitationCode = {
  __typename?: 'InvitationInvitationCode';
  code: Scalars['String'];
  createdAt: Scalars['Timestamp'];
  ownerId: Scalars['ID'];
  usedAt?: Maybe<Scalars['Timestamp']>;
  usedBy?: Maybe<ProfileProfile>;
  usedById?: Maybe<Scalars['ID']>;
};

export type InvitationInvitationCodeUpdateEvent = {
  __typename?: 'InvitationInvitationCodeUpdateEvent';
  codes: Array<InvitationInvitationCode>;
  updateType: InvitationInvitationCodeUpdateEventUpdateType;
  updatedAt: Scalars['Timestamp'];
};

export enum InvitationInvitationCodeUpdateEventUpdateType {
  UpdateTypeCreated = 'UPDATE_TYPE_CREATED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUsed = 'UPDATE_TYPE_USED'
}

export type InvitationListInvitationCodesResponse = {
  __typename?: 'InvitationListInvitationCodesResponse';
  codes: Array<InvitationInvitationCode>;
};

export type ItemBatchExpandItemsResponse = {
  __typename?: 'ItemBatchExpandItemsResponse';
  items: Array<ItemItem>;
};

export type ItemBatchGetItemsResponse = {
  __typename?: 'ItemBatchGetItemsResponse';
  items: Array<ItemItem>;
};

export type ItemExpandItemResponse = {
  __typename?: 'ItemExpandItemResponse';
  items: Array<ItemItem>;
};

export type ItemGetItemResponse = {
  __typename?: 'ItemGetItemResponse';
  item: ItemItem;
};

export type ItemItem = {
  __typename?: 'ItemItem';
  attributes: AttributeAttributeMap;
  bootstraps?: Maybe<Array<ItemItemBootstrap>>;
  channel?: Maybe<ChannelChannel>;
  channelId: Scalars['ID'];
  children?: Maybe<Array<ItemItem>>;
  consumable: Scalars['Boolean'];
  details?: Maybe<ItemItemDetailsUnion>;
  disabled: Scalars['Boolean'];
  game?: Maybe<GameGame>;
  gameId: Scalars['ID'];
  id: Scalars['ID'];
  inventoryItem: InventoryInventoryItem;
  name: Scalars['String'];
  /** if the parent item is owned, this item is owned as well */
  parentItemId: Scalars['ID'];
  season?: Maybe<GameSeason>;
  seasonId: Scalars['ID'];
  type: ItemItemType;
  /** unlock_item_id what if any item is required to unlock this item for bundles and other consumption */
  unlockItemId: Scalars['ID'];
  updatedAt: Scalars['Timestamp'];
};


export type ItemItemInventoryItemArgs = {
  user_id: Scalars['ID'];
};

export type ItemItemBootstrap = {
  __typename?: 'ItemItemBootstrap';
  itemCount: Scalars['Int'];
  itemId: Scalars['ID'];
  revision: Scalars['String'];
};

export type ItemItemBootstrapInput = {
  itemCount?: InputMaybe<Scalars['Int']>;
  itemId?: InputMaybe<Scalars['ID']>;
  revision?: InputMaybe<Scalars['String']>;
};

export type ItemItemCount = {
  __typename?: 'ItemItemCount';
  count: Scalars['Int'];
  type: ItemItemType;
};

export type ItemItemDetailsUnion = AvatarAnimation | AvatarAvatarPart | EmojiEmoji | GameLogicCard | GameLogicStreamerCard;

export type ItemItemStat = {
  __typename?: 'ItemItemStat';
  counts: Array<ItemItemCount>;
  gameId: Scalars['ID'];
};

export type ItemItemTotalCount = {
  __typename?: 'ItemItemTotalCount';
  disabled: Scalars['Int'];
  total: Scalars['Int'];
};

export enum ItemItemType {
  TypeAvatarItem = 'TYPE_AVATAR_ITEM',
  TypeBootstrap = 'TYPE_BOOTSTRAP',
  TypeDailyGoalCardSlot = 'TYPE_DAILY_GOAL_CARD_SLOT',
  TypeEmoji = 'TYPE_EMOJI',
  TypeEmote = 'TYPE_EMOTE',
  TypeGameCard = 'TYPE_GAME_CARD',
  TypeStreamerCard = 'TYPE_STREAMER_CARD',
  TypeSubscription = 'TYPE_SUBSCRIPTION',
  TypeUnlock = 'TYPE_UNLOCK',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type ItemListItemsRequestFilterAttributeInput = {
  name?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type ItemListItemsRequestFilterInput = {
  attribute?: InputMaybe<ItemListItemsRequestFilterAttributeInput>;
  channelId?: InputMaybe<Scalars['ID']>;
  gameId?: InputMaybe<Scalars['ID']>;
  itemType?: InputMaybe<ItemItemType>;
  parentId?: InputMaybe<Scalars['ID']>;
  seasonId?: InputMaybe<Scalars['ID']>;
};

export type ItemListItemsResponse = {
  __typename?: 'ItemListItemsResponse';
  count?: Maybe<ItemItemTotalCount>;
  items: Array<ItemItem>;
  pageInfo: ApiPageInfo;
};

export type MatchCardCount = {
  __typename?: 'MatchCardCount';
  card: GameLogicCard;
  cardId: Scalars['ID'];
  count: Scalars['Int'];
};

export type MatchChallengeUpdate = {
  __typename?: 'MatchChallengeUpdate';
  content?: Maybe<MatchChallengeUpdateContentUnion>;
};

export type MatchChallengeUpdateContentUnion = MatchChallengeUpdateReset | MatchChallengeUpdateStatusUpdate;

export type MatchChallengeUpdateReset = {
  __typename?: 'MatchChallengeUpdateReset';
  emptyTypeWorkaround: Scalars['Boolean'];
};

export type MatchChallengeUpdateStatusUpdate = {
  __typename?: 'MatchChallengeUpdateStatusUpdate';
  challenges: Array<GameLogicChallengeStatus>;
};

export type MatchGetGroupChatIdResponse = {
  __typename?: 'MatchGetGroupChatIDResponse';
  chatId: Scalars['ID'];
};

export type MatchGetGroupStateResponse = {
  __typename?: 'MatchGetGroupStateResponse';
  runnerState: GameStateGroupRunnerState;
  /** @deprecated field is deprecated */
  state: GameStateGroupState;
};

export type MatchGetMatchStateResponse = {
  __typename?: 'MatchGetMatchStateResponse';
  matchState: GameLogicStreamStateMatchState;
};

export type MatchGetStreamStateResponse = {
  __typename?: 'MatchGetStreamStateResponse';
  gameConfig: GameStateGameConfig;
  groups: Array<Scalars['String']>;
  highScoringCard: GameStateHighScoringCardState;
  started: Scalars['Boolean'];
  streamGroupsTracker: GameStateStreamGroupsTrackerState;
  streamInfo: StreamInfoStreamInfo;
  streamTracker: GameStateStreamTrackerState;
};

export type MatchGetTopActiveCardsResponse = {
  __typename?: 'MatchGetTopActiveCardsResponse';
  topCards: Array<MatchCardCount>;
};

export type MatchStreamSpectatorChangeGroupEvent = {
  __typename?: 'MatchStreamSpectatorChangeGroupEvent';
  groupId: Scalars['ID'];
};

export type MatchStreamSpectatorCoordinationEvent = {
  __typename?: 'MatchStreamSpectatorCoordinationEvent';
  event?: Maybe<MatchStreamSpectatorCoordinationEventEventUnion>;
};

export type MatchStreamSpectatorCoordinationEventEventUnion = MatchStreamSpectatorChangeGroupEvent;

export type MatchTopCardsUpdate = {
  __typename?: 'MatchTopCardsUpdate';
  content?: Maybe<MatchTopCardsUpdateContentUnion>;
};

export type MatchTopCardsUpdateCardCountUpdate = {
  __typename?: 'MatchTopCardsUpdateCardCountUpdate';
  cards: Array<MatchCardCount>;
};

export type MatchTopCardsUpdateContentUnion = MatchTopCardsUpdateCardCountUpdate | MatchTopCardsUpdateReset;

export type MatchTopCardsUpdateReset = {
  __typename?: 'MatchTopCardsUpdateReset';
  emptyTypeWorkaround: Scalars['Boolean'];
};

export type MediaBatchGetMediaUrlResponse = {
  __typename?: 'MediaBatchGetMediaURLResponse';
  urls: Array<Scalars['String']>;
};

export type MediaMediaOptionsInput = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};

export type MlControllerGetHudScaleResponse = {
  __typename?: 'MlControllerGetHUDScaleResponse';
  estimatedScale: Scalars['Int'];
  isScaleSufficient: Scalars['Boolean'];
  mlDisabled: Scalars['Boolean'];
  suggestedMinimumScale: Scalars['Int'];
};

export enum ModerationAppealStatus {
  AppealStatusAccepted = 'APPEAL_STATUS_ACCEPTED',
  AppealStatusDeclined = 'APPEAL_STATUS_DECLINED',
  AppealStatusPending = 'APPEAL_STATUS_PENDING',
  AppealStatusUnspecified = 'APPEAL_STATUS_UNSPECIFIED'
}

export enum ModerationBanStatus {
  BanStatusActive = 'BAN_STATUS_ACTIVE',
  BanStatusInactive = 'BAN_STATUS_INACTIVE',
  BanStatusUnspecified = 'BAN_STATUS_UNSPECIFIED'
}

export type ModerationListPlatformBanAppealsResponse = {
  __typename?: 'ModerationListPlatformBanAppealsResponse';
  appeals: Array<ModerationPlatformBanAppeal>;
  pageInfo: ApiPageInfo;
};

export type ModerationPlatformBan = {
  __typename?: 'ModerationPlatformBan';
  appeal?: Maybe<ModerationPlatformBanAppeal>;
  appealApproved: Scalars['Boolean'];
  banId: Scalars['ID'];
  bannedAt: Scalars['Timestamp'];
  description: Scalars['String'];
  expiresAt?: Maybe<Scalars['Timestamp']>;
  moderator: ProfileProfile;
  moderatorId: Scalars['ID'];
  status: ModerationBanStatus;
  unbannedAt?: Maybe<Scalars['Timestamp']>;
  unbannedBy: Scalars['String'];
  userId: Scalars['ID'];
  violation: ModerationViolation;
};

export type ModerationPlatformBanAppeal = {
  __typename?: 'ModerationPlatformBanAppeal';
  appealText: Scalars['String'];
  ban: ModerationPlatformBan;
  banId: Scalars['ID'];
  closedAt?: Maybe<Scalars['Timestamp']>;
  createdAt: Scalars['Timestamp'];
  reviewer?: Maybe<ProfileProfile>;
  reviewerComment: Scalars['String'];
  reviewerId: Scalars['ID'];
  status: ModerationAppealStatus;
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type ModerationPlatformUserBannedNotification = {
  __typename?: 'ModerationPlatformUserBannedNotification';
  bannedAt: Scalars['Timestamp'];
  description: Scalars['String'];
  expiresAt?: Maybe<Scalars['Timestamp']>;
  userId: Scalars['ID'];
  violation: ModerationViolation;
};

export enum ModerationViolation {
  ViolationChildSafety = 'VIOLATION_CHILD_SAFETY',
  ViolationCircumventionEvasion = 'VIOLATION_CIRCUMVENTION_EVASION',
  ViolationExtremism = 'VIOLATION_EXTREMISM',
  ViolationGraphicRealWorldMedia = 'VIOLATION_GRAPHIC_REAL_WORLD_MEDIA',
  ViolationHarassmentTargetedAbuse = 'VIOLATION_HARASSMENT_TARGETED_ABUSE',
  ViolationHatefulBehavior = 'VIOLATION_HATEFUL_BEHAVIOR',
  ViolationIllegalHarmfulAndRestrictedActivity = 'VIOLATION_ILLEGAL_HARMFUL_AND_RESTRICTED_ACTIVITY',
  ViolationOffPlatformBehavior = 'VIOLATION_OFF_PLATFORM_BEHAVIOR',
  ViolationOther = 'VIOLATION_OTHER',
  ViolationPlatformManipulation = 'VIOLATION_PLATFORM_MANIPULATION',
  ViolationRepeatedCopyrightInfringement = 'VIOLATION_REPEATED_COPYRIGHT_INFRINGEMENT',
  ViolationResponsibleStreaming = 'VIOLATION_RESPONSIBLE_STREAMING',
  ViolationRestrictedGamesAndGamesWithGraphicFootage = 'VIOLATION_RESTRICTED_GAMES_AND_GAMES_WITH_GRAPHIC_FOOTAGE',
  ViolationSelfHarm = 'VIOLATION_SELF_HARM',
  ViolationSexualBehavior = 'VIOLATION_SEXUAL_BEHAVIOR',
  ViolationSpam = 'VIOLATION_SPAM',
  ViolationUnspecified = 'VIOLATION_UNSPECIFIED',
  ViolationViolence = 'VIOLATION_VIOLENCE'
}

export type Mutation = {
  __typename?: 'Mutation';
  /** FriendsService.AcceptFriendRequest */
  acceptFriendRequest?: Maybe<FriendsAcceptFriendRequestResponse>;
  /** ChannelService.AcceptMonetizationTerms */
  acceptMonetizationTerms?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.AddOAuth2Consent */
  addOAuth2Consent?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.CreatePushNotificationToken */
  addPushNotificationToken?: Maybe<GoogleProtobufEmpty>;
  /** ReactionService.AddReaction */
  addReaction?: Maybe<ReactionReactionState>;
  /** UserInventoryAdminService.AddEntitlements */
  addUserEntitlements?: Maybe<InventoryAddEntitlementsResponse>;
  /** WalletAdminService.AddCurrencies */
  addWalletCurrencies?: Maybe<WalletAddCurrenciesResponse>;
  /** ChatModerationService.AllowModerationItem */
  allowChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.BanUser */
  banChannelUser?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.BanUser */
  banPlatformUser?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.BatchDeleteNotifications */
  batchDeleteNotifications?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.BatchMarkNotificationsRead */
  batchMarkNotificationsRead?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.BlockUser */
  blockUser?: Maybe<FriendsBlockUserResponse>;
  /** StoreServiceV2.BuyWithInGameCurrency */
  buyWithInGameCurrency?: Maybe<StoreV2BuyWithInGameCurrencyResponse>;
  /** StoreServiceV2.BuyWithPayment */
  buyWithPayment?: Maybe<StoreV2BuyWithPaymentResponse>;
  /** ChannelSubscriptionService.CancelSubscription */
  cancelChannelSubscription?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.CancelDeletion */
  cancelDataDeletion?: Maybe<GoogleProtobufEmpty>;
  /** StoreServiceV2.CancelOrder */
  cancelOrder?: Maybe<GoogleProtobufEmpty>;
  /** ChannelSubscriptionService.CheckoutExistingSubscription */
  checkoutExistingChannelSubscription?: Maybe<SubscriptionCheckoutExistingSubscriptionResponse>;
  /** ChannelSubscriptionService.CheckoutNewSubscription */
  checkoutNewChannelSubscription?: Maybe<SubscriptionCheckoutNewSubscriptionResponse>;
  /** RewardService.ClaimReward */
  claimReward?: Maybe<RewardClaimRewardResponse>;
  /** ChatModerationService.ClearModerationItem */
  clearChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.ClearPushNotifications */
  clearPushNotifications?: Maybe<GoogleProtobufEmpty>;
  /** UserInventoryAdminService.ConsumeItem */
  consumeUserItem?: Maybe<InventoryConsumeItemResponse>;
  /** AuthAdminService.CreateAccount */
  createAccount?: Maybe<AuthAccount>;
  /** AnnouncementService.CreateAnnouncement */
  createAnnouncement?: Maybe<AnnouncementAnnouncement>;
  /** AnnouncementService.CreateAnnouncementImageUploadToken */
  createAnnouncementImageUploadToken?: Maybe<AnnouncementCreateAnnouncementImageUploadTokenResponse>;
  /** ChallengeService.CreateChallenge */
  createChallenge?: Maybe<GameLogicChallenge>;
  /** ChallengeSessionService.CreateChallengeSession */
  createChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelService.CreateChannel */
  createChannel?: Maybe<ChannelChannel>;
  /** ChannelService.CreateChannelAssetUploadToken */
  createChannelAssetUploadToken?: Maybe<ChannelCreateChannelAssetUploadTokenResponse>;
  /** ChannelModerationService.CreateBanAppeal */
  createChannelBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** ChannelEmojiService.CreateChannelEmoji */
  createChannelEmoji?: Maybe<EmojiEmoji>;
  /** EmojiService.CreateEmojiUploadToken */
  createEmojiUploadToken?: Maybe<EmojiCreateEmojiUploadTokenResponse>;
  /** StreamIngestConfigService.CreateIngestConfigs */
  createIngestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** InvitationService.CreateInvitationCodes */
  createInvitationCodes?: Maybe<InvitationCreateInvitationCodesResponse>;
  /** ItemService.CreateItemBootstrap */
  createItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.CreateParty */
  createParty?: Maybe<PartyParty>;
  /** PartyService.CreatePartyInvitation */
  createPartyInvitation?: Maybe<PartyPartyInvitation>;
  /** PartyService.CreatePartyMember */
  createPartyMember?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.CreateUserPlatformBanAppeal */
  createPlatformBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.CreatePlatformEmoji */
  createPlatformEmoji?: Maybe<EmojiEmoji>;
  /** SupportService.CreateReport */
  createReport?: Maybe<SupportReport>;
  /** ChannelConfigService.CreateStreamBackendConfig */
  createStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StreamerCardService.CreateStreamerCardAssetUploadToken */
  createStreamerCardAssetUploadToken?: Maybe<GameCardCreateStreamerCardAssetUploadTokenResponse>;
  /** StreamerCardService.CreateStreamerCardDraft */
  createStreamerCardDraft?: Maybe<GameLogicStreamerCard>;
  /** StoreServiceV2.CreateStreamerCardSaleConfig */
  createStreamerCardSaleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  /** SupportService.CreateTicket */
  createSupportTicket?: Maybe<GoogleProtobufEmpty>;
  /** AnnouncementService.DeleteAnnouncement */
  deleteAnnouncement?: Maybe<GoogleProtobufEmpty>;
  /** AnnouncementService.DeleteAnnouncementImage */
  deleteAnnouncementImage?: Maybe<GoogleProtobufEmpty>;
  /** ChallengeService.DeleteChallenge */
  deleteChallenge?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.DeleteChannel */
  deleteChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.DeleteChannelAsset */
  deleteChannelAsset?: Maybe<GoogleProtobufEmpty>;
  /** ChannelEmojiService.DeleteChannelEmoji */
  deleteChannelEmoji?: Maybe<GoogleProtobufEmpty>;
  /** FTUEService.DeleteDismissedTooltip */
  deleteDismissedTooltip?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.DeleteExternalAccount */
  deleteExternalAccount?: Maybe<GoogleProtobufEmpty>;
  /** StreamIngestConfigService.DeleteIngestConfigs */
  deleteIngestConfigs?: Maybe<GoogleProtobufEmpty>;
  /** ItemService.DeleteItemBootstrap */
  deleteItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.DeleteNotification */
  deleteNotification?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.DeleteOAuth2Consent */
  deleteOAuth2Consent?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.DeletePartyInvitation */
  deletePartyInvitation?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.DeletePartyMember */
  deletePartyMember?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.DeletePlatformEmoji */
  deletePlatformEmoji?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.DeletePushNotificationToken */
  deletePushNotificationToken?: Maybe<GoogleProtobufEmpty>;
  /** ChannelConfigService.DeleteStreamBackendConfig */
  deleteStreamBackendConfig?: Maybe<GoogleProtobufEmpty>;
  /** StreamerCardService.DeleteStreamerCardDraft */
  deleteStreamerCardDraft?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.DeleteUserData */
  deleteUserData?: Maybe<PrivacyDeleteUserDataResponse>;
  /** ChatModerationService.DenyModerationItem */
  denyChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** FTUEService.DismissTooltip */
  dismissTooltip?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.ExportUserData */
  exportUserData?: Maybe<PrivacyExportUserDataResponse>;
  /** ChannelService.FollowChannel - Following APIs */
  followChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.HideChatMessage */
  hideChatMessage?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.MarkNotificationRead */
  markNotificationRead?: Maybe<NotificationNotification>;
  /** MLControllerService.TriggerMatchEnd */
  mlTriggerMatchEnd?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.MuteChatUser */
  muteChatUser?: Maybe<GoogleProtobufEmpty>;
  /** ChallengeSessionService.PickChallenge */
  pickChallenge?: Maybe<ChallengesessionChallengePick>;
  /** ChallengeSessionService.ProgressChallengeSession */
  progressChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** StreamerCardService.PublishStreamerCardDraft */
  publishStreamerCardDraft?: Maybe<GoogleProtobufEmpty>;
  /** ChannelSubscriptionService.ReactivateSubscription */
  reactivateChannelSubscription?: Maybe<GoogleProtobufEmpty>;
  /** StreamIngestConfigService.RefreshIngestConfigs */
  refreshIngestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** ProfileService.RejectUsername */
  rejectUsername?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.DeleteFriend */
  removeFriend?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.DeleteFriendRequest */
  removeFriendRequest?: Maybe<GoogleProtobufEmpty>;
  /** ReactionService.RemoveReaction */
  removeReaction?: Maybe<ReactionReactionState>;
  /** GoalCardService.ReshuffleSlot */
  reshuffleGoalCardSlot?: Maybe<GoalCardReshuffleSlotResponse>;
  /** ChallengeSessionService.ResolveChallenge */
  resolveChallenge?: Maybe<ChallengesessionChallengeSession>;
  /** PlacementsService.RewardPlacement */
  rewardPlacement?: Maybe<GoogleProtobufEmpty>;
  /** ChannelConfigService.SelectStreamBackendConfig */
  selectStreamBackendConfig?: Maybe<GoogleProtobufEmpty>;
  /** ChatService.SendChatMessage */
  sendChatMessage?: Maybe<ChatSendMessageResponse>;
  /** FriendsService.SendFriendRequest */
  sendFriendRequest?: Maybe<FriendsSendFriendRequestResponse>;
  /** PushNotificationService.SendPushNotification */
  sendPushNotification?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.SetBirthday */
  setBirthday?: Maybe<GoogleProtobufEmpty>;
  /** FeatureFlagService.SetFeatureFlagConfig */
  setFeatureFlagConfig?: Maybe<FlagFeatureFlagConfig>;
  /** GoalCardService.SetGoalCardSlot */
  setGoalCardSlot?: Maybe<GoalCardSetGoalCardSlotResponse>;
  /** ChannelService.SetUserChannelRoles */
  setUserChannelRoles?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.SignAgreements */
  signAgreements?: Maybe<GoogleProtobufEmpty>;
  /** StreamerService.ActivateContextualTeamAction */
  streamerActivateContextualTeamAction?: Maybe<StreamerActivateContextualTeamActionResponse>;
  /** StreamerService.TriggerCameraTransition */
  streamerTriggerCameraTransition?: Maybe<StreamerTriggerCameraTransitionResponse>;
  /** WalletAdminService.SubtractCurrencies */
  subtractWalletCurrencies?: Maybe<WalletSubtractCurrenciesResponse>;
  /** ChannelModerationService.SuspendChannelFeature */
  suspendChannelFeature?: Maybe<GoogleProtobufEmpty>;
  /** UserActionService.TriggerEmoji */
  triggerEmoji?: Maybe<GoogleProtobufEmpty>;
  /** UserActionService.TriggerEmote */
  triggerEmote?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.UnbanUser */
  unbanChannelUser?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.UnbanUser */
  unbanPlatformUser?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.UnblockUser */
  unblockUser?: Maybe<FriendsUnblockUserResponse>;
  /** ChannelService.UnfollowChannel */
  unfollowChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.UnmuteChatUser */
  unmuteChatUser?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.UnsuspendChannelFeature */
  unsuspendChannelFeature?: Maybe<GoogleProtobufEmpty>;
  /** AuthAdminService.UpdateAccount */
  updateAccount?: Maybe<AuthAccount>;
  /** AnnouncementService.UpdateAnnouncement */
  updateAnnouncement?: Maybe<AnnouncementAnnouncement>;
  /** AvatarService.UpdateAvatar */
  updateAvatar?: Maybe<AvatarAvatar>;
  /** ChallengeService.UpdateChallenge */
  updateChallenge?: Maybe<GameLogicChallenge>;
  /** ChallengeSessionService.UpdateChallengeSession */
  updateChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelModerationService.UpdateBanAppeal */
  updateChannelBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.UpdateChannelDetails */
  updateChannelDetails?: Maybe<ChannelChannel>;
  /** ChannelEmojiService.UpdateChannelEmoji */
  updateChannelEmoji?: Maybe<EmojiEmoji>;
  /** ChannelModerationService.UpdateModerationSettings */
  updateChannelModerationSettings?: Maybe<ChannelModerationSettings>;
  /** ChannelService.UpdateMonetizationSettings */
  updateChannelMonetizationSettings?: Maybe<ChannelMonetizationSettings>;
  /** ChannelNotificationService.UpdateNotificationSettings */
  updateChannelNotificationSettings?: Maybe<ChannelNotificationSettings>;
  /** ChannelSubscriptionService.UpdateChannelSubscriptionConfig */
  updateChannelSubscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  /** ChannelNotificationService.UpdateFollowerNotificationSettings */
  updateFollowerNotificationSettings?: Maybe<ChannelFollowerNotificationSettings>;
  /** FriendsService.UpdateFriendsSettings */
  updateFriendsSettings?: Maybe<FriendsFriendsSettings>;
  /** ItemService.UpdateItemBootstrap */
  updateItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.UpdateMarketingConsent */
  updateMarketingConsent?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.UpdatePlatformBanAppeal */
  updatePlatformBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.UpdatePlatformEmoji */
  updatePlatformEmoji?: Maybe<EmojiEmoji>;
  /** ProfileService.UpdatePrivacySettings */
  updatePrivacySettings?: Maybe<ProfilePrivacySettings>;
  /** ProfileService.UpdateProfile */
  updateProfile?: Maybe<ProfileProfile>;
  /** ProfileService.UpdateProfileAvatar */
  updateProfileAvatar?: Maybe<GoogleProtobufEmpty>;
  /** ProfileService.UpdateProfileAvatarV2 */
  updateProfileAvatarV2?: Maybe<AvatarAvatar>;
  /** ChannelConfigService.UpdateRestreamingConfig */
  updateRestreamingConfig?: Maybe<ChannelRestreamingConfig>;
  /** ChannelConfigService.UpdateStreamBackendConfig */
  updateStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StreamerCardService.UpdateStreamerCardDraft */
  updateStreamerCardDraft?: Maybe<GameLogicStreamerCard>;
  /** StoreServiceV2.UpdateStreamerCardSaleConfig */
  updateStreamerCardSaleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  /** ChannelSubscriptionService.UpdateSubscriptionPaymentMethod - protolint:disable:next MAX_LINE_LENGTH */
  updateSubscriptionPaymentMethod?: Maybe<SubscriptionUpdateSubscriptionPaymentMethodResponse>;
  /** InvitationService.UseInvitationCode */
  useInvitationCode?: Maybe<GoogleProtobufEmpty>;
  /** AvatarService.ValidateAvatarComposition */
  validateAvatarComposition?: Maybe<AvatarValidateAvatarCompositionResponse>;
};


export type MutationAcceptFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationAcceptMonetizationTermsArgs = {
  address?: InputMaybe<ApiAddressInput>;
  birthday?: InputMaybe<ApiDateInput>;
  channelId?: InputMaybe<Scalars['ID']>;
  firstName?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<ChannelGender>;
  lastName?: InputMaybe<Scalars['String']>;
};


export type MutationAddOAuth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']>;
  scopes?: InputMaybe<Array<Scalars['String']>>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationAddPushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']>;
  tokenType?: InputMaybe<NotificationPushNotificationTokenType>;
};


export type MutationAddReactionArgs = {
  parentId?: InputMaybe<Scalars['ID']>;
  parentType?: InputMaybe<Scalars['String']>;
  reactionType?: InputMaybe<ReactionReactionType>;
  resourceId?: InputMaybe<Scalars['ID']>;
  resourceType?: InputMaybe<Scalars['String']>;
};


export type MutationAddUserEntitlementsArgs = {
  entitlements?: InputMaybe<Array<InventoryItemEntitlementInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationAddWalletCurrenciesArgs = {
  currencies?: InputMaybe<Array<WalletWalletCurrencyInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationAllowChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
  moderationItemId?: InputMaybe<Scalars['ID']>;
};


export type MutationBanChannelUserArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  description?: InputMaybe<Scalars['String']>;
  keepRecentMessages?: InputMaybe<Scalars['Boolean']>;
  userId?: InputMaybe<Scalars['ID']>;
  violation?: InputMaybe<ChannelViolation>;
};


export type MutationBanPlatformUserArgs = {
  description?: InputMaybe<Scalars['String']>;
  duration?: InputMaybe<Scalars['Duration']>;
  userId?: InputMaybe<Scalars['ID']>;
  violation?: InputMaybe<ModerationViolation>;
};


export type MutationBatchDeleteNotificationsArgs = {
  notificationIds?: InputMaybe<Array<Scalars['String']>>;
};


export type MutationBatchMarkNotificationsReadArgs = {
  notificationIds?: InputMaybe<Array<Scalars['String']>>;
};


export type MutationBlockUserArgs = {
  blockedUserId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationBuyWithInGameCurrencyArgs = {
  currencyId?: InputMaybe<Scalars['ID']>;
  giftOptions?: InputMaybe<StoreV2GiftOptionsInput>;
  itemId?: InputMaybe<Scalars['ID']>;
  signature?: InputMaybe<Scalars['String']>;
};


export type MutationBuyWithPaymentArgs = {
  giftOptions?: InputMaybe<StoreV2GiftOptionsInput>;
  itemId?: InputMaybe<Scalars['ID']>;
  paymentMethod?: InputMaybe<StoreV2PaymentMethod>;
  signature?: InputMaybe<Scalars['String']>;
};


export type MutationCancelChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationCancelDataDeletionArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationCancelOrderArgs = {
  orderId?: InputMaybe<Scalars['ID']>;
};


export type MutationCheckoutExistingChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationCheckoutNewChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  tier?: InputMaybe<Scalars['Int']>;
};


export type MutationClaimRewardArgs = {
  rewardId?: InputMaybe<Scalars['ID']>;
};


export type MutationClearChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
  moderationItemId?: InputMaybe<Scalars['ID']>;
};


export type MutationConsumeUserItemArgs = {
  consumptions?: InputMaybe<Array<InventoryItemConsumptionInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreateAccountArgs = {
  displayName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  isBot?: InputMaybe<Scalars['Boolean']>;
  username?: InputMaybe<Scalars['String']>;
};


export type MutationCreateAnnouncementArgs = {
  category?: InputMaybe<AnnouncementAnnouncementCategory>;
  endTime?: InputMaybe<Scalars['Timestamp']>;
  imageUrl?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  startTime?: InputMaybe<Scalars['Timestamp']>;
  targets?: InputMaybe<AnnouncementTargetsInput>;
  text?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};


export type MutationCreateAnnouncementImageUploadTokenArgs = {
  announcementId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreateChallengeArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  description?: InputMaybe<Scalars['String']>;
  disabled?: InputMaybe<Scalars['Boolean']>;
  gameId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreateChallengeSessionArgs = {
  challenges?: InputMaybe<Array<ChallengesessionChallengeInput>>;
  gameId?: InputMaybe<Scalars['ID']>;
  streamId?: InputMaybe<Scalars['ID']>;
  submissionWindowLength?: InputMaybe<Scalars['Int']>;
};


export type MutationCreateChannelArgs = {
  name?: InputMaybe<Scalars['String']>;
  streamerId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreateChannelAssetUploadTokenArgs = {
  assetType?: InputMaybe<ChannelAssetType>;
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreateChannelBanAppealArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  text?: InputMaybe<Scalars['String']>;
};


export type MutationCreateChannelEmojiArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  label?: InputMaybe<Scalars['String']>;
};


export type MutationCreateEmojiUploadTokenArgs = {
  itemId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreateIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreateInvitationCodesArgs = {
  amount?: InputMaybe<Scalars['Int']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreateItemBootstrapArgs = {
  bootstrap?: InputMaybe<ItemItemBootstrapInput>;
};


export type MutationCreatePartyArgs = {
  inviteeIds?: InputMaybe<Array<Scalars['String']>>;
};


export type MutationCreatePartyInvitationArgs = {
  inviteeId?: InputMaybe<Scalars['ID']>;
  inviterId?: InputMaybe<Scalars['ID']>;
  partyId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreatePartyMemberArgs = {
  partyId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreatePlatformBanAppealArgs = {
  appealText?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreatePlatformEmojiArgs = {
  label?: InputMaybe<Scalars['String']>;
};


export type MutationCreateReportArgs = {
  context?: InputMaybe<SupportReportContextInput>;
  description?: InputMaybe<Scalars['String']>;
  reason?: InputMaybe<SupportReportReason>;
};


export type MutationCreateStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  crConfig?: InputMaybe<ChannelContentRendererConfigInput>;
  gameId?: InputMaybe<Scalars['ID']>;
  mlConfig?: InputMaybe<ChannelMachineLearningConfigInput>;
  recConfig?: InputMaybe<ChannelStreamRecorderConfigInput>;
  transcoderConfig?: InputMaybe<ChannelStreamTranscoderConfigInput>;
};


export type MutationCreateStreamerCardAssetUploadTokenArgs = {
  assetType?: InputMaybe<GameCardAssetType>;
  cardId?: InputMaybe<Scalars['ID']>;
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationCreateStreamerCardDraftArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  familyId?: InputMaybe<Scalars['ID']>;
  gameId?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
};


export type MutationCreateStreamerCardSaleConfigArgs = {
  cardId?: InputMaybe<Scalars['ID']>;
  channelId?: InputMaybe<Scalars['ID']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  excludeFromBundles?: InputMaybe<Scalars['Boolean']>;
  period?: InputMaybe<StoreV2PeriodInput>;
};


export type MutationCreateSupportTicketArgs = {
  description?: InputMaybe<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
};


export type MutationDeleteAnnouncementArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteAnnouncementImageArgs = {
  announcementId?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']>;
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteChannelArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteChannelAssetArgs = {
  assetType?: InputMaybe<ChannelAssetType>;
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteChannelEmojiArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  id?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteDismissedTooltipArgs = {
  tooltipId?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteExternalAccountArgs = {
  idType?: InputMaybe<AuthIdentityType>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteItemBootstrapArgs = {
  itemId?: InputMaybe<Scalars['ID']>;
  revision?: InputMaybe<Scalars['String']>;
};


export type MutationDeleteNotificationArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteOAuth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationDeletePartyInvitationArgs = {
  partyId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationDeletePartyMemberArgs = {
  partyId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationDeletePlatformEmojiArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type MutationDeletePushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']>;
};


export type MutationDeleteStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  id?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteStreamerCardDraftArgs = {
  cardId?: InputMaybe<Scalars['ID']>;
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationDeleteUserDataArgs = {
  gracePeriod?: InputMaybe<Scalars['Duration']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationDenyChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
  moderationItemId?: InputMaybe<Scalars['ID']>;
};


export type MutationDismissTooltipArgs = {
  dismissalType?: InputMaybe<FtueDismissalType>;
  tooltipId?: InputMaybe<Scalars['ID']>;
};


export type MutationFollowChannelArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationHideChatMessageArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
  messageId?: InputMaybe<Scalars['ID']>;
};


export type MutationMarkNotificationReadArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type MutationMlTriggerMatchEndArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type MutationMuteChatUserArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
  description?: InputMaybe<Scalars['String']>;
  duration?: InputMaybe<Scalars['Duration']>;
  reason?: InputMaybe<ChatReason>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationPickChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']>;
  stake?: InputMaybe<ChallengesessionStakeInput>;
  streamId?: InputMaybe<Scalars['ID']>;
};


export type MutationProgressChallengeSessionArgs = {
  phase?: InputMaybe<ChallengesessionChallengeSessionPhase>;
  streamId?: InputMaybe<Scalars['ID']>;
};


export type MutationPublishStreamerCardDraftArgs = {
  cardId?: InputMaybe<Scalars['ID']>;
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationReactivateChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationRefreshIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type MutationRejectUsernameArgs = {
  currentUsername?: InputMaybe<Scalars['String']>;
  reason?: InputMaybe<ModerationViolation>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationRemoveFriendArgs = {
  friendId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationRemoveFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationRemoveReactionArgs = {
  parentId?: InputMaybe<Scalars['ID']>;
  parentType?: InputMaybe<Scalars['String']>;
  resourceId?: InputMaybe<Scalars['ID']>;
  resourceType?: InputMaybe<Scalars['String']>;
};


export type MutationReshuffleGoalCardSlotArgs = {
  slotId?: InputMaybe<Scalars['ID']>;
};


export type MutationResolveChallengeArgs = {
  challenge?: InputMaybe<ChallengesessionChallengeInput>;
  streamId?: InputMaybe<Scalars['ID']>;
};


export type MutationRewardPlacementArgs = {
  placementId?: InputMaybe<Scalars['ID']>;
};


export type MutationSelectStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  configId?: InputMaybe<Scalars['ID']>;
};


export type MutationSendChatMessageArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
  consentToModeration?: InputMaybe<Scalars['Boolean']>;
  content?: InputMaybe<ChatMessageContentInput>;
};


export type MutationSendFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationSendPushNotificationArgs = {
  body?: InputMaybe<Scalars['String']>;
  imageUrl?: InputMaybe<Scalars['String']>;
  link?: InputMaybe<Scalars['String']>;
  payload?: InputMaybe<NotificationPushNotificationPayloadInput>;
  title?: InputMaybe<Scalars['String']>;
  topic?: InputMaybe<Scalars['String']>;
};


export type MutationSetBirthdayArgs = {
  birthday?: InputMaybe<AuthDateInput>;
};


export type MutationSetFeatureFlagConfigArgs = {
  config?: InputMaybe<FlagFeatureFlagConfigInput>;
  previousRevision?: InputMaybe<Scalars['String']>;
  validateSchema?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSetGoalCardSlotArgs = {
  goalCardId?: InputMaybe<Scalars['ID']>;
  goalCardSlotId?: InputMaybe<Scalars['ID']>;
};


export type MutationSetUserChannelRolesArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  roles?: InputMaybe<Array<ChannelChannelRole>>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationSignAgreementsArgs = {
  agreements?: InputMaybe<Array<AuthTermsVersionInput>>;
};


export type MutationStreamerActivateContextualTeamActionArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type MutationStreamerTriggerCameraTransitionArgs = {
  cameraTransitionTarget?: InputMaybe<RenderingCameraTransitionRequestTransitionTarget>;
  streamId?: InputMaybe<Scalars['ID']>;
};


export type MutationSubtractWalletCurrenciesArgs = {
  currencies?: InputMaybe<Array<WalletWalletCurrencyInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationSuspendChannelFeatureArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  description?: InputMaybe<Scalars['String']>;
  duration?: InputMaybe<Scalars['Duration']>;
  feature?: InputMaybe<ChannelChannelFeature>;
  reason?: InputMaybe<ChannelSuspensionReason>;
};


export type MutationTriggerEmojiArgs = {
  emojiId?: InputMaybe<Scalars['ID']>;
  streamId?: InputMaybe<Scalars['ID']>;
};


export type MutationTriggerEmoteArgs = {
  emoteId?: InputMaybe<Scalars['ID']>;
  streamId?: InputMaybe<Scalars['ID']>;
};


export type MutationUnbanChannelUserArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationUnbanPlatformUserArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationUnblockUserArgs = {
  blockedUserId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationUnfollowChannelArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationUnmuteChatUserArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationUnsuspendChannelFeatureArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  feature?: InputMaybe<ChannelChannelFeature>;
};


export type MutationUpdateAccountArgs = {
  body?: InputMaybe<AuthAccountUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateAnnouncementArgs = {
  body?: InputMaybe<AnnouncementAnnouncementInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateAvatarArgs = {
  body?: InputMaybe<AvatarAvatarInput>;
};


export type MutationUpdateChallengeArgs = {
  body?: InputMaybe<ChallengeChallengeUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChallengeSessionArgs = {
  body?: InputMaybe<ChallengesessionChallengeSessionUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelBanAppealArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  status?: InputMaybe<ChannelAppealStatus>;
  text?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationUpdateChannelDetailsArgs = {
  body?: InputMaybe<ChannelChannelDetailsUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelEmojiArgs = {
  body?: InputMaybe<EmojiUpdateChannelEmojiParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelModerationSettingsArgs = {
  body?: InputMaybe<ChannelModerationSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelMonetizationSettingsArgs = {
  body?: InputMaybe<ChannelMonetizationSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelNotificationSettingsArgs = {
  body?: InputMaybe<ChannelUpdateNotificationSettingsParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelSubscriptionConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  subscriptionsEnabled?: InputMaybe<Scalars['Boolean']>;
};


export type MutationUpdateFollowerNotificationSettingsArgs = {
  body?: InputMaybe<ChannelUpdateFollowerNotificationSettingsParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateFriendsSettingsArgs = {
  body?: InputMaybe<FriendsFriendsSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationUpdateItemBootstrapArgs = {
  body?: InputMaybe<ItemItemBootstrapInput>;
};


export type MutationUpdateMarketingConsentArgs = {
  marketingConsent?: InputMaybe<AuthConsentStatus>;
};


export type MutationUpdatePlatformBanAppealArgs = {
  banId?: InputMaybe<Scalars['ID']>;
  comment?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<ModerationAppealStatus>;
};


export type MutationUpdatePlatformEmojiArgs = {
  body?: InputMaybe<EmojiUpdatePlatformEmojiParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdatePrivacySettingsArgs = {
  body?: InputMaybe<ProfilePrivacySettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationUpdateProfileArgs = {
  body?: InputMaybe<ProfileProfileUpdateInput>;
  options?: InputMaybe<ProfileUpdateProfileRequestOptionsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateProfileAvatarArgs = {
  modelId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationUpdateProfileAvatarV2Args = {
  modelId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type MutationUpdateRestreamingConfigArgs = {
  body?: InputMaybe<ChannelRestreamingConfigInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamBackendConfigArgs = {
  body?: InputMaybe<ChannelStreamBackendConfigInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamerCardDraftArgs = {
  body?: InputMaybe<GameCardStreamerCardDraftUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamerCardSaleConfigArgs = {
  body?: InputMaybe<StoreV2StreamerCardSaleConfigUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUseInvitationCodeArgs = {
  code?: InputMaybe<Scalars['String']>;
};


export type MutationValidateAvatarCompositionArgs = {
  composition?: InputMaybe<AvatarAvatarCompositionInput>;
};

export type NotificationForcedSignoutEvent = {
  __typename?: 'NotificationForcedSignoutEvent';
  emptyTypeWorkaround: Scalars['Boolean'];
};

export type NotificationGiftSubscription = {
  __typename?: 'NotificationGiftSubscription';
  channel: ChannelChannel;
  channelId: Scalars['ID'];
  giver?: Maybe<ProfileProfile>;
  giverId: Scalars['ID'];
  tier: Scalars['Int'];
};

export type NotificationListNotificationsResponse = {
  __typename?: 'NotificationListNotificationsResponse';
  notifications: Array<NotificationNotification>;
};

export type NotificationNotification = {
  __typename?: 'NotificationNotification';
  content: NotificationNotificationContent;
  createdAt: Scalars['Timestamp'];
  id: Scalars['ID'];
  new: Scalars['Boolean'];
  persisted: Scalars['Boolean'];
};

export type NotificationNotificationContent = {
  __typename?: 'NotificationNotificationContent';
  content?: Maybe<NotificationNotificationContentContentUnion>;
};

export type NotificationNotificationContentContentUnion = AdsPlacementStateEvent | ChannelUserBannedNotification | FriendsFriendStatusUpdateEvent | GoalCardGoalCardSlot | IntType | InventoryInventoryUpdateEvent | InvitationInvitationCodeUpdateEvent | ModerationPlatformUserBannedNotification | NotificationForcedSignoutEvent | NotificationGiftSubscription | PartyPartyInvitationUpdateEvent | PrivacyUserDataExportCompleteEvent | ProfileUsernameChange | ProgressionProgressionUpdateEvent | RewardReward | SubscriptionChannelSubscriptionUpdateEvent | WalletTransactionEvent;

export type NotificationPushNotificationPayloadChannelLiveInput = {
  channelId?: InputMaybe<Scalars['ID']>;
  channelName?: InputMaybe<Scalars['String']>;
};

export type NotificationPushNotificationPayloadInput = {
  channelLive?: InputMaybe<NotificationPushNotificationPayloadChannelLiveInput>;
};

export type NotificationPushNotificationToken = {
  __typename?: 'NotificationPushNotificationToken';
  token: Scalars['String'];
  tokenType: NotificationPushNotificationTokenType;
  userId: Scalars['ID'];
};

export enum NotificationPushNotificationTokenType {
  PushNotificationTokenTypeFirebase = 'PUSH_NOTIFICATION_TOKEN_TYPE_FIREBASE',
  PushNotificationTokenTypeUnspecified = 'PUSH_NOTIFICATION_TOKEN_TYPE_UNSPECIFIED'
}

export type PartyParty = {
  __typename?: 'PartyParty';
  channel?: Maybe<ChannelChannel>;
  id: Scalars['ID'];
  leaderId: Scalars['ID'];
  members: Array<PartyPartyMember>;
  name: Scalars['String'];
  public: Scalars['Boolean'];
  streamId: Scalars['ID'];
};

export type PartyPartyInvitation = {
  __typename?: 'PartyPartyInvitation';
  inviteeId: Scalars['ID'];
  inviterId: Scalars['ID'];
  partyId: Scalars['ID'];
};

export type PartyPartyInvitationUpdateEvent = {
  __typename?: 'PartyPartyInvitationUpdateEvent';
  partyInvitation: PartyPartyInvitation;
  type: PartyPartyInvitationUpdateEventUpdateType;
};

export enum PartyPartyInvitationUpdateEventUpdateType {
  UpdateTypeInvitationAccepted = 'UPDATE_TYPE_INVITATION_ACCEPTED',
  UpdateTypeInvitationCreated = 'UPDATE_TYPE_INVITATION_CREATED',
  UpdateTypeInvitationDeclined = 'UPDATE_TYPE_INVITATION_DECLINED',
  UpdateTypeInvitationDeleted = 'UPDATE_TYPE_INVITATION_DELETED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED'
}

export type PartyPartyMember = {
  __typename?: 'PartyPartyMember';
  profile: ProfileProfile;
  userId: Scalars['ID'];
};

export type PartyPartyUpdateEvent = {
  __typename?: 'PartyPartyUpdateEvent';
  party: PartyParty;
};

export type PaymentAmount = {
  __typename?: 'PaymentAmount';
  currency: PaymentCurrency;
  value: Scalars['Int'];
};

export type PaymentAmountInput = {
  currency?: InputMaybe<PaymentCurrency>;
  value?: InputMaybe<Scalars['Int']>;
};

export type PaymentAppStoreSession = {
  __typename?: 'PaymentAppStoreSession';
  paymentId: Scalars['ID'];
  productId: Scalars['ID'];
};

export enum PaymentCurrency {
  CurrencyAed = 'CURRENCY_AED',
  CurrencyAfn = 'CURRENCY_AFN',
  CurrencyAll = 'CURRENCY_ALL',
  CurrencyAmd = 'CURRENCY_AMD',
  CurrencyAng = 'CURRENCY_ANG',
  CurrencyAoa = 'CURRENCY_AOA',
  CurrencyArs = 'CURRENCY_ARS',
  CurrencyAud = 'CURRENCY_AUD',
  CurrencyAwg = 'CURRENCY_AWG',
  CurrencyAzn = 'CURRENCY_AZN',
  CurrencyBam = 'CURRENCY_BAM',
  CurrencyBbd = 'CURRENCY_BBD',
  CurrencyBdt = 'CURRENCY_BDT',
  CurrencyBgn = 'CURRENCY_BGN',
  CurrencyBhd = 'CURRENCY_BHD',
  CurrencyBif = 'CURRENCY_BIF',
  CurrencyBmd = 'CURRENCY_BMD',
  CurrencyBnd = 'CURRENCY_BND',
  CurrencyBob = 'CURRENCY_BOB',
  CurrencyBov = 'CURRENCY_BOV',
  CurrencyBrl = 'CURRENCY_BRL',
  CurrencyBsd = 'CURRENCY_BSD',
  CurrencyBtn = 'CURRENCY_BTN',
  CurrencyBwp = 'CURRENCY_BWP',
  CurrencyByn = 'CURRENCY_BYN',
  CurrencyBzd = 'CURRENCY_BZD',
  CurrencyCad = 'CURRENCY_CAD',
  CurrencyCdf = 'CURRENCY_CDF',
  CurrencyChe = 'CURRENCY_CHE',
  CurrencyChf = 'CURRENCY_CHF',
  CurrencyChw = 'CURRENCY_CHW',
  CurrencyClf = 'CURRENCY_CLF',
  CurrencyClp = 'CURRENCY_CLP',
  CurrencyCny = 'CURRENCY_CNY',
  CurrencyCop = 'CURRENCY_COP',
  CurrencyCou = 'CURRENCY_COU',
  CurrencyCrc = 'CURRENCY_CRC',
  CurrencyCuc = 'CURRENCY_CUC',
  CurrencyCup = 'CURRENCY_CUP',
  CurrencyCve = 'CURRENCY_CVE',
  CurrencyCzk = 'CURRENCY_CZK',
  CurrencyDjf = 'CURRENCY_DJF',
  CurrencyDkk = 'CURRENCY_DKK',
  CurrencyDop = 'CURRENCY_DOP',
  CurrencyDzd = 'CURRENCY_DZD',
  CurrencyEgp = 'CURRENCY_EGP',
  CurrencyErn = 'CURRENCY_ERN',
  CurrencyEtb = 'CURRENCY_ETB',
  CurrencyEur = 'CURRENCY_EUR',
  CurrencyFjd = 'CURRENCY_FJD',
  CurrencyFkp = 'CURRENCY_FKP',
  CurrencyGbp = 'CURRENCY_GBP',
  CurrencyGel = 'CURRENCY_GEL',
  CurrencyGhs = 'CURRENCY_GHS',
  CurrencyGip = 'CURRENCY_GIP',
  CurrencyGmd = 'CURRENCY_GMD',
  CurrencyGnf = 'CURRENCY_GNF',
  CurrencyGtq = 'CURRENCY_GTQ',
  CurrencyGyd = 'CURRENCY_GYD',
  CurrencyHkd = 'CURRENCY_HKD',
  CurrencyHnl = 'CURRENCY_HNL',
  CurrencyHtg = 'CURRENCY_HTG',
  CurrencyHuf = 'CURRENCY_HUF',
  CurrencyIdr = 'CURRENCY_IDR',
  CurrencyIls = 'CURRENCY_ILS',
  CurrencyInr = 'CURRENCY_INR',
  CurrencyIqd = 'CURRENCY_IQD',
  CurrencyIrr = 'CURRENCY_IRR',
  CurrencyIsk = 'CURRENCY_ISK',
  CurrencyJmd = 'CURRENCY_JMD',
  CurrencyJod = 'CURRENCY_JOD',
  CurrencyJpy = 'CURRENCY_JPY',
  CurrencyKes = 'CURRENCY_KES',
  CurrencyKgs = 'CURRENCY_KGS',
  CurrencyKhr = 'CURRENCY_KHR',
  CurrencyKmf = 'CURRENCY_KMF',
  CurrencyKpw = 'CURRENCY_KPW',
  CurrencyKrw = 'CURRENCY_KRW',
  CurrencyKwd = 'CURRENCY_KWD',
  CurrencyKyd = 'CURRENCY_KYD',
  CurrencyKzt = 'CURRENCY_KZT',
  CurrencyLak = 'CURRENCY_LAK',
  CurrencyLbp = 'CURRENCY_LBP',
  CurrencyLkr = 'CURRENCY_LKR',
  CurrencyLrd = 'CURRENCY_LRD',
  CurrencyLsl = 'CURRENCY_LSL',
  CurrencyLyd = 'CURRENCY_LYD',
  CurrencyMad = 'CURRENCY_MAD',
  CurrencyMdl = 'CURRENCY_MDL',
  CurrencyMga = 'CURRENCY_MGA',
  CurrencyMkd = 'CURRENCY_MKD',
  CurrencyMmk = 'CURRENCY_MMK',
  CurrencyMnt = 'CURRENCY_MNT',
  CurrencyMop = 'CURRENCY_MOP',
  CurrencyMru = 'CURRENCY_MRU',
  CurrencyMur = 'CURRENCY_MUR',
  CurrencyMvr = 'CURRENCY_MVR',
  CurrencyMwk = 'CURRENCY_MWK',
  CurrencyMxn = 'CURRENCY_MXN',
  CurrencyMxv = 'CURRENCY_MXV',
  CurrencyMyr = 'CURRENCY_MYR',
  CurrencyMzn = 'CURRENCY_MZN',
  CurrencyNad = 'CURRENCY_NAD',
  CurrencyNgn = 'CURRENCY_NGN',
  CurrencyNio = 'CURRENCY_NIO',
  CurrencyNok = 'CURRENCY_NOK',
  CurrencyNpr = 'CURRENCY_NPR',
  CurrencyNzd = 'CURRENCY_NZD',
  CurrencyOmr = 'CURRENCY_OMR',
  CurrencyPab = 'CURRENCY_PAB',
  CurrencyPen = 'CURRENCY_PEN',
  CurrencyPgk = 'CURRENCY_PGK',
  CurrencyPhp = 'CURRENCY_PHP',
  CurrencyPkr = 'CURRENCY_PKR',
  CurrencyPln = 'CURRENCY_PLN',
  CurrencyPyg = 'CURRENCY_PYG',
  CurrencyQar = 'CURRENCY_QAR',
  CurrencyRon = 'CURRENCY_RON',
  CurrencyRsd = 'CURRENCY_RSD',
  CurrencyRub = 'CURRENCY_RUB',
  CurrencyRwf = 'CURRENCY_RWF',
  CurrencySar = 'CURRENCY_SAR',
  CurrencySbd = 'CURRENCY_SBD',
  CurrencyScr = 'CURRENCY_SCR',
  CurrencySdg = 'CURRENCY_SDG',
  CurrencySek = 'CURRENCY_SEK',
  CurrencySgd = 'CURRENCY_SGD',
  CurrencyShp = 'CURRENCY_SHP',
  CurrencySle = 'CURRENCY_SLE',
  CurrencySos = 'CURRENCY_SOS',
  CurrencySrd = 'CURRENCY_SRD',
  CurrencySsp = 'CURRENCY_SSP',
  CurrencyStn = 'CURRENCY_STN',
  CurrencySvc = 'CURRENCY_SVC',
  CurrencySyp = 'CURRENCY_SYP',
  CurrencySzl = 'CURRENCY_SZL',
  CurrencyThb = 'CURRENCY_THB',
  CurrencyTjs = 'CURRENCY_TJS',
  CurrencyTmt = 'CURRENCY_TMT',
  CurrencyTnd = 'CURRENCY_TND',
  CurrencyTop = 'CURRENCY_TOP',
  CurrencyTry = 'CURRENCY_TRY',
  CurrencyTtd = 'CURRENCY_TTD',
  CurrencyTwd = 'CURRENCY_TWD',
  CurrencyTzs = 'CURRENCY_TZS',
  CurrencyUah = 'CURRENCY_UAH',
  CurrencyUgx = 'CURRENCY_UGX',
  CurrencyUnspecified = 'CURRENCY_UNSPECIFIED',
  CurrencyUsd = 'CURRENCY_USD',
  CurrencyUsn = 'CURRENCY_USN',
  CurrencyUyi = 'CURRENCY_UYI',
  CurrencyUyu = 'CURRENCY_UYU',
  CurrencyUyw = 'CURRENCY_UYW',
  CurrencyUzs = 'CURRENCY_UZS',
  CurrencyVed = 'CURRENCY_VED',
  CurrencyVes = 'CURRENCY_VES',
  CurrencyVnd = 'CURRENCY_VND',
  CurrencyVuv = 'CURRENCY_VUV',
  CurrencyWst = 'CURRENCY_WST',
  CurrencyXaf = 'CURRENCY_XAF',
  CurrencyXag = 'CURRENCY_XAG',
  CurrencyXau = 'CURRENCY_XAU',
  CurrencyXba = 'CURRENCY_XBA',
  CurrencyXbb = 'CURRENCY_XBB',
  CurrencyXbc = 'CURRENCY_XBC',
  CurrencyXbd = 'CURRENCY_XBD',
  CurrencyXcd = 'CURRENCY_XCD',
  CurrencyXdr = 'CURRENCY_XDR',
  CurrencyXof = 'CURRENCY_XOF',
  CurrencyXpd = 'CURRENCY_XPD',
  CurrencyXpf = 'CURRENCY_XPF',
  CurrencyXpt = 'CURRENCY_XPT',
  CurrencyXsu = 'CURRENCY_XSU',
  CurrencyXts = 'CURRENCY_XTS',
  CurrencyXua = 'CURRENCY_XUA',
  CurrencyXxx = 'CURRENCY_XXX',
  CurrencyYer = 'CURRENCY_YER',
  CurrencyZar = 'CURRENCY_ZAR',
  CurrencyZmw = 'CURRENCY_ZMW',
  CurrencyZwl = 'CURRENCY_ZWL'
}

export type PaymentLineItem = {
  __typename?: 'PaymentLineItem';
  currency: PaymentCurrency;
  description: Scalars['String'];
  price: Scalars['Int'];
  quantity: Scalars['Int'];
};

export type PaymentListPaymentsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']>;
  statuses?: InputMaybe<Array<PaymentPaymentStatus>>;
  to?: InputMaybe<Scalars['InputTimestamp']>;
};

export type PaymentListPaymentsResponse = {
  __typename?: 'PaymentListPaymentsResponse';
  pageInfo: ApiPageInfo;
  payments: Array<PaymentPayment>;
};

export type PaymentListSuccessfulPaymentsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']>;
  to?: InputMaybe<Scalars['InputTimestamp']>;
};

export type PaymentListSuccessfulPaymentsResponse = {
  __typename?: 'PaymentListSuccessfulPaymentsResponse';
  pageInfo: ApiPageInfo;
  payments: Array<PaymentPayment>;
};

export type PaymentPayment = {
  __typename?: 'PaymentPayment';
  amount: PaymentAmount;
  externalReference: Scalars['String'];
  id: Scalars['ID'];
  info: PaymentPaymentInfo;
  items: Array<PaymentLineItem>;
  meta: PaymentSessionMeta;
  provider: PaymentPaymentProvider;
  status: PaymentPaymentStatus;
  tax: PaymentTax;
  timestamp: Scalars['Timestamp'];
  userId: Scalars['ID'];
};

export type PaymentPaymentInfo = {
  __typename?: 'PaymentPaymentInfo';
  cardHolderName: Scalars['String'];
  cardIssuingCountry: Scalars['String'];
  cardSummary: Scalars['String'];
};

export enum PaymentPaymentProvider {
  PaymentProviderAdyen = 'PAYMENT_PROVIDER_ADYEN',
  PaymentProviderAppstore = 'PAYMENT_PROVIDER_APPSTORE',
  PaymentProviderUnspecified = 'PAYMENT_PROVIDER_UNSPECIFIED'
}

export enum PaymentPaymentStatus {
  PaymentStatusExpired = 'PAYMENT_STATUS_EXPIRED',
  PaymentStatusFailed = 'PAYMENT_STATUS_FAILED',
  PaymentStatusPending = 'PAYMENT_STATUS_PENDING',
  PaymentStatusReversed = 'PAYMENT_STATUS_REVERSED',
  PaymentStatusSuccess = 'PAYMENT_STATUS_SUCCESS',
  PaymentStatusUnspecified = 'PAYMENT_STATUS_UNSPECIFIED'
}

export type PaymentSession = {
  __typename?: 'PaymentSession';
  session?: Maybe<PaymentSessionSessionUnion>;
};

export type PaymentSessionMeta = {
  __typename?: 'PaymentSessionMeta';
  attributes: Array<PaymentSessionMetaAttributesEntry>;
  namespace: Scalars['String'];
};

export type PaymentSessionMetaAttributesEntry = {
  __typename?: 'PaymentSessionMetaAttributesEntry';
  key: Scalars['String'];
  value: Scalars['String'];
};

export type PaymentSessionSessionUnion = AdyenSession | PaymentAppStoreSession;

export type PaymentTax = {
  __typename?: 'PaymentTax';
  amount?: Maybe<PaymentAmount>;
  rate: Scalars['Int'];
  rateInBasisPoints: Scalars['Int'];
};

export type PlayerStatsPlayerStats = {
  __typename?: 'PlayerStatsPlayerStats';
  adsWatched: Scalars['Int'];
  boosterUsage?: Maybe<PlayerStatsPlayerStatsBoosterUsage>;
  cardBundlesPurchased: Scalars['Int'];
  cardLevelUps: Scalars['Int'];
  cardsPlayed: Scalars['Int'];
  cardsSucceeded: Scalars['Int'];
  currencySpending?: Maybe<PlayerStatsPlayerStatsCurrencySpending>;
  dailyGoalCardsCompleted: Scalars['Int'];
  dailyGoalCardsSet: Scalars['Int'];
  matchesPlayed: Scalars['Int'];
  partyMatchesPlayed: Scalars['Int'];
  shufflesUsed: Scalars['Int'];
  soloMatchesPlayed: Scalars['Int'];
  timePlayed?: Maybe<Scalars['Duration']>;
};

export type PlayerStatsPlayerStatsBoosterUsage = {
  __typename?: 'PlayerStatsPlayerStatsBoosterUsage';
  doubt: Scalars['Int'];
  goodCall: Scalars['Int'];
  letsGo: Scalars['Int'];
  nextUp: Scalars['Int'];
  scavenge: Scalars['Int'];
  speedUp: Scalars['Int'];
  total: Scalars['Int'];
};

export type PlayerStatsPlayerStatsCurrencySpending = {
  __typename?: 'PlayerStatsPlayerStatsCurrencySpending';
  channelCurrency: Scalars['Int'];
  hardCurrency: Scalars['Int'];
  softCurrency: Scalars['Int'];
};

export type PrivacyDeleteUserDataResponse = {
  __typename?: 'PrivacyDeleteUserDataResponse';
  taskId: Scalars['ID'];
};

export type PrivacyExportUserDataResponse = {
  __typename?: 'PrivacyExportUserDataResponse';
  taskId: Scalars['ID'];
};

export type PrivacyUserDataExportCompleteEvent = {
  __typename?: 'PrivacyUserDataExportCompleteEvent';
  dataUrl: Scalars['String'];
  taskId: Scalars['ID'];
  userId: Scalars['ID'];
};

export type ProfileBatchGetProfilesResponse = {
  __typename?: 'ProfileBatchGetProfilesResponse';
  profiles: Array<ProfileProfile>;
};

export enum ProfileColor {
  Color_6Ec9F7 = 'COLOR_6EC9F7',
  Color_56F6C0 = 'COLOR_56F6C0',
  Color_63F655 = 'COLOR_63F655',
  Color_8686F9 = 'COLOR_8686F9',
  ColorB26Afb = 'COLOR_B26AFB',
  ColorC0F656 = 'COLOR_C0F656',
  ColorF6Ce56 = 'COLOR_F6CE56',
  ColorF6F656 = 'COLOR_F6F656',
  ColorF76Ef7 = 'COLOR_F76EF7',
  ColorF69856 = 'COLOR_F69856',
  ColorUnspecified = 'COLOR_UNSPECIFIED'
}

export type ProfileGetUsernameHistoryResponse = {
  __typename?: 'ProfileGetUsernameHistoryResponse';
  changes: Array<ProfileUsernameChange>;
};

export type ProfileListPlayedGamesResponse = {
  __typename?: 'ProfileListPlayedGamesResponse';
  games: Array<ProfilePlayedGame>;
  pageInfo: ApiPageInfo;
};

export type ProfileListProfilesResponse = {
  __typename?: 'ProfileListProfilesResponse';
  pageInfo: ApiPageInfo;
  profiles: Array<ProfileProfile>;
};

export type ProfilePlayedGame = {
  __typename?: 'ProfilePlayedGame';
  game: GameGame;
  id: Scalars['ID'];
  lastPlayedAt: Scalars['Timestamp'];
  progression: GameUserProgression;
  season: GameSeason;
  seasonId: Scalars['ID'];
  userId: Scalars['ID'];
};

export enum ProfilePresenceStatus {
  PresenceStatusOffline = 'PRESENCE_STATUS_OFFLINE',
  PresenceStatusOnline = 'PRESENCE_STATUS_ONLINE',
  PresenceStatusUnspecified = 'PRESENCE_STATUS_UNSPECIFIED'
}

export type ProfilePrivacySettings = {
  __typename?: 'ProfilePrivacySettings';
  anonymisePurchaseHighlights: Scalars['Boolean'];
  discordUsernameVisibility: ProfilePrivacySettingsVisibility;
  hideOnlineStatus: Scalars['Boolean'];
  showMatureContentWarning: Scalars['Boolean'];
  visibility: ProfilePrivacySettingsVisibility;
};

export type ProfilePrivacySettingsInput = {
  anonymisePurchaseHighlights?: InputMaybe<Scalars['Boolean']>;
  discordUsernameVisibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
  hideOnlineStatus?: InputMaybe<Scalars['Boolean']>;
  showMatureContentWarning?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
};

export enum ProfilePrivacySettingsVisibility {
  VisibilityAll = 'VISIBILITY_ALL',
  VisibilityFriends = 'VISIBILITY_FRIENDS',
  VisibilityOnlyMe = 'VISIBILITY_ONLY_ME',
  VisibilityUnspecified = 'VISIBILITY_UNSPECIFIED'
}

/** Profile message contains user profile information */
export type ProfileProfile = {
  __typename?: 'ProfileProfile';
  account?: Maybe<AuthAccount>;
  avatarConfig?: Maybe<ProfileProfileAvatarConfig>;
  /**
   * contains a concatenated list of different avatar urls (use avatars object instead)
   * @deprecated field is deprecated
   */
  avatarUrl: Scalars['String'];
  avatars?: Maybe<ProfileProfileAvatars>;
  badges: Array<BadgeBadge>;
  bio: Scalars['String'];
  canChangeUsernameAt?: Maybe<Scalars['Timestamp']>;
  channel?: Maybe<ChannelChannel>;
  discordUsername?: Maybe<Scalars['String']>;
  /** @deprecated field is deprecated */
  displayName: Scalars['String'];
  friends: Array<ProfileProfile>;
  friendshipStatus: FriendsFriendshipStatus;
  isNewUsername: Scalars['Boolean'];
  lastSeen?: Maybe<Scalars['Timestamp']>;
  onlineStatus: ProfilePresenceStatus;
  playedGames: Array<ProfilePlayedGame>;
  preferredColor: ProfileColor;
  settings?: Maybe<ProfileProfileSettings>;
  state: ApiEntityState;
  stats: PlayerStatsPlayerStats;
  temporary: Scalars['Boolean'];
  userId: Scalars['ID'];
  userTag: Scalars['String'];
  usernameHistory?: Maybe<Array<ProfileUsernameChange>>;
  visibility: ProfileProfileVisibility;
};


/** Profile message contains user profile information */
export type ProfileProfileBadgesArgs = {
  channel_id?: InputMaybe<Scalars['ID']>;
};


/** Profile message contains user profile information */
export type ProfileProfileStatsArgs = {
  season_id?: InputMaybe<Scalars['String']>;
};


/** Profile message contains user profile information */
export type ProfileProfileUsernameHistoryArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};

export type ProfileProfileAvatarConfig = {
  __typename?: 'ProfileProfileAvatarConfig';
  model: AvatarAvatar;
  modelId: Scalars['ID'];
};

export type ProfileProfileAvatars = {
  __typename?: 'ProfileProfileAvatars';
  avatar2D: Scalars['String'];
  avatar3D: Scalars['String'];
  avatarFullbody: Scalars['String'];
  avatarGender: Scalars['String'];
};

export type ProfileProfileSettings = {
  __typename?: 'ProfileProfileSettings';
  friends: FriendsFriendsSettings;
  privacy: ProfilePrivacySettings;
};

export type ProfileProfileUpdateInput = {
  bio?: InputMaybe<Scalars['String']>;
  discordUsername?: InputMaybe<Scalars['String']>;
  /** @deprecated field is deprecated */
  displayName?: InputMaybe<Scalars['String']>;
  preferredColor?: InputMaybe<ProfileColor>;
  userId?: InputMaybe<Scalars['ID']>;
  userTag?: InputMaybe<Scalars['String']>;
};

export enum ProfileProfileVisibility {
  ProfileVisibilityPrivate = 'PROFILE_VISIBILITY_PRIVATE',
  ProfileVisibilityPublic = 'PROFILE_VISIBILITY_PUBLIC',
  ProfileVisibilityUnspecified = 'PROFILE_VISIBILITY_UNSPECIFIED'
}

export type ProfileResolveUserTagsResponse = {
  __typename?: 'ProfileResolveUserTagsResponse';
  profiles: Array<ProfileProfile>;
  userIds: Array<ProfileResolveUserTagsResponseUserIdsEntry>;
};

export type ProfileResolveUserTagsResponseUserIdsEntry = {
  __typename?: 'ProfileResolveUserTagsResponseUserIdsEntry';
  key: Scalars['String'];
  value: Scalars['String'];
};

export type ProfileUpdateProfileRequestOptionsInput = {
  omitNameValidation?: InputMaybe<Scalars['Boolean']>;
  omitRankValidation?: InputMaybe<Scalars['Boolean']>;
};

export type ProfileUsernameChange = {
  __typename?: 'ProfileUsernameChange';
  changedAt: Scalars['Timestamp'];
  changedBy: Scalars['String'];
  changer?: Maybe<ProfileProfile>;
  newUsername: Scalars['String'];
  oldUsername: Scalars['String'];
  reason: ModerationViolation;
};

export type ProgressionBatchGetSeasonProgressionRequestQueryInput = {
  seasonId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};

export type ProgressionBatchGetSeasonProgressionResponse = {
  __typename?: 'ProgressionBatchGetSeasonProgressionResponse';
  progression: Array<ProgressionSeasonProgression>;
};

export type ProgressionChannel = {
  __typename?: 'ProgressionChannel';
  channelId: Scalars['ID'];
  userId: Scalars['ID'];
};

export type ProgressionExperiencePoints = {
  __typename?: 'ProgressionExperiencePoints';
  amount: Scalars['Int'];
  target?: Maybe<ProgressionExperiencePointsTargetUnion>;
};

export type ProgressionExperiencePointsTargetUnion = ProgressionChannel | ProgressionFan | ProgressionSeason;

export type ProgressionFan = {
  __typename?: 'ProgressionFan';
  userId: Scalars['ID'];
};

export type ProgressionGetDailyParticipationLimitResponse = {
  __typename?: 'ProgressionGetDailyParticipationLimitResponse';
  remainingDailyParticipationMinutes: Scalars['Int'];
};

export type ProgressionGetDailyXpBoostLimitResponse = {
  __typename?: 'ProgressionGetDailyXPBoostLimitResponse';
  remainingDailyXpBoost: Scalars['Int'];
};

export type ProgressionGetDailyXpEarningsLimitResponse = {
  __typename?: 'ProgressionGetDailyXPEarningsLimitResponse';
  remainingDailyXpEarningsMinutes: Scalars['Int'];
};

export type ProgressionLevel = {
  __typename?: 'ProgressionLevel';
  number: Scalars['Int'];
  target?: Maybe<ProgressionLevelTargetUnion>;
};

export type ProgressionLevelConfig = {
  __typename?: 'ProgressionLevelConfig';
  /**
   * channel_id is an optional configuration for channel loyalty related level
   *  configs
   */
  channelId: Scalars['ID'];
  number: Scalars['Int'];
  rewards: Array<RewardRewardType>;
  /** season_id is an optional configuration for season related level configs */
  seasonId: Scalars['ID'];
  threshold: Scalars['Int'];
};

export type ProgressionLevelTargetUnion = ProgressionChannel | ProgressionFan | ProgressionSeason;

export type ProgressionListLevelConfigsResponse = {
  __typename?: 'ProgressionListLevelConfigsResponse';
  levelConfigs: Array<ProgressionLevelConfig>;
};

export type ProgressionListSeasonProgressionResponse = {
  __typename?: 'ProgressionListSeasonProgressionResponse';
  progression: Array<ProgressionSeasonProgression>;
};

export type ProgressionProgressionUpdateEvent = {
  __typename?: 'ProgressionProgressionUpdateEvent';
  reason: ReasonReason;
  updates: Array<ProgressionProgressionUpdateEventUpdate>;
};

export type ProgressionProgressionUpdateEventUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdate';
  update?: Maybe<ProgressionProgressionUpdateEventUpdateUpdateUnion>;
};

export type ProgressionProgressionUpdateEventUpdateExperiencePointUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdateExperiencePointUpdate';
  newPoints: ProgressionExperiencePoints;
  oldPoints: ProgressionExperiencePoints;
};

export type ProgressionProgressionUpdateEventUpdateLevelUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdateLevelUpdate';
  newLevel: ProgressionLevel;
  oldLevel: ProgressionLevel;
};

export type ProgressionProgressionUpdateEventUpdateUpdateUnion = ProgressionProgressionUpdateEventUpdateExperiencePointUpdate | ProgressionProgressionUpdateEventUpdateLevelUpdate;

export type ProgressionSeason = {
  __typename?: 'ProgressionSeason';
  seasonId: Scalars['ID'];
  userId: Scalars['ID'];
};

export type ProgressionSeasonProgression = {
  __typename?: 'ProgressionSeasonProgression';
  level: Scalars['Int'];
  nextLevel: Scalars['Int'];
  nextLevelThreshold: Scalars['Int'];
  season: GameSeason;
  seasonId: Scalars['ID'];
  xpAmount: Scalars['Int'];
};

export type Query = {
  __typename?: 'Query';
  /** AuthServiceV4.GetAccount */
  account?: Maybe<AuthAccount>;
  /** AgreementService.ListAgreements */
  agreements?: Maybe<AgreementListAgreementResponse>;
  /** AnnouncementService.ListAnnouncements */
  announcements?: Maybe<AnnouncementListAnnouncementsResponse>;
  /** ArenaService.GetArena */
  arena?: Maybe<ArenaArena>;
  /** ArenaService.ListArenas */
  arenas?: Maybe<ArenaListArenasResponse>;
  /** AvatarService.GetAvatar */
  avatar?: Maybe<AvatarAvatar>;
  /** AvatarAnimationService.GetAnimation */
  avatarAnimation?: Maybe<AvatarAnimation>;
  /** AvatarAnimationService.BatchGetAnimations */
  avatarAnimationBatch?: Maybe<AvatarBatchGetAnimationsResponse>;
  /** AvatarAnimationService.ListAnimations */
  avatarAnimations?: Maybe<AvatarListAnimationsResponse>;
  /** StoreServiceV2.GetAvatarEditorStoreFront */
  avatarEditorStoreFront?: Maybe<StoreV2StoreFront>;
  /** AvatarService.GetAvatarPart */
  avatarPart?: Maybe<AvatarAvatarPart>;
  /** AvatarService.ListAvatarParts */
  avatarParts?: Maybe<AvatarListAvatarPartsResponse>;
  /** AvatarService.BatchGetAvatarParts */
  avatarPartsBatch?: Maybe<AvatarBatchGetAvatarPartsResponse>;
  /** AvatarService.ListAvatars */
  avatars?: Maybe<AvatarListAvatarsResponse>;
  /** AvatarService.BatchGetAvatars */
  avatarsBatch?: Maybe<AvatarBatchGetAvatarsResponse>;
  /** ProgressionService.BatchGetSeasonProgression */
  batchGetSeasonProgression?: Maybe<ProgressionBatchGetSeasonProgressionResponse>;
  /** BadgeService.BatchGetUserBadges */
  batchGetUserBadges?: Maybe<BadgeBatchGetUserBadgesResponse>;
  /** FriendsService.ListBlockedUsers */
  blockedUsers?: Maybe<FriendsListBlockedUsersResponse>;
  /** BoosterService.GetBooster */
  booster?: Maybe<GameLogicBooster>;
  /** BoosterService.ListBoosters */
  boosters?: Maybe<GameCardListBoostersResponse>;
  /** ChallengeService.GetChallenge */
  challenge?: Maybe<GameLogicChallenge>;
  /** ChallengeService.GetChallengeRewards */
  challengeRewards?: Maybe<ChallengeGetChallengeRewardsResponse>;
  /** ChallengeService.BatchGetChallenges */
  challengesBatch?: Maybe<ChallengeListChallengesResponse>;
  /** ChannelService.GetChannel */
  channel?: Maybe<ChannelChannel>;
  /** FriendsService.GetChannelActiveFriends */
  channelActiveFriends?: Maybe<FriendsGetChannelActiveFriendsResponse>;
  /** StreamerService.ListChannelActivityEvents */
  channelActivityEvents?: Maybe<StreamerListChannelActivityEventsResponse>;
  /** ChannelModerationService.ListBanAppeals */
  channelBanAppeals?: Maybe<ChannelListBanAppealsResponse>;
  /** ChannelModerationService.GetUserBanStatus */
  channelBanUserStatus?: Maybe<ChannelUserBanStatus>;
  /** ChannelModerationService.BatchGetUserBanStatus */
  channelBanUserStatuses?: Maybe<ChannelBatchGetUserBanStatusResponse>;
  /** ChannelModerationService.ListBannedUsers */
  channelBannedUsers?: Maybe<ChannelListBannedUsersResponse>;
  /** ChannelService.GetChannelByName */
  channelByName?: Maybe<ChannelChannel>;
  /** ChannelEmojiService.ListChannelEmojis */
  channelEmojis?: Maybe<EmojiListChannelEmojisResponse>;
  /** FeatureFlagService.GetChannelFeatureFlag */
  channelFeatureFlag?: Maybe<FlagFeatureFlagState>;
  /** FeatureFlagService.ListChannelFeatureFlags */
  channelFeatureFlags?: Maybe<FlagListChannelFeatureFlagsResponse>;
  /** ChannelNotificationService.GetFollowerNotificationSettings */
  channelFollowerNotificationSettings?: Maybe<ChannelFollowerNotificationSettings>;
  /** ChannelService.GetChannelFollowerStatus */
  channelFollowerStatus?: Maybe<ChannelGetChannelFollowerStatusResponse>;
  /** ChannelService.ListGameStats */
  channelGameStats?: Maybe<ChannelListGameStatsResponse>;
  /** ChannelService.BatchGetGameStats */
  channelGameStatsBatch?: Maybe<ChannelBatchGetGameStatsResponse>;
  /** ChannelModerationService.GetModerationSettings */
  channelModerationSettings?: Maybe<ChannelModerationSettings>;
  /** ChannelNotificationService.GetNotificationSettings */
  channelNotificationSettings?: Maybe<ChannelNotificationSettings>;
  /** ChannelService.ListChannelPrivilegedUsers */
  channelPrivilegedUsers?: Maybe<ChannelListChannelPrivilegedUsersResponse>;
  /** StoreServiceV2.GetChannelStoreFront */
  channelStoreFront?: Maybe<StoreV2StoreFront>;
  /** ChannelSubscriptionService.GetChannelSubscriptionConfig */
  channelSubscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  /** ChannelSubscriptionService.ListChannelSubscriptionTiers */
  channelSubscriptionTiers?: Maybe<SubscriptionListChannelSubscriptionTiersResponse>;
  /** ChannelSubscriptionService.ListChannelSubscriptions */
  channelSubscriptions?: Maybe<SubscriptionListChannelSubscriptionsResponse>;
  /** ChannelService.ListChannels */
  channels?: Maybe<ChannelListChannelsResponse>;
  /** ChatService.ListMessages */
  chatMessages?: Maybe<ChatListMessagesResponse>;
  /** ChatModerationService.GetChatUserStatus */
  chatUserStatus?: Maybe<ChatGetChatUserStatusResponse>;
  /** ChatService.ListChatUsers */
  chatUsers?: Maybe<ChatListChatUsersResponse>;
  /** ArenaService.GetClientSideArena */
  clientSideArena?: Maybe<ArenaClientSideArena>;
  /** ArenaService.ListClientSideArenas */
  clientSideArenas?: Maybe<ArenaListClientSideArenasResponse>;
  /** ProgressionService.GetDailyParticipationLimit */
  dailyParticipationLimit?: Maybe<ProgressionGetDailyParticipationLimitResponse>;
  /** ProgressionService.GetDailyXPBoostLimit */
  dailyXPBoostLimit?: Maybe<ProgressionGetDailyXpBoostLimitResponse>;
  /** ProgressionService.GetDailyXPEarningsLimit */
  dailyXPEarningsLimit?: Maybe<ProgressionGetDailyXpEarningsLimitResponse>;
  /** FTUEService.ListDismissedTooltips */
  dismissedTooltips?: Maybe<FtueListDismissedTooltipsResponse>;
  /** EmojiService.GetEmoji */
  emoji?: Maybe<EmojiEmoji>;
  /** EmojiService.BatchGetEmojis */
  emojisBatch?: Maybe<EmojiBatchGetEmojisResponse>;
  /** FeatureFlagService.GetFeatureFlagConfig */
  featureFlagConfig?: Maybe<FlagFeatureFlagConfig>;
  /** FeatureFlagService.GetFeatureFlagSchema */
  featureFlagSchema?: Maybe<FlagFeatureFlagSchema>;
  /** ChannelService.GetFollowStatus */
  followStatuses?: Maybe<ChannelGetFollowStatusResponse>;
  /** ChannelService.GetUserFollowedChannels */
  followedChannels?: Maybe<ChannelGetUserFollowedChannelsResponse>;
  /** FriendsService.ListFriends */
  friends?: Maybe<FriendsListFriendsResponse>;
  /** FriendsService.GetFriendshipStatus */
  friendshipStatuses?: Maybe<FriendsGetFriendshipStatusResponse>;
  /** GameService.GetGame */
  game?: Maybe<GameGame>;
  /** GameCardService.BatchGetGameCards */
  gameCards?: Maybe<GameCardBatchGetGameCardsResponse>;
  /** GameService.BatchGetGames */
  games?: Maybe<GameBatchGetGamesResponse>;
  /** ChallengeSessionService.GetChallengeSession */
  getChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelService.BatchGetChannels */
  getChannels?: Maybe<ChannelBatchGetChannelsResponse>;
  /** ChannelService.BatchStreamGetChannel */
  getStreamChannels?: Maybe<ChannelBatchStreamGetChannelResponse>;
  /** StoreServiceV2.ListGiftSellableItems */
  giftSellableItems?: Maybe<StoreV2ListGiftSellableItemsResponse>;
  /** GoalCardService.GetGoalCard */
  goalCard?: Maybe<GoalCardGoalCard>;
  /** GoalCardService.GetSlotOptions */
  goalCardSlotOptions?: Maybe<GoalCardGetSlotOptionsResponse>;
  /** GoalCardService.ListGoalCardSlots */
  goalCardSlots?: Maybe<GoalCardListGoalCardSlotsResponse>;
  /** GoalCardService.BatchGetGoalCards */
  goalCards?: Maybe<GoalCardBatchGetGoalCardsResponse>;
  /** ChannelService.ListHighlightedChannels */
  highlightedChannels?: Maybe<ChannelListHighlightedChannelsResponse>;
  /** StreamIngestConfigService.GetIngestConfig */
  ingestConfig?: Maybe<StreamIngestConfigChannelIngestConfig>;
  /** StreamIngestConfigService.ListIngestConfigs */
  ingestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** UserInventoryService.ListUserInventory */
  inventory?: Maybe<InventoryListUserInventoryResponse>;
  /** InvitationService.ListInvitationCodes */
  invitationCodes?: Maybe<InvitationListInvitationCodesResponse>;
  /** ItemService.GetItem */
  item?: Maybe<ItemGetItemResponse>;
  /** ItemService.ExpandItem */
  itemExpand?: Maybe<ItemExpandItemResponse>;
  /** ItemService.ListItems */
  items?: Maybe<ItemListItemsResponse>;
  /** ItemService.BatchGetItems */
  itemsBatch?: Maybe<ItemBatchGetItemsResponse>;
  /** ItemService.BatchExpandItems */
  itemsBatchExpand?: Maybe<ItemBatchExpandItemsResponse>;
  /** ChallengeService.ListChallenges */
  listChallenges?: Maybe<ChallengeListChallengesResponse>;
  /** GameCardService.ListGameCards */
  listGameCards?: Maybe<GameCardListGameCardsResponse>;
  /** GameService.ListGames */
  listGames?: Maybe<GameListGamesResponse>;
  /** ProgressionService.ListLevelConfigs */
  listLevelConfigs?: Maybe<ProgressionListLevelConfigsResponse>;
  /** ProgressionService.ListSeasonProgression */
  listSeasonProgression?: Maybe<ProgressionListSeasonProgressionResponse>;
  /** GameService.ListSeasons */
  listSeasons?: Maybe<GameListSeasonsResponse>;
  /** MatchServiceV2.GetGroupChatID */
  matchGroupChatID?: Maybe<MatchGetGroupChatIdResponse>;
  /** MatchAdminService.GetGroupState */
  matchGroupState?: Maybe<MatchGetGroupStateResponse>;
  /** MatchServiceV2.GetMatchState */
  matchState?: Maybe<MatchGetMatchStateResponse>;
  /** MatchAdminService.GetStreamState */
  matchStreamState?: Maybe<MatchGetStreamStateResponse>;
  /** MediaService.BatchGetMediaUrl */
  mediaUrlsBatch?: Maybe<MediaBatchGetMediaUrlResponse>;
  /** MLControllerService.GetHUDScale */
  mlHUDScale?: Maybe<MlControllerGetHudScaleResponse>;
  /** ChannelModerationService.ListModerationEvents */
  moderationEvents?: Maybe<ChannelListModerationEventsResponse>;
  /** NotificationService.ListNotifications */
  notifications?: Maybe<NotificationListNotificationsResponse>;
  /** AuthServiceV4.GetOAuth2Consent */
  oauth2Consent?: Maybe<AuthV4GetOAuth2ConsentResponse>;
  /** PartyService.GetParty */
  party?: Maybe<PartyParty>;
  /** PaymentService.GetPayment */
  payment?: Maybe<PaymentPayment>;
  /** PaymentService.ListPayments */
  payments?: Maybe<PaymentListPaymentsResponse>;
  /** PlacementsService.GetPlacement */
  placement?: Maybe<AdsGetPlacementResponse>;
  /** PlatformModerationService.GetUserPlatformBan */
  platformBan?: Maybe<ModerationPlatformBan>;
  /** PlatformModerationService.ListPlatformBanAppeals */
  platformBanAppeals?: Maybe<ModerationListPlatformBanAppealsResponse>;
  /** PlatformEmojiService.ListPlatformEmojis */
  platformEmojis?: Maybe<EmojiListPlatformEmojisResponse>;
  /** StoreServiceV2.GetPlatformStoreFront */
  platformStoreFront?: Maybe<StoreV2StoreFront>;
  /** ProfileService.ListPlayedGames */
  playedGames?: Maybe<ProfileListPlayedGamesResponse>;
  /** ProfileService.GetProfile - Returns user profiles based on a given userID */
  profile?: Maybe<ProfileProfile>;
  /** ProfileService.BatchGetProfiles */
  profileBatch?: Maybe<ProfileBatchGetProfilesResponse>;
  /** ProfileService.ListProfiles */
  profiles?: Maybe<ProfileListProfilesResponse>;
  /** SearchService.PublicSearch */
  publicSearch?: Maybe<SearchSearchResponse>;
  /** PushNotificationService.GetNotificationToken */
  pushNotificationToken?: Maybe<NotificationPushNotificationToken>;
  /** FriendsService.ListReceivedFriendRequests */
  receivedFriendRequests?: Maybe<FriendsListReceivedFriendRequestsResponse>;
  /** SupportService.GetReportCase */
  reportCase?: Maybe<SupportReportCase>;
  /** SupportService.ListReports */
  reports?: Maybe<SupportListReportsResponse>;
  /** ProfileService.ResolveUserTags */
  resolveUserTags?: Maybe<ProfileResolveUserTagsResponse>;
  /** ChannelConfigService.GetRestreamingConfig */
  restreamingConfig?: Maybe<ChannelRestreamingConfig>;
  /** RewardService.ListRewards */
  rewards?: Maybe<RewardListRewardsResponse>;
  /** SearchService.Search */
  search?: Maybe<SearchSearchResponse>;
  /** GameService.GetSeason */
  season?: Maybe<GameSeason>;
  /** ProgressionService.GetSeasonProgression */
  seasonProgression?: Maybe<ProgressionSeasonProgression>;
  /** GameService.BatchGetSeasons */
  seasons?: Maybe<GameBatchGetSeasonsResponse>;
  /** ChannelConfigService.GetSelectedStreamBackendConfig */
  selectedStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StoreServiceV2.GetSellableItem */
  sellableItem?: Maybe<StoreV2SellableItem>;
  /** StoreServiceV2.ListSellableItems */
  sellableItems?: Maybe<StoreV2ListSellableItemsResponse>;
  /** FriendsService.ListSentFriendRequests */
  sentFriendRequests?: Maybe<FriendsListSentFriendRequestsResponse>;
  /** ChannelService.GetStream */
  stream?: Maybe<ChannelStream>;
  /** StreamerService.GetStreamAudienceInsights */
  streamAudienceInsights?: Maybe<StreamerStreamAudienceInsights>;
  /** ChannelConfigService.GetStreamBackendConfig */
  streamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** ChannelConfigService.ListStreamBackendConfigs */
  streamBackendConfigs?: Maybe<ChannelListStreamBackendConfigsResponse>;
  /** ChannelService.GetStreamSummary */
  streamSummary?: Maybe<ChannelStreamSummary>;
  /** ChannelService.BatchGetStreamSummary */
  streamSummaryBatch?: Maybe<ChannelBatchGetStreamSummaryResponse>;
  /** MatchServiceV2.GetTopActiveCards */
  streamTopActiveCards?: Maybe<MatchGetTopActiveCardsResponse>;
  /** StreamerCardService.GetStreamerCard */
  streamerCard?: Maybe<GameLogicStreamerCard>;
  /** StreamerCardService.ListStreamerCardDrafts */
  streamerCardDrafts?: Maybe<GameCardListStreamerCardDraftsResponse>;
  /** StoreServiceV2.ListStreamerCardSaleConfigs */
  streamerCardSaleConfigs?: Maybe<StoreV2ListStreamerCardSaleConfigsResponse>;
  /** StreamerCardService.ListStreamerCards */
  streamerCards?: Maybe<GameCardListStreamerCardsResponse>;
  /** StreamerCardService.BatchGetStreamerCards */
  streamerCardsBatch?: Maybe<GameCardBatchGetStreamerCardsResponse>;
  /** ChannelService.ListStreams */
  streams?: Maybe<ChannelListStreamsResponse>;
  /** PaymentService.ListSuccessfulPayments */
  successfulPayments?: Maybe<PaymentListSuccessfulPaymentsResponse>;
  /** SupportService.GetArticle */
  supportArticle?: Maybe<SupportArticle>;
  /** StoreServiceV2.ListTopUpSellableItems */
  topUpSellableItems?: Maybe<StoreV2ListTopUpSellableItemsResponse>;
  /** AnnouncementService.ListUserAnnouncements */
  userAnnouncements?: Maybe<AnnouncementListUserAnnouncementsResponse>;
  /** BadgeService.GetUserBadges */
  userBadges?: Maybe<BadgeGetUserBadgesResponse>;
  /** ChannelService.GetUserChannel */
  userChannel?: Maybe<ChannelChannel>;
  /** ChannelModerationService.ListUserChannelBans */
  userChannelBans?: Maybe<ChannelListUserChannelBansResponse>;
  /** ChannelService.ListUserChannelRoles */
  userChannelRoles?: Maybe<ChannelListUserChannelRolesResponse>;
  /** ChannelSubscriptionService.GetUserChannelSubscription */
  userChannelSubscription?: Maybe<SubscriptionChannelSubscription>;
  /** ChannelSubscriptionService.ListUserChannelSubscriptions */
  userChannelSubscriptions?: Maybe<SubscriptionListUserChannelSubscriptionsResponse>;
  /** FeatureFlagService.GetUserFeatureFlag */
  userFeatureFlag?: Maybe<FlagFeatureFlagState>;
  /** FeatureFlagService.ListUserFeatureFlags */
  userFeatureFlags?: Maybe<FlagListUserFeatureFlagsResponse>;
  /** PartyService.GetUserParty */
  userParty?: Maybe<PartyParty>;
  /** ChannelService.ListUserPrivilegedChannels */
  userPrivilegedChannels?: Maybe<ChannelListUserPrivilegedChannelsResponse>;
  /** ProfileService.GetUsernameHistory */
  usernameHistory?: Maybe<ProfileGetUsernameHistoryResponse>;
  /** WalletService.GetWallet */
  wallet?: Maybe<WalletGetWalletResponse>;
  /** WalletService.ListWalletTransactions */
  walletTransactions?: Maybe<WalletListWalletTransactionsResponse>;
};


export type QueryAccountArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryAgreementsArgs = {
  includeOldRevisions?: InputMaybe<Scalars['Boolean']>;
};


export type QueryAnnouncementsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<AnnouncementAnnouncementFilterInput>;
};


export type QueryArenaArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryArenasArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryAvatarArgs = {
  avatarId?: InputMaybe<Scalars['ID']>;
};


export type QueryAvatarAnimationArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryAvatarAnimationBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryAvatarPartArgs = {
  avatarPartId?: InputMaybe<Scalars['ID']>;
};


export type QueryAvatarPartsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryAvatarsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  listAll?: InputMaybe<Scalars['Boolean']>;
};


export type QueryAvatarsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryBatchGetSeasonProgressionArgs = {
  queries?: InputMaybe<Array<ProgressionBatchGetSeasonProgressionRequestQueryInput>>;
};


export type QueryBatchGetUserBadgesArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  userIds?: InputMaybe<Array<Scalars['ID']>>;
};


export type QueryBlockedUsersArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryBoosterArgs = {
  id?: InputMaybe<Scalars['Int']>;
};


export type QueryChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']>;
};


export type QueryChallengeRewardsArgs = {
  gameId?: InputMaybe<Scalars['ID']>;
};


export type QueryChallengesBatchArgs = {
  challengeIds?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryChannelArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelActiveFriendsArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']>>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelActivityEventsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<StreamerChannelActivityEventFilterInput>;
};


export type QueryChannelBanAppealsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelBanUserStatusArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelBanUserStatusesArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']>>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelBannedUsersArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelByNameArgs = {
  name?: InputMaybe<Scalars['String']>;
};


export type QueryChannelEmojisArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
  includeCount?: InputMaybe<Scalars['Boolean']>;
  includeDisabled?: InputMaybe<Scalars['Boolean']>;
};


export type QueryChannelFeatureFlagArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  flagName?: InputMaybe<Scalars['String']>;
};


export type QueryChannelFeatureFlagsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelFollowerNotificationSettingsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelFollowerStatusArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelGameStatsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<ChannelListGameStatsRequestFilterInput>>;
};


export type QueryChannelGameStatsBatchArgs = {
  gameIds?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryChannelModerationSettingsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelNotificationSettingsArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelPrivilegedUsersArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelStoreFrontArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  gameId?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelSubscriptionConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelSubscriptionTiersArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type QueryChannelSubscriptionsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<SubscriptionListChannelSubscriptionsRequestFilterInput>>;
};


export type QueryChannelsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  gameId?: InputMaybe<Scalars['ID']>;
  liveStatus?: InputMaybe<ChannelLiveStatus>;
  name?: InputMaybe<Scalars['String']>;
};


export type QueryChatMessagesArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChatUserStatusArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryChatUsersArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
  limit?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<Scalars['String']>;
  userLabel?: InputMaybe<ChatUserLabel>;
};


export type QueryClientSideArenaArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryClientSideArenasArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type QueryDismissedTooltipsArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryEmojiArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryEmojisBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryFeatureFlagConfigArgs = {
  revision?: InputMaybe<Scalars['String']>;
};


export type QueryFollowStatusesArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']>>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryFollowedChannelsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  liveStatus?: InputMaybe<ChannelLiveStatus>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryFriendsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<FriendsListFriendsRequestFilterInput>>;
  priorityOrder?: InputMaybe<Scalars['Boolean']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryFriendshipStatusesArgs = {
  friendIds?: InputMaybe<Array<Scalars['String']>>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryGameArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryGameCardsArgs = {
  cardIds?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryGamesArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryGetChallengeSessionArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type QueryGetChannelsArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryGetStreamChannelsArgs = {
  streamIds?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryGiftSellableItemsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};


export type QueryGoalCardArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryGoalCardSlotOptionsArgs = {
  slotId?: InputMaybe<Scalars['ID']>;
};


export type QueryGoalCardsArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryHighlightedChannelsArgs = {
  gameId?: InputMaybe<Scalars['ID']>;
  limit?: InputMaybe<Scalars['Int']>;
};


export type QueryIngestConfigArgs = {
  ftlId?: InputMaybe<Scalars['Int']>;
};


export type QueryIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type QueryInventoryArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<InventoryListUserInventoryRequestFilterInput>>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryInvitationCodesArgs = {
  includeUsed?: InputMaybe<Scalars['Boolean']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryItemArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryItemExpandArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryItemsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<ItemListItemsRequestFilterInput>>;
};


export type QueryItemsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryItemsBatchExpandArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryListChallengesArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  gameId?: InputMaybe<Scalars['ID']>;
};


export type QueryListGameCardsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  gameId?: InputMaybe<Scalars['ID']>;
  seasonId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryListGamesArgs = {
  gameName?: InputMaybe<Scalars['String']>;
};


export type QueryListLevelConfigsArgs = {
  maxLevel?: InputMaybe<Scalars['Int']>;
  minLevel?: InputMaybe<Scalars['Int']>;
  seasonId?: InputMaybe<Scalars['ID']>;
};


export type QueryListSeasonProgressionArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryListSeasonsArgs = {
  gameId?: InputMaybe<Scalars['ID']>;
};


export type QueryMatchGroupChatIdArgs = {
  groupId?: InputMaybe<Scalars['ID']>;
  streamId?: InputMaybe<Scalars['ID']>;
};


export type QueryMatchGroupStateArgs = {
  groupId?: InputMaybe<Scalars['ID']>;
  streamId?: InputMaybe<Scalars['ID']>;
};


export type QueryMatchStateArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type QueryMatchStreamStateArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type QueryMediaUrlsBatchArgs = {
  options?: InputMaybe<MediaMediaOptionsInput>;
  urls?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryMlHudScaleArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type QueryModerationEventsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<ChannelModerationEventsFilterInput>;
};


export type QueryNotificationsArgs = {
  cursor?: InputMaybe<Scalars['String']>;
};


export type QueryOauth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']>;
  scopes?: InputMaybe<Array<Scalars['String']>>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryPartyArgs = {
  partyId?: InputMaybe<Scalars['ID']>;
};


export type QueryPaymentArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryPaymentsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<PaymentListPaymentsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryPlacementArgs = {
  placementId?: InputMaybe<Scalars['ID']>;
};


export type QueryPlatformBanArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryPlatformBanAppealsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  status?: InputMaybe<ModerationAppealStatus>;
};


export type QueryPlatformEmojisArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  includeCount?: InputMaybe<Scalars['Boolean']>;
  includeDisabled?: InputMaybe<Scalars['Boolean']>;
};


export type QueryPlatformStoreFrontArgs = {
  gameId?: InputMaybe<Scalars['ID']>;
};


export type QueryPlayedGamesArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryProfileArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryProfileBatchArgs = {
  userIds?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryProfilesArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryPublicSearchArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  entityTypes?: InputMaybe<Array<SearchEntityType>>;
  query?: InputMaybe<Scalars['String']>;
};


export type QueryPushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']>;
};


export type QueryReceivedFriendRequestsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryReportCaseArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryReportsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<SupportReportsFilterInput>;
};


export type QueryResolveUserTagsArgs = {
  userTags?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryRestreamingConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type QueryRewardsArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QuerySearchArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  entityTypes?: InputMaybe<Array<SearchEntityType>>;
  query?: InputMaybe<Scalars['String']>;
};


export type QuerySeasonArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QuerySeasonProgressionArgs = {
  seasonId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QuerySeasonsArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
};


export type QuerySelectedStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type QuerySellableItemArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QuerySellableItemsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<StoreV2ListSellableItemsRequestFilterInput>;
};


export type QuerySentFriendRequestsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryStreamArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryStreamAudienceInsightsArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type QueryStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryStreamBackendConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type QueryStreamSummaryArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryStreamSummaryBatchArgs = {
  streamIds?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryStreamTopActiveCardsArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type QueryStreamerCardArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryStreamerCardDraftsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<GameCardListStreamerCardDraftsRequestFilterInput>>;
};


export type QueryStreamerCardSaleConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryStreamerCardsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<GameCardListStreamerCardsRequestFilterInput>>;
};


export type QueryStreamerCardsBatchArgs = {
  streamerCardIds?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryStreamsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QuerySuccessfulPaymentsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<PaymentListSuccessfulPaymentsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QuerySupportArticleArgs = {
  attachmentBaseUrl?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  locale?: InputMaybe<Scalars['String']>;
};


export type QueryTopUpSellableItemsArgs = {
  currencyId?: InputMaybe<Scalars['ID']>;
  minAmount?: InputMaybe<Scalars['Int']>;
};


export type QueryUserAnnouncementsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  target?: InputMaybe<AnnouncementAnnouncementTarget>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryUserBadgesArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryUserChannelArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryUserChannelBansArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryUserChannelRolesArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryUserChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryUserChannelSubscriptionsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<SubscriptionListUserChannelSubscriptionsRequestFilterInput>>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryUserFeatureFlagArgs = {
  flagName?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryUserFeatureFlagsArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryUserPartyArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryUserPrivilegedChannelsArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryUsernameHistoryArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryWalletArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type QueryWalletTransactionsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<WalletListWalletTransactionsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']>;
};

export enum RarityRarity {
  RarityCommon = 'RARITY_COMMON',
  RarityEpic = 'RARITY_EPIC',
  RarityLegendary = 'RARITY_LEGENDARY',
  RarityRare = 'RARITY_RARE',
  RarityUncommon = 'RARITY_UNCOMMON',
  RarityUnspecified = 'RARITY_UNSPECIFIED'
}

export type ReactionReactionEvent = {
  __typename?: 'ReactionReactionEvent';
  event?: Maybe<ReactionReactionEventEventUnion>;
  parentId: Scalars['ID'];
  parentType: Scalars['String'];
};

export type ReactionReactionEventAdd = {
  __typename?: 'ReactionReactionEventAdd';
  reactionType: ReactionReactionType;
  resourceId: Scalars['ID'];
  resourceType: Scalars['String'];
  userId: Scalars['ID'];
};

export type ReactionReactionEventEventUnion = ReactionReactionEventAdd | ReactionReactionEventInitial | ReactionReactionEventRemove;

export type ReactionReactionEventInitial = {
  __typename?: 'ReactionReactionEventInitial';
  states: Array<ReactionReactionState>;
};

export type ReactionReactionEventRemove = {
  __typename?: 'ReactionReactionEventRemove';
  reactionType: ReactionReactionType;
  resourceId: Scalars['ID'];
  resourceType: Scalars['String'];
  userId: Scalars['ID'];
};

export type ReactionReactionState = {
  __typename?: 'ReactionReactionState';
  /** reactions is a map of reaction type (enum string) to count */
  reactions: Array<ReactionReactionStateReactionsEntry>;
  resourceId: Scalars['ID'];
  resourceType: Scalars['String'];
  userHasReacted: Scalars['Boolean'];
};

export type ReactionReactionStateReactionsEntry = {
  __typename?: 'ReactionReactionStateReactionsEntry';
  key: Scalars['String'];
  value: Scalars['Int'];
};

export enum ReactionReactionType {
  ReactionTypeLike = 'REACTION_TYPE_LIKE',
  ReactionTypeUnspecified = 'REACTION_TYPE_UNSPECIFIED'
}

export type ReasonReason = {
  __typename?: 'ReasonReason';
  metadata?: Maybe<AttributeAttributeMap>;
  reason?: Maybe<ReasonReasonReasonUnion>;
};

export type ReasonReasonAdWatched = {
  __typename?: 'ReasonReasonAdWatched';
  placementId: Scalars['ID'];
};

export type ReasonReasonAdWatchedInput = {
  placementId?: InputMaybe<Scalars['ID']>;
};

export type ReasonReasonAdministrative = {
  __typename?: 'ReasonReasonAdministrative';
  reason: Scalars['String'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type ReasonReasonAdministrativeInput = {
  reason?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['ID']>;
};

export type ReasonReasonChallengeSuccessful = {
  __typename?: 'ReasonReasonChallengeSuccessful';
  challengeId: Scalars['ID'];
};

export type ReasonReasonChallengeSuccessfulInput = {
  challengeId?: InputMaybe<Scalars['ID']>;
};

export type ReasonReasonChannelOwner = {
  __typename?: 'ReasonReasonChannelOwner';
  channelId: Scalars['ID'];
};

export type ReasonReasonChannelOwnerInput = {
  channelId?: InputMaybe<Scalars['ID']>;
};

export type ReasonReasonChannelSubscription = {
  __typename?: 'ReasonReasonChannelSubscription';
  channelId: Scalars['ID'];
};

export type ReasonReasonChannelSubscriptionInput = {
  channelId?: InputMaybe<Scalars['ID']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithInGameCurrency = {
  __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID'];
  revenueShares: Array<ReasonRevenueShare>;
  senderId: Scalars['ID'];
  sku: Scalars['String'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithInGameCurrencyInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  senderId?: InputMaybe<Scalars['ID']>;
  sku?: InputMaybe<Scalars['String']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithPayment = {
  __typename?: 'ReasonReasonGiftPurchaseWithPayment';
  cardIssuingCountry: Scalars['String'];
  orderId: Scalars['ID'];
  price: PaymentAmount;
  reference: Scalars['String'];
  senderId: Scalars['ID'];
  sku: Scalars['String'];
  timestamp: Scalars['Timestamp'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithPaymentInput = {
  cardIssuingCountry?: InputMaybe<Scalars['String']>;
  orderId?: InputMaybe<Scalars['ID']>;
  price?: InputMaybe<PaymentAmountInput>;
  reference?: InputMaybe<Scalars['String']>;
  senderId?: InputMaybe<Scalars['ID']>;
  sku?: InputMaybe<Scalars['String']>;
  timestamp?: InputMaybe<Scalars['InputTimestamp']>;
};

export type ReasonReasonGoalCardComplete = {
  __typename?: 'ReasonReasonGoalCardComplete';
  goalCard: GoalCardGoalCard;
  goalCardId: Scalars['ID'];
  goalCardSlotId: Scalars['ID'];
};

export type ReasonReasonGoalCardCompleteInput = {
  goalCardId?: InputMaybe<Scalars['ID']>;
  goalCardSlotId?: InputMaybe<Scalars['ID']>;
};

export type ReasonReasonGoalCardSlotReshuffle = {
  __typename?: 'ReasonReasonGoalCardSlotReshuffle';
  goalCardSlotId: Scalars['ID'];
};

export type ReasonReasonGoalCardSlotReshuffleInput = {
  goalCardSlotId?: InputMaybe<Scalars['ID']>;
};

export type ReasonReasonInput = {
  adWatched?: InputMaybe<ReasonReasonAdWatchedInput>;
  administrative?: InputMaybe<ReasonReasonAdministrativeInput>;
  challengeSuccessful?: InputMaybe<ReasonReasonChallengeSuccessfulInput>;
  channelOwner?: InputMaybe<ReasonReasonChannelOwnerInput>;
  channelSubscription?: InputMaybe<ReasonReasonChannelSubscriptionInput>;
  giftPurchaseWithInGameCurrency?: InputMaybe<ReasonReasonGiftPurchaseWithInGameCurrencyInput>;
  giftPurchaseWithPayment?: InputMaybe<ReasonReasonGiftPurchaseWithPaymentInput>;
  goalCardComplete?: InputMaybe<ReasonReasonGoalCardCompleteInput>;
  goalCardSlotReshuffle?: InputMaybe<ReasonReasonGoalCardSlotReshuffleInput>;
  levelUp?: InputMaybe<ReasonReasonLevelUpInput>;
  matchEnd?: InputMaybe<ReasonReasonMatchEndInput>;
  metadata?: InputMaybe<AttributeAttributeMapInput>;
  provision?: InputMaybe<ReasonReasonProvisionInput>;
  purchaseWithInGameCurrency?: InputMaybe<ReasonReasonPurchaseWithInGameCurrencyInput>;
  purchaseWithPayment?: InputMaybe<ReasonReasonPurchaseWithPaymentInput>;
  reshuffle?: InputMaybe<ReasonReasonReshuffleInput>;
  rewardClaimed?: InputMaybe<ReasonReasonRewardClaimedInput>;
  storeOrderPayment?: InputMaybe<ReasonReasonStoreOrderPaymentInput>;
};

export type ReasonReasonLevelUp = {
  __typename?: 'ReasonReasonLevelUp';
  level: Scalars['Int'];
  season: GameSeason;
  seasonId: Scalars['ID'];
};

export type ReasonReasonLevelUpInput = {
  level?: InputMaybe<Scalars['Int']>;
  seasonId?: InputMaybe<Scalars['ID']>;
};

export type ReasonReasonMatchEnd = {
  __typename?: 'ReasonReasonMatchEnd';
  groupId: Scalars['ID'];
};

export type ReasonReasonMatchEndInput = {
  groupId?: InputMaybe<Scalars['ID']>;
};

export type ReasonReasonProvision = {
  __typename?: 'ReasonReasonProvision';
  rev: Scalars['String'];
  seasonId: Scalars['ID'];
};

export type ReasonReasonProvisionInput = {
  rev?: InputMaybe<Scalars['String']>;
  seasonId?: InputMaybe<Scalars['ID']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithInGameCurrency = {
  __typename?: 'ReasonReasonPurchaseWithInGameCurrency';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID'];
  revenueShares: Array<ReasonRevenueShare>;
  sku: Scalars['String'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithInGameCurrencyInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  sku?: InputMaybe<Scalars['String']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithPayment = {
  __typename?: 'ReasonReasonPurchaseWithPayment';
  cardIssuingCountry: Scalars['String'];
  orderId: Scalars['ID'];
  price: PaymentAmount;
  reference: Scalars['String'];
  sku: Scalars['String'];
  timestamp: Scalars['Timestamp'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithPaymentInput = {
  cardIssuingCountry?: InputMaybe<Scalars['String']>;
  orderId?: InputMaybe<Scalars['ID']>;
  price?: InputMaybe<PaymentAmountInput>;
  reference?: InputMaybe<Scalars['String']>;
  sku?: InputMaybe<Scalars['String']>;
  timestamp?: InputMaybe<Scalars['InputTimestamp']>;
};

export type ReasonReasonReasonUnion = ReasonReasonAdWatched | ReasonReasonAdministrative | ReasonReasonChallengeSuccessful | ReasonReasonChannelOwner | ReasonReasonChannelSubscription | ReasonReasonGiftPurchaseWithInGameCurrency | ReasonReasonGiftPurchaseWithPayment | ReasonReasonGoalCardComplete | ReasonReasonGoalCardSlotReshuffle | ReasonReasonLevelUp | ReasonReasonMatchEnd | ReasonReasonProvision | ReasonReasonPurchaseWithInGameCurrency | ReasonReasonPurchaseWithPayment | ReasonReasonReshuffle | ReasonReasonRewardClaimed | ReasonReasonStoreOrderPayment;

export type ReasonReasonReshuffle = {
  __typename?: 'ReasonReasonReshuffle';
  groupId: Scalars['ID'];
  matchId: Scalars['ID'];
  streamId: Scalars['ID'];
};

export type ReasonReasonReshuffleInput = {
  groupId?: InputMaybe<Scalars['ID']>;
  matchId?: InputMaybe<Scalars['ID']>;
  streamId?: InputMaybe<Scalars['ID']>;
};

export type ReasonReasonRewardClaimed = {
  __typename?: 'ReasonReasonRewardClaimed';
  rewardId: Scalars['ID'];
  rewardReason: ReasonReason;
};

export type ReasonReasonRewardClaimedInput = {
  rewardId?: InputMaybe<Scalars['ID']>;
  rewardReason?: InputMaybe<ReasonReasonInput>;
};

export type ReasonReasonStoreOrderPayment = {
  __typename?: 'ReasonReasonStoreOrderPayment';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID'];
  revenueShares: Array<ReasonRevenueShare>;
  sku: Scalars['String'];
};

export type ReasonReasonStoreOrderPaymentInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  sku?: InputMaybe<Scalars['String']>;
};

export type ReasonRevenueRecipient = {
  __typename?: 'ReasonRevenueRecipient';
  kind: ReasonRevenueRecipientKind;
  recipientId: Scalars['ID'];
};

export type ReasonRevenueRecipientInput = {
  kind?: InputMaybe<ReasonRevenueRecipientKind>;
  recipientId?: InputMaybe<Scalars['ID']>;
};

export enum ReasonRevenueRecipientKind {
  KindChannel = 'KIND_CHANNEL',
  KindPlatform = 'KIND_PLATFORM',
  KindUnspecified = 'KIND_UNSPECIFIED'
}

export type ReasonRevenueShare = {
  __typename?: 'ReasonRevenueShare';
  percent: Scalars['Int'];
  recipient: ReasonRevenueRecipient;
};

export type ReasonRevenueShareInput = {
  percent?: InputMaybe<Scalars['Int']>;
  recipient?: InputMaybe<ReasonRevenueRecipientInput>;
};

export enum RenderingCameraTransitionRequestTransitionTarget {
  TransitionTargetArena = 'TRANSITION_TARGET_ARENA',
  TransitionTargetCameraDrive1 = 'TRANSITION_TARGET_CAMERA_DRIVE1',
  TransitionTargetSpotlight = 'TRANSITION_TARGET_SPOTLIGHT',
  TransitionTargetUnspecified = 'TRANSITION_TARGET_UNSPECIFIED'
}

export type RewardClaimRewardResponse = {
  __typename?: 'RewardClaimRewardResponse';
  emptyTypeWorkaround: Scalars['Boolean'];
};

export type RewardListRewardsResponse = {
  __typename?: 'RewardListRewardsResponse';
  rewards: Array<RewardReward>;
};

export type RewardReward = {
  __typename?: 'RewardReward';
  id: Scalars['ID'];
  reason: ReasonReason;
  rewardedAt: Scalars['Timestamp'];
  type: RewardRewardType;
  userId: Scalars['ID'];
};

export type RewardRewardType = {
  __typename?: 'RewardRewardType';
  reward?: Maybe<RewardRewardTypeRewardUnion>;
};

export type RewardRewardTypeCurrency = {
  __typename?: 'RewardRewardTypeCurrency';
  currencyAmount: Scalars['Int'];
  currencyId: Scalars['ID'];
};

export type RewardRewardTypeItem = {
  __typename?: 'RewardRewardTypeItem';
  item: ItemItem;
  itemCount: Scalars['Int'];
  itemId: Scalars['ID'];
};

export type RewardRewardTypeRewardUnion = RewardRewardTypeCurrency | RewardRewardTypeItem;

export enum SearchEntityType {
  EntityTypeChannel = 'ENTITY_TYPE_CHANNEL',
  EntityTypeGame = 'ENTITY_TYPE_GAME',
  EntityTypeUnspecified = 'ENTITY_TYPE_UNSPECIFIED',
  EntityTypeUser = 'ENTITY_TYPE_USER'
}

export type SearchResultItem = {
  __typename?: 'SearchResultItem';
  entity?: Maybe<SearchResultItemEntityUnion>;
  entityId: Scalars['ID'];
  entityType: SearchEntityType;
  matchedProperties: Array<Scalars['String']>;
  score: Scalars['Float'];
};

export type SearchResultItemEntityUnion = ChannelChannel | ChannelGameStats | ProfileProfile;

export type SearchSearchResponse = {
  __typename?: 'SearchSearchResponse';
  pageInfo: ApiPageInfo;
  resultItems: Array<SearchResultItem>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2BuyWithInGameCurrencyResponse = {
  __typename?: 'StoreV2BuyWithInGameCurrencyResponse';
  orderId: Scalars['ID'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2BuyWithPaymentResponse = {
  __typename?: 'StoreV2BuyWithPaymentResponse';
  orderId: Scalars['ID'];
  session: PaymentSession;
};

export type StoreV2Content = {
  __typename?: 'StoreV2Content';
  value?: Maybe<StoreV2ContentValueUnion>;
};

export type StoreV2ContentValueUnion = StoreV2CurrencyRef | StoreV2ItemRef | StoreV2SubscriptionRef;

export type StoreV2CurrencyRef = {
  __typename?: 'StoreV2CurrencyRef';
  amount: Scalars['Int'];
  id: Scalars['ID'];
};

export type StoreV2GiftOptionsInput = {
  giftAnonymously?: InputMaybe<Scalars['Boolean']>;
  recipientIds?: InputMaybe<Array<Scalars['String']>>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2InGameCurrencyPrice = {
  __typename?: 'StoreV2InGameCurrencyPrice';
  amount: Scalars['Int'];
  amountWithoutDiscount: Scalars['Int'];
  currencyId: Scalars['ID'];
  default: Scalars['Boolean'];
};

export type StoreV2ItemRef = {
  __typename?: 'StoreV2ItemRef';
  count: Scalars['Int'];
  id: Scalars['ID'];
  inventoryState?: Maybe<InventoryInventoryItem>;
  item: ItemItem;
};

export enum StoreV2ItemType {
  ItemTypeAvatarPart = 'ITEM_TYPE_AVATAR_PART',
  ItemTypeCurrencyPack = 'ITEM_TYPE_CURRENCY_PACK',
  ItemTypeGiftSubscription = 'ITEM_TYPE_GIFT_SUBSCRIPTION',
  ItemTypePremiumCardBundle = 'ITEM_TYPE_PREMIUM_CARD_BUNDLE',
  ItemTypeStandardCardBundle = 'ITEM_TYPE_STANDARD_CARD_BUNDLE',
  ItemTypeStreamerCard = 'ITEM_TYPE_STREAMER_CARD',
  ItemTypeUnspecified = 'ITEM_TYPE_UNSPECIFIED'
}

export type StoreV2ListGiftSellableItemsResponse = {
  __typename?: 'StoreV2ListGiftSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
};

export type StoreV2ListSellableItemsRequestChannelStoreFilterInput = {
  categoryId?: InputMaybe<Scalars['ID']>;
  channelId?: InputMaybe<Scalars['ID']>;
  gameId?: InputMaybe<Scalars['ID']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};

export type StoreV2ListSellableItemsRequestFilterInput = {
  channel?: InputMaybe<StoreV2ListSellableItemsRequestChannelStoreFilterInput>;
  platform?: InputMaybe<StoreV2ListSellableItemsRequestPlatformStoreFilterInput>;
};

export type StoreV2ListSellableItemsRequestPlatformStoreFilterInput = {
  categoryId?: InputMaybe<Scalars['ID']>;
  gameId?: InputMaybe<Scalars['ID']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};

export type StoreV2ListSellableItemsResponse = {
  __typename?: 'StoreV2ListSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
  pageInfo: ApiPageInfo;
};

export type StoreV2ListStreamerCardSaleConfigsResponse = {
  __typename?: 'StoreV2ListStreamerCardSaleConfigsResponse';
  configs: Array<StoreV2StreamerCardSaleConfig>;
  pageInfo: ApiPageInfo;
};

export type StoreV2ListTopUpSellableItemsResponse = {
  __typename?: 'StoreV2ListTopUpSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
};

export enum StoreV2PaymentMethod {
  PaymentMethodAdyen = 'PAYMENT_METHOD_ADYEN',
  PaymentMethodAppstore = 'PAYMENT_METHOD_APPSTORE',
  PaymentMethodUnspecified = 'PAYMENT_METHOD_UNSPECIFIED'
}

export type StoreV2Period = {
  __typename?: 'StoreV2Period';
  from: Scalars['Timestamp'];
  until: Scalars['Timestamp'];
};

export type StoreV2PeriodInput = {
  from?: InputMaybe<Scalars['InputTimestamp']>;
  until?: InputMaybe<Scalars['InputTimestamp']>;
};

export type StoreV2Price = {
  __typename?: 'StoreV2Price';
  amount: Scalars['Int'];
  amountWithoutDiscount: Scalars['Int'];
  currency: PaymentCurrency;
};

export type StoreV2PurchaseLimits = {
  __typename?: 'StoreV2PurchaseLimits';
  perItem: Scalars['Int'];
  perUser: Scalars['Int'];
};

export enum StoreV2RecipientRestriction {
  RecipientRestrictionGiftOnly = 'RECIPIENT_RESTRICTION_GIFT_ONLY',
  RecipientRestrictionSelfOnly = 'RECIPIENT_RESTRICTION_SELF_ONLY',
  RecipientRestrictionUnspecified = 'RECIPIENT_RESTRICTION_UNSPECIFIED'
}

export type StoreV2SellableItem = {
  __typename?: 'StoreV2SellableItem';
  availableUntil?: Maybe<Scalars['Timestamp']>;
  content: Array<StoreV2Content>;
  discountPercent: Scalars['Int'];
  id: Scalars['ID'];
  igcPrices?: Maybe<Array<StoreV2InGameCurrencyPrice>>;
  meta: StoreV2SellableItemMeta;
  name: Scalars['String'];
  price?: Maybe<StoreV2Price>;
  promotionName: Scalars['String'];
  purchaseLimits: StoreV2PurchaseLimits;
  recipientRestriction: StoreV2RecipientRestriction;
  signature: Scalars['String'];
  sku: Scalars['String'];
  type: StoreV2ItemType;
};

export type StoreV2SellableItemMeta = {
  __typename?: 'StoreV2SellableItemMeta';
  channelId: Scalars['ID'];
  configId: Scalars['ID'];
  itemType: StoreV2ItemType;
  promotionId: Scalars['ID'];
  storeFrontId: Scalars['ID'];
  storeType: StoreV2StoreType;
};

export type StoreV2StoreFront = {
  __typename?: 'StoreV2StoreFront';
  categories?: Maybe<Array<StoreV2StoreFrontCategory>>;
  gameId: Scalars['ID'];
  id: Scalars['ID'];
  type: StoreV2StoreType;
};

export type StoreV2StoreFrontCategory = {
  __typename?: 'StoreV2StoreFrontCategory';
  id: Scalars['ID'];
  itemType: StoreV2ItemType;
  sellableItems: Array<StoreV2SellableItem>;
};

export enum StoreV2StoreType {
  StoreTypeAvatarEditor = 'STORE_TYPE_AVATAR_EDITOR',
  StoreTypeChannel = 'STORE_TYPE_CHANNEL',
  StoreTypePlatform = 'STORE_TYPE_PLATFORM',
  StoreTypeUnspecified = 'STORE_TYPE_UNSPECIFIED'
}

export type StoreV2StreamerCardSaleConfig = {
  __typename?: 'StoreV2StreamerCardSaleConfig';
  cardId: Scalars['ID'];
  channelId: Scalars['ID'];
  enabled: Scalars['Boolean'];
  excludeFromBundles: Scalars['Boolean'];
  period?: Maybe<StoreV2Period>;
};

export type StoreV2StreamerCardSaleConfigUpdateInput = {
  cardId?: InputMaybe<Scalars['ID']>;
  channelId?: InputMaybe<Scalars['ID']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  excludeFromBundles?: InputMaybe<Scalars['Boolean']>;
  period?: InputMaybe<StoreV2PeriodInput>;
  unsetPeriod?: InputMaybe<Scalars['Boolean']>;
};

export type StoreV2SubscriptionRef = {
  __typename?: 'StoreV2SubscriptionRef';
  amount: Scalars['Int'];
  channelId: Scalars['ID'];
  /** this is not used */
  id: Scalars['ID'];
  tier: Scalars['Int'];
};

export enum StreamDeploymentStreamDeploymentStatusComponentStatus {
  ComponentStatusContainersUnready = 'COMPONENT_STATUS_CONTAINERS_UNREADY',
  ComponentStatusDeployingContainers = 'COMPONENT_STATUS_DEPLOYING_CONTAINERS',
  ComponentStatusDeployingPod = 'COMPONENT_STATUS_DEPLOYING_POD',
  ComponentStatusDeploymentStarted = 'COMPONENT_STATUS_DEPLOYMENT_STARTED',
  ComponentStatusDisabled = 'COMPONENT_STATUS_DISABLED',
  ComponentStatusOffline = 'COMPONENT_STATUS_OFFLINE',
  ComponentStatusProvisioningNode = 'COMPONENT_STATUS_PROVISIONING_NODE',
  ComponentStatusReady = 'COMPONENT_STATUS_READY',
  ComponentStatusUnspecified = 'COMPONENT_STATUS_UNSPECIFIED'
}

export type StreamInfoStreamInfo = {
  __typename?: 'StreamInfoStreamInfo';
  channelId: Scalars['ID'];
  gameId: Scalars['ID'];
  seasonId: Scalars['ID'];
  streamId: Scalars['ID'];
};

export type StreamIngestConfigChannelIngestConfig = {
  __typename?: 'StreamIngestConfigChannelIngestConfig';
  channelId: Scalars['ID'];
  config: StreamIngestConfigIngestConfig;
  streamingStatus: StreamIngestConfigStreamingStatus;
};

export type StreamIngestConfigChannelIngestConfigs = {
  __typename?: 'StreamIngestConfigChannelIngestConfigs';
  channelId: Scalars['ID'];
  configs: Array<StreamIngestConfigIngestConfig>;
};

export type StreamIngestConfigIngestConfig = {
  __typename?: 'StreamIngestConfigIngestConfig';
  ingest?: Maybe<StreamIngestConfigIngestConfigIngestUnion>;
};

export type StreamIngestConfigIngestConfigFtlConfig = {
  __typename?: 'StreamIngestConfigIngestConfigFTLConfig';
  sharedKey: Scalars['String'];
  streamId: Scalars['Int'];
  streamKey: Scalars['String'];
};

export type StreamIngestConfigIngestConfigIngestUnion = StreamIngestConfigIngestConfigFtlConfig;

export enum StreamIngestConfigStreamingStatus {
  StreamingStatusStreamingDisabled = 'STREAMING_STATUS_STREAMING_DISABLED',
  StreamingStatusUnspecified = 'STREAMING_STATUS_UNSPECIFIED',
  StreamingStatusUserSuspended = 'STREAMING_STATUS_USER_SUSPENDED'
}

export type StreamerActivateContextualTeamActionResponse = {
  __typename?: 'StreamerActivateContextualTeamActionResponse';
  activated: Scalars['Boolean'];
  cooldown: Scalars['Duration'];
};

export type StreamerAvatarItemPurchased = {
  __typename?: 'StreamerAvatarItemPurchased';
  item: ItemItem;
  itemId: Scalars['ID'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type StreamerBundlePurchased = {
  __typename?: 'StreamerBundlePurchased';
  bundleName: Scalars['String'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type StreamerChannelActivityEvent = {
  __typename?: 'StreamerChannelActivityEvent';
  content?: Maybe<StreamerChannelActivityEventContentUnion>;
  id: Scalars['ID'];
  timestamp: Scalars['Timestamp'];
};

export type StreamerChannelActivityEventContentUnion = GameLogicHighScoringCardPromotedMsg | StreamerAvatarItemPurchased | StreamerBundlePurchased | StreamerChannelFollowed | StreamerChannelSubscribed | StreamerMatchEnded | StreamerMatchStarted | StreamerPlayerJoined | StreamerStreamEnded | StreamerStreamStarted | StreamerStreamTitleChanged | StreamerStreamerCardPurchased | StreamerSubscriptionGifted | StreamerSubscriptionRenewed;

export enum StreamerChannelActivityEventFilterEventType {
  EventTypeAvatarItemPurchased = 'EVENT_TYPE_AVATAR_ITEM_PURCHASED',
  EventTypeBundlePurchased = 'EVENT_TYPE_BUNDLE_PURCHASED',
  EventTypeChannelFollowed = 'EVENT_TYPE_CHANNEL_FOLLOWED',
  EventTypeChannelSubscribed = 'EVENT_TYPE_CHANNEL_SUBSCRIBED',
  EventTypeChannelSubscriptionGifted = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_GIFTED',
  EventTypeChannelSubscriptionRenewed = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_RENEWED',
  EventTypeHighScoringCardPromoted = 'EVENT_TYPE_HIGH_SCORING_CARD_PROMOTED',
  EventTypeMatchEnded = 'EVENT_TYPE_MATCH_ENDED',
  EventTypeMatchStarted = 'EVENT_TYPE_MATCH_STARTED',
  EventTypePlayerJoined = 'EVENT_TYPE_PLAYER_JOINED',
  EventTypeStreamerCardPurchased = 'EVENT_TYPE_STREAMER_CARD_PURCHASED',
  EventTypeStreamEnded = 'EVENT_TYPE_STREAM_ENDED',
  EventTypeStreamStarted = 'EVENT_TYPE_STREAM_STARTED',
  EventTypeStreamTitleChanged = 'EVENT_TYPE_STREAM_TITLE_CHANGED',
  EventTypeUnspecified = 'EVENT_TYPE_UNSPECIFIED'
}

export type StreamerChannelActivityEventFilterInput = {
  eventTypes?: InputMaybe<Array<StreamerChannelActivityEventFilterEventType>>;
};

export type StreamerChannelFollowed = {
  __typename?: 'StreamerChannelFollowed';
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type StreamerChannelSubscribed = {
  __typename?: 'StreamerChannelSubscribed';
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type StreamerListChannelActivityEventsResponse = {
  __typename?: 'StreamerListChannelActivityEventsResponse';
  events: Array<StreamerChannelActivityEvent>;
  pageInfo: ApiPageInfo;
};

export type StreamerMatchEnded = {
  __typename?: 'StreamerMatchEnded';
  bestCard?: Maybe<GameLogicCardDetails>;
  bestGroup?: Maybe<GameLogicGroupDetails>;
  bestPlayer?: Maybe<GameLogicPlayerDetails>;
  challengeStatuses?: Maybe<Array<GameLogicChallengeStatus>>;
  streamId: Scalars['ID'];
};

export type StreamerMatchStarted = {
  __typename?: 'StreamerMatchStarted';
  streamId: Scalars['ID'];
};

export type StreamerPlayerJoined = {
  __typename?: 'StreamerPlayerJoined';
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type StreamerStreamAudienceInsights = {
  __typename?: 'StreamerStreamAudienceInsights';
  chatters: Scalars['Int'];
  followers: Scalars['Int'];
  players: Scalars['Int'];
  subscribers: Scalars['Int'];
  viewers: Scalars['Int'];
};

export type StreamerStreamDiagnosticsEvent = {
  __typename?: 'StreamerStreamDiagnosticsEvent';
  channelId: Scalars['ID'];
  obsNoiceValidator: StreamerStreamDiagnosticsEventObsNoiceValidator;
  obsPluginInfo: StreamerStreamDiagnosticsEventObsPluginInfo;
  streamId: Scalars['ID'];
};

export type StreamerStreamDiagnosticsEventObsNoiceValidator = {
  __typename?: 'StreamerStreamDiagnosticsEventObsNoiceValidator';
  missingValidator: Scalars['Boolean'];
  occludingSourceNames: Array<Scalars['String']>;
};

export type StreamerStreamDiagnosticsEventObsPluginInfo = {
  __typename?: 'StreamerStreamDiagnosticsEventObsPluginInfo';
  obsVersion: Scalars['String'];
  pluginVersion: Scalars['String'];
};

export type StreamerStreamDiagnosticsUpdate = {
  __typename?: 'StreamerStreamDiagnosticsUpdate';
  content?: Maybe<StreamerStreamDiagnosticsUpdateContentUnion>;
};

export type StreamerStreamDiagnosticsUpdateContentUnion = IntType | StreamerStreamDiagnosticsEvent;

export type StreamerStreamEnded = {
  __typename?: 'StreamerStreamEnded';
  streamId: Scalars['ID'];
};

export type StreamerStreamEvent = {
  __typename?: 'StreamerStreamEvent';
  content?: Maybe<StreamerStreamEventContentUnion>;
  timestamp: Scalars['Timestamp'];
};

export type StreamerStreamEventContentUnion = GameLogicActiveCardSucceededMsg | GameLogicHighScoringCardPromotedMsg | GameLogicMatchEndedMsg | GameLogicMatchPauseStateChangedMsg | GameLogicMatchStartedMsg | GameLogicPlayerJoinedMsg | GameStateStreamState | IntType | StreamerChannelFollowed | StreamerChannelSubscribed | StreamerSubscriptionGifted;

export enum StreamerStreamEventFilterEventType {
  EventTypeActiveCardSucceeded = 'EVENT_TYPE_ACTIVE_CARD_SUCCEEDED',
  EventTypeChannelFollowed = 'EVENT_TYPE_CHANNEL_FOLLOWED',
  EventTypeChannelSubscribed = 'EVENT_TYPE_CHANNEL_SUBSCRIBED',
  EventTypeChannelSubscriptionGifted = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_GIFTED',
  EventTypeHighScoringCardPromoted = 'EVENT_TYPE_HIGH_SCORING_CARD_PROMOTED',
  EventTypePlayerJoined = 'EVENT_TYPE_PLAYER_JOINED',
  EventTypeUnspecified = 'EVENT_TYPE_UNSPECIFIED'
}

export type StreamerStreamEventFilterInput = {
  eventTypes?: InputMaybe<Array<StreamerStreamEventFilterEventType>>;
};

export type StreamerStreamStarted = {
  __typename?: 'StreamerStreamStarted';
  streamId: Scalars['ID'];
};

export type StreamerStreamTitleChanged = {
  __typename?: 'StreamerStreamTitleChanged';
  title: Scalars['String'];
};

export type StreamerStreamerCardPurchased = {
  __typename?: 'StreamerStreamerCardPurchased';
  streamerCard: GameLogicStreamerCard;
  streamerCardId: Scalars['ID'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type StreamerSubscriptionGifted = {
  __typename?: 'StreamerSubscriptionGifted';
  recipientUserIds: Array<Scalars['String']>;
  recipients?: Maybe<Array<ProfileProfile>>;
  tier: Scalars['Int'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type StreamerSubscriptionRenewed = {
  __typename?: 'StreamerSubscriptionRenewed';
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID'];
};

export type StreamerTriggerCameraTransitionResponse = {
  __typename?: 'StreamerTriggerCameraTransitionResponse';
  success: Scalars['Boolean'];
};

export type StringType = {
  __typename?: 'StringType';
  /** The wrapped value of type String */
  value: Scalars['String'];
};

export type Subscription = {
  __typename?: 'Subscription';
  /** StreamerService.ChannelActivityEvents */
  channelActivityEventsSubscribe?: Maybe<StreamerChannelActivityEvent>;
  /** ChannelService.ChannelEventStream */
  channelEventsSubscribe?: Maybe<ChannelChannelEvent>;
  /** ChannelService.FollowerCountUpdates */
  channelFollowerCountSubscribe?: Maybe<ChannelFollowerCountEvent>;
  /** ChannelService.LiveStatusUpdates - Subscription APIs */
  channelLiveStatusSubscribe?: Maybe<ChannelLiveStatusEvent>;
  /** ChannelService.ChannelStreamDetailUpdates */
  channelStreamDetailSubscribe?: Maybe<ChannelChannelStreamDetailEvent>;
  /** ChannelService.ViewerCountUpdates */
  channelViewerCountSubscribe?: Maybe<ChannelViewerCountEvent>;
  /** ChatModerationService.StreamAutoModQueue */
  chatAutoModQueueSubscribe?: Maybe<ChatAutoModQueueEvent>;
  /** ChatService.ChatMessageStream */
  chatMessageSubscribe?: Maybe<ChatChatEvent>;
  /** ChannelConfigService.IngestStatsUpdates */
  ingestStatsSubscribe?: Maybe<ChannelIngestStatsEvent>;
  /** MLControllerService.StreamHUDScaleUpdates */
  mlHUDScaleUpdatesSubscribe?: Maybe<MlControllerGetHudScaleResponse>;
  /** ChannelModerationService.ModerationEventsStream */
  moderationEventsSubscribe?: Maybe<ChannelModerationEvent>;
  /** NotificationService.Notifications */
  notificationSubscribe?: Maybe<NotificationNotification>;
  /** PartyService.StreamPartyUpdates */
  partyUpdateSubscribe?: Maybe<PartyPartyUpdateEvent>;
  /** ReactionService.StreamReactions */
  reactionsSubscription?: Maybe<ReactionReactionEvent>;
  /** ChallengeSessionService.ChallengeSessionEvents */
  streamChallengeSessionEvents?: Maybe<ChallengesessionChallengeSessionEvent>;
  /** MatchServiceV2.ChallengeUpdates */
  streamChallengeUpdatesSubscribe?: Maybe<MatchChallengeUpdate>;
  /** StreamerService.StreamDiagnosticsUpdates */
  streamDiagnosticsSubscribe?: Maybe<StreamerStreamDiagnosticsUpdate>;
  /** StreamerService.StreamEvents */
  streamEventsSubscribe?: Maybe<StreamerStreamEvent>;
  /** MatchServiceV2.StreamSpectatorCoordinationEvents */
  streamSpectatorCoordinationEventsSubscribe?: Maybe<MatchStreamSpectatorCoordinationEvent>;
  /** ChannelConfigService.StreamStatusUpdates */
  streamStatusSubscribe?: Maybe<ChannelStreamStatusEvent>;
  /** MatchServiceV2.TopCardUpdates */
  streamTopActiveCardsSubscribe?: Maybe<MatchTopCardsUpdate>;
  /** FeatureFlagService.StreamConfigUpdates */
  subscribeFeatureFlagConfigUpdates?: Maybe<FlagFeatureFlagConfig>;
};


export type SubscriptionChannelActivityEventsSubscribeArgs = {
  after?: InputMaybe<Scalars['String']>;
  channelId?: InputMaybe<Scalars['ID']>;
  filter?: InputMaybe<StreamerChannelActivityEventFilterInput>;
};


export type SubscriptionChannelEventsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionChannelFollowerCountSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionChannelLiveStatusSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionChannelStreamDetailSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionChannelViewerCountSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionChatAutoModQueueSubscribeArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionChatMessageSubscribeArgs = {
  chatId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionIngestStatsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionMlHudScaleUpdatesSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionModerationEventsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  filter?: InputMaybe<ChannelModerationEventsFilterInput>;
};


export type SubscriptionNotificationSubscribeArgs = {
  cursor?: InputMaybe<Scalars['String']>;
};


export type SubscriptionPartyUpdateSubscribeArgs = {
  partyId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionReactionsSubscriptionArgs = {
  parentId?: InputMaybe<Scalars['ID']>;
  parentType?: InputMaybe<Scalars['String']>;
};


export type SubscriptionStreamChallengeSessionEventsArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionStreamChallengeUpdatesSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionStreamDiagnosticsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionStreamEventsSubscribeArgs = {
  filter?: InputMaybe<StreamerStreamEventFilterInput>;
  streamId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionStreamSpectatorCoordinationEventsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionStreamStatusSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  streamId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionStreamTopActiveCardsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionSubscribeFeatureFlagConfigUpdatesArgs = {
  revision?: InputMaybe<Scalars['String']>;
};

export type SubscriptionChannelSubscription = {
  __typename?: 'SubscriptionChannelSubscription';
  activatedAt?: Maybe<Scalars['Timestamp']>;
  cancelReason: SubscriptionChannelSubscriptionCancelReason;
  cancelledAt?: Maybe<Scalars['Timestamp']>;
  channel: ChannelChannel;
  channelId: Scalars['ID'];
  createdAt: Scalars['Timestamp'];
  expiresAt?: Maybe<Scalars['Timestamp']>;
  externalReference: Scalars['String'];
  giverId: Scalars['ID'];
  id: Scalars['ID'];
  paymentFailedAt?: Maybe<Scalars['Timestamp']>;
  paymentSucceededAt?: Maybe<Scalars['Timestamp']>;
  provider: SubscriptionChannelSubscriptionProvider;
  renewedAt?: Maybe<Scalars['Timestamp']>;
  state: SubscriptionChannelSubscriptionState;
  terminatedAt?: Maybe<Scalars['Timestamp']>;
  tier: Scalars['Int'];
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export enum SubscriptionChannelSubscriptionCancelReason {
  CancelReasonCurrencyIncompatibleWithGateway = 'CANCEL_REASON_CURRENCY_INCOMPATIBLE_WITH_GATEWAY',
  CancelReasonFraudReviewFailed = 'CANCEL_REASON_FRAUD_REVIEW_FAILED',
  CancelReasonNonCompliantCustomer = 'CANCEL_REASON_NON_COMPLIANT_CUSTOMER',
  CancelReasonNonCompliantEuCustomer = 'CANCEL_REASON_NON_COMPLIANT_EU_CUSTOMER',
  CancelReasonNotPaid = 'CANCEL_REASON_NOT_PAID',
  CancelReasonNoCard = 'CANCEL_REASON_NO_CARD',
  CancelReasonTaxCalculationFailed = 'CANCEL_REASON_TAX_CALCULATION_FAILED',
  CancelReasonUnspecified = 'CANCEL_REASON_UNSPECIFIED'
}

export type SubscriptionChannelSubscriptionConfig = {
  __typename?: 'SubscriptionChannelSubscriptionConfig';
  channelId: Scalars['ID'];
  subscriptionsEnabled: Scalars['Boolean'];
  tiers: Array<SubscriptionChannelSubscriptionTier>;
};

export type SubscriptionChannelSubscriptionEntitlement = {
  __typename?: 'SubscriptionChannelSubscriptionEntitlement';
  amount: Scalars['Int'];
  item: ItemItem;
  itemId: Scalars['ID'];
};

export enum SubscriptionChannelSubscriptionProvider {
  ProviderApple = 'PROVIDER_APPLE',
  ProviderChargebee = 'PROVIDER_CHARGEBEE',
  ProviderUnspecified = 'PROVIDER_UNSPECIFIED'
}

export enum SubscriptionChannelSubscriptionState {
  StateActive = 'STATE_ACTIVE',
  StateCancelled = 'STATE_CANCELLED',
  StateExpired = 'STATE_EXPIRED',
  StateLocked = 'STATE_LOCKED',
  StatePending = 'STATE_PENDING',
  StateTerminated = 'STATE_TERMINATED',
  StateUnspecified = 'STATE_UNSPECIFIED'
}

export type SubscriptionChannelSubscriptionTier = {
  __typename?: 'SubscriptionChannelSubscriptionTier';
  description: Scalars['String'];
  entitlements: Array<SubscriptionChannelSubscriptionEntitlement>;
  level: Scalars['Int'];
  name: Scalars['String'];
  prices: Array<SubscriptionSubscriptionPrice>;
};

export type SubscriptionChannelSubscriptionUpdateEvent = {
  __typename?: 'SubscriptionChannelSubscriptionUpdateEvent';
  meta: SubscriptionSubscriptionUpdateMeta;
  subscription: SubscriptionChannelSubscription;
  updateType: SubscriptionChannelSubscriptionUpdateEventUpdateType;
  updatedAt: Scalars['Timestamp'];
};

export enum SubscriptionChannelSubscriptionUpdateEventUpdateType {
  UpdateTypeActivated = 'UPDATE_TYPE_ACTIVATED',
  UpdateTypeCancellationRemoved = 'UPDATE_TYPE_CANCELLATION_REMOVED',
  UpdateTypeCancellationRequested = 'UPDATE_TYPE_CANCELLATION_REQUESTED',
  UpdateTypeCancelled = 'UPDATE_TYPE_CANCELLED',
  UpdateTypeCreated = 'UPDATE_TYPE_CREATED',
  UpdateTypeExpired = 'UPDATE_TYPE_EXPIRED',
  UpdateTypePaymentFailed = 'UPDATE_TYPE_PAYMENT_FAILED',
  UpdateTypePaymentSucceeded = 'UPDATE_TYPE_PAYMENT_SUCCEEDED',
  UpdateTypeRenewed = 'UPDATE_TYPE_RENEWED',
  UpdateTypeTerminated = 'UPDATE_TYPE_TERMINATED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUpgraded = 'UPDATE_TYPE_UPGRADED'
}

export type SubscriptionCheckoutExistingSubscriptionResponse = {
  __typename?: 'SubscriptionCheckoutExistingSubscriptionResponse';
  sessionData: Scalars['String'];
};

export type SubscriptionCheckoutNewSubscriptionResponse = {
  __typename?: 'SubscriptionCheckoutNewSubscriptionResponse';
  sessionData: Scalars['String'];
};

export type SubscriptionListChannelSubscriptionTiersResponse = {
  __typename?: 'SubscriptionListChannelSubscriptionTiersResponse';
  tiers: Array<SubscriptionChannelSubscriptionTier>;
};

export type SubscriptionListChannelSubscriptionsRequestFilterInput = {
  state?: InputMaybe<SubscriptionChannelSubscriptionState>;
};

export type SubscriptionListChannelSubscriptionsResponse = {
  __typename?: 'SubscriptionListChannelSubscriptionsResponse';
  pageInfo: ApiPageInfo;
  subscriptions: Array<SubscriptionChannelSubscription>;
};

export type SubscriptionListUserChannelSubscriptionsRequestFilterInput = {
  paymentFailed?: InputMaybe<Scalars['Boolean']>;
  state?: InputMaybe<SubscriptionChannelSubscriptionState>;
};

export type SubscriptionListUserChannelSubscriptionsResponse = {
  __typename?: 'SubscriptionListUserChannelSubscriptionsResponse';
  pageInfo: ApiPageInfo;
  subscriptions: Array<SubscriptionChannelSubscription>;
};

export type SubscriptionSubscriptionPrice = {
  __typename?: 'SubscriptionSubscriptionPrice';
  currency: PaymentCurrency;
  period: SubscriptionSubscriptionPricePeriod;
  price: Scalars['Int'];
};

export enum SubscriptionSubscriptionPricePeriod {
  PeriodMonth = 'PERIOD_MONTH',
  PeriodUnspecified = 'PERIOD_UNSPECIFIED',
  PeriodYear = 'PERIOD_YEAR'
}

export type SubscriptionSubscriptionUpdateMeta = {
  __typename?: 'SubscriptionSubscriptionUpdateMeta';
  giverId: Scalars['ID'];
};

export type SubscriptionUpdateSubscriptionPaymentMethodResponse = {
  __typename?: 'SubscriptionUpdateSubscriptionPaymentMethodResponse';
  sessionData: Scalars['String'];
};

export type SupportArticle = {
  __typename?: 'SupportArticle';
  body: Scalars['String'];
  id: Scalars['ID'];
  locale: Scalars['String'];
  title: Scalars['String'];
};

export type SupportListReportsResponse = {
  __typename?: 'SupportListReportsResponse';
  pageInfo: ApiPageInfo;
  reports: Array<SupportReport>;
};

export type SupportReport = {
  __typename?: 'SupportReport';
  caseId: Scalars['ID'];
  context: SupportReportContext;
  createdAt: Scalars['Timestamp'];
  description: Scalars['String'];
  id: Scalars['ID'];
  reason: SupportReportReason;
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type SupportReportCase = {
  __typename?: 'SupportReportCase';
  closedAt: Scalars['Timestamp'];
  closedBy: Scalars['String'];
  context: SupportReportContext;
  createdAt: Scalars['Timestamp'];
  firstDescription: Scalars['String'];
  firstReason: SupportReportReason;
  firstReporterId: Scalars['ID'];
  id: Scalars['ID'];
  moderatorComment: Scalars['String'];
  resolution: SupportReportCaseResolution;
  status: SupportReportCaseStatus;
};

export enum SupportReportCaseResolution {
  ReportCaseResolutionAllowContent = 'REPORT_CASE_RESOLUTION_ALLOW_CONTENT',
  ReportCaseResolutionRemoveContent = 'REPORT_CASE_RESOLUTION_REMOVE_CONTENT',
  ReportCaseResolutionUnspecified = 'REPORT_CASE_RESOLUTION_UNSPECIFIED'
}

export enum SupportReportCaseStatus {
  ReportCaseStatusClosed = 'REPORT_CASE_STATUS_CLOSED',
  ReportCaseStatusOpen = 'REPORT_CASE_STATUS_OPEN',
  ReportCaseStatusUnspecified = 'REPORT_CASE_STATUS_UNSPECIFIED'
}

export type SupportReportContext = {
  __typename?: 'SupportReportContext';
  value?: Maybe<SupportReportContextValueUnion>;
};

export type SupportReportContextChannel = {
  __typename?: 'SupportReportContextChannel';
  channelId: Scalars['ID'];
  target: SupportReportContextChannelTarget;
};

export type SupportReportContextChannelInput = {
  channelId?: InputMaybe<Scalars['ID']>;
  target?: InputMaybe<SupportReportContextChannelTarget>;
};

export enum SupportReportContextChannelTarget {
  TargetDescription = 'TARGET_DESCRIPTION',
  TargetName = 'TARGET_NAME',
  TargetUnspecified = 'TARGET_UNSPECIFIED'
}

export type SupportReportContextChatMessage = {
  __typename?: 'SupportReportContextChatMessage';
  channelId: Scalars['ID'];
  chatId: Scalars['ID'];
  messageId: Scalars['ID'];
  userId: Scalars['ID'];
};

export type SupportReportContextChatMessageInput = {
  channelId?: InputMaybe<Scalars['ID']>;
  chatId?: InputMaybe<Scalars['ID']>;
  messageId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};

export type SupportReportContextInput = {
  channel?: InputMaybe<SupportReportContextChannelInput>;
  chatMessage?: InputMaybe<SupportReportContextChatMessageInput>;
  stream?: InputMaybe<SupportReportContextStreamInput>;
  user?: InputMaybe<SupportReportContextUserInput>;
};

export type SupportReportContextStream = {
  __typename?: 'SupportReportContextStream';
  channelId: Scalars['ID'];
  startAt: Scalars['Int'];
  streamId: Scalars['ID'];
  userId: Scalars['ID'];
};

export type SupportReportContextStreamInput = {
  channelId?: InputMaybe<Scalars['ID']>;
  startAt?: InputMaybe<Scalars['Int']>;
  streamId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};

export type SupportReportContextUser = {
  __typename?: 'SupportReportContextUser';
  target: SupportReportContextUserTarget;
  userId: Scalars['ID'];
};

export type SupportReportContextUserInput = {
  target?: InputMaybe<SupportReportContextUserTarget>;
  userId?: InputMaybe<Scalars['ID']>;
};

export enum SupportReportContextUserTarget {
  TargetName = 'TARGET_NAME',
  TargetUnspecified = 'TARGET_UNSPECIFIED'
}

export type SupportReportContextValueUnion = SupportReportContextChannel | SupportReportContextChatMessage | SupportReportContextStream | SupportReportContextUser;

export enum SupportReportReason {
  ReportReasonChildSafetyChildAbuse = 'REPORT_REASON_CHILD_SAFETY_CHILD_ABUSE',
  ReportReasonChildSafetyCse = 'REPORT_REASON_CHILD_SAFETY_CSE',
  ReportReasonChildSafetyDangerous = 'REPORT_REASON_CHILD_SAFETY_DANGEROUS',
  ReportReasonChildSafetyUnderageUser = 'REPORT_REASON_CHILD_SAFETY_UNDERAGE_USER',
  ReportReasonGraphicMediaAnimalAbuse = 'REPORT_REASON_GRAPHIC_MEDIA_ANIMAL_ABUSE',
  ReportReasonGraphicMediaGore = 'REPORT_REASON_GRAPHIC_MEDIA_GORE',
  ReportReasonGraphicMediaViolence = 'REPORT_REASON_GRAPHIC_MEDIA_VIOLENCE',
  ReportReasonHarassment = 'REPORT_REASON_HARASSMENT',
  ReportReasonHarassmentBlackmail = 'REPORT_REASON_HARASSMENT_BLACKMAIL',
  ReportReasonHarassmentIncitement = 'REPORT_REASON_HARASSMENT_INCITEMENT',
  ReportReasonHarassmentNonConsensualIntimateImages = 'REPORT_REASON_HARASSMENT_NON_CONSENSUAL_INTIMATE_IMAGES',
  ReportReasonHarassmentSexualNonConsensual = 'REPORT_REASON_HARASSMENT_SEXUAL_NON_CONSENSUAL',
  ReportReasonHarassmentStalking = 'REPORT_REASON_HARASSMENT_STALKING',
  ReportReasonHatefulBehavior = 'REPORT_REASON_HATEFUL_BEHAVIOR',
  ReportReasonIllegalActivitySale = 'REPORT_REASON_ILLEGAL_ACTIVITY_SALE',
  ReportReasonIllegalActivityWeapons = 'REPORT_REASON_ILLEGAL_ACTIVITY_WEAPONS',
  ReportReasonIllegalAlcoholNicotine = 'REPORT_REASON_ILLEGAL_ALCOHOL_NICOTINE',
  ReportReasonIllegalDrugs = 'REPORT_REASON_ILLEGAL_DRUGS',
  ReportReasonIllegalManipulation = 'REPORT_REASON_ILLEGAL_MANIPULATION',
  ReportReasonIllegalSpam = 'REPORT_REASON_ILLEGAL_SPAM',
  ReportReasonImpersonation = 'REPORT_REASON_IMPERSONATION',
  ReportReasonInauthenticGameplay = 'REPORT_REASON_INAUTHENTIC_GAMEPLAY',
  ReportReasonOffPlatform = 'REPORT_REASON_OFF_PLATFORM',
  ReportReasonPlatformRulesViolation = 'REPORT_REASON_PLATFORM_RULES_VIOLATION',
  ReportReasonPossibleIllegalActivity = 'REPORT_REASON_POSSIBLE_ILLEGAL_ACTIVITY',
  ReportReasonRestrictedGamesInherentlyViolative = 'REPORT_REASON_RESTRICTED_GAMES_INHERENTLY_VIOLATIVE',
  ReportReasonRestrictedGamesMature = 'REPORT_REASON_RESTRICTED_GAMES_MATURE',
  ReportReasonSelfHarm = 'REPORT_REASON_SELF_HARM',
  ReportReasonSexualBehaviorExplicit = 'REPORT_REASON_SEXUAL_BEHAVIOR_EXPLICIT',
  ReportReasonSexualBehaviorSuggestive = 'REPORT_REASON_SEXUAL_BEHAVIOR_SUGGESTIVE',
  ReportReasonSpam = 'REPORT_REASON_SPAM',
  ReportReasonSpamSuspensionEvasion = 'REPORT_REASON_SPAM_SUSPENSION_EVASION',
  ReportReasonUnknown = 'REPORT_REASON_UNKNOWN',
  ReportReasonUnspecified = 'REPORT_REASON_UNSPECIFIED',
  ReportReasonViolenceExtremism = 'REPORT_REASON_VIOLENCE_EXTREMISM'
}

export type SupportReportsFilterInput = {
  caseId?: InputMaybe<Scalars['ID']>;
};

export type WalletAddCurrenciesResponse = {
  __typename?: 'WalletAddCurrenciesResponse';
  emptyTypeWorkaround: Scalars['Boolean'];
};

export type WalletGetWalletResponse = {
  __typename?: 'WalletGetWalletResponse';
  wallet: WalletWallet;
};

export type WalletListWalletTransactionsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']>;
  reasons?: InputMaybe<Array<WalletTransactionReason>>;
  to?: InputMaybe<Scalars['InputTimestamp']>;
};

export type WalletListWalletTransactionsResponse = {
  __typename?: 'WalletListWalletTransactionsResponse';
  pageInfo: ApiPageInfo;
  transactions: Array<WalletTransaction>;
};

export type WalletOperation = {
  __typename?: 'WalletOperation';
  currencyAmount: Scalars['Int'];
  currencyBalance: Scalars['Int'];
  currencyId: Scalars['ID'];
  type: WalletOperationType;
};

export enum WalletOperationType {
  TypeAdd = 'TYPE_ADD',
  TypeSubtract = 'TYPE_SUBTRACT',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type WalletSubtractCurrenciesResponse = {
  __typename?: 'WalletSubtractCurrenciesResponse';
  emptyTypeWorkaround: Scalars['Boolean'];
};

export type WalletTransaction = {
  __typename?: 'WalletTransaction';
  createdAt: Scalars['Timestamp'];
  expiresAt?: Maybe<Scalars['Timestamp']>;
  id: Scalars['ID'];
  operations: Array<WalletOperation>;
  reason: ReasonReason;
  state: WalletTransactionState;
  user: ProfileProfile;
  userId: Scalars['ID'];
};

export type WalletTransactionEvent = {
  __typename?: 'WalletTransactionEvent';
  transaction: WalletTransaction;
};

export enum WalletTransactionReason {
  TransactionReasonAdministrative = 'TRANSACTION_REASON_ADMINISTRATIVE',
  TransactionReasonAdWatched = 'TRANSACTION_REASON_AD_WATCHED',
  TransactionReasonChannelSubscription = 'TRANSACTION_REASON_CHANNEL_SUBSCRIPTION',
  TransactionReasonGoalCardComplete = 'TRANSACTION_REASON_GOAL_CARD_COMPLETE',
  TransactionReasonGoalCardSlotReshuffle = 'TRANSACTION_REASON_GOAL_CARD_SLOT_RESHUFFLE',
  TransactionReasonLevelUp = 'TRANSACTION_REASON_LEVEL_UP',
  TransactionReasonMatchEnd = 'TRANSACTION_REASON_MATCH_END',
  TransactionReasonProvision = 'TRANSACTION_REASON_PROVISION',
  TransactionReasonPurchaseWithInGameCurrency = 'TRANSACTION_REASON_PURCHASE_WITH_IN_GAME_CURRENCY',
  TransactionReasonPurchaseWithPayment = 'TRANSACTION_REASON_PURCHASE_WITH_PAYMENT',
  TransactionReasonReshuffle = 'TRANSACTION_REASON_RESHUFFLE',
  TransactionReasonRewardClaimed = 'TRANSACTION_REASON_REWARD_CLAIMED',
  TransactionReasonStoreOrderPayment = 'TRANSACTION_REASON_STORE_ORDER_PAYMENT',
  TransactionReasonUnspecified = 'TRANSACTION_REASON_UNSPECIFIED'
}

export enum WalletTransactionState {
  TransactionStateCancelled = 'TRANSACTION_STATE_CANCELLED',
  TransactionStateCommitted = 'TRANSACTION_STATE_COMMITTED',
  TransactionStatePending = 'TRANSACTION_STATE_PENDING',
  TransactionStateUnspecified = 'TRANSACTION_STATE_UNSPECIFIED'
}

export type WalletWallet = {
  __typename?: 'WalletWallet';
  currencies: Array<WalletWalletCurrency>;
  userId: Scalars['ID'];
};

export type WalletWalletCurrency = {
  __typename?: 'WalletWalletCurrency';
  currencyAmount: Scalars['Int'];
  currencyId: Scalars['ID'];
};

export type WalletWalletCurrencyInput = {
  currencyAmount?: InputMaybe<Scalars['Int']>;
  currencyId?: InputMaybe<Scalars['ID']>;
};

export type AvatarViewFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null };

export type AvatarSelectorOptionFragment = { __typename?: 'AvatarAvatar', id: string, gender: string, face: string, body: string, avatar3D: string, avatarLods: Array<string>, selectable: boolean };

export type ChannelViewLinksFragment = { __typename?: 'ChannelChannel', links: Array<{ __typename?: 'ChannelChannelLink', type: ChannelChannelLinkLinkType, name: string, url: string }> };

export type ChannelListQueryVariables = Exact<{
  liveStatus?: InputMaybe<ChannelLiveStatus>;
  gameId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type ChannelListQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, following: boolean, title: string, name: string, viewerCount: number, thumbnail: string, currentStreamId: string, liveStatus: ChannelLiveStatus, offlineBanner: string, followerCount: number, matureRatedContent: boolean, logo: string, channelFriends: { __typename?: 'FriendsChannelFriends', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } }> }, game: { __typename?: 'GameGame', id: string, name: string } }>, pageInfo: { __typename?: 'APIPageInfo', hasNextPage: boolean, endCursor: string } } | null };

export type ChannelDataFragment = { __typename?: 'ChannelChannel', id: string, following: boolean, title: string, name: string, viewerCount: number, thumbnail: string, currentStreamId: string, liveStatus: ChannelLiveStatus, offlineBanner: string, followerCount: number, matureRatedContent: boolean, logo: string, channelFriends: { __typename?: 'FriendsChannelFriends', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } }> }, game: { __typename?: 'GameGame', id: string, name: string } };

export type ChannelLogoFragment = { __typename?: 'ChannelChannel', logo: string, name: string };

export type OfflineChannelThumbnailFragment = { __typename?: 'ChannelChannel', id: string, name: string, offlineBanner: string, following: boolean, followerCount: number, matureRatedContent: boolean, liveStatus: ChannelLiveStatus, logo: string };

export type OnlineChannelPreviewViewFragment = { __typename?: 'ChannelChannel', id: string, title: string, following: boolean, name: string, viewerCount: number, thumbnail: string, currentStreamId: string, liveStatus: ChannelLiveStatus, matureRatedContent: boolean, logo: string, channelFriends: { __typename?: 'FriendsChannelFriends', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } }> }, game: { __typename?: 'GameGame', id: string, name: string } };

export type ChannelDetailsFragment = { __typename?: 'ChannelChannel', matureRatedContent: boolean, liveStatus: ChannelLiveStatus, logo: string, name: string };

export type CurrencyInfoRowQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type CurrencyInfoRowQuery = { __typename?: 'Query', wallet?: { __typename?: 'WalletGetWalletResponse', wallet: { __typename?: 'WalletWallet', currencies: Array<{ __typename?: 'WalletWalletCurrency', currencyId: string, currencyAmount: number }> } } | null };

export type FollowedChannelsRowQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type FollowedChannelsRowQuery = { __typename?: 'Query', followedChannels?: { __typename?: 'ChannelGetUserFollowedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, currentStreamId: string, name: string, liveStatus: ChannelLiveStatus, logo: string }> } | null };

export type FollowedChannelsRowChannelDataFragment = { __typename?: 'ChannelChannel', id: string, currentStreamId: string, name: string, liveStatus: ChannelLiveStatus, logo: string };

export type TimeAdsRewardsQueryVariables = Exact<{
  placementId: Scalars['ID'];
}>;


export type TimeAdsRewardsQuery = { __typename?: 'Query', placement?: { __typename?: 'AdsGetPlacementResponse', placementId: string, rewards: Array<{ __typename?: 'AdsRewardDescription', readyAt: string }> } | null };

export type CurrenciesQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type CurrenciesQuery = { __typename?: 'Query', wallet?: { __typename?: 'WalletGetWalletResponse', wallet: { __typename?: 'WalletWallet', currencies: Array<{ __typename?: 'WalletWalletCurrency', currencyId: string, currencyAmount: number }> } } | null };

export type HeaderAvatarPreviewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type HeaderAvatarPreviewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', onlineStatus: ProfilePresenceStatus, userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null };

export type StreamCategoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type StreamCategoriesQuery = { __typename?: 'Query', listGames?: { __typename?: 'GameListGamesResponse', games: Array<{ __typename?: 'GameGame', id: string, name: string }> } | null };

export type StreamPreviewCardFragment = { __typename?: 'ChannelChannel', currentStreamId: string, viewerCount: number, name: string, title: string, following: boolean, matureRatedContent: boolean, logo: string, channelFriends: { __typename?: 'FriendsChannelFriends', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } }> }, currentStream?: { __typename?: 'ChannelStream', streamId: string, noicePredictionsEnabled: boolean } | null, game: { __typename?: 'GameGame', id: string, name: string }, subscription?: { __typename?: 'SubscriptionChannelSubscription', state: SubscriptionChannelSubscriptionState } | null };

export type SubscriptionItemBadgeQueryVariables = Exact<{
  channelId: Scalars['ID'];
  userId: Scalars['ID'];
}>;


export type SubscriptionItemBadgeQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, badges: Array<{ __typename?: 'BadgeBadge', level: number, type: BadgeBadgeType }> } | null };

export type SubscriptionSettingItemSubscriptionFragment = { __typename?: 'SubscriptionChannelSubscription', id: string, activatedAt?: string | null, expiresAt?: string | null, cancelledAt?: string | null, state: SubscriptionChannelSubscriptionState, paymentFailedAt?: string | null, externalReference: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, offlineBanner: string, logo: string, subscription?: { __typename?: 'SubscriptionChannelSubscription', tier: number, provider: SubscriptionChannelSubscriptionProvider } | null } };

export type UserHeaderRowFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null };

export type ChannelFollowingQueryVariables = Exact<{
  channelId: Scalars['ID'];
}>;


export type ChannelFollowingQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, following: boolean } | null };

export type ChannelLiveStatusSubscriptionVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']>;
}>;


export type ChannelLiveStatusSubscription = { __typename?: 'Subscription', channelLiveStatusSubscribe?: { __typename?: 'ChannelLiveStatusEvent', liveStatus: ChannelLiveStatus } | null };

export type ChannelLiveStatusUpdateFragment = { __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus };

export type ChannelFollowChannelMutationVariables = Exact<{
  channelId: Scalars['ID'];
  userId: Scalars['ID'];
}>;


export type ChannelFollowChannelMutation = { __typename?: 'Mutation', followChannel?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChannelUnfollowChannelMutationVariables = Exact<{
  channelId: Scalars['ID'];
  userId: Scalars['ID'];
}>;


export type ChannelUnfollowChannelMutation = { __typename?: 'Mutation', unfollowChannel?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChatModerationStatusQueryVariables = Exact<{
  chatId: Scalars['ID'];
  userId: Scalars['ID'];
}>;


export type ChatModerationStatusQuery = { __typename?: 'Query', chatUserStatus?: { __typename?: 'ChatGetChatUserStatusResponse', muted: boolean, muteDuration?: string | null } | null };

export type ChatHistoryQueryVariables = Exact<{
  chatId: Scalars['ID'];
  channelId?: InputMaybe<Scalars['ID']>;
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type ChatHistoryQuery = { __typename?: 'Query', chatMessages?: { __typename?: 'ChatListMessagesResponse', messages: Array<{ __typename?: 'ChatChatMessage', senderId: string, chatId: string, state: ApiEntityState, messageId: string, createdAt: string, moderationStatus: ChatModerationStatus, sender: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, content: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string, attachments: Array<{ __typename?: 'ChatTextMessageAttachment', label: string, source: string, itemId: string, startIndex: number, endIndex: number }>, links: Array<{ __typename: 'ChatTextMessageLink', startIndex: number, endIndex: number, url: string }> } | { __typename?: 'ChatTombstone', emptyTypeWorkaround: boolean } | null } }> } | null };

export type ChatMessageSenderProfileQueryVariables = Exact<{
  userId: Scalars['ID'];
  channelId?: InputMaybe<Scalars['ID']>;
}>;


export type ChatMessageSenderProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type ChatSubscriptionSubscriptionVariables = Exact<{
  chatId: Scalars['ID'];
}>;


export type ChatSubscriptionSubscription = { __typename?: 'Subscription', chatMessageSubscribe?: { __typename?: 'ChatChatEvent', event?: { __typename?: 'ChatChatDetails' } | { __typename?: 'ChatChatMessage', senderId: string, chatId: string, state: ApiEntityState, messageId: string, createdAt: string, moderationStatus: ChatModerationStatus, content: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string, attachments: Array<{ __typename?: 'ChatTextMessageAttachment', label: string, source: string, itemId: string, startIndex: number, endIndex: number }>, links: Array<{ __typename: 'ChatTextMessageLink', startIndex: number, endIndex: number, url: string }> } | { __typename?: 'ChatTombstone', emptyTypeWorkaround: boolean } | null } } | { __typename?: 'ChatHideMessage', messageId: string } | { __typename?: 'ChatMessageDenied', userId: string } | { __typename?: 'ChatPing' } | { __typename?: 'ChatUserBanned', userId: string } | { __typename?: 'ChatUserMuted', userId: string, duration: string } | { __typename?: 'ChatUserUnmuted' } | null } | null };

export type ChatMessageWithSenderFragment = { __typename?: 'ChatChatMessage', senderId: string, chatId: string, state: ApiEntityState, messageId: string, createdAt: string, moderationStatus: ChatModerationStatus, sender: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, content: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string, attachments: Array<{ __typename?: 'ChatTextMessageAttachment', label: string, source: string, itemId: string, startIndex: number, endIndex: number }>, links: Array<{ __typename: 'ChatTextMessageLink', startIndex: number, endIndex: number, url: string }> } | { __typename?: 'ChatTombstone', emptyTypeWorkaround: boolean } | null } };

export type ChatMessageFragment = { __typename?: 'ChatChatMessage', senderId: string, chatId: string, state: ApiEntityState, messageId: string, createdAt: string, moderationStatus: ChatModerationStatus, content: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string, attachments: Array<{ __typename?: 'ChatTextMessageAttachment', label: string, source: string, itemId: string, startIndex: number, endIndex: number }>, links: Array<{ __typename: 'ChatTextMessageLink', startIndex: number, endIndex: number, url: string }> } | { __typename?: 'ChatTombstone', emptyTypeWorkaround: boolean } | null } };

export type UseChatEmojisAndMentionsAttachmentFragment = { __typename?: 'ChatTextMessageAttachment', label: string, source: string, itemId: string, startIndex: number, endIndex: number };

export type ChatMessageLinkFragment = { __typename: 'ChatTextMessageLink', startIndex: number, endIndex: number, url: string };

export type UserBadgeFragment = { __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number };

export type ChatMessageSenderProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type SendChatMessageMutationVariables = Exact<{
  chatId: Scalars['ID'];
  content: ChatTextMessageInput;
  consentToModeration?: InputMaybe<Scalars['Boolean']>;
}>;


export type SendChatMessageMutation = { __typename?: 'Mutation', sendChatMessage?: { __typename?: 'ChatSendMessageResponse', messageId: string } | null };

export type UserInventoryEmojiFragment = { __typename?: 'EmojiEmoji', id: string, label: string, image: string, channelId: string };

export type UserInventoryEmojisChannelFragment = { __typename?: 'ChannelChannel', id: string, logo: string, name: string };

export type UserInventoryEmojisQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']>;
}>;


export type UserInventoryEmojisQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string, label: string, image: string, channelId: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } }> } | null };

export type UserInventoryEmojisChannelsQueryVariables = Exact<{
  channelIds?: InputMaybe<Array<Scalars['String']> | Scalars['String']>;
}>;


export type UserInventoryEmojisChannelsQuery = { __typename?: 'Query', getChannels?: { __typename?: 'ChannelBatchGetChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, logo: string, name: string }> } | null };

export type UpdateChannelNotificationSettingsMutationVariables = Exact<{
  channelId: Scalars['ID'];
  userId: Scalars['ID'];
  enabled: Scalars['Boolean'];
}>;


export type UpdateChannelNotificationSettingsMutation = { __typename?: 'Mutation', updateFollowerNotificationSettings?: { __typename?: 'ChannelFollowerNotificationSettings', userId: string, channelId: string, channelLiveNotificationEnabled: boolean } | null };

export type ChannelNotificationsQueryVariables = Exact<{
  channelId: Scalars['ID'];
  userId: Scalars['ID'];
}>;


export type ChannelNotificationsQuery = { __typename?: 'Query', channelFollowerNotificationSettings?: { __typename?: 'ChannelFollowerNotificationSettings', userId: string, channelId: string, channelLiveNotificationEnabled: boolean } | null };

export type AddPushNotificationTokenMutationVariables = Exact<{
  token: Scalars['String'];
}>;


export type AddPushNotificationTokenMutation = { __typename?: 'Mutation', addPushNotificationToken?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ProfilePrivacyFriendSettingsMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']>;
  disableFriendRequests?: InputMaybe<Scalars['Boolean']>;
}>;


export type ProfilePrivacyFriendSettingsMutation = { __typename?: 'Mutation', updateFriendsSettings?: { __typename?: 'FriendsFriendsSettings', disableFriendRequests: boolean } | null };

export type ProfileAccountMatureContentQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']>;
}>;


export type ProfileAccountMatureContentQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', matureRatedContentAllowed: boolean } | null } | null };

export type ProfilePrivacyHideOnlineStatusMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']>;
  hideOnlineStatus?: InputMaybe<Scalars['Boolean']>;
}>;


export type ProfilePrivacyHideOnlineStatusMutation = { __typename?: 'Mutation', updatePrivacySettings?: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } | null };

export type ProfilePrivacyChangeVisibilityMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']>;
  visibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
}>;


export type ProfilePrivacyChangeVisibilityMutation = { __typename?: 'Mutation', updatePrivacySettings?: { __typename?: 'ProfilePrivacySettings', visibility: ProfilePrivacySettingsVisibility } | null };

export type ProfilePrivacyChangeDiscordIdVisibilityMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']>;
  discordUsernameVisibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
}>;


export type ProfilePrivacyChangeDiscordIdVisibilityMutation = { __typename?: 'Mutation', updatePrivacySettings?: { __typename?: 'ProfilePrivacySettings', discordUsernameVisibility: ProfilePrivacySettingsVisibility } | null };

export type ProfilePrivacyShowContentWarningMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']>;
  showMatureContentWarning?: InputMaybe<Scalars['Boolean']>;
}>;


export type ProfilePrivacyShowContentWarningMutation = { __typename?: 'Mutation', updatePrivacySettings?: { __typename?: 'ProfilePrivacySettings', showMatureContentWarning: boolean } | null };

export type SellableItemsQueryVariables = Exact<{ [key: string]: never; }>;


export type SellableItemsQuery = { __typename?: 'Query', sellableItems?: { __typename?: 'StoreV2ListSellableItemsResponse', items: Array<{ __typename?: 'StoreV2SellableItem', id: string, sku: string, name: string, type: StoreV2ItemType, signature: string, discountPercent: number }> } | null };

export type CurrencyStoreSellableItemFragment = { __typename?: 'StoreV2SellableItem', id: string, sku: string, name: string, type: StoreV2ItemType, signature: string, discountPercent: number };

export type BuyCurrencyPackMutationVariables = Exact<{
  itemId: Scalars['ID'];
  signature: Scalars['String'];
  paymentMethod?: InputMaybe<StoreV2PaymentMethod>;
}>;


export type BuyCurrencyPackMutation = { __typename?: 'Mutation', buyWithPayment?: { __typename?: 'StoreV2BuyWithPaymentResponse', orderId: string, session: { __typename?: 'PaymentSession', session?: { __typename?: 'AdyenSession' } | { __typename?: 'PaymentAppStoreSession', productId: string, paymentId: string } | null } } | null };

export type CancelBuyCurrencyPackOrderMutationVariables = Exact<{
  orderId: Scalars['ID'];
}>;


export type CancelBuyCurrencyPackOrderMutation = { __typename?: 'Mutation', cancelOrder?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type UserPurchaseInfoQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UserPurchaseInfoQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', email: string } | null } | null };

export type FriendStatusUpdateProfileFragment = { __typename?: 'ProfileProfile', userId: string, onlineStatus: ProfilePresenceStatus, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type SocialAcceptFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID'];
  friendId: Scalars['ID'];
}>;


export type SocialAcceptFriendRequestMutation = { __typename?: 'Mutation', acceptFriendRequest?: { __typename?: 'FriendsAcceptFriendRequestResponse', friendId: string, friend: { __typename?: 'ProfileProfile', userId: string, onlineStatus: ProfilePresenceStatus, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } } | null };

export type NewFriendRequestUserFragment = { __typename?: 'FriendsUser', userId: string };

export type SocialBlockUserMutationVariables = Exact<{
  userId: Scalars['ID'];
  blockedUserId: Scalars['ID'];
}>;


export type SocialBlockUserMutation = { __typename?: 'Mutation', blockUser?: { __typename?: 'FriendsBlockUserResponse', blockedUserId: string, blockedUser: { __typename?: 'ProfileProfile', userId: string, onlineStatus: ProfilePresenceStatus, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } } | null };

export type FriendRequestsQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type FriendRequestsQuery = { __typename?: 'Query', receivedFriendRequests?: { __typename?: 'FriendsListReceivedFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, lastStatusChange: string }> } | null, sentFriendRequests?: { __typename?: 'FriendsListSentFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, lastStatusChange: string }> } | null };

export type SocialRemoveFriendMutationVariables = Exact<{
  userId: Scalars['ID'];
  friendId: Scalars['ID'];
}>;


export type SocialRemoveFriendMutation = { __typename?: 'Mutation', removeFriend?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialRemoveReceivedFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID'];
  friendId: Scalars['ID'];
}>;


export type SocialRemoveReceivedFriendRequestMutation = { __typename?: 'Mutation', removeFriendRequest?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialRemoveSentFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID'];
  friendId: Scalars['ID'];
}>;


export type SocialRemoveSentFriendRequestMutation = { __typename?: 'Mutation', removeFriendRequest?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialSendFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID'];
  friendId: Scalars['ID'];
}>;


export type SocialSendFriendRequestMutation = { __typename?: 'Mutation', sendFriendRequest?: { __typename?: 'FriendsSendFriendRequestResponse', friendId: string, friend: { __typename?: 'ProfileProfile', userId: string, onlineStatus: ProfilePresenceStatus, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } } | null };

export type SocialUnblockUserMutationVariables = Exact<{
  userId: Scalars['ID'];
  blockedUserId: Scalars['ID'];
}>;


export type SocialUnblockUserMutation = { __typename?: 'Mutation', unblockUser?: { __typename?: 'FriendsUnblockUserResponse', unblockedUserId: string, unblockedUser: { __typename?: 'ProfileProfile', userId: string, onlineStatus: ProfilePresenceStatus, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } } | null };

export type ChannelSubscribeSubscriptionVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']>;
}>;


export type ChannelSubscribeSubscription = { __typename?: 'Subscription', channelStreamDetailSubscribe?: { __typename?: 'ChannelChannelStreamDetailEvent', channelId: string, liveStatus: ChannelLiveStatus, noicePredictionsEnabled: boolean, streamId: string, gameId: string, matureRatedContent: boolean } | null };

export type ChannelLiveStatusFragment = { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, currentStreamId: string, matureRatedContent: boolean, game: { __typename?: 'GameGame', id: string } };

export type ViewerCountSubscriptionVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']>;
}>;


export type ViewerCountSubscription = { __typename?: 'Subscription', channelViewerCountSubscribe?: { __typename?: 'ChannelViewerCountEvent', viewerCount: number } | null };

export type ChannelViewCountUpdateFragment = { __typename?: 'ChannelChannel', id: string, viewerCount: number };

export type UpdateUserAvatarMutationVariables = Exact<{
  userId: Scalars['ID'];
  avatarId: Scalars['ID'];
}>;


export type UpdateUserAvatarMutation = { __typename?: 'Mutation', updateProfileAvatarV2?: { __typename?: 'AvatarAvatar', id: string } | null };

export type SettingsConnectionDeleteExternalAccountMutationVariables = Exact<{
  userId: Scalars['ID'];
  type: AuthIdentityType;
}>;


export type SettingsConnectionDeleteExternalAccountMutation = { __typename?: 'Mutation', deleteExternalAccount?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SettingsConnectionsDataFragment = { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', externalIds: Array<{ __typename?: 'AuthIdentity', type: AuthIdentityType }> } | null };

export type UserOnboardingStateQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UserOnboardingStateQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', acceptedTerms: Array<{ __typename?: 'AuthTermsVersion', name: string, revision: string }> } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type UseUserPlatformBanQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UseUserPlatformBanQuery = { __typename?: 'Query', platformBan?: { __typename?: 'ModerationPlatformBan', banId: string, status: ModerationBanStatus } | null };

export type ChatProviderDataQueryVariables = Exact<{
  userId: Scalars['ID'];
  chatId: Scalars['ID'];
  channelId: Scalars['ID'];
}>;


export type ChatProviderDataQuery = { __typename?: 'Query', chatUserStatus?: { __typename?: 'ChatGetChatUserStatusResponse', muted: boolean, muteDuration?: string | null } | null, userChannelRoles?: { __typename?: 'ChannelListUserChannelRolesResponse', roles: Array<ChannelChannelRole> } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null };

export type OwnChatSenderInfoProfileQueryVariables = Exact<{
  userId: Scalars['ID'];
  channelId?: InputMaybe<Scalars['ID']>;
}>;


export type OwnChatSenderInfoProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null };

export type MobileMicroSurveyPlayerTraitsQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type MobileMicroSurveyPlayerTraitsQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, stats: { __typename?: 'PlayerStatsPlayerStats', adsWatched: number, matchesPlayed: number, timePlayed?: string | null, cardsPlayed: number, cardsSucceeded: number }, account?: { __typename?: 'AuthAccount', createdAt: string, email: string } | null } | null };

export type AvailableRewardsFragment = { __typename?: 'AdsRewardDescription', readyAt: string };

export type SubscriptionGetChannelEmojisChannelFragment = { __typename?: 'ChannelChannel', subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> }> } | null };

export type SubscriptionTierFragment = { __typename?: 'SubscriptionChannelSubscriptionTier', level: number, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> };

export type SubscriptionGetChannelEmojisChannelEmojiFragment = { __typename?: 'EmojiEmoji', id: string, image: string, name: string };

export type GamesFilterQueryVariables = Exact<{ [key: string]: never; }>;


export type GamesFilterQuery = { __typename?: 'Query', listGames?: { __typename?: 'GameListGamesResponse', games: Array<{ __typename?: 'GameGame', id: string, name: string }> } | null };

export type GamesFilterGameFragment = { __typename?: 'GameGame', id: string, name: string };

export type ChannelUserBanViewQueryQueryVariables = Exact<{
  channelId: Scalars['ID'];
}>;


export type ChannelUserBanViewQueryQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, userBanStatus: { __typename?: 'ChannelUserBanStatus', bannedAt?: string | null, violation: ChannelViolation, description: string, appeal?: { __typename?: 'ChannelBanAppealInfo', appealText: string, status: ChannelAppealStatus, reviewerComment: string } | null } } | null };

export type ChannelViewQueryVariables = Exact<{
  channelName: Scalars['String'];
}>;


export type ChannelViewQuery = { __typename?: 'Query', channelByName?: { __typename?: 'ChannelChannel', id: string, title: string, name: string, thumbnail: string, description: string, currentStreamId: string, liveStatus: ChannelLiveStatus, offlineBanner: string, followerCount: number, viewerCount: number, logo: string, following: boolean, matureRatedContent: boolean, streamer: { __typename?: 'ProfileProfile', userId: string }, userBanStatus: { __typename?: 'ChannelUserBanStatus', banned: boolean }, streamedGames?: Array<{ __typename?: 'GameGame', id: string, name: string }> | null, subscription?: { __typename?: 'SubscriptionChannelSubscription', state: SubscriptionChannelSubscriptionState } | null, links: Array<{ __typename?: 'ChannelChannelLink', type: ChannelChannelLinkLinkType, name: string, url: string }>, channelFriends: { __typename?: 'FriendsChannelFriends', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } }> }, currentStream?: { __typename?: 'ChannelStream', streamId: string, noicePredictionsEnabled: boolean } | null, game: { __typename?: 'GameGame', id: string, name: string } } | null };

export type SubscriptionInfoQueryVariables = Exact<{
  channelId: Scalars['ID'];
}>;


export type SubscriptionInfoQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, name: string, description: string, prices: Array<{ __typename?: 'SubscriptionSubscriptionPrice', period: SubscriptionSubscriptionPricePeriod, price: number }>, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', amount: number, itemId: string }> }> } | null } | null };

export type AddFriendModalViewQueryVariables = Exact<{
  userTag: Scalars['String'];
}>;


export type AddFriendModalViewQuery = { __typename?: 'Query', resolveUserTags?: { __typename?: 'ProfileResolveUserTagsResponse', userIds: Array<{ __typename?: 'ProfileResolveUserTagsResponseUserIdsEntry', key: string, value: string }> } | null };

export type FriendsViewUserFragment = { __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, lastSeen?: string | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', channelId: string, isOnline: boolean, streamId: string, channel?: { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, game: { __typename?: 'GameGame', name: string } } | null } | null };

export type FriendsViewResponseFragment = { __typename?: 'FriendsListFriendsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, lastSeen?: string | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', channelId: string, isOnline: boolean, streamId: string, channel?: { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, game: { __typename?: 'GameGame', name: string } } | null } | null }>, pageInfo: { __typename?: 'APIPageInfo', startCursor: string, endCursor: string, hasPreviousPage: boolean, hasNextPage: boolean } };

export type FriendsViewFriendsQueryVariables = Exact<{
  userId: Scalars['ID'];
  cursor?: InputMaybe<Scalars['String']>;
  pageSize: Scalars['Int'];
}>;


export type FriendsViewFriendsQuery = { __typename?: 'Query', friends?: { __typename?: 'FriendsListFriendsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, lastSeen?: string | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', channelId: string, isOnline: boolean, streamId: string, channel?: { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, game: { __typename?: 'GameGame', name: string } } | null } | null }>, pageInfo: { __typename?: 'APIPageInfo', startCursor: string, endCursor: string, hasPreviousPage: boolean, hasNextPage: boolean } } | null };

export type FriendsViewRequestsQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type FriendsViewRequestsQuery = { __typename?: 'Query', receivedFriendRequests?: { __typename?: 'FriendsListReceivedFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, lastSeen?: string | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', channelId: string, isOnline: boolean, streamId: string, channel?: { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, game: { __typename?: 'GameGame', name: string } } | null } | null }> } | null, sentFriendRequests?: { __typename?: 'FriendsListSentFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, lastSeen?: string | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', channelId: string, isOnline: boolean, streamId: string, channel?: { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, game: { __typename?: 'GameGame', name: string } } | null } | null }> } | null };

export type ActiveFriendsPreviewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type ActiveFriendsPreviewQuery = { __typename?: 'Query', friends?: { __typename?: 'FriendsListFriendsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } }> } | null };

export type LiveChannelsQueryVariables = Exact<{ [key: string]: never; }>;


export type LiveChannelsQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, title: string, following: boolean, name: string, viewerCount: number, thumbnail: string, currentStreamId: string, liveStatus: ChannelLiveStatus, matureRatedContent: boolean, logo: string, channelFriends: { __typename?: 'FriendsChannelFriends', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } }> }, game: { __typename?: 'GameGame', id: string, name: string } }> } | null };

export type ActiveFriendsPreviewItemFragment = { __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } };

export type ProfileGamesListFragment = { __typename?: 'ProfileProfile', playedGames: Array<{ __typename?: 'ProfilePlayedGame', userId: string, id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, progression: { __typename?: 'ProgressionSeasonProgression', seasonId: string, xpAmount: number, level: number, nextLevelThreshold: number } } } }> };

export type ProfileViewFriendsFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null };

export type UserTagQueryVariables = Exact<{
  userTag: Scalars['String'];
}>;


export type UserTagQuery = { __typename?: 'Query', resolveUserTags?: { __typename?: 'ProfileResolveUserTagsResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, visibility: ProfileProfileVisibility }> } | null };

export type ProfileViewQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']>;
}>;


export type ProfileViewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null, friends: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }>, stats: { __typename?: 'PlayerStatsPlayerStats', matchesPlayed: number, timePlayed?: string | null, cardsSucceeded: number, dailyGoalCardsCompleted: number }, playedGames: Array<{ __typename?: 'ProfilePlayedGame', userId: string, id: string, game: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, progression: { __typename?: 'ProgressionSeasonProgression', seasonId: string, xpAmount: number, level: number, nextLevelThreshold: number } } } }>, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null } | null };

export type ReportedStreamerProfileQueryVariables = Exact<{
  channelId: Scalars['ID'];
}>;


export type ReportedStreamerProfileQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, logo: string } | null };

export type ReportUserMutationVariables = Exact<{
  reason: SupportReportReason;
  description?: InputMaybe<Scalars['String']>;
  context: SupportReportContextInput;
}>;


export type ReportUserMutation = { __typename?: 'Mutation', createReport?: { __typename?: 'SupportReport', createdAt: string } | null };

export type ReportedUserQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type ReportedUserQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null };

export type RewardHintFragment = { __typename?: 'AdsGetPlacementResponse', placementId: string, reward: { __typename?: 'AdsRewardDescription', rarity: RarityRarity, prizes: Array<{ __typename?: 'AdsRewardDescriptionPrizeDescription', kind: AdsRewardDescriptionPrizeDescriptionKind, value: string, min: number, max: number, amount: number }> } };

export type VideoRewardRowFragment = { __typename?: 'AdsGetPlacementResponse', placementId: string, rewards: Array<{ __typename?: 'AdsRewardDescription', rarity: RarityRarity }> };

export type AdsPlacementQueryVariables = Exact<{
  placementId?: InputMaybe<Scalars['ID']>;
}>;


export type AdsPlacementQuery = { __typename?: 'Query', placement?: { __typename?: 'AdsGetPlacementResponse', placementId: string, reward: { __typename?: 'AdsRewardDescription', rarity: RarityRarity, readyAt: string, prizes: Array<{ __typename?: 'AdsRewardDescriptionPrizeDescription', kind: AdsRewardDescriptionPrizeDescriptionKind, value: string, min: number, max: number, amount: number }> }, rewards: Array<{ __typename?: 'AdsRewardDescription', rarity: RarityRarity }> } | null };

export type AdsRewardPlacementMutationVariables = Exact<{
  placementId?: InputMaybe<Scalars['ID']>;
}>;


export type AdsRewardPlacementMutation = { __typename?: 'Mutation', rewardPlacement?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type StreamChatViewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type StreamChatViewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type StreamChatMessageQueryVariables = Exact<{
  userId: Scalars['ID'];
  channelId?: InputMaybe<Scalars['ID']>;
}>;


export type StreamChatMessageQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null };

export type StreamInfoChannelFragment = { __typename?: 'ChannelChannel', name: string, title: string, following: boolean, matureRatedContent: boolean, logo: string, currentStream?: { __typename?: 'ChannelStream', streamId: string, noicePredictionsEnabled: boolean } | null, game: { __typename?: 'GameGame', id: string, name: string }, subscription?: { __typename?: 'SubscriptionChannelSubscription', state: SubscriptionChannelSubscriptionState } | null };

export type StreamPlayerFragment = { __typename?: 'ChannelChannel', viewerCount: number, activeStream?: { __typename?: 'ChannelStreamSummary', startTime: string, streamId: string } | null };

export type StreamPlayerActionOverlayFragment = { __typename?: 'ChannelChannel', viewerCount: number, activeStream?: { __typename?: 'ChannelStreamSummary', startTime: string, streamId: string } | null };

export type StreamProfileModalViewQueryVariables = Exact<{
  userId: Scalars['ID'];
  channelId: Scalars['ID'];
}>;


export type StreamProfileModalViewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, discordUsername?: string | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null, userChannelSubscription?: { __typename?: 'SubscriptionChannelSubscription', activatedAt?: string | null } | null };

export type StreamViewChannelQueryQueryVariables = Exact<{
  channelId: Scalars['ID'];
}>;


export type StreamViewChannelQueryQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, currentChatId?: string | null, followerCount: number, matureRatedContent: boolean, name: string, title: string, following: boolean, logo: string, viewerCount: number, userBanStatus: { __typename?: 'ChannelUserBanStatus', banned: boolean }, streamer: { __typename?: 'ProfileProfile', userId: string }, currentStream?: { __typename?: 'ChannelStream', streamId: string, noicePredictionsEnabled: boolean } | null, game: { __typename?: 'GameGame', id: string, name: string }, subscription?: { __typename?: 'SubscriptionChannelSubscription', state: SubscriptionChannelSubscriptionState } | null, activeStream?: { __typename?: 'ChannelStreamSummary', startTime: string, streamId: string } | null } | null };

export type ManageSubscriptionQueryVariables = Exact<{
  channelId: Scalars['ID'];
  userId: Scalars['ID'];
}>;


export type ManageSubscriptionQuery = { __typename?: 'Query', userChannelSubscription?: { __typename?: 'SubscriptionChannelSubscription', provider: SubscriptionChannelSubscriptionProvider } | null };

export type SubscriptionModalQueryVariables = Exact<{
  channelId: Scalars['ID'];
}>;


export type SubscriptionModalQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', name: string, logo: string, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> }> } | null } | null };

export type UpdateStreamSubscriptionFragment = { __typename: 'ChannelChannel', id: string, subscription?: { __typename: 'SubscriptionChannelSubscription', state: SubscriptionChannelSubscriptionState } | null };

export type SubscriptionsSettingListQueryVariables = Exact<{
  userId: Scalars['ID'];
  cursor?: InputMaybe<Scalars['String']>;
}>;


export type SubscriptionsSettingListQuery = { __typename?: 'Query', userChannelSubscriptions?: { __typename?: 'SubscriptionListUserChannelSubscriptionsResponse', subscriptions: Array<{ __typename?: 'SubscriptionChannelSubscription', id: string, state: SubscriptionChannelSubscriptionState, activatedAt?: string | null, expiresAt?: string | null, cancelledAt?: string | null, paymentFailedAt?: string | null, externalReference: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, offlineBanner: string, logo: string, subscription?: { __typename?: 'SubscriptionChannelSubscription', tier: number, provider: SubscriptionChannelSubscriptionProvider } | null } }>, pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean } } | null };

export type CreatePlatformBanAppealMutationVariables = Exact<{
  userId: Scalars['ID'];
  appealText: Scalars['String'];
}>;


export type CreatePlatformBanAppealMutation = { __typename?: 'Mutation', createPlatformBanAppeal?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type UserPlatformBanViewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UserPlatformBanViewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null, platformBan?: { __typename?: 'ModerationPlatformBan', banId: string, status: ModerationBanStatus, violation: ModerationViolation, description: string, bannedAt: string, expiresAt?: string | null, appeal?: { __typename?: 'ModerationPlatformBanAppeal', banId: string, status: ModerationAppealStatus, appealText: string } | null } | null };

export type UserSettingsViewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UserSettingsViewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', roles: Array<AuthPlatformRole> } | null } | null };

export type UserAccountViewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UserAccountViewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', email: string } | null } | null };

export type DeleteOwnAccountMutationVariables = Exact<{ [key: string]: never; }>;


export type DeleteOwnAccountMutation = { __typename?: 'Mutation', deleteUserData?: { __typename?: 'PrivacyDeleteUserDataResponse', taskId: string } | null };

export type UserBlockedViewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UserBlockedViewQuery = { __typename?: 'Query', blockedUsers?: { __typename?: 'FriendsListBlockedUsersResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userTag: string, userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } }> } | null };

export type UserConnectionsViewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UserConnectionsViewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', uid: string, externalIds: Array<{ __typename?: 'AuthIdentity', type: AuthIdentityType }> } | null } | null };

export type UserDeveloperViewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UserDeveloperViewQuery = { __typename?: 'Query', userFeatureFlags?: { __typename?: 'FlagListUserFeatureFlagsResponse', flags: Array<{ __typename?: 'FlagFeatureFlagState', name: string, value: string, revision: string }> } | null };

export type UserPrivacyViewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UserPrivacyViewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', externalIds: Array<{ __typename?: 'AuthIdentity', id: string, type: AuthIdentityType }> } | null } | null, blockedUsers?: { __typename?: 'FriendsListBlockedUsersResponse', users: Array<{ __typename?: 'FriendsUser', userId: string }> } | null };

export type ProfilePrivacySettingsQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']>;
}>;


export type ProfilePrivacySettingsQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', matureRatedContentAllowed: boolean } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean, visibility: ProfilePrivacySettingsVisibility, discordUsernameVisibility: ProfilePrivacySettingsVisibility, showMatureContentWarning: boolean }, friends: { __typename?: 'FriendsFriendsSettings', disableFriendRequests: boolean } } | null } | null };

export type UserProfileInfoViewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UserProfileInfoViewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type UserViewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type UserViewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null };

export type AcceptTermsViewQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;


export type AcceptTermsViewQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type SignTermsAgreementMutationVariables = Exact<{
  agreement: AuthTermsVersionInput;
}>;


export type SignTermsAgreementMutation = { __typename?: 'Mutation', signAgreements?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type AvatarSelectorViewQueryVariables = Exact<{ [key: string]: never; }>;


export type AvatarSelectorViewQuery = { __typename?: 'Query', avatars?: { __typename?: 'AvatarListAvatarsResponse', avatars: Array<{ __typename?: 'AvatarAvatar', id: string, gender: string, face: string, body: string, avatar3D: string, avatarLods: Array<string>, selectable: boolean }> } | null };

export type TestChannelQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type TestChannelQueryQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string }> } | null };

export type ChatChannelEventsSubscriptionSubscriptionVariables = Exact<{
  channelId: Scalars['ID'];
}>;


export type ChatChannelEventsSubscriptionSubscription = { __typename?: 'Subscription', channelEventsSubscribe?: { __typename?: 'ChannelChannelEvent', channelId: string, createdAt: string, id: string, content: { __typename?: 'ChannelChannelEventContent', content?: { __typename?: 'ChannelAvatarItemPurchase', itemId: string, item: { __typename?: 'ItemItem', id: string, name: string }, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string } | null } | { __typename?: 'ChannelBundlePurchase', bundleName: string, userId: string, streamerCards?: Array<{ __typename?: 'GameLogicStreamerCard', id: string, channelId: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string } }> | null, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string } | null } | { __typename?: 'ChannelGiftSubscriptionPurchase', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, recipients?: Array<{ __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> }> | null } | { __typename?: 'ChannelStreamerCardPurchase', userId: string, streamerCard: { __typename?: 'GameLogicStreamerCard', id: string, channelId: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string } }, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string } | null } | { __typename?: 'ChannelSubscriptionPurchase', userId: string, tier: number, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null } | { __typename?: 'ChannelSubscriptionRenewal' } | null } } | null };

export type ChannelEventContentProfileFragment = { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string };

export type ChannelEventSubscriptionContentProfileFragment = { __typename?: 'ProfileProfile', badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type ChannelEventAvatarItemPurchaseItemFragment = { __typename?: 'ItemItem', id: string, name: string };

export type ChatMessageAttachmentsFragment = { __typename: 'ChatTextMessageAttachment', label: string, source: string, startIndex: number, endIndex: number };

export type ChatMessagesHookProfileFragment = { __typename?: 'ProfileProfile', userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type SendChatMessageProfileFragment = { __typename?: 'ProfileProfile', userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type InventoryEmojiFragment = { __typename?: 'EmojiEmoji', id: string, label: string, image: string, channelId: string };

export type InventoryEmojisQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']>;
}>;


export type InventoryEmojisQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string, label: string, image: string, channelId: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } }> } | null };

export type SocialChannelBanMutationVariables = Exact<{
  userId: Scalars['ID'];
  channelId: Scalars['ID'];
  violation?: InputMaybe<ChannelViolation>;
  description?: InputMaybe<Scalars['String']>;
  keepRecentMessages?: InputMaybe<Scalars['Boolean']>;
}>;


export type SocialChannelBanMutation = { __typename?: 'Mutation', banChannelUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialChannelUnbanMutationVariables = Exact<{
  userId: Scalars['ID'];
  channelId: Scalars['ID'];
}>;


export type SocialChannelUnbanMutation = { __typename?: 'Mutation', unbanChannelUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export const AvatarSelectorOptionFragmentDoc = gql`
    fragment AvatarSelectorOption on AvatarAvatar {
  id
  gender
  face
  body
  avatar3D
  avatarLods
  selectable
}
    `;
export const ChannelViewLinksFragmentDoc = gql`
    fragment ChannelViewLinks on ChannelChannel {
  links {
    type
    name
    url
  }
}
    `;
export const ChannelLogoFragmentDoc = gql`
    fragment ChannelLogo on ChannelChannel {
  logo
  name
}
    `;
export const ChannelDetailsFragmentDoc = gql`
    fragment ChannelDetails on ChannelChannel {
  matureRatedContent
  liveStatus
  ...ChannelLogo
}
    ${ChannelLogoFragmentDoc}`;
export const AvatarViewFragmentDoc = gql`
    fragment AvatarView on ProfileProfile {
  userId
  settings {
    privacy {
      hideOnlineStatus
    }
  }
  userTag
  avatars {
    avatar2D
    avatarFullbody
  }
}
    `;
export const ActiveFriendsPreviewItemFragmentDoc = gql`
    fragment ActiveFriendsPreviewItem on FriendsUser {
  userId
  profile {
    ...AvatarView
  }
}
    ${AvatarViewFragmentDoc}`;
export const OnlineChannelPreviewViewFragmentDoc = gql`
    fragment OnlineChannelPreviewView on ChannelChannel {
  id
  title
  following
  name
  viewerCount
  thumbnail
  currentStreamId
  liveStatus
  ...ChannelDetails
  channelFriends {
    users {
      userId
      ...ActiveFriendsPreviewItem
    }
  }
  game {
    id
    name
  }
}
    ${ChannelDetailsFragmentDoc}
${ActiveFriendsPreviewItemFragmentDoc}`;
export const OfflineChannelThumbnailFragmentDoc = gql`
    fragment OfflineChannelThumbnail on ChannelChannel {
  id
  name
  offlineBanner
  following
  followerCount
  ...ChannelDetails
}
    ${ChannelDetailsFragmentDoc}`;
export const ChannelDataFragmentDoc = gql`
    fragment ChannelData on ChannelChannel {
  id
  following
  ...OnlineChannelPreviewView
  ...OfflineChannelThumbnail
}
    ${OnlineChannelPreviewViewFragmentDoc}
${OfflineChannelThumbnailFragmentDoc}`;
export const FollowedChannelsRowChannelDataFragmentDoc = gql`
    fragment FollowedChannelsRowChannelData on ChannelChannel {
  id
  currentStreamId
  name
  liveStatus
  ...ChannelLogo
}
    ${ChannelLogoFragmentDoc}`;
export const StreamInfoChannelFragmentDoc = gql`
    fragment StreamInfoChannel on ChannelChannel {
  name
  title
  following
  matureRatedContent
  currentStream {
    streamId
    noicePredictionsEnabled
  }
  game {
    id
    name
  }
  subscription {
    state
  }
  ...ChannelLogo
}
    ${ChannelLogoFragmentDoc}`;
export const StreamPreviewCardFragmentDoc = gql`
    fragment StreamPreviewCard on ChannelChannel {
  currentStreamId
  viewerCount
  channelFriends {
    users {
      userId
      profile {
        ...AvatarView
      }
    }
  }
  ...StreamInfoChannel
}
    ${AvatarViewFragmentDoc}
${StreamInfoChannelFragmentDoc}`;
export const SubscriptionSettingItemSubscriptionFragmentDoc = gql`
    fragment SubscriptionSettingItemSubscription on SubscriptionChannelSubscription {
  id
  activatedAt
  expiresAt
  cancelledAt
  state
  paymentFailedAt
  externalReference
  channel {
    subscription {
      tier
      provider
    }
    id
    name
    offlineBanner
    logo
  }
}
    `;
export const UserHeaderRowFragmentDoc = gql`
    fragment UserHeaderRow on ProfileProfile {
  userId
  userTag
  onlineStatus
  ...AvatarView
}
    ${AvatarViewFragmentDoc}`;
export const ChannelLiveStatusUpdateFragmentDoc = gql`
    fragment ChannelLiveStatusUpdate on ChannelChannel {
  id
  liveStatus
}
    `;
export const UseChatEmojisAndMentionsAttachmentFragmentDoc = gql`
    fragment UseChatEmojisAndMentionsAttachment on ChatTextMessageAttachment {
  label
  source
  itemId
  startIndex
  endIndex
}
    `;
export const ChatMessageLinkFragmentDoc = gql`
    fragment ChatMessageLink on ChatTextMessageLink {
  startIndex
  endIndex
  url
  __typename
}
    `;
export const ChatMessageFragmentDoc = gql`
    fragment ChatMessage on ChatChatMessage {
  senderId
  chatId
  state
  messageId
  createdAt
  moderationStatus
  content {
    content {
      ... on ChatTextMessage {
        text
        attachments {
          ...UseChatEmojisAndMentionsAttachment
        }
        links {
          ...ChatMessageLink
        }
      }
      ... on ChatTombstone {
        emptyTypeWorkaround
      }
    }
  }
}
    ${UseChatEmojisAndMentionsAttachmentFragmentDoc}
${ChatMessageLinkFragmentDoc}`;
export const ChatMessageSenderProfileFragmentDoc = gql`
    fragment ChatMessageSenderProfile on ProfileProfile {
  userId
  userTag
  preferredColor
  avatars {
    avatar2D
  }
}
    `;
export const ChatMessageWithSenderFragmentDoc = gql`
    fragment ChatMessageWithSender on ChatChatMessage {
  ...ChatMessage
  sender {
    ...ChatMessageSenderProfile
  }
}
    ${ChatMessageFragmentDoc}
${ChatMessageSenderProfileFragmentDoc}`;
export const UserBadgeFragmentDoc = gql`
    fragment UserBadge on BadgeBadge {
  type
  level
}
    `;
export const UserInventoryEmojiFragmentDoc = gql`
    fragment UserInventoryEmoji on EmojiEmoji {
  id
  label
  image
  channelId
}
    `;
export const UserInventoryEmojisChannelFragmentDoc = gql`
    fragment UserInventoryEmojisChannel on ChannelChannel {
  id
  logo
  name
}
    `;
export const CurrencyStoreSellableItemFragmentDoc = gql`
    fragment CurrencyStoreSellableItem on StoreV2SellableItem {
  id
  sku
  name
  type
  signature
  discountPercent
}
    `;
export const FriendStatusUpdateProfileFragmentDoc = gql`
    fragment FriendStatusUpdateProfile on ProfileProfile {
  userId
  friendshipStatus {
    status
  }
  onlineStatus
}
    `;
export const NewFriendRequestUserFragmentDoc = gql`
    fragment NewFriendRequestUser on FriendsUser {
  userId
}
    `;
export const ChannelLiveStatusFragmentDoc = gql`
    fragment ChannelLiveStatus on ChannelChannel {
  liveStatus
  currentStreamId
  game {
    id
  }
  matureRatedContent
}
    `;
export const ChannelViewCountUpdateFragmentDoc = gql`
    fragment ChannelViewCountUpdate on ChannelChannel {
  id
  viewerCount
}
    `;
export const SettingsConnectionsDataFragmentDoc = gql`
    fragment SettingsConnectionsData on ProfileProfile {
  userId
  account {
    externalIds {
      type
    }
  }
}
    `;
export const AvailableRewardsFragmentDoc = gql`
    fragment AvailableRewards on AdsRewardDescription {
  readyAt
}
    `;
export const SubscriptionGetChannelEmojisChannelEmojiFragmentDoc = gql`
    fragment SubscriptionGetChannelEmojisChannelEmoji on EmojiEmoji {
  id
  image
  name
}
    `;
export const SubscriptionTierFragmentDoc = gql`
    fragment SubscriptionTier on SubscriptionChannelSubscriptionTier {
  level
  entitlements {
    itemId
    item {
      id
      type
      children {
        id
        type
        details {
          ... on EmojiEmoji {
            ...SubscriptionGetChannelEmojisChannelEmoji
          }
        }
      }
    }
  }
}
    ${SubscriptionGetChannelEmojisChannelEmojiFragmentDoc}`;
export const SubscriptionGetChannelEmojisChannelFragmentDoc = gql`
    fragment SubscriptionGetChannelEmojisChannel on ChannelChannel {
  subscriptionConfig {
    channelId
    tiers {
      ...SubscriptionTier
    }
  }
}
    ${SubscriptionTierFragmentDoc}`;
export const GamesFilterGameFragmentDoc = gql`
    fragment GamesFilterGame on GameGame {
  id
  name
}
    `;
export const FriendsViewUserFragmentDoc = gql`
    fragment FriendsViewUser on FriendsUser {
  userId
  profile {
    userId
    userTag
    onlineStatus
    lastSeen
    avatars {
      avatar2D
    }
    ...AvatarView
  }
  activity {
    channelId
    isOnline
    streamId
    channel {
      name
      liveStatus
      game {
        name
      }
    }
  }
}
    ${AvatarViewFragmentDoc}`;
export const FriendsViewResponseFragmentDoc = gql`
    fragment FriendsViewResponse on FriendsListFriendsResponse {
  users {
    ...FriendsViewUser
  }
  pageInfo {
    startCursor
    endCursor
    hasPreviousPage
    hasNextPage
  }
}
    ${FriendsViewUserFragmentDoc}`;
export const ProfileGamesListFragmentDoc = gql`
    fragment ProfileGamesList on ProfileProfile {
  playedGames {
    userId
    id
    game {
      id
      name
      activeSeason {
        id
        progression {
          seasonId
          xpAmount
          level
          nextLevelThreshold
        }
      }
    }
  }
}
    `;
export const ProfileViewFriendsFragmentDoc = gql`
    fragment ProfileViewFriends on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
  onlineStatus
  ...AvatarView
}
    ${AvatarViewFragmentDoc}`;
export const RewardHintFragmentDoc = gql`
    fragment RewardHint on AdsGetPlacementResponse {
  placementId
  reward {
    rarity
    prizes {
      kind
      value
      min
      max
      amount
    }
  }
}
    `;
export const VideoRewardRowFragmentDoc = gql`
    fragment VideoRewardRow on AdsGetPlacementResponse {
  placementId
  rewards {
    rarity
  }
}
    `;
export const StreamPlayerActionOverlayFragmentDoc = gql`
    fragment StreamPlayerActionOverlay on ChannelChannel {
  viewerCount
  activeStream {
    startTime
    streamId
  }
}
    `;
export const StreamPlayerFragmentDoc = gql`
    fragment StreamPlayer on ChannelChannel {
  ...StreamPlayerActionOverlay
}
    ${StreamPlayerActionOverlayFragmentDoc}`;
export const UpdateStreamSubscriptionFragmentDoc = gql`
    fragment UpdateStreamSubscription on ChannelChannel {
  __typename
  id
  subscription {
    __typename
    state
  }
}
    `;
export const ChannelEventContentProfileFragmentDoc = gql`
    fragment ChannelEventContentProfile on ProfileProfile {
  preferredColor
  userId
  userTag
}
    `;
export const ChannelEventSubscriptionContentProfileFragmentDoc = gql`
    fragment ChannelEventSubscriptionContentProfile on ProfileProfile {
  badges(channel_id: $channelId) {
    type
    level
  }
}
    `;
export const ChannelEventAvatarItemPurchaseItemFragmentDoc = gql`
    fragment ChannelEventAvatarItemPurchaseItem on ItemItem {
  id
  name
}
    `;
export const ChatMessageAttachmentsFragmentDoc = gql`
    fragment ChatMessageAttachments on ChatTextMessageAttachment {
  label
  source
  startIndex
  endIndex
  __typename
}
    `;
export const SendChatMessageProfileFragmentDoc = gql`
    fragment SendChatMessageProfile on ProfileProfile {
  userTag
  avatars {
    avatar2D
  }
  badges(channel_id: $channelId) {
    type
    level
  }
  preferredColor
}
    `;
export const ChatMessagesHookProfileFragmentDoc = gql`
    fragment ChatMessagesHookProfile on ProfileProfile {
  ...SendChatMessageProfile
}
    ${SendChatMessageProfileFragmentDoc}`;
export const InventoryEmojiFragmentDoc = gql`
    fragment InventoryEmoji on EmojiEmoji {
  id
  label
  image
  channelId
}
    `;
export const ChannelListDocument = gql`
    query ChannelList($liveStatus: ChannelLiveStatus, $gameId: ID, $cursor: APICursorInput) {
  channels(liveStatus: $liveStatus, gameId: $gameId, cursor: $cursor) {
    channels {
      ...ChannelData
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
    ${ChannelDataFragmentDoc}`;

/**
 * __useChannelListQuery__
 *
 * To run a query within a React component, call `useChannelListQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelListQuery({
 *   variables: {
 *      liveStatus: // value for 'liveStatus'
 *      gameId: // value for 'gameId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useChannelListQuery(baseOptions?: Apollo.QueryHookOptions<ChannelListQuery, ChannelListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelListQuery, ChannelListQueryVariables>(ChannelListDocument, options);
      }
export function useChannelListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelListQuery, ChannelListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelListQuery, ChannelListQueryVariables>(ChannelListDocument, options);
        }
export type ChannelListQueryHookResult = ReturnType<typeof useChannelListQuery>;
export type ChannelListLazyQueryHookResult = ReturnType<typeof useChannelListLazyQuery>;
export type ChannelListQueryResult = Apollo.QueryResult<ChannelListQuery, ChannelListQueryVariables>;
export const CurrencyInfoRowDocument = gql`
    query CurrencyInfoRow($userId: ID!) {
  wallet(userId: $userId) {
    wallet {
      currencies {
        currencyId
        currencyAmount
      }
    }
  }
}
    `;

/**
 * __useCurrencyInfoRowQuery__
 *
 * To run a query within a React component, call `useCurrencyInfoRowQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrencyInfoRowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrencyInfoRowQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useCurrencyInfoRowQuery(baseOptions: Apollo.QueryHookOptions<CurrencyInfoRowQuery, CurrencyInfoRowQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CurrencyInfoRowQuery, CurrencyInfoRowQueryVariables>(CurrencyInfoRowDocument, options);
      }
export function useCurrencyInfoRowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CurrencyInfoRowQuery, CurrencyInfoRowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CurrencyInfoRowQuery, CurrencyInfoRowQueryVariables>(CurrencyInfoRowDocument, options);
        }
export type CurrencyInfoRowQueryHookResult = ReturnType<typeof useCurrencyInfoRowQuery>;
export type CurrencyInfoRowLazyQueryHookResult = ReturnType<typeof useCurrencyInfoRowLazyQuery>;
export type CurrencyInfoRowQueryResult = Apollo.QueryResult<CurrencyInfoRowQuery, CurrencyInfoRowQueryVariables>;
export const FollowedChannelsRowDocument = gql`
    query FollowedChannelsRow($userId: ID!) {
  followedChannels(userId: $userId) {
    channels {
      ...FollowedChannelsRowChannelData
    }
  }
}
    ${FollowedChannelsRowChannelDataFragmentDoc}`;

/**
 * __useFollowedChannelsRowQuery__
 *
 * To run a query within a React component, call `useFollowedChannelsRowQuery` and pass it any options that fit your needs.
 * When your component renders, `useFollowedChannelsRowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFollowedChannelsRowQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFollowedChannelsRowQuery(baseOptions: Apollo.QueryHookOptions<FollowedChannelsRowQuery, FollowedChannelsRowQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FollowedChannelsRowQuery, FollowedChannelsRowQueryVariables>(FollowedChannelsRowDocument, options);
      }
export function useFollowedChannelsRowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FollowedChannelsRowQuery, FollowedChannelsRowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FollowedChannelsRowQuery, FollowedChannelsRowQueryVariables>(FollowedChannelsRowDocument, options);
        }
export type FollowedChannelsRowQueryHookResult = ReturnType<typeof useFollowedChannelsRowQuery>;
export type FollowedChannelsRowLazyQueryHookResult = ReturnType<typeof useFollowedChannelsRowLazyQuery>;
export type FollowedChannelsRowQueryResult = Apollo.QueryResult<FollowedChannelsRowQuery, FollowedChannelsRowQueryVariables>;
export const TimeAdsRewardsDocument = gql`
    query TimeAdsRewards($placementId: ID!) {
  placement(placementId: $placementId) {
    placementId
    rewards {
      ...AvailableRewards
    }
  }
}
    ${AvailableRewardsFragmentDoc}`;

/**
 * __useTimeAdsRewardsQuery__
 *
 * To run a query within a React component, call `useTimeAdsRewardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTimeAdsRewardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTimeAdsRewardsQuery({
 *   variables: {
 *      placementId: // value for 'placementId'
 *   },
 * });
 */
export function useTimeAdsRewardsQuery(baseOptions: Apollo.QueryHookOptions<TimeAdsRewardsQuery, TimeAdsRewardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TimeAdsRewardsQuery, TimeAdsRewardsQueryVariables>(TimeAdsRewardsDocument, options);
      }
export function useTimeAdsRewardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TimeAdsRewardsQuery, TimeAdsRewardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TimeAdsRewardsQuery, TimeAdsRewardsQueryVariables>(TimeAdsRewardsDocument, options);
        }
export type TimeAdsRewardsQueryHookResult = ReturnType<typeof useTimeAdsRewardsQuery>;
export type TimeAdsRewardsLazyQueryHookResult = ReturnType<typeof useTimeAdsRewardsLazyQuery>;
export type TimeAdsRewardsQueryResult = Apollo.QueryResult<TimeAdsRewardsQuery, TimeAdsRewardsQueryVariables>;
export const CurrenciesDocument = gql`
    query Currencies($userId: ID!) {
  wallet(userId: $userId) {
    wallet {
      currencies {
        currencyId
        currencyAmount
      }
    }
  }
}
    `;

/**
 * __useCurrenciesQuery__
 *
 * To run a query within a React component, call `useCurrenciesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrenciesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrenciesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useCurrenciesQuery(baseOptions: Apollo.QueryHookOptions<CurrenciesQuery, CurrenciesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CurrenciesQuery, CurrenciesQueryVariables>(CurrenciesDocument, options);
      }
export function useCurrenciesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CurrenciesQuery, CurrenciesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CurrenciesQuery, CurrenciesQueryVariables>(CurrenciesDocument, options);
        }
export type CurrenciesQueryHookResult = ReturnType<typeof useCurrenciesQuery>;
export type CurrenciesLazyQueryHookResult = ReturnType<typeof useCurrenciesLazyQuery>;
export type CurrenciesQueryResult = Apollo.QueryResult<CurrenciesQuery, CurrenciesQueryVariables>;
export const HeaderAvatarPreviewDocument = gql`
    query HeaderAvatarPreview($userId: ID!) {
  profile(userId: $userId) {
    ...AvatarView
    onlineStatus
  }
}
    ${AvatarViewFragmentDoc}`;

/**
 * __useHeaderAvatarPreviewQuery__
 *
 * To run a query within a React component, call `useHeaderAvatarPreviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useHeaderAvatarPreviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHeaderAvatarPreviewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useHeaderAvatarPreviewQuery(baseOptions: Apollo.QueryHookOptions<HeaderAvatarPreviewQuery, HeaderAvatarPreviewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HeaderAvatarPreviewQuery, HeaderAvatarPreviewQueryVariables>(HeaderAvatarPreviewDocument, options);
      }
export function useHeaderAvatarPreviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HeaderAvatarPreviewQuery, HeaderAvatarPreviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HeaderAvatarPreviewQuery, HeaderAvatarPreviewQueryVariables>(HeaderAvatarPreviewDocument, options);
        }
export type HeaderAvatarPreviewQueryHookResult = ReturnType<typeof useHeaderAvatarPreviewQuery>;
export type HeaderAvatarPreviewLazyQueryHookResult = ReturnType<typeof useHeaderAvatarPreviewLazyQuery>;
export type HeaderAvatarPreviewQueryResult = Apollo.QueryResult<HeaderAvatarPreviewQuery, HeaderAvatarPreviewQueryVariables>;
export const StreamCategoriesDocument = gql`
    query StreamCategories {
  listGames {
    games {
      id
      name
    }
  }
}
    `;

/**
 * __useStreamCategoriesQuery__
 *
 * To run a query within a React component, call `useStreamCategoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamCategoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamCategoriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useStreamCategoriesQuery(baseOptions?: Apollo.QueryHookOptions<StreamCategoriesQuery, StreamCategoriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamCategoriesQuery, StreamCategoriesQueryVariables>(StreamCategoriesDocument, options);
      }
export function useStreamCategoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamCategoriesQuery, StreamCategoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamCategoriesQuery, StreamCategoriesQueryVariables>(StreamCategoriesDocument, options);
        }
export type StreamCategoriesQueryHookResult = ReturnType<typeof useStreamCategoriesQuery>;
export type StreamCategoriesLazyQueryHookResult = ReturnType<typeof useStreamCategoriesLazyQuery>;
export type StreamCategoriesQueryResult = Apollo.QueryResult<StreamCategoriesQuery, StreamCategoriesQueryVariables>;
export const SubscriptionItemBadgeDocument = gql`
    query SubscriptionItemBadge($channelId: ID!, $userId: ID!) {
  profile(userId: $userId) {
    userId
    badges(channel_id: $channelId) {
      level
      ...UserBadge
    }
  }
}
    ${UserBadgeFragmentDoc}`;

/**
 * __useSubscriptionItemBadgeQuery__
 *
 * To run a query within a React component, call `useSubscriptionItemBadgeQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionItemBadgeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionItemBadgeQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSubscriptionItemBadgeQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionItemBadgeQuery, SubscriptionItemBadgeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionItemBadgeQuery, SubscriptionItemBadgeQueryVariables>(SubscriptionItemBadgeDocument, options);
      }
export function useSubscriptionItemBadgeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionItemBadgeQuery, SubscriptionItemBadgeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionItemBadgeQuery, SubscriptionItemBadgeQueryVariables>(SubscriptionItemBadgeDocument, options);
        }
export type SubscriptionItemBadgeQueryHookResult = ReturnType<typeof useSubscriptionItemBadgeQuery>;
export type SubscriptionItemBadgeLazyQueryHookResult = ReturnType<typeof useSubscriptionItemBadgeLazyQuery>;
export type SubscriptionItemBadgeQueryResult = Apollo.QueryResult<SubscriptionItemBadgeQuery, SubscriptionItemBadgeQueryVariables>;
export const ChannelFollowingDocument = gql`
    query ChannelFollowing($channelId: ID!) {
  channel(id: $channelId) {
    id
    following
  }
}
    `;

/**
 * __useChannelFollowingQuery__
 *
 * To run a query within a React component, call `useChannelFollowingQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelFollowingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelFollowingQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelFollowingQuery(baseOptions: Apollo.QueryHookOptions<ChannelFollowingQuery, ChannelFollowingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelFollowingQuery, ChannelFollowingQueryVariables>(ChannelFollowingDocument, options);
      }
export function useChannelFollowingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelFollowingQuery, ChannelFollowingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelFollowingQuery, ChannelFollowingQueryVariables>(ChannelFollowingDocument, options);
        }
export type ChannelFollowingQueryHookResult = ReturnType<typeof useChannelFollowingQuery>;
export type ChannelFollowingLazyQueryHookResult = ReturnType<typeof useChannelFollowingLazyQuery>;
export type ChannelFollowingQueryResult = Apollo.QueryResult<ChannelFollowingQuery, ChannelFollowingQueryVariables>;
export const ChannelLiveStatusDocument = gql`
    subscription ChannelLiveStatus($channelId: ID) {
  channelLiveStatusSubscribe(channelId: $channelId) {
    liveStatus
  }
}
    `;

/**
 * __useChannelLiveStatusSubscription__
 *
 * To run a query within a React component, call `useChannelLiveStatusSubscription` and pass it any options that fit your needs.
 * When your component renders, `useChannelLiveStatusSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelLiveStatusSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelLiveStatusSubscription(baseOptions?: Apollo.SubscriptionHookOptions<ChannelLiveStatusSubscription, ChannelLiveStatusSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ChannelLiveStatusSubscription, ChannelLiveStatusSubscriptionVariables>(ChannelLiveStatusDocument, options);
      }
export type ChannelLiveStatusSubscriptionHookResult = ReturnType<typeof useChannelLiveStatusSubscription>;
export type ChannelLiveStatusSubscriptionResult = Apollo.SubscriptionResult<ChannelLiveStatusSubscription>;
export const ChannelFollowChannelDocument = gql`
    mutation ChannelFollowChannel($channelId: ID!, $userId: ID!) {
  followChannel(channelId: $channelId, userId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type ChannelFollowChannelMutationFn = Apollo.MutationFunction<ChannelFollowChannelMutation, ChannelFollowChannelMutationVariables>;

/**
 * __useChannelFollowChannelMutation__
 *
 * To run a mutation, you first call `useChannelFollowChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelFollowChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelFollowChannelMutation, { data, loading, error }] = useChannelFollowChannelMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChannelFollowChannelMutation(baseOptions?: Apollo.MutationHookOptions<ChannelFollowChannelMutation, ChannelFollowChannelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelFollowChannelMutation, ChannelFollowChannelMutationVariables>(ChannelFollowChannelDocument, options);
      }
export type ChannelFollowChannelMutationHookResult = ReturnType<typeof useChannelFollowChannelMutation>;
export type ChannelFollowChannelMutationResult = Apollo.MutationResult<ChannelFollowChannelMutation>;
export type ChannelFollowChannelMutationOptions = Apollo.BaseMutationOptions<ChannelFollowChannelMutation, ChannelFollowChannelMutationVariables>;
export const ChannelUnfollowChannelDocument = gql`
    mutation ChannelUnfollowChannel($channelId: ID!, $userId: ID!) {
  unfollowChannel(channelId: $channelId, userId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type ChannelUnfollowChannelMutationFn = Apollo.MutationFunction<ChannelUnfollowChannelMutation, ChannelUnfollowChannelMutationVariables>;

/**
 * __useChannelUnfollowChannelMutation__
 *
 * To run a mutation, you first call `useChannelUnfollowChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelUnfollowChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelUnfollowChannelMutation, { data, loading, error }] = useChannelUnfollowChannelMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChannelUnfollowChannelMutation(baseOptions?: Apollo.MutationHookOptions<ChannelUnfollowChannelMutation, ChannelUnfollowChannelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelUnfollowChannelMutation, ChannelUnfollowChannelMutationVariables>(ChannelUnfollowChannelDocument, options);
      }
export type ChannelUnfollowChannelMutationHookResult = ReturnType<typeof useChannelUnfollowChannelMutation>;
export type ChannelUnfollowChannelMutationResult = Apollo.MutationResult<ChannelUnfollowChannelMutation>;
export type ChannelUnfollowChannelMutationOptions = Apollo.BaseMutationOptions<ChannelUnfollowChannelMutation, ChannelUnfollowChannelMutationVariables>;
export const ChatModerationStatusDocument = gql`
    query ChatModerationStatus($chatId: ID!, $userId: ID!) {
  chatUserStatus(chatId: $chatId, userId: $userId) {
    muted
    muteDuration
  }
}
    `;

/**
 * __useChatModerationStatusQuery__
 *
 * To run a query within a React component, call `useChatModerationStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatModerationStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatModerationStatusQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChatModerationStatusQuery(baseOptions: Apollo.QueryHookOptions<ChatModerationStatusQuery, ChatModerationStatusQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatModerationStatusQuery, ChatModerationStatusQueryVariables>(ChatModerationStatusDocument, options);
      }
export function useChatModerationStatusLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatModerationStatusQuery, ChatModerationStatusQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatModerationStatusQuery, ChatModerationStatusQueryVariables>(ChatModerationStatusDocument, options);
        }
export type ChatModerationStatusQueryHookResult = ReturnType<typeof useChatModerationStatusQuery>;
export type ChatModerationStatusLazyQueryHookResult = ReturnType<typeof useChatModerationStatusLazyQuery>;
export type ChatModerationStatusQueryResult = Apollo.QueryResult<ChatModerationStatusQuery, ChatModerationStatusQueryVariables>;
export const ChatHistoryDocument = gql`
    query ChatHistory($chatId: ID!, $channelId: ID, $cursor: APICursorInput) {
  chatMessages(chatId: $chatId, cursor: $cursor) {
    messages {
      ... on ChatChatMessage {
        ...ChatMessageWithSender
        sender {
          badges(channel_id: $channelId) {
            ...UserBadge
          }
        }
      }
    }
  }
}
    ${ChatMessageWithSenderFragmentDoc}
${UserBadgeFragmentDoc}`;

/**
 * __useChatHistoryQuery__
 *
 * To run a query within a React component, call `useChatHistoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatHistoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatHistoryQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      channelId: // value for 'channelId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useChatHistoryQuery(baseOptions: Apollo.QueryHookOptions<ChatHistoryQuery, ChatHistoryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatHistoryQuery, ChatHistoryQueryVariables>(ChatHistoryDocument, options);
      }
export function useChatHistoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatHistoryQuery, ChatHistoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatHistoryQuery, ChatHistoryQueryVariables>(ChatHistoryDocument, options);
        }
export type ChatHistoryQueryHookResult = ReturnType<typeof useChatHistoryQuery>;
export type ChatHistoryLazyQueryHookResult = ReturnType<typeof useChatHistoryLazyQuery>;
export type ChatHistoryQueryResult = Apollo.QueryResult<ChatHistoryQuery, ChatHistoryQueryVariables>;
export const ChatMessageSenderProfileDocument = gql`
    query ChatMessageSenderProfile($userId: ID!, $channelId: ID) {
  profile(userId: $userId) {
    userId
    ...ChatMessageSenderProfile
    badges(channel_id: $channelId) {
      ...UserBadge
    }
  }
}
    ${ChatMessageSenderProfileFragmentDoc}
${UserBadgeFragmentDoc}`;

/**
 * __useChatMessageSenderProfileQuery__
 *
 * To run a query within a React component, call `useChatMessageSenderProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatMessageSenderProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatMessageSenderProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChatMessageSenderProfileQuery(baseOptions: Apollo.QueryHookOptions<ChatMessageSenderProfileQuery, ChatMessageSenderProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatMessageSenderProfileQuery, ChatMessageSenderProfileQueryVariables>(ChatMessageSenderProfileDocument, options);
      }
export function useChatMessageSenderProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatMessageSenderProfileQuery, ChatMessageSenderProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatMessageSenderProfileQuery, ChatMessageSenderProfileQueryVariables>(ChatMessageSenderProfileDocument, options);
        }
export type ChatMessageSenderProfileQueryHookResult = ReturnType<typeof useChatMessageSenderProfileQuery>;
export type ChatMessageSenderProfileLazyQueryHookResult = ReturnType<typeof useChatMessageSenderProfileLazyQuery>;
export type ChatMessageSenderProfileQueryResult = Apollo.QueryResult<ChatMessageSenderProfileQuery, ChatMessageSenderProfileQueryVariables>;
export const ChatSubscriptionDocument = gql`
    subscription ChatSubscription($chatId: ID!) {
  chatMessageSubscribe(chatId: $chatId) {
    event {
      ... on ChatChatMessage {
        ...ChatMessage
      }
      ... on ChatHideMessage {
        messageId
      }
      ... on ChatUserMuted {
        userId
        duration
      }
      ... on ChatUserBanned {
        userId
      }
      ... on ChatMessageDenied {
        userId
      }
    }
  }
}
    ${ChatMessageFragmentDoc}`;

/**
 * __useChatSubscriptionSubscription__
 *
 * To run a query within a React component, call `useChatSubscriptionSubscription` and pass it any options that fit your needs.
 * When your component renders, `useChatSubscriptionSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatSubscriptionSubscription({
 *   variables: {
 *      chatId: // value for 'chatId'
 *   },
 * });
 */
export function useChatSubscriptionSubscription(baseOptions: Apollo.SubscriptionHookOptions<ChatSubscriptionSubscription, ChatSubscriptionSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ChatSubscriptionSubscription, ChatSubscriptionSubscriptionVariables>(ChatSubscriptionDocument, options);
      }
export type ChatSubscriptionSubscriptionHookResult = ReturnType<typeof useChatSubscriptionSubscription>;
export type ChatSubscriptionSubscriptionResult = Apollo.SubscriptionResult<ChatSubscriptionSubscription>;
export const SendChatMessageDocument = gql`
    mutation SendChatMessage($chatId: ID!, $content: ChatTextMessageInput!, $consentToModeration: Boolean) {
  sendChatMessage(
    chatId: $chatId
    content: {textContent: $content}
    consentToModeration: $consentToModeration
  ) {
    messageId
  }
}
    `;
export type SendChatMessageMutationFn = Apollo.MutationFunction<SendChatMessageMutation, SendChatMessageMutationVariables>;

/**
 * __useSendChatMessageMutation__
 *
 * To run a mutation, you first call `useSendChatMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendChatMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendChatMessageMutation, { data, loading, error }] = useSendChatMessageMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      content: // value for 'content'
 *      consentToModeration: // value for 'consentToModeration'
 *   },
 * });
 */
export function useSendChatMessageMutation(baseOptions?: Apollo.MutationHookOptions<SendChatMessageMutation, SendChatMessageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendChatMessageMutation, SendChatMessageMutationVariables>(SendChatMessageDocument, options);
      }
export type SendChatMessageMutationHookResult = ReturnType<typeof useSendChatMessageMutation>;
export type SendChatMessageMutationResult = Apollo.MutationResult<SendChatMessageMutation>;
export type SendChatMessageMutationOptions = Apollo.BaseMutationOptions<SendChatMessageMutation, SendChatMessageMutationVariables>;
export const UserInventoryEmojisDocument = gql`
    query UserInventoryEmojis($userId: ID) {
  inventory(userId: $userId, filters: {itemType: TYPE_EMOJI}) {
    items {
      itemId
      item {
        id
        details {
          ...UserInventoryEmoji
        }
      }
    }
  }
}
    ${UserInventoryEmojiFragmentDoc}`;

/**
 * __useUserInventoryEmojisQuery__
 *
 * To run a query within a React component, call `useUserInventoryEmojisQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserInventoryEmojisQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserInventoryEmojisQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserInventoryEmojisQuery(baseOptions?: Apollo.QueryHookOptions<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>(UserInventoryEmojisDocument, options);
      }
export function useUserInventoryEmojisLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>(UserInventoryEmojisDocument, options);
        }
export type UserInventoryEmojisQueryHookResult = ReturnType<typeof useUserInventoryEmojisQuery>;
export type UserInventoryEmojisLazyQueryHookResult = ReturnType<typeof useUserInventoryEmojisLazyQuery>;
export type UserInventoryEmojisQueryResult = Apollo.QueryResult<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>;
export const UserInventoryEmojisChannelsDocument = gql`
    query UserInventoryEmojisChannels($channelIds: [String!]) {
  getChannels(channelIds: $channelIds) {
    channels {
      ...UserInventoryEmojisChannel
    }
  }
}
    ${UserInventoryEmojisChannelFragmentDoc}`;

/**
 * __useUserInventoryEmojisChannelsQuery__
 *
 * To run a query within a React component, call `useUserInventoryEmojisChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserInventoryEmojisChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserInventoryEmojisChannelsQuery({
 *   variables: {
 *      channelIds: // value for 'channelIds'
 *   },
 * });
 */
export function useUserInventoryEmojisChannelsQuery(baseOptions?: Apollo.QueryHookOptions<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>(UserInventoryEmojisChannelsDocument, options);
      }
export function useUserInventoryEmojisChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>(UserInventoryEmojisChannelsDocument, options);
        }
export type UserInventoryEmojisChannelsQueryHookResult = ReturnType<typeof useUserInventoryEmojisChannelsQuery>;
export type UserInventoryEmojisChannelsLazyQueryHookResult = ReturnType<typeof useUserInventoryEmojisChannelsLazyQuery>;
export type UserInventoryEmojisChannelsQueryResult = Apollo.QueryResult<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>;
export const UpdateChannelNotificationSettingsDocument = gql`
    mutation UpdateChannelNotificationSettings($channelId: ID!, $userId: ID!, $enabled: Boolean!) {
  updateFollowerNotificationSettings(
    body: {channelId: $channelId, userId: $userId, channelLiveNotificationEnabled: $enabled}
  ) {
    userId
    channelId
    channelLiveNotificationEnabled
  }
}
    `;
export type UpdateChannelNotificationSettingsMutationFn = Apollo.MutationFunction<UpdateChannelNotificationSettingsMutation, UpdateChannelNotificationSettingsMutationVariables>;

/**
 * __useUpdateChannelNotificationSettingsMutation__
 *
 * To run a mutation, you first call `useUpdateChannelNotificationSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChannelNotificationSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChannelNotificationSettingsMutation, { data, loading, error }] = useUpdateChannelNotificationSettingsMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *      enabled: // value for 'enabled'
 *   },
 * });
 */
export function useUpdateChannelNotificationSettingsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChannelNotificationSettingsMutation, UpdateChannelNotificationSettingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChannelNotificationSettingsMutation, UpdateChannelNotificationSettingsMutationVariables>(UpdateChannelNotificationSettingsDocument, options);
      }
export type UpdateChannelNotificationSettingsMutationHookResult = ReturnType<typeof useUpdateChannelNotificationSettingsMutation>;
export type UpdateChannelNotificationSettingsMutationResult = Apollo.MutationResult<UpdateChannelNotificationSettingsMutation>;
export type UpdateChannelNotificationSettingsMutationOptions = Apollo.BaseMutationOptions<UpdateChannelNotificationSettingsMutation, UpdateChannelNotificationSettingsMutationVariables>;
export const ChannelNotificationsDocument = gql`
    query ChannelNotifications($channelId: ID!, $userId: ID!) {
  channelFollowerNotificationSettings(channelId: $channelId, userId: $userId) {
    userId
    channelId
    channelLiveNotificationEnabled
  }
}
    `;

/**
 * __useChannelNotificationsQuery__
 *
 * To run a query within a React component, call `useChannelNotificationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelNotificationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelNotificationsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChannelNotificationsQuery(baseOptions: Apollo.QueryHookOptions<ChannelNotificationsQuery, ChannelNotificationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelNotificationsQuery, ChannelNotificationsQueryVariables>(ChannelNotificationsDocument, options);
      }
export function useChannelNotificationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelNotificationsQuery, ChannelNotificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelNotificationsQuery, ChannelNotificationsQueryVariables>(ChannelNotificationsDocument, options);
        }
export type ChannelNotificationsQueryHookResult = ReturnType<typeof useChannelNotificationsQuery>;
export type ChannelNotificationsLazyQueryHookResult = ReturnType<typeof useChannelNotificationsLazyQuery>;
export type ChannelNotificationsQueryResult = Apollo.QueryResult<ChannelNotificationsQuery, ChannelNotificationsQueryVariables>;
export const AddPushNotificationTokenDocument = gql`
    mutation AddPushNotificationToken($token: String!) {
  addPushNotificationToken(
    token: $token
    tokenType: PUSH_NOTIFICATION_TOKEN_TYPE_FIREBASE
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type AddPushNotificationTokenMutationFn = Apollo.MutationFunction<AddPushNotificationTokenMutation, AddPushNotificationTokenMutationVariables>;

/**
 * __useAddPushNotificationTokenMutation__
 *
 * To run a mutation, you first call `useAddPushNotificationTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddPushNotificationTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addPushNotificationTokenMutation, { data, loading, error }] = useAddPushNotificationTokenMutation({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useAddPushNotificationTokenMutation(baseOptions?: Apollo.MutationHookOptions<AddPushNotificationTokenMutation, AddPushNotificationTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddPushNotificationTokenMutation, AddPushNotificationTokenMutationVariables>(AddPushNotificationTokenDocument, options);
      }
export type AddPushNotificationTokenMutationHookResult = ReturnType<typeof useAddPushNotificationTokenMutation>;
export type AddPushNotificationTokenMutationResult = Apollo.MutationResult<AddPushNotificationTokenMutation>;
export type AddPushNotificationTokenMutationOptions = Apollo.BaseMutationOptions<AddPushNotificationTokenMutation, AddPushNotificationTokenMutationVariables>;
export const ProfilePrivacyFriendSettingsDocument = gql`
    mutation ProfilePrivacyFriendSettings($userId: ID, $disableFriendRequests: Boolean) {
  updateFriendsSettings(
    userId: $userId
    body: {disableFriendRequests: $disableFriendRequests}
  ) {
    disableFriendRequests
  }
}
    `;
export type ProfilePrivacyFriendSettingsMutationFn = Apollo.MutationFunction<ProfilePrivacyFriendSettingsMutation, ProfilePrivacyFriendSettingsMutationVariables>;

/**
 * __useProfilePrivacyFriendSettingsMutation__
 *
 * To run a mutation, you first call `useProfilePrivacyFriendSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfilePrivacyFriendSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profilePrivacyFriendSettingsMutation, { data, loading, error }] = useProfilePrivacyFriendSettingsMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      disableFriendRequests: // value for 'disableFriendRequests'
 *   },
 * });
 */
export function useProfilePrivacyFriendSettingsMutation(baseOptions?: Apollo.MutationHookOptions<ProfilePrivacyFriendSettingsMutation, ProfilePrivacyFriendSettingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProfilePrivacyFriendSettingsMutation, ProfilePrivacyFriendSettingsMutationVariables>(ProfilePrivacyFriendSettingsDocument, options);
      }
export type ProfilePrivacyFriendSettingsMutationHookResult = ReturnType<typeof useProfilePrivacyFriendSettingsMutation>;
export type ProfilePrivacyFriendSettingsMutationResult = Apollo.MutationResult<ProfilePrivacyFriendSettingsMutation>;
export type ProfilePrivacyFriendSettingsMutationOptions = Apollo.BaseMutationOptions<ProfilePrivacyFriendSettingsMutation, ProfilePrivacyFriendSettingsMutationVariables>;
export const ProfileAccountMatureContentDocument = gql`
    query ProfileAccountMatureContent($userId: ID) {
  profile(userId: $userId) {
    userId
    account {
      matureRatedContentAllowed
    }
  }
}
    `;

/**
 * __useProfileAccountMatureContentQuery__
 *
 * To run a query within a React component, call `useProfileAccountMatureContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileAccountMatureContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileAccountMatureContentQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useProfileAccountMatureContentQuery(baseOptions?: Apollo.QueryHookOptions<ProfileAccountMatureContentQuery, ProfileAccountMatureContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileAccountMatureContentQuery, ProfileAccountMatureContentQueryVariables>(ProfileAccountMatureContentDocument, options);
      }
export function useProfileAccountMatureContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileAccountMatureContentQuery, ProfileAccountMatureContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileAccountMatureContentQuery, ProfileAccountMatureContentQueryVariables>(ProfileAccountMatureContentDocument, options);
        }
export type ProfileAccountMatureContentQueryHookResult = ReturnType<typeof useProfileAccountMatureContentQuery>;
export type ProfileAccountMatureContentLazyQueryHookResult = ReturnType<typeof useProfileAccountMatureContentLazyQuery>;
export type ProfileAccountMatureContentQueryResult = Apollo.QueryResult<ProfileAccountMatureContentQuery, ProfileAccountMatureContentQueryVariables>;
export const ProfilePrivacyHideOnlineStatusDocument = gql`
    mutation ProfilePrivacyHideOnlineStatus($userId: ID, $hideOnlineStatus: Boolean) {
  updatePrivacySettings(
    userId: $userId
    body: {hideOnlineStatus: $hideOnlineStatus}
  ) {
    hideOnlineStatus
  }
}
    `;
export type ProfilePrivacyHideOnlineStatusMutationFn = Apollo.MutationFunction<ProfilePrivacyHideOnlineStatusMutation, ProfilePrivacyHideOnlineStatusMutationVariables>;

/**
 * __useProfilePrivacyHideOnlineStatusMutation__
 *
 * To run a mutation, you first call `useProfilePrivacyHideOnlineStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfilePrivacyHideOnlineStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profilePrivacyHideOnlineStatusMutation, { data, loading, error }] = useProfilePrivacyHideOnlineStatusMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      hideOnlineStatus: // value for 'hideOnlineStatus'
 *   },
 * });
 */
export function useProfilePrivacyHideOnlineStatusMutation(baseOptions?: Apollo.MutationHookOptions<ProfilePrivacyHideOnlineStatusMutation, ProfilePrivacyHideOnlineStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProfilePrivacyHideOnlineStatusMutation, ProfilePrivacyHideOnlineStatusMutationVariables>(ProfilePrivacyHideOnlineStatusDocument, options);
      }
export type ProfilePrivacyHideOnlineStatusMutationHookResult = ReturnType<typeof useProfilePrivacyHideOnlineStatusMutation>;
export type ProfilePrivacyHideOnlineStatusMutationResult = Apollo.MutationResult<ProfilePrivacyHideOnlineStatusMutation>;
export type ProfilePrivacyHideOnlineStatusMutationOptions = Apollo.BaseMutationOptions<ProfilePrivacyHideOnlineStatusMutation, ProfilePrivacyHideOnlineStatusMutationVariables>;
export const ProfilePrivacyChangeVisibilityDocument = gql`
    mutation ProfilePrivacyChangeVisibility($userId: ID, $visibility: ProfilePrivacySettingsVisibility) {
  updatePrivacySettings(userId: $userId, body: {visibility: $visibility}) {
    visibility
  }
}
    `;
export type ProfilePrivacyChangeVisibilityMutationFn = Apollo.MutationFunction<ProfilePrivacyChangeVisibilityMutation, ProfilePrivacyChangeVisibilityMutationVariables>;

/**
 * __useProfilePrivacyChangeVisibilityMutation__
 *
 * To run a mutation, you first call `useProfilePrivacyChangeVisibilityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfilePrivacyChangeVisibilityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profilePrivacyChangeVisibilityMutation, { data, loading, error }] = useProfilePrivacyChangeVisibilityMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      visibility: // value for 'visibility'
 *   },
 * });
 */
export function useProfilePrivacyChangeVisibilityMutation(baseOptions?: Apollo.MutationHookOptions<ProfilePrivacyChangeVisibilityMutation, ProfilePrivacyChangeVisibilityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProfilePrivacyChangeVisibilityMutation, ProfilePrivacyChangeVisibilityMutationVariables>(ProfilePrivacyChangeVisibilityDocument, options);
      }
export type ProfilePrivacyChangeVisibilityMutationHookResult = ReturnType<typeof useProfilePrivacyChangeVisibilityMutation>;
export type ProfilePrivacyChangeVisibilityMutationResult = Apollo.MutationResult<ProfilePrivacyChangeVisibilityMutation>;
export type ProfilePrivacyChangeVisibilityMutationOptions = Apollo.BaseMutationOptions<ProfilePrivacyChangeVisibilityMutation, ProfilePrivacyChangeVisibilityMutationVariables>;
export const ProfilePrivacyChangeDiscordIdVisibilityDocument = gql`
    mutation ProfilePrivacyChangeDiscordIdVisibility($userId: ID, $discordUsernameVisibility: ProfilePrivacySettingsVisibility) {
  updatePrivacySettings(
    userId: $userId
    body: {discordUsernameVisibility: $discordUsernameVisibility}
  ) {
    discordUsernameVisibility
  }
}
    `;
export type ProfilePrivacyChangeDiscordIdVisibilityMutationFn = Apollo.MutationFunction<ProfilePrivacyChangeDiscordIdVisibilityMutation, ProfilePrivacyChangeDiscordIdVisibilityMutationVariables>;

/**
 * __useProfilePrivacyChangeDiscordIdVisibilityMutation__
 *
 * To run a mutation, you first call `useProfilePrivacyChangeDiscordIdVisibilityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfilePrivacyChangeDiscordIdVisibilityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profilePrivacyChangeDiscordIdVisibilityMutation, { data, loading, error }] = useProfilePrivacyChangeDiscordIdVisibilityMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      discordUsernameVisibility: // value for 'discordUsernameVisibility'
 *   },
 * });
 */
export function useProfilePrivacyChangeDiscordIdVisibilityMutation(baseOptions?: Apollo.MutationHookOptions<ProfilePrivacyChangeDiscordIdVisibilityMutation, ProfilePrivacyChangeDiscordIdVisibilityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProfilePrivacyChangeDiscordIdVisibilityMutation, ProfilePrivacyChangeDiscordIdVisibilityMutationVariables>(ProfilePrivacyChangeDiscordIdVisibilityDocument, options);
      }
export type ProfilePrivacyChangeDiscordIdVisibilityMutationHookResult = ReturnType<typeof useProfilePrivacyChangeDiscordIdVisibilityMutation>;
export type ProfilePrivacyChangeDiscordIdVisibilityMutationResult = Apollo.MutationResult<ProfilePrivacyChangeDiscordIdVisibilityMutation>;
export type ProfilePrivacyChangeDiscordIdVisibilityMutationOptions = Apollo.BaseMutationOptions<ProfilePrivacyChangeDiscordIdVisibilityMutation, ProfilePrivacyChangeDiscordIdVisibilityMutationVariables>;
export const ProfilePrivacyShowContentWarningDocument = gql`
    mutation ProfilePrivacyShowContentWarning($userId: ID, $showMatureContentWarning: Boolean) {
  updatePrivacySettings(
    userId: $userId
    body: {showMatureContentWarning: $showMatureContentWarning}
  ) {
    showMatureContentWarning
  }
}
    `;
export type ProfilePrivacyShowContentWarningMutationFn = Apollo.MutationFunction<ProfilePrivacyShowContentWarningMutation, ProfilePrivacyShowContentWarningMutationVariables>;

/**
 * __useProfilePrivacyShowContentWarningMutation__
 *
 * To run a mutation, you first call `useProfilePrivacyShowContentWarningMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfilePrivacyShowContentWarningMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profilePrivacyShowContentWarningMutation, { data, loading, error }] = useProfilePrivacyShowContentWarningMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      showMatureContentWarning: // value for 'showMatureContentWarning'
 *   },
 * });
 */
export function useProfilePrivacyShowContentWarningMutation(baseOptions?: Apollo.MutationHookOptions<ProfilePrivacyShowContentWarningMutation, ProfilePrivacyShowContentWarningMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProfilePrivacyShowContentWarningMutation, ProfilePrivacyShowContentWarningMutationVariables>(ProfilePrivacyShowContentWarningDocument, options);
      }
export type ProfilePrivacyShowContentWarningMutationHookResult = ReturnType<typeof useProfilePrivacyShowContentWarningMutation>;
export type ProfilePrivacyShowContentWarningMutationResult = Apollo.MutationResult<ProfilePrivacyShowContentWarningMutation>;
export type ProfilePrivacyShowContentWarningMutationOptions = Apollo.BaseMutationOptions<ProfilePrivacyShowContentWarningMutation, ProfilePrivacyShowContentWarningMutationVariables>;
export const SellableItemsDocument = gql`
    query SellableItems {
  sellableItems(filter: {platform: {categoryId: "currency-packs"}}) {
    items {
      ...CurrencyStoreSellableItem
    }
  }
}
    ${CurrencyStoreSellableItemFragmentDoc}`;

/**
 * __useSellableItemsQuery__
 *
 * To run a query within a React component, call `useSellableItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSellableItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSellableItemsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSellableItemsQuery(baseOptions?: Apollo.QueryHookOptions<SellableItemsQuery, SellableItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SellableItemsQuery, SellableItemsQueryVariables>(SellableItemsDocument, options);
      }
export function useSellableItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SellableItemsQuery, SellableItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SellableItemsQuery, SellableItemsQueryVariables>(SellableItemsDocument, options);
        }
export type SellableItemsQueryHookResult = ReturnType<typeof useSellableItemsQuery>;
export type SellableItemsLazyQueryHookResult = ReturnType<typeof useSellableItemsLazyQuery>;
export type SellableItemsQueryResult = Apollo.QueryResult<SellableItemsQuery, SellableItemsQueryVariables>;
export const BuyCurrencyPackDocument = gql`
    mutation BuyCurrencyPack($itemId: ID!, $signature: String!, $paymentMethod: StoreV2PaymentMethod) {
  buyWithPayment(
    itemId: $itemId
    signature: $signature
    paymentMethod: $paymentMethod
  ) {
    orderId
    session {
      session {
        ... on PaymentAppStoreSession {
          productId
          paymentId
        }
      }
    }
  }
}
    `;
export type BuyCurrencyPackMutationFn = Apollo.MutationFunction<BuyCurrencyPackMutation, BuyCurrencyPackMutationVariables>;

/**
 * __useBuyCurrencyPackMutation__
 *
 * To run a mutation, you first call `useBuyCurrencyPackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBuyCurrencyPackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [buyCurrencyPackMutation, { data, loading, error }] = useBuyCurrencyPackMutation({
 *   variables: {
 *      itemId: // value for 'itemId'
 *      signature: // value for 'signature'
 *      paymentMethod: // value for 'paymentMethod'
 *   },
 * });
 */
export function useBuyCurrencyPackMutation(baseOptions?: Apollo.MutationHookOptions<BuyCurrencyPackMutation, BuyCurrencyPackMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BuyCurrencyPackMutation, BuyCurrencyPackMutationVariables>(BuyCurrencyPackDocument, options);
      }
export type BuyCurrencyPackMutationHookResult = ReturnType<typeof useBuyCurrencyPackMutation>;
export type BuyCurrencyPackMutationResult = Apollo.MutationResult<BuyCurrencyPackMutation>;
export type BuyCurrencyPackMutationOptions = Apollo.BaseMutationOptions<BuyCurrencyPackMutation, BuyCurrencyPackMutationVariables>;
export const CancelBuyCurrencyPackOrderDocument = gql`
    mutation CancelBuyCurrencyPackOrder($orderId: ID!) {
  cancelOrder(orderId: $orderId) {
    emptyTypeWorkaround
  }
}
    `;
export type CancelBuyCurrencyPackOrderMutationFn = Apollo.MutationFunction<CancelBuyCurrencyPackOrderMutation, CancelBuyCurrencyPackOrderMutationVariables>;

/**
 * __useCancelBuyCurrencyPackOrderMutation__
 *
 * To run a mutation, you first call `useCancelBuyCurrencyPackOrderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCancelBuyCurrencyPackOrderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cancelBuyCurrencyPackOrderMutation, { data, loading, error }] = useCancelBuyCurrencyPackOrderMutation({
 *   variables: {
 *      orderId: // value for 'orderId'
 *   },
 * });
 */
export function useCancelBuyCurrencyPackOrderMutation(baseOptions?: Apollo.MutationHookOptions<CancelBuyCurrencyPackOrderMutation, CancelBuyCurrencyPackOrderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CancelBuyCurrencyPackOrderMutation, CancelBuyCurrencyPackOrderMutationVariables>(CancelBuyCurrencyPackOrderDocument, options);
      }
export type CancelBuyCurrencyPackOrderMutationHookResult = ReturnType<typeof useCancelBuyCurrencyPackOrderMutation>;
export type CancelBuyCurrencyPackOrderMutationResult = Apollo.MutationResult<CancelBuyCurrencyPackOrderMutation>;
export type CancelBuyCurrencyPackOrderMutationOptions = Apollo.BaseMutationOptions<CancelBuyCurrencyPackOrderMutation, CancelBuyCurrencyPackOrderMutationVariables>;
export const UserPurchaseInfoDocument = gql`
    query UserPurchaseInfo($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      email
    }
  }
}
    `;

/**
 * __useUserPurchaseInfoQuery__
 *
 * To run a query within a React component, call `useUserPurchaseInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserPurchaseInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserPurchaseInfoQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserPurchaseInfoQuery(baseOptions: Apollo.QueryHookOptions<UserPurchaseInfoQuery, UserPurchaseInfoQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserPurchaseInfoQuery, UserPurchaseInfoQueryVariables>(UserPurchaseInfoDocument, options);
      }
export function useUserPurchaseInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserPurchaseInfoQuery, UserPurchaseInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserPurchaseInfoQuery, UserPurchaseInfoQueryVariables>(UserPurchaseInfoDocument, options);
        }
export type UserPurchaseInfoQueryHookResult = ReturnType<typeof useUserPurchaseInfoQuery>;
export type UserPurchaseInfoLazyQueryHookResult = ReturnType<typeof useUserPurchaseInfoLazyQuery>;
export type UserPurchaseInfoQueryResult = Apollo.QueryResult<UserPurchaseInfoQuery, UserPurchaseInfoQueryVariables>;
export const SocialAcceptFriendRequestDocument = gql`
    mutation SocialAcceptFriendRequest($userId: ID!, $friendId: ID!) {
  acceptFriendRequest(userId: $userId, friendId: $friendId) {
    friendId
    friend {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialAcceptFriendRequestMutationFn = Apollo.MutationFunction<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>;

/**
 * __useSocialAcceptFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialAcceptFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialAcceptFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialAcceptFriendRequestMutation, { data, loading, error }] = useSocialAcceptFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialAcceptFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>(SocialAcceptFriendRequestDocument, options);
      }
export type SocialAcceptFriendRequestMutationHookResult = ReturnType<typeof useSocialAcceptFriendRequestMutation>;
export type SocialAcceptFriendRequestMutationResult = Apollo.MutationResult<SocialAcceptFriendRequestMutation>;
export type SocialAcceptFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>;
export const SocialBlockUserDocument = gql`
    mutation SocialBlockUser($userId: ID!, $blockedUserId: ID!) {
  blockUser(userId: $userId, blockedUserId: $blockedUserId) {
    blockedUserId
    blockedUser {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialBlockUserMutationFn = Apollo.MutationFunction<SocialBlockUserMutation, SocialBlockUserMutationVariables>;

/**
 * __useSocialBlockUserMutation__
 *
 * To run a mutation, you first call `useSocialBlockUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialBlockUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialBlockUserMutation, { data, loading, error }] = useSocialBlockUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      blockedUserId: // value for 'blockedUserId'
 *   },
 * });
 */
export function useSocialBlockUserMutation(baseOptions?: Apollo.MutationHookOptions<SocialBlockUserMutation, SocialBlockUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialBlockUserMutation, SocialBlockUserMutationVariables>(SocialBlockUserDocument, options);
      }
export type SocialBlockUserMutationHookResult = ReturnType<typeof useSocialBlockUserMutation>;
export type SocialBlockUserMutationResult = Apollo.MutationResult<SocialBlockUserMutation>;
export type SocialBlockUserMutationOptions = Apollo.BaseMutationOptions<SocialBlockUserMutation, SocialBlockUserMutationVariables>;
export const FriendRequestsDocument = gql`
    query FriendRequests($userId: ID!) {
  receivedFriendRequests(userId: $userId) {
    users {
      userId
      lastStatusChange
    }
  }
  sentFriendRequests(userId: $userId) {
    users {
      userId
      lastStatusChange
    }
  }
}
    `;

/**
 * __useFriendRequestsQuery__
 *
 * To run a query within a React component, call `useFriendRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendRequestsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFriendRequestsQuery(baseOptions: Apollo.QueryHookOptions<FriendRequestsQuery, FriendRequestsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendRequestsQuery, FriendRequestsQueryVariables>(FriendRequestsDocument, options);
      }
export function useFriendRequestsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendRequestsQuery, FriendRequestsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendRequestsQuery, FriendRequestsQueryVariables>(FriendRequestsDocument, options);
        }
export type FriendRequestsQueryHookResult = ReturnType<typeof useFriendRequestsQuery>;
export type FriendRequestsLazyQueryHookResult = ReturnType<typeof useFriendRequestsLazyQuery>;
export type FriendRequestsQueryResult = Apollo.QueryResult<FriendRequestsQuery, FriendRequestsQueryVariables>;
export const SocialRemoveFriendDocument = gql`
    mutation SocialRemoveFriend($userId: ID!, $friendId: ID!) {
  removeFriend(userId: $userId, friendId: $friendId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialRemoveFriendMutationFn = Apollo.MutationFunction<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>;

/**
 * __useSocialRemoveFriendMutation__
 *
 * To run a mutation, you first call `useSocialRemoveFriendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialRemoveFriendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialRemoveFriendMutation, { data, loading, error }] = useSocialRemoveFriendMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialRemoveFriendMutation(baseOptions?: Apollo.MutationHookOptions<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>(SocialRemoveFriendDocument, options);
      }
export type SocialRemoveFriendMutationHookResult = ReturnType<typeof useSocialRemoveFriendMutation>;
export type SocialRemoveFriendMutationResult = Apollo.MutationResult<SocialRemoveFriendMutation>;
export type SocialRemoveFriendMutationOptions = Apollo.BaseMutationOptions<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>;
export const SocialRemoveReceivedFriendRequestDocument = gql`
    mutation SocialRemoveReceivedFriendRequest($userId: ID!, $friendId: ID!) {
  removeFriendRequest(userId: $userId, friendId: $friendId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialRemoveReceivedFriendRequestMutationFn = Apollo.MutationFunction<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>;

/**
 * __useSocialRemoveReceivedFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialRemoveReceivedFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialRemoveReceivedFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialRemoveReceivedFriendRequestMutation, { data, loading, error }] = useSocialRemoveReceivedFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialRemoveReceivedFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>(SocialRemoveReceivedFriendRequestDocument, options);
      }
export type SocialRemoveReceivedFriendRequestMutationHookResult = ReturnType<typeof useSocialRemoveReceivedFriendRequestMutation>;
export type SocialRemoveReceivedFriendRequestMutationResult = Apollo.MutationResult<SocialRemoveReceivedFriendRequestMutation>;
export type SocialRemoveReceivedFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>;
export const SocialRemoveSentFriendRequestDocument = gql`
    mutation SocialRemoveSentFriendRequest($userId: ID!, $friendId: ID!) {
  removeFriendRequest(userId: $friendId, friendId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialRemoveSentFriendRequestMutationFn = Apollo.MutationFunction<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>;

/**
 * __useSocialRemoveSentFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialRemoveSentFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialRemoveSentFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialRemoveSentFriendRequestMutation, { data, loading, error }] = useSocialRemoveSentFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialRemoveSentFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>(SocialRemoveSentFriendRequestDocument, options);
      }
export type SocialRemoveSentFriendRequestMutationHookResult = ReturnType<typeof useSocialRemoveSentFriendRequestMutation>;
export type SocialRemoveSentFriendRequestMutationResult = Apollo.MutationResult<SocialRemoveSentFriendRequestMutation>;
export type SocialRemoveSentFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>;
export const SocialSendFriendRequestDocument = gql`
    mutation SocialSendFriendRequest($userId: ID!, $friendId: ID!) {
  sendFriendRequest(userId: $userId, friendId: $friendId) {
    friendId
    friend {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialSendFriendRequestMutationFn = Apollo.MutationFunction<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>;

/**
 * __useSocialSendFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialSendFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialSendFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialSendFriendRequestMutation, { data, loading, error }] = useSocialSendFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialSendFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>(SocialSendFriendRequestDocument, options);
      }
export type SocialSendFriendRequestMutationHookResult = ReturnType<typeof useSocialSendFriendRequestMutation>;
export type SocialSendFriendRequestMutationResult = Apollo.MutationResult<SocialSendFriendRequestMutation>;
export type SocialSendFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>;
export const SocialUnblockUserDocument = gql`
    mutation SocialUnblockUser($userId: ID!, $blockedUserId: ID!) {
  unblockUser(userId: $userId, blockedUserId: $blockedUserId) {
    unblockedUserId
    unblockedUser {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialUnblockUserMutationFn = Apollo.MutationFunction<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>;

/**
 * __useSocialUnblockUserMutation__
 *
 * To run a mutation, you first call `useSocialUnblockUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialUnblockUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialUnblockUserMutation, { data, loading, error }] = useSocialUnblockUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      blockedUserId: // value for 'blockedUserId'
 *   },
 * });
 */
export function useSocialUnblockUserMutation(baseOptions?: Apollo.MutationHookOptions<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>(SocialUnblockUserDocument, options);
      }
export type SocialUnblockUserMutationHookResult = ReturnType<typeof useSocialUnblockUserMutation>;
export type SocialUnblockUserMutationResult = Apollo.MutationResult<SocialUnblockUserMutation>;
export type SocialUnblockUserMutationOptions = Apollo.BaseMutationOptions<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>;
export const ChannelSubscribeDocument = gql`
    subscription ChannelSubscribe($channelId: ID) {
  channelStreamDetailSubscribe(channelId: $channelId) {
    channelId
    liveStatus
    noicePredictionsEnabled
    streamId
    gameId
    matureRatedContent
  }
}
    `;

/**
 * __useChannelSubscribeSubscription__
 *
 * To run a query within a React component, call `useChannelSubscribeSubscription` and pass it any options that fit your needs.
 * When your component renders, `useChannelSubscribeSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelSubscribeSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelSubscribeSubscription(baseOptions?: Apollo.SubscriptionHookOptions<ChannelSubscribeSubscription, ChannelSubscribeSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ChannelSubscribeSubscription, ChannelSubscribeSubscriptionVariables>(ChannelSubscribeDocument, options);
      }
export type ChannelSubscribeSubscriptionHookResult = ReturnType<typeof useChannelSubscribeSubscription>;
export type ChannelSubscribeSubscriptionResult = Apollo.SubscriptionResult<ChannelSubscribeSubscription>;
export const ViewerCountDocument = gql`
    subscription ViewerCount($channelId: ID) {
  channelViewerCountSubscribe(channelId: $channelId) {
    viewerCount
  }
}
    `;

/**
 * __useViewerCountSubscription__
 *
 * To run a query within a React component, call `useViewerCountSubscription` and pass it any options that fit your needs.
 * When your component renders, `useViewerCountSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useViewerCountSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useViewerCountSubscription(baseOptions?: Apollo.SubscriptionHookOptions<ViewerCountSubscription, ViewerCountSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ViewerCountSubscription, ViewerCountSubscriptionVariables>(ViewerCountDocument, options);
      }
export type ViewerCountSubscriptionHookResult = ReturnType<typeof useViewerCountSubscription>;
export type ViewerCountSubscriptionResult = Apollo.SubscriptionResult<ViewerCountSubscription>;
export const UpdateUserAvatarDocument = gql`
    mutation UpdateUserAvatar($userId: ID!, $avatarId: ID!) {
  updateProfileAvatarV2(userId: $userId, modelId: $avatarId) {
    id
  }
}
    `;
export type UpdateUserAvatarMutationFn = Apollo.MutationFunction<UpdateUserAvatarMutation, UpdateUserAvatarMutationVariables>;

/**
 * __useUpdateUserAvatarMutation__
 *
 * To run a mutation, you first call `useUpdateUserAvatarMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserAvatarMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserAvatarMutation, { data, loading, error }] = useUpdateUserAvatarMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      avatarId: // value for 'avatarId'
 *   },
 * });
 */
export function useUpdateUserAvatarMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserAvatarMutation, UpdateUserAvatarMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserAvatarMutation, UpdateUserAvatarMutationVariables>(UpdateUserAvatarDocument, options);
      }
export type UpdateUserAvatarMutationHookResult = ReturnType<typeof useUpdateUserAvatarMutation>;
export type UpdateUserAvatarMutationResult = Apollo.MutationResult<UpdateUserAvatarMutation>;
export type UpdateUserAvatarMutationOptions = Apollo.BaseMutationOptions<UpdateUserAvatarMutation, UpdateUserAvatarMutationVariables>;
export const SettingsConnectionDeleteExternalAccountDocument = gql`
    mutation SettingsConnectionDeleteExternalAccount($userId: ID!, $type: AuthIdentityType!) {
  deleteExternalAccount(userId: $userId, idType: $type) {
    emptyTypeWorkaround
  }
}
    `;
export type SettingsConnectionDeleteExternalAccountMutationFn = Apollo.MutationFunction<SettingsConnectionDeleteExternalAccountMutation, SettingsConnectionDeleteExternalAccountMutationVariables>;

/**
 * __useSettingsConnectionDeleteExternalAccountMutation__
 *
 * To run a mutation, you first call `useSettingsConnectionDeleteExternalAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSettingsConnectionDeleteExternalAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [settingsConnectionDeleteExternalAccountMutation, { data, loading, error }] = useSettingsConnectionDeleteExternalAccountMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useSettingsConnectionDeleteExternalAccountMutation(baseOptions?: Apollo.MutationHookOptions<SettingsConnectionDeleteExternalAccountMutation, SettingsConnectionDeleteExternalAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SettingsConnectionDeleteExternalAccountMutation, SettingsConnectionDeleteExternalAccountMutationVariables>(SettingsConnectionDeleteExternalAccountDocument, options);
      }
export type SettingsConnectionDeleteExternalAccountMutationHookResult = ReturnType<typeof useSettingsConnectionDeleteExternalAccountMutation>;
export type SettingsConnectionDeleteExternalAccountMutationResult = Apollo.MutationResult<SettingsConnectionDeleteExternalAccountMutation>;
export type SettingsConnectionDeleteExternalAccountMutationOptions = Apollo.BaseMutationOptions<SettingsConnectionDeleteExternalAccountMutation, SettingsConnectionDeleteExternalAccountMutationVariables>;
export const UserOnboardingStateDocument = gql`
    query UserOnboardingState($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      acceptedTerms {
        name
        revision
      }
    }
    avatars {
      avatar2D
    }
  }
}
    `;

/**
 * __useUserOnboardingStateQuery__
 *
 * To run a query within a React component, call `useUserOnboardingStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserOnboardingStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserOnboardingStateQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserOnboardingStateQuery(baseOptions: Apollo.QueryHookOptions<UserOnboardingStateQuery, UserOnboardingStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserOnboardingStateQuery, UserOnboardingStateQueryVariables>(UserOnboardingStateDocument, options);
      }
export function useUserOnboardingStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserOnboardingStateQuery, UserOnboardingStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserOnboardingStateQuery, UserOnboardingStateQueryVariables>(UserOnboardingStateDocument, options);
        }
export type UserOnboardingStateQueryHookResult = ReturnType<typeof useUserOnboardingStateQuery>;
export type UserOnboardingStateLazyQueryHookResult = ReturnType<typeof useUserOnboardingStateLazyQuery>;
export type UserOnboardingStateQueryResult = Apollo.QueryResult<UserOnboardingStateQuery, UserOnboardingStateQueryVariables>;
export const UseUserPlatformBanDocument = gql`
    query useUserPlatformBan($userId: ID!) {
  platformBan(userId: $userId) {
    banId
    status
  }
}
    `;

/**
 * __useUseUserPlatformBanQuery__
 *
 * To run a query within a React component, call `useUseUserPlatformBanQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseUserPlatformBanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseUserPlatformBanQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUseUserPlatformBanQuery(baseOptions: Apollo.QueryHookOptions<UseUserPlatformBanQuery, UseUserPlatformBanQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseUserPlatformBanQuery, UseUserPlatformBanQueryVariables>(UseUserPlatformBanDocument, options);
      }
export function useUseUserPlatformBanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseUserPlatformBanQuery, UseUserPlatformBanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseUserPlatformBanQuery, UseUserPlatformBanQueryVariables>(UseUserPlatformBanDocument, options);
        }
export type UseUserPlatformBanQueryHookResult = ReturnType<typeof useUseUserPlatformBanQuery>;
export type UseUserPlatformBanLazyQueryHookResult = ReturnType<typeof useUseUserPlatformBanLazyQuery>;
export type UseUserPlatformBanQueryResult = Apollo.QueryResult<UseUserPlatformBanQuery, UseUserPlatformBanQueryVariables>;
export const ChatProviderDataDocument = gql`
    query ChatProviderData($userId: ID!, $chatId: ID!, $channelId: ID!) {
  chatUserStatus(chatId: $chatId, userId: $userId) {
    muted
    muteDuration
  }
  userChannelRoles(userId: $userId, channelId: $channelId) {
    roles
  }
  profile(userId: $userId) {
    userId
    ...ChatMessagesHookProfile
  }
}
    ${ChatMessagesHookProfileFragmentDoc}`;

/**
 * __useChatProviderDataQuery__
 *
 * To run a query within a React component, call `useChatProviderDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatProviderDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatProviderDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      chatId: // value for 'chatId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChatProviderDataQuery(baseOptions: Apollo.QueryHookOptions<ChatProviderDataQuery, ChatProviderDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatProviderDataQuery, ChatProviderDataQueryVariables>(ChatProviderDataDocument, options);
      }
export function useChatProviderDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatProviderDataQuery, ChatProviderDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatProviderDataQuery, ChatProviderDataQueryVariables>(ChatProviderDataDocument, options);
        }
export type ChatProviderDataQueryHookResult = ReturnType<typeof useChatProviderDataQuery>;
export type ChatProviderDataLazyQueryHookResult = ReturnType<typeof useChatProviderDataLazyQuery>;
export type ChatProviderDataQueryResult = Apollo.QueryResult<ChatProviderDataQuery, ChatProviderDataQueryVariables>;
export const OwnChatSenderInfoProfileDocument = gql`
    query OwnChatSenderInfoProfile($userId: ID!, $channelId: ID) {
  profile(userId: $userId) {
    userId
    userTag
    avatars {
      avatar2D
    }
    preferredColor
    badges(channel_id: $channelId) {
      ...UserBadge
    }
  }
}
    ${UserBadgeFragmentDoc}`;

/**
 * __useOwnChatSenderInfoProfileQuery__
 *
 * To run a query within a React component, call `useOwnChatSenderInfoProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useOwnChatSenderInfoProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOwnChatSenderInfoProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useOwnChatSenderInfoProfileQuery(baseOptions: Apollo.QueryHookOptions<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>(OwnChatSenderInfoProfileDocument, options);
      }
export function useOwnChatSenderInfoProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>(OwnChatSenderInfoProfileDocument, options);
        }
export type OwnChatSenderInfoProfileQueryHookResult = ReturnType<typeof useOwnChatSenderInfoProfileQuery>;
export type OwnChatSenderInfoProfileLazyQueryHookResult = ReturnType<typeof useOwnChatSenderInfoProfileLazyQuery>;
export type OwnChatSenderInfoProfileQueryResult = Apollo.QueryResult<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>;
export const MobileMicroSurveyPlayerTraitsDocument = gql`
    query MobileMicroSurveyPlayerTraits($userId: ID!) {
  profile(userId: $userId) {
    userId
    stats {
      adsWatched
      matchesPlayed
      timePlayed
      cardsPlayed
      cardsSucceeded
    }
    account {
      createdAt
      email
    }
  }
}
    `;

/**
 * __useMobileMicroSurveyPlayerTraitsQuery__
 *
 * To run a query within a React component, call `useMobileMicroSurveyPlayerTraitsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMobileMicroSurveyPlayerTraitsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMobileMicroSurveyPlayerTraitsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useMobileMicroSurveyPlayerTraitsQuery(baseOptions: Apollo.QueryHookOptions<MobileMicroSurveyPlayerTraitsQuery, MobileMicroSurveyPlayerTraitsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MobileMicroSurveyPlayerTraitsQuery, MobileMicroSurveyPlayerTraitsQueryVariables>(MobileMicroSurveyPlayerTraitsDocument, options);
      }
export function useMobileMicroSurveyPlayerTraitsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MobileMicroSurveyPlayerTraitsQuery, MobileMicroSurveyPlayerTraitsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MobileMicroSurveyPlayerTraitsQuery, MobileMicroSurveyPlayerTraitsQueryVariables>(MobileMicroSurveyPlayerTraitsDocument, options);
        }
export type MobileMicroSurveyPlayerTraitsQueryHookResult = ReturnType<typeof useMobileMicroSurveyPlayerTraitsQuery>;
export type MobileMicroSurveyPlayerTraitsLazyQueryHookResult = ReturnType<typeof useMobileMicroSurveyPlayerTraitsLazyQuery>;
export type MobileMicroSurveyPlayerTraitsQueryResult = Apollo.QueryResult<MobileMicroSurveyPlayerTraitsQuery, MobileMicroSurveyPlayerTraitsQueryVariables>;
export const GamesFilterDocument = gql`
    query GamesFilter {
  listGames {
    games {
      ...GamesFilterGame
    }
  }
}
    ${GamesFilterGameFragmentDoc}`;

/**
 * __useGamesFilterQuery__
 *
 * To run a query within a React component, call `useGamesFilterQuery` and pass it any options that fit your needs.
 * When your component renders, `useGamesFilterQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGamesFilterQuery({
 *   variables: {
 *   },
 * });
 */
export function useGamesFilterQuery(baseOptions?: Apollo.QueryHookOptions<GamesFilterQuery, GamesFilterQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GamesFilterQuery, GamesFilterQueryVariables>(GamesFilterDocument, options);
      }
export function useGamesFilterLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GamesFilterQuery, GamesFilterQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GamesFilterQuery, GamesFilterQueryVariables>(GamesFilterDocument, options);
        }
export type GamesFilterQueryHookResult = ReturnType<typeof useGamesFilterQuery>;
export type GamesFilterLazyQueryHookResult = ReturnType<typeof useGamesFilterLazyQuery>;
export type GamesFilterQueryResult = Apollo.QueryResult<GamesFilterQuery, GamesFilterQueryVariables>;
export const ChannelUserBanViewQueryDocument = gql`
    query ChannelUserBanViewQuery($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
    userBanStatus {
      bannedAt
      violation
      description
      appeal {
        appealText
        status
        reviewerComment
      }
    }
    ...ChannelLogo
  }
}
    ${ChannelLogoFragmentDoc}`;

/**
 * __useChannelUserBanViewQueryQuery__
 *
 * To run a query within a React component, call `useChannelUserBanViewQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelUserBanViewQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelUserBanViewQueryQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelUserBanViewQueryQuery(baseOptions: Apollo.QueryHookOptions<ChannelUserBanViewQueryQuery, ChannelUserBanViewQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelUserBanViewQueryQuery, ChannelUserBanViewQueryQueryVariables>(ChannelUserBanViewQueryDocument, options);
      }
export function useChannelUserBanViewQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelUserBanViewQueryQuery, ChannelUserBanViewQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelUserBanViewQueryQuery, ChannelUserBanViewQueryQueryVariables>(ChannelUserBanViewQueryDocument, options);
        }
export type ChannelUserBanViewQueryQueryHookResult = ReturnType<typeof useChannelUserBanViewQueryQuery>;
export type ChannelUserBanViewQueryLazyQueryHookResult = ReturnType<typeof useChannelUserBanViewQueryLazyQuery>;
export type ChannelUserBanViewQueryQueryResult = Apollo.QueryResult<ChannelUserBanViewQueryQuery, ChannelUserBanViewQueryQueryVariables>;
export const ChannelViewDocument = gql`
    query ChannelView($channelName: String!) {
  channelByName(name: $channelName) {
    id
    title
    name
    thumbnail
    description
    currentStreamId
    liveStatus
    offlineBanner
    followerCount
    viewerCount
    logo
    following
    streamer {
      userId
    }
    userBanStatus {
      banned
    }
    streamedGames {
      id
      name
    }
    subscription {
      state
    }
    ...ChannelViewLinks
    ...StreamPreviewCard
  }
}
    ${ChannelViewLinksFragmentDoc}
${StreamPreviewCardFragmentDoc}`;

/**
 * __useChannelViewQuery__
 *
 * To run a query within a React component, call `useChannelViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelViewQuery({
 *   variables: {
 *      channelName: // value for 'channelName'
 *   },
 * });
 */
export function useChannelViewQuery(baseOptions: Apollo.QueryHookOptions<ChannelViewQuery, ChannelViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelViewQuery, ChannelViewQueryVariables>(ChannelViewDocument, options);
      }
export function useChannelViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelViewQuery, ChannelViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelViewQuery, ChannelViewQueryVariables>(ChannelViewDocument, options);
        }
export type ChannelViewQueryHookResult = ReturnType<typeof useChannelViewQuery>;
export type ChannelViewLazyQueryHookResult = ReturnType<typeof useChannelViewLazyQuery>;
export type ChannelViewQueryResult = Apollo.QueryResult<ChannelViewQuery, ChannelViewQueryVariables>;
export const SubscriptionInfoDocument = gql`
    query SubscriptionInfo($channelId: ID!) {
  channel(id: $channelId) {
    id
    subscriptionConfig {
      channelId
      subscriptionsEnabled
      tiers {
        level
        name
        description
        prices {
          period
          price
        }
        entitlements {
          amount
          itemId
        }
      }
    }
  }
}
    `;

/**
 * __useSubscriptionInfoQuery__
 *
 * To run a query within a React component, call `useSubscriptionInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionInfoQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSubscriptionInfoQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionInfoQuery, SubscriptionInfoQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionInfoQuery, SubscriptionInfoQueryVariables>(SubscriptionInfoDocument, options);
      }
export function useSubscriptionInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionInfoQuery, SubscriptionInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionInfoQuery, SubscriptionInfoQueryVariables>(SubscriptionInfoDocument, options);
        }
export type SubscriptionInfoQueryHookResult = ReturnType<typeof useSubscriptionInfoQuery>;
export type SubscriptionInfoLazyQueryHookResult = ReturnType<typeof useSubscriptionInfoLazyQuery>;
export type SubscriptionInfoQueryResult = Apollo.QueryResult<SubscriptionInfoQuery, SubscriptionInfoQueryVariables>;
export const AddFriendModalViewDocument = gql`
    query AddFriendModalView($userTag: String!) {
  resolveUserTags(userTags: [$userTag]) {
    userIds {
      key
      value
    }
  }
}
    `;

/**
 * __useAddFriendModalViewQuery__
 *
 * To run a query within a React component, call `useAddFriendModalViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddFriendModalViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddFriendModalViewQuery({
 *   variables: {
 *      userTag: // value for 'userTag'
 *   },
 * });
 */
export function useAddFriendModalViewQuery(baseOptions: Apollo.QueryHookOptions<AddFriendModalViewQuery, AddFriendModalViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddFriendModalViewQuery, AddFriendModalViewQueryVariables>(AddFriendModalViewDocument, options);
      }
export function useAddFriendModalViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddFriendModalViewQuery, AddFriendModalViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddFriendModalViewQuery, AddFriendModalViewQueryVariables>(AddFriendModalViewDocument, options);
        }
export type AddFriendModalViewQueryHookResult = ReturnType<typeof useAddFriendModalViewQuery>;
export type AddFriendModalViewLazyQueryHookResult = ReturnType<typeof useAddFriendModalViewLazyQuery>;
export type AddFriendModalViewQueryResult = Apollo.QueryResult<AddFriendModalViewQuery, AddFriendModalViewQueryVariables>;
export const FriendsViewFriendsDocument = gql`
    query FriendsViewFriends($userId: ID!, $cursor: String, $pageSize: Int!) {
  friends(
    userId: $userId
    cursor: {first: $pageSize, after: $cursor}
    priorityOrder: true
  ) {
    ...FriendsViewResponse
  }
}
    ${FriendsViewResponseFragmentDoc}`;

/**
 * __useFriendsViewFriendsQuery__
 *
 * To run a query within a React component, call `useFriendsViewFriendsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendsViewFriendsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendsViewFriendsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useFriendsViewFriendsQuery(baseOptions: Apollo.QueryHookOptions<FriendsViewFriendsQuery, FriendsViewFriendsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendsViewFriendsQuery, FriendsViewFriendsQueryVariables>(FriendsViewFriendsDocument, options);
      }
export function useFriendsViewFriendsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendsViewFriendsQuery, FriendsViewFriendsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendsViewFriendsQuery, FriendsViewFriendsQueryVariables>(FriendsViewFriendsDocument, options);
        }
export type FriendsViewFriendsQueryHookResult = ReturnType<typeof useFriendsViewFriendsQuery>;
export type FriendsViewFriendsLazyQueryHookResult = ReturnType<typeof useFriendsViewFriendsLazyQuery>;
export type FriendsViewFriendsQueryResult = Apollo.QueryResult<FriendsViewFriendsQuery, FriendsViewFriendsQueryVariables>;
export const FriendsViewRequestsDocument = gql`
    query FriendsViewRequests($userId: ID!) {
  receivedFriendRequests(userId: $userId) {
    users {
      ...FriendsViewUser
    }
  }
  sentFriendRequests(userId: $userId) {
    users {
      ...FriendsViewUser
    }
  }
}
    ${FriendsViewUserFragmentDoc}`;

/**
 * __useFriendsViewRequestsQuery__
 *
 * To run a query within a React component, call `useFriendsViewRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendsViewRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendsViewRequestsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFriendsViewRequestsQuery(baseOptions: Apollo.QueryHookOptions<FriendsViewRequestsQuery, FriendsViewRequestsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendsViewRequestsQuery, FriendsViewRequestsQueryVariables>(FriendsViewRequestsDocument, options);
      }
export function useFriendsViewRequestsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendsViewRequestsQuery, FriendsViewRequestsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendsViewRequestsQuery, FriendsViewRequestsQueryVariables>(FriendsViewRequestsDocument, options);
        }
export type FriendsViewRequestsQueryHookResult = ReturnType<typeof useFriendsViewRequestsQuery>;
export type FriendsViewRequestsLazyQueryHookResult = ReturnType<typeof useFriendsViewRequestsLazyQuery>;
export type FriendsViewRequestsQueryResult = Apollo.QueryResult<FriendsViewRequestsQuery, FriendsViewRequestsQueryVariables>;
export const ActiveFriendsPreviewDocument = gql`
    query ActiveFriendsPreview($userId: ID!) {
  friends(userId: $userId, filters: [{isOnline: true}]) {
    users {
      ...ActiveFriendsPreviewItem
    }
  }
}
    ${ActiveFriendsPreviewItemFragmentDoc}`;

/**
 * __useActiveFriendsPreviewQuery__
 *
 * To run a query within a React component, call `useActiveFriendsPreviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useActiveFriendsPreviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActiveFriendsPreviewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useActiveFriendsPreviewQuery(baseOptions: Apollo.QueryHookOptions<ActiveFriendsPreviewQuery, ActiveFriendsPreviewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActiveFriendsPreviewQuery, ActiveFriendsPreviewQueryVariables>(ActiveFriendsPreviewDocument, options);
      }
export function useActiveFriendsPreviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActiveFriendsPreviewQuery, ActiveFriendsPreviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActiveFriendsPreviewQuery, ActiveFriendsPreviewQueryVariables>(ActiveFriendsPreviewDocument, options);
        }
export type ActiveFriendsPreviewQueryHookResult = ReturnType<typeof useActiveFriendsPreviewQuery>;
export type ActiveFriendsPreviewLazyQueryHookResult = ReturnType<typeof useActiveFriendsPreviewLazyQuery>;
export type ActiveFriendsPreviewQueryResult = Apollo.QueryResult<ActiveFriendsPreviewQuery, ActiveFriendsPreviewQueryVariables>;
export const LiveChannelsDocument = gql`
    query LiveChannels {
  channels(liveStatus: LIVE_STATUS_LIVE) {
    channels {
      id
      ...OnlineChannelPreviewView
    }
  }
}
    ${OnlineChannelPreviewViewFragmentDoc}`;

/**
 * __useLiveChannelsQuery__
 *
 * To run a query within a React component, call `useLiveChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useLiveChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLiveChannelsQuery({
 *   variables: {
 *   },
 * });
 */
export function useLiveChannelsQuery(baseOptions?: Apollo.QueryHookOptions<LiveChannelsQuery, LiveChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LiveChannelsQuery, LiveChannelsQueryVariables>(LiveChannelsDocument, options);
      }
export function useLiveChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LiveChannelsQuery, LiveChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LiveChannelsQuery, LiveChannelsQueryVariables>(LiveChannelsDocument, options);
        }
export type LiveChannelsQueryHookResult = ReturnType<typeof useLiveChannelsQuery>;
export type LiveChannelsLazyQueryHookResult = ReturnType<typeof useLiveChannelsLazyQuery>;
export type LiveChannelsQueryResult = Apollo.QueryResult<LiveChannelsQuery, LiveChannelsQueryVariables>;
export const UserTagDocument = gql`
    query UserTag($userTag: String!) {
  resolveUserTags(userTags: [$userTag]) {
    profiles {
      userId
      visibility
    }
  }
}
    `;

/**
 * __useUserTagQuery__
 *
 * To run a query within a React component, call `useUserTagQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserTagQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserTagQuery({
 *   variables: {
 *      userTag: // value for 'userTag'
 *   },
 * });
 */
export function useUserTagQuery(baseOptions: Apollo.QueryHookOptions<UserTagQuery, UserTagQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserTagQuery, UserTagQueryVariables>(UserTagDocument, options);
      }
export function useUserTagLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserTagQuery, UserTagQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserTagQuery, UserTagQueryVariables>(UserTagDocument, options);
        }
export type UserTagQueryHookResult = ReturnType<typeof useUserTagQuery>;
export type UserTagLazyQueryHookResult = ReturnType<typeof useUserTagLazyQuery>;
export type UserTagQueryResult = Apollo.QueryResult<UserTagQuery, UserTagQueryVariables>;
export const ProfileViewDocument = gql`
    query ProfileView($userId: ID) {
  profile(userId: $userId) {
    userId
    userTag
    onlineStatus
    friendshipStatus {
      status
    }
    avatars {
      avatar2D
    }
    friends {
      ...ProfileViewFriends
    }
    stats {
      matchesPlayed
      timePlayed
      cardsSucceeded
      dailyGoalCardsCompleted
    }
    ...ProfileGamesList
    ...UserHeaderRow
  }
}
    ${ProfileViewFriendsFragmentDoc}
${ProfileGamesListFragmentDoc}
${UserHeaderRowFragmentDoc}`;

/**
 * __useProfileViewQuery__
 *
 * To run a query within a React component, call `useProfileViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useProfileViewQuery(baseOptions?: Apollo.QueryHookOptions<ProfileViewQuery, ProfileViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileViewQuery, ProfileViewQueryVariables>(ProfileViewDocument, options);
      }
export function useProfileViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileViewQuery, ProfileViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileViewQuery, ProfileViewQueryVariables>(ProfileViewDocument, options);
        }
export type ProfileViewQueryHookResult = ReturnType<typeof useProfileViewQuery>;
export type ProfileViewLazyQueryHookResult = ReturnType<typeof useProfileViewLazyQuery>;
export type ProfileViewQueryResult = Apollo.QueryResult<ProfileViewQuery, ProfileViewQueryVariables>;
export const ReportedStreamerProfileDocument = gql`
    query ReportedStreamerProfile($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
    logo
  }
}
    `;

/**
 * __useReportedStreamerProfileQuery__
 *
 * To run a query within a React component, call `useReportedStreamerProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportedStreamerProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportedStreamerProfileQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useReportedStreamerProfileQuery(baseOptions: Apollo.QueryHookOptions<ReportedStreamerProfileQuery, ReportedStreamerProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportedStreamerProfileQuery, ReportedStreamerProfileQueryVariables>(ReportedStreamerProfileDocument, options);
      }
export function useReportedStreamerProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportedStreamerProfileQuery, ReportedStreamerProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportedStreamerProfileQuery, ReportedStreamerProfileQueryVariables>(ReportedStreamerProfileDocument, options);
        }
export type ReportedStreamerProfileQueryHookResult = ReturnType<typeof useReportedStreamerProfileQuery>;
export type ReportedStreamerProfileLazyQueryHookResult = ReturnType<typeof useReportedStreamerProfileLazyQuery>;
export type ReportedStreamerProfileQueryResult = Apollo.QueryResult<ReportedStreamerProfileQuery, ReportedStreamerProfileQueryVariables>;
export const ReportUserDocument = gql`
    mutation ReportUser($reason: SupportReportReason!, $description: String, $context: SupportReportContextInput!) {
  createReport(reason: $reason, description: $description, context: $context) {
    createdAt
  }
}
    `;
export type ReportUserMutationFn = Apollo.MutationFunction<ReportUserMutation, ReportUserMutationVariables>;

/**
 * __useReportUserMutation__
 *
 * To run a mutation, you first call `useReportUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReportUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [reportUserMutation, { data, loading, error }] = useReportUserMutation({
 *   variables: {
 *      reason: // value for 'reason'
 *      description: // value for 'description'
 *      context: // value for 'context'
 *   },
 * });
 */
export function useReportUserMutation(baseOptions?: Apollo.MutationHookOptions<ReportUserMutation, ReportUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReportUserMutation, ReportUserMutationVariables>(ReportUserDocument, options);
      }
export type ReportUserMutationHookResult = ReturnType<typeof useReportUserMutation>;
export type ReportUserMutationResult = Apollo.MutationResult<ReportUserMutation>;
export type ReportUserMutationOptions = Apollo.BaseMutationOptions<ReportUserMutation, ReportUserMutationVariables>;
export const ReportedUserDocument = gql`
    query ReportedUser($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    ...AvatarView
  }
}
    ${AvatarViewFragmentDoc}`;

/**
 * __useReportedUserQuery__
 *
 * To run a query within a React component, call `useReportedUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportedUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportedUserQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useReportedUserQuery(baseOptions: Apollo.QueryHookOptions<ReportedUserQuery, ReportedUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportedUserQuery, ReportedUserQueryVariables>(ReportedUserDocument, options);
      }
export function useReportedUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportedUserQuery, ReportedUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportedUserQuery, ReportedUserQueryVariables>(ReportedUserDocument, options);
        }
export type ReportedUserQueryHookResult = ReturnType<typeof useReportedUserQuery>;
export type ReportedUserLazyQueryHookResult = ReturnType<typeof useReportedUserLazyQuery>;
export type ReportedUserQueryResult = Apollo.QueryResult<ReportedUserQuery, ReportedUserQueryVariables>;
export const AdsPlacementDocument = gql`
    query AdsPlacement($placementId: ID) {
  placement(placementId: $placementId) {
    placementId
    reward {
      rarity
      readyAt
      prizes {
        kind
      }
    }
    ...RewardHint
    ...VideoRewardRow
  }
}
    ${RewardHintFragmentDoc}
${VideoRewardRowFragmentDoc}`;

/**
 * __useAdsPlacementQuery__
 *
 * To run a query within a React component, call `useAdsPlacementQuery` and pass it any options that fit your needs.
 * When your component renders, `useAdsPlacementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAdsPlacementQuery({
 *   variables: {
 *      placementId: // value for 'placementId'
 *   },
 * });
 */
export function useAdsPlacementQuery(baseOptions?: Apollo.QueryHookOptions<AdsPlacementQuery, AdsPlacementQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AdsPlacementQuery, AdsPlacementQueryVariables>(AdsPlacementDocument, options);
      }
export function useAdsPlacementLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AdsPlacementQuery, AdsPlacementQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AdsPlacementQuery, AdsPlacementQueryVariables>(AdsPlacementDocument, options);
        }
export type AdsPlacementQueryHookResult = ReturnType<typeof useAdsPlacementQuery>;
export type AdsPlacementLazyQueryHookResult = ReturnType<typeof useAdsPlacementLazyQuery>;
export type AdsPlacementQueryResult = Apollo.QueryResult<AdsPlacementQuery, AdsPlacementQueryVariables>;
export const AdsRewardPlacementDocument = gql`
    mutation AdsRewardPlacement($placementId: ID) {
  rewardPlacement(placementId: $placementId) {
    emptyTypeWorkaround
  }
}
    `;
export type AdsRewardPlacementMutationFn = Apollo.MutationFunction<AdsRewardPlacementMutation, AdsRewardPlacementMutationVariables>;

/**
 * __useAdsRewardPlacementMutation__
 *
 * To run a mutation, you first call `useAdsRewardPlacementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAdsRewardPlacementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [adsRewardPlacementMutation, { data, loading, error }] = useAdsRewardPlacementMutation({
 *   variables: {
 *      placementId: // value for 'placementId'
 *   },
 * });
 */
export function useAdsRewardPlacementMutation(baseOptions?: Apollo.MutationHookOptions<AdsRewardPlacementMutation, AdsRewardPlacementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AdsRewardPlacementMutation, AdsRewardPlacementMutationVariables>(AdsRewardPlacementDocument, options);
      }
export type AdsRewardPlacementMutationHookResult = ReturnType<typeof useAdsRewardPlacementMutation>;
export type AdsRewardPlacementMutationResult = Apollo.MutationResult<AdsRewardPlacementMutation>;
export type AdsRewardPlacementMutationOptions = Apollo.BaseMutationOptions<AdsRewardPlacementMutation, AdsRewardPlacementMutationVariables>;
export const StreamChatViewDocument = gql`
    query StreamChatView($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
  }
}
    `;

/**
 * __useStreamChatViewQuery__
 *
 * To run a query within a React component, call `useStreamChatViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamChatViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamChatViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useStreamChatViewQuery(baseOptions: Apollo.QueryHookOptions<StreamChatViewQuery, StreamChatViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamChatViewQuery, StreamChatViewQueryVariables>(StreamChatViewDocument, options);
      }
export function useStreamChatViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamChatViewQuery, StreamChatViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamChatViewQuery, StreamChatViewQueryVariables>(StreamChatViewDocument, options);
        }
export type StreamChatViewQueryHookResult = ReturnType<typeof useStreamChatViewQuery>;
export type StreamChatViewLazyQueryHookResult = ReturnType<typeof useStreamChatViewLazyQuery>;
export type StreamChatViewQueryResult = Apollo.QueryResult<StreamChatViewQuery, StreamChatViewQueryVariables>;
export const StreamChatMessageDocument = gql`
    query StreamChatMessage($userId: ID!, $channelId: ID) {
  profile(userId: $userId) {
    userId
    ...AvatarView
    preferredColor
    badges(channel_id: $channelId) {
      ...UserBadge
    }
  }
}
    ${AvatarViewFragmentDoc}
${UserBadgeFragmentDoc}`;

/**
 * __useStreamChatMessageQuery__
 *
 * To run a query within a React component, call `useStreamChatMessageQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamChatMessageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamChatMessageQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStreamChatMessageQuery(baseOptions: Apollo.QueryHookOptions<StreamChatMessageQuery, StreamChatMessageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamChatMessageQuery, StreamChatMessageQueryVariables>(StreamChatMessageDocument, options);
      }
export function useStreamChatMessageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamChatMessageQuery, StreamChatMessageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamChatMessageQuery, StreamChatMessageQueryVariables>(StreamChatMessageDocument, options);
        }
export type StreamChatMessageQueryHookResult = ReturnType<typeof useStreamChatMessageQuery>;
export type StreamChatMessageLazyQueryHookResult = ReturnType<typeof useStreamChatMessageLazyQuery>;
export type StreamChatMessageQueryResult = Apollo.QueryResult<StreamChatMessageQuery, StreamChatMessageQueryVariables>;
export const StreamProfileModalViewDocument = gql`
    query StreamProfileModalView($userId: ID!, $channelId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    onlineStatus
    discordUsername
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    friendshipStatus {
      status
    }
    ...AvatarView
  }
  userChannelSubscription(userId: $userId, channelId: $channelId) {
    activatedAt
  }
}
    ${UserBadgeFragmentDoc}
${AvatarViewFragmentDoc}`;

/**
 * __useStreamProfileModalViewQuery__
 *
 * To run a query within a React component, call `useStreamProfileModalViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamProfileModalViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamProfileModalViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStreamProfileModalViewQuery(baseOptions: Apollo.QueryHookOptions<StreamProfileModalViewQuery, StreamProfileModalViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamProfileModalViewQuery, StreamProfileModalViewQueryVariables>(StreamProfileModalViewDocument, options);
      }
export function useStreamProfileModalViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamProfileModalViewQuery, StreamProfileModalViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamProfileModalViewQuery, StreamProfileModalViewQueryVariables>(StreamProfileModalViewDocument, options);
        }
export type StreamProfileModalViewQueryHookResult = ReturnType<typeof useStreamProfileModalViewQuery>;
export type StreamProfileModalViewLazyQueryHookResult = ReturnType<typeof useStreamProfileModalViewLazyQuery>;
export type StreamProfileModalViewQueryResult = Apollo.QueryResult<StreamProfileModalViewQuery, StreamProfileModalViewQueryVariables>;
export const StreamViewChannelQueryDocument = gql`
    query StreamViewChannelQuery($channelId: ID!) {
  channel(id: $channelId) {
    id
    currentChatId
    followerCount
    matureRatedContent
    userBanStatus {
      banned
    }
    streamer {
      userId
    }
    ...StreamInfoChannel
    ...StreamPlayer
  }
}
    ${StreamInfoChannelFragmentDoc}
${StreamPlayerFragmentDoc}`;

/**
 * __useStreamViewChannelQueryQuery__
 *
 * To run a query within a React component, call `useStreamViewChannelQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamViewChannelQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamViewChannelQueryQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStreamViewChannelQueryQuery(baseOptions: Apollo.QueryHookOptions<StreamViewChannelQueryQuery, StreamViewChannelQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamViewChannelQueryQuery, StreamViewChannelQueryQueryVariables>(StreamViewChannelQueryDocument, options);
      }
export function useStreamViewChannelQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamViewChannelQueryQuery, StreamViewChannelQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamViewChannelQueryQuery, StreamViewChannelQueryQueryVariables>(StreamViewChannelQueryDocument, options);
        }
export type StreamViewChannelQueryQueryHookResult = ReturnType<typeof useStreamViewChannelQueryQuery>;
export type StreamViewChannelQueryLazyQueryHookResult = ReturnType<typeof useStreamViewChannelQueryLazyQuery>;
export type StreamViewChannelQueryQueryResult = Apollo.QueryResult<StreamViewChannelQueryQuery, StreamViewChannelQueryQueryVariables>;
export const ManageSubscriptionDocument = gql`
    query ManageSubscription($channelId: ID!, $userId: ID!) {
  userChannelSubscription(channelId: $channelId, userId: $userId) {
    provider
  }
}
    `;

/**
 * __useManageSubscriptionQuery__
 *
 * To run a query within a React component, call `useManageSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageSubscriptionQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useManageSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<ManageSubscriptionQuery, ManageSubscriptionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageSubscriptionQuery, ManageSubscriptionQueryVariables>(ManageSubscriptionDocument, options);
      }
export function useManageSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageSubscriptionQuery, ManageSubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageSubscriptionQuery, ManageSubscriptionQueryVariables>(ManageSubscriptionDocument, options);
        }
export type ManageSubscriptionQueryHookResult = ReturnType<typeof useManageSubscriptionQuery>;
export type ManageSubscriptionLazyQueryHookResult = ReturnType<typeof useManageSubscriptionLazyQuery>;
export type ManageSubscriptionQueryResult = Apollo.QueryResult<ManageSubscriptionQuery, ManageSubscriptionQueryVariables>;
export const SubscriptionModalDocument = gql`
    query SubscriptionModal($channelId: ID!) {
  channel(id: $channelId) {
    name
    logo
    ...SubscriptionGetChannelEmojisChannel
  }
}
    ${SubscriptionGetChannelEmojisChannelFragmentDoc}`;

/**
 * __useSubscriptionModalQuery__
 *
 * To run a query within a React component, call `useSubscriptionModalQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionModalQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionModalQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSubscriptionModalQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionModalQuery, SubscriptionModalQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionModalQuery, SubscriptionModalQueryVariables>(SubscriptionModalDocument, options);
      }
export function useSubscriptionModalLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionModalQuery, SubscriptionModalQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionModalQuery, SubscriptionModalQueryVariables>(SubscriptionModalDocument, options);
        }
export type SubscriptionModalQueryHookResult = ReturnType<typeof useSubscriptionModalQuery>;
export type SubscriptionModalLazyQueryHookResult = ReturnType<typeof useSubscriptionModalLazyQuery>;
export type SubscriptionModalQueryResult = Apollo.QueryResult<SubscriptionModalQuery, SubscriptionModalQueryVariables>;
export const SubscriptionsSettingListDocument = gql`
    query SubscriptionsSettingList($userId: ID!, $cursor: String) {
  userChannelSubscriptions(userId: $userId, cursor: {first: 5, after: $cursor}) {
    subscriptions {
      id
      state
      ...SubscriptionSettingItemSubscription
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
    ${SubscriptionSettingItemSubscriptionFragmentDoc}`;

/**
 * __useSubscriptionsSettingListQuery__
 *
 * To run a query within a React component, call `useSubscriptionsSettingListQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionsSettingListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionsSettingListQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useSubscriptionsSettingListQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionsSettingListQuery, SubscriptionsSettingListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionsSettingListQuery, SubscriptionsSettingListQueryVariables>(SubscriptionsSettingListDocument, options);
      }
export function useSubscriptionsSettingListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionsSettingListQuery, SubscriptionsSettingListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionsSettingListQuery, SubscriptionsSettingListQueryVariables>(SubscriptionsSettingListDocument, options);
        }
export type SubscriptionsSettingListQueryHookResult = ReturnType<typeof useSubscriptionsSettingListQuery>;
export type SubscriptionsSettingListLazyQueryHookResult = ReturnType<typeof useSubscriptionsSettingListLazyQuery>;
export type SubscriptionsSettingListQueryResult = Apollo.QueryResult<SubscriptionsSettingListQuery, SubscriptionsSettingListQueryVariables>;
export const CreatePlatformBanAppealDocument = gql`
    mutation CreatePlatformBanAppeal($userId: ID!, $appealText: String!) {
  createPlatformBanAppeal(userId: $userId, appealText: $appealText) {
    emptyTypeWorkaround
  }
}
    `;
export type CreatePlatformBanAppealMutationFn = Apollo.MutationFunction<CreatePlatformBanAppealMutation, CreatePlatformBanAppealMutationVariables>;

/**
 * __useCreatePlatformBanAppealMutation__
 *
 * To run a mutation, you first call `useCreatePlatformBanAppealMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlatformBanAppealMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlatformBanAppealMutation, { data, loading, error }] = useCreatePlatformBanAppealMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      appealText: // value for 'appealText'
 *   },
 * });
 */
export function useCreatePlatformBanAppealMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlatformBanAppealMutation, CreatePlatformBanAppealMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePlatformBanAppealMutation, CreatePlatformBanAppealMutationVariables>(CreatePlatformBanAppealDocument, options);
      }
export type CreatePlatformBanAppealMutationHookResult = ReturnType<typeof useCreatePlatformBanAppealMutation>;
export type CreatePlatformBanAppealMutationResult = Apollo.MutationResult<CreatePlatformBanAppealMutation>;
export type CreatePlatformBanAppealMutationOptions = Apollo.BaseMutationOptions<CreatePlatformBanAppealMutation, CreatePlatformBanAppealMutationVariables>;
export const UserPlatformBanViewDocument = gql`
    query UserPlatformBanView($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    ...AvatarView
  }
  platformBan(userId: $userId) {
    banId
    status
    violation
    description
    bannedAt
    expiresAt
    appeal {
      banId
      status
      appealText
    }
  }
}
    ${AvatarViewFragmentDoc}`;

/**
 * __useUserPlatformBanViewQuery__
 *
 * To run a query within a React component, call `useUserPlatformBanViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserPlatformBanViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserPlatformBanViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserPlatformBanViewQuery(baseOptions: Apollo.QueryHookOptions<UserPlatformBanViewQuery, UserPlatformBanViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserPlatformBanViewQuery, UserPlatformBanViewQueryVariables>(UserPlatformBanViewDocument, options);
      }
export function useUserPlatformBanViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserPlatformBanViewQuery, UserPlatformBanViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserPlatformBanViewQuery, UserPlatformBanViewQueryVariables>(UserPlatformBanViewDocument, options);
        }
export type UserPlatformBanViewQueryHookResult = ReturnType<typeof useUserPlatformBanViewQuery>;
export type UserPlatformBanViewLazyQueryHookResult = ReturnType<typeof useUserPlatformBanViewLazyQuery>;
export type UserPlatformBanViewQueryResult = Apollo.QueryResult<UserPlatformBanViewQuery, UserPlatformBanViewQueryVariables>;
export const UserSettingsViewDocument = gql`
    query UserSettingsView($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      roles
    }
  }
}
    `;

/**
 * __useUserSettingsViewQuery__
 *
 * To run a query within a React component, call `useUserSettingsViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserSettingsViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserSettingsViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserSettingsViewQuery(baseOptions: Apollo.QueryHookOptions<UserSettingsViewQuery, UserSettingsViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserSettingsViewQuery, UserSettingsViewQueryVariables>(UserSettingsViewDocument, options);
      }
export function useUserSettingsViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserSettingsViewQuery, UserSettingsViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserSettingsViewQuery, UserSettingsViewQueryVariables>(UserSettingsViewDocument, options);
        }
export type UserSettingsViewQueryHookResult = ReturnType<typeof useUserSettingsViewQuery>;
export type UserSettingsViewLazyQueryHookResult = ReturnType<typeof useUserSettingsViewLazyQuery>;
export type UserSettingsViewQueryResult = Apollo.QueryResult<UserSettingsViewQuery, UserSettingsViewQueryVariables>;
export const UserAccountViewDocument = gql`
    query UserAccountView($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      email
    }
  }
}
    `;

/**
 * __useUserAccountViewQuery__
 *
 * To run a query within a React component, call `useUserAccountViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserAccountViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserAccountViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserAccountViewQuery(baseOptions: Apollo.QueryHookOptions<UserAccountViewQuery, UserAccountViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserAccountViewQuery, UserAccountViewQueryVariables>(UserAccountViewDocument, options);
      }
export function useUserAccountViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserAccountViewQuery, UserAccountViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserAccountViewQuery, UserAccountViewQueryVariables>(UserAccountViewDocument, options);
        }
export type UserAccountViewQueryHookResult = ReturnType<typeof useUserAccountViewQuery>;
export type UserAccountViewLazyQueryHookResult = ReturnType<typeof useUserAccountViewLazyQuery>;
export type UserAccountViewQueryResult = Apollo.QueryResult<UserAccountViewQuery, UserAccountViewQueryVariables>;
export const DeleteOwnAccountDocument = gql`
    mutation DeleteOwnAccount {
  deleteUserData {
    taskId
  }
}
    `;
export type DeleteOwnAccountMutationFn = Apollo.MutationFunction<DeleteOwnAccountMutation, DeleteOwnAccountMutationVariables>;

/**
 * __useDeleteOwnAccountMutation__
 *
 * To run a mutation, you first call `useDeleteOwnAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOwnAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOwnAccountMutation, { data, loading, error }] = useDeleteOwnAccountMutation({
 *   variables: {
 *   },
 * });
 */
export function useDeleteOwnAccountMutation(baseOptions?: Apollo.MutationHookOptions<DeleteOwnAccountMutation, DeleteOwnAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteOwnAccountMutation, DeleteOwnAccountMutationVariables>(DeleteOwnAccountDocument, options);
      }
export type DeleteOwnAccountMutationHookResult = ReturnType<typeof useDeleteOwnAccountMutation>;
export type DeleteOwnAccountMutationResult = Apollo.MutationResult<DeleteOwnAccountMutation>;
export type DeleteOwnAccountMutationOptions = Apollo.BaseMutationOptions<DeleteOwnAccountMutation, DeleteOwnAccountMutationVariables>;
export const UserBlockedViewDocument = gql`
    query UserBlockedView($userId: ID!) {
  blockedUsers(userId: $userId) {
    users {
      userId
      profile {
        userTag
        ...AvatarView
      }
      lastStatusChange
    }
  }
}
    ${AvatarViewFragmentDoc}`;

/**
 * __useUserBlockedViewQuery__
 *
 * To run a query within a React component, call `useUserBlockedViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserBlockedViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserBlockedViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserBlockedViewQuery(baseOptions: Apollo.QueryHookOptions<UserBlockedViewQuery, UserBlockedViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserBlockedViewQuery, UserBlockedViewQueryVariables>(UserBlockedViewDocument, options);
      }
export function useUserBlockedViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserBlockedViewQuery, UserBlockedViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserBlockedViewQuery, UserBlockedViewQueryVariables>(UserBlockedViewDocument, options);
        }
export type UserBlockedViewQueryHookResult = ReturnType<typeof useUserBlockedViewQuery>;
export type UserBlockedViewLazyQueryHookResult = ReturnType<typeof useUserBlockedViewLazyQuery>;
export type UserBlockedViewQueryResult = Apollo.QueryResult<UserBlockedViewQuery, UserBlockedViewQueryVariables>;
export const UserConnectionsViewDocument = gql`
    query userConnectionsView($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      uid
      externalIds {
        type
      }
    }
  }
}
    `;

/**
 * __useUserConnectionsViewQuery__
 *
 * To run a query within a React component, call `useUserConnectionsViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserConnectionsViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserConnectionsViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserConnectionsViewQuery(baseOptions: Apollo.QueryHookOptions<UserConnectionsViewQuery, UserConnectionsViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserConnectionsViewQuery, UserConnectionsViewQueryVariables>(UserConnectionsViewDocument, options);
      }
export function useUserConnectionsViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserConnectionsViewQuery, UserConnectionsViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserConnectionsViewQuery, UserConnectionsViewQueryVariables>(UserConnectionsViewDocument, options);
        }
export type UserConnectionsViewQueryHookResult = ReturnType<typeof useUserConnectionsViewQuery>;
export type UserConnectionsViewLazyQueryHookResult = ReturnType<typeof useUserConnectionsViewLazyQuery>;
export type UserConnectionsViewQueryResult = Apollo.QueryResult<UserConnectionsViewQuery, UserConnectionsViewQueryVariables>;
export const UserDeveloperViewDocument = gql`
    query UserDeveloperView($userId: ID!) {
  userFeatureFlags(userId: $userId) {
    flags {
      name
      value
      revision
    }
  }
}
    `;

/**
 * __useUserDeveloperViewQuery__
 *
 * To run a query within a React component, call `useUserDeveloperViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserDeveloperViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserDeveloperViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserDeveloperViewQuery(baseOptions: Apollo.QueryHookOptions<UserDeveloperViewQuery, UserDeveloperViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserDeveloperViewQuery, UserDeveloperViewQueryVariables>(UserDeveloperViewDocument, options);
      }
export function useUserDeveloperViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserDeveloperViewQuery, UserDeveloperViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserDeveloperViewQuery, UserDeveloperViewQueryVariables>(UserDeveloperViewDocument, options);
        }
export type UserDeveloperViewQueryHookResult = ReturnType<typeof useUserDeveloperViewQuery>;
export type UserDeveloperViewLazyQueryHookResult = ReturnType<typeof useUserDeveloperViewLazyQuery>;
export type UserDeveloperViewQueryResult = Apollo.QueryResult<UserDeveloperViewQuery, UserDeveloperViewQueryVariables>;
export const UserPrivacyViewDocument = gql`
    query UserPrivacyView($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      externalIds {
        id
        type
      }
    }
  }
  blockedUsers(userId: $userId) {
    users {
      userId
    }
  }
}
    `;

/**
 * __useUserPrivacyViewQuery__
 *
 * To run a query within a React component, call `useUserPrivacyViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserPrivacyViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserPrivacyViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserPrivacyViewQuery(baseOptions: Apollo.QueryHookOptions<UserPrivacyViewQuery, UserPrivacyViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserPrivacyViewQuery, UserPrivacyViewQueryVariables>(UserPrivacyViewDocument, options);
      }
export function useUserPrivacyViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserPrivacyViewQuery, UserPrivacyViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserPrivacyViewQuery, UserPrivacyViewQueryVariables>(UserPrivacyViewDocument, options);
        }
export type UserPrivacyViewQueryHookResult = ReturnType<typeof useUserPrivacyViewQuery>;
export type UserPrivacyViewLazyQueryHookResult = ReturnType<typeof useUserPrivacyViewLazyQuery>;
export type UserPrivacyViewQueryResult = Apollo.QueryResult<UserPrivacyViewQuery, UserPrivacyViewQueryVariables>;
export const ProfilePrivacySettingsDocument = gql`
    query ProfilePrivacySettings($userId: ID) {
  profile(userId: $userId) {
    userId
    account {
      matureRatedContentAllowed
    }
    settings {
      privacy {
        hideOnlineStatus
        visibility
        discordUsernameVisibility
        showMatureContentWarning
      }
      friends {
        disableFriendRequests
      }
    }
  }
}
    `;

/**
 * __useProfilePrivacySettingsQuery__
 *
 * To run a query within a React component, call `useProfilePrivacySettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfilePrivacySettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfilePrivacySettingsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useProfilePrivacySettingsQuery(baseOptions?: Apollo.QueryHookOptions<ProfilePrivacySettingsQuery, ProfilePrivacySettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfilePrivacySettingsQuery, ProfilePrivacySettingsQueryVariables>(ProfilePrivacySettingsDocument, options);
      }
export function useProfilePrivacySettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfilePrivacySettingsQuery, ProfilePrivacySettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfilePrivacySettingsQuery, ProfilePrivacySettingsQueryVariables>(ProfilePrivacySettingsDocument, options);
        }
export type ProfilePrivacySettingsQueryHookResult = ReturnType<typeof useProfilePrivacySettingsQuery>;
export type ProfilePrivacySettingsLazyQueryHookResult = ReturnType<typeof useProfilePrivacySettingsLazyQuery>;
export type ProfilePrivacySettingsQueryResult = Apollo.QueryResult<ProfilePrivacySettingsQuery, ProfilePrivacySettingsQueryVariables>;
export const UserProfileInfoViewDocument = gql`
    query UserProfileInfoView($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
  }
}
    `;

/**
 * __useUserProfileInfoViewQuery__
 *
 * To run a query within a React component, call `useUserProfileInfoViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserProfileInfoViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserProfileInfoViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserProfileInfoViewQuery(baseOptions: Apollo.QueryHookOptions<UserProfileInfoViewQuery, UserProfileInfoViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserProfileInfoViewQuery, UserProfileInfoViewQueryVariables>(UserProfileInfoViewDocument, options);
      }
export function useUserProfileInfoViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserProfileInfoViewQuery, UserProfileInfoViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserProfileInfoViewQuery, UserProfileInfoViewQueryVariables>(UserProfileInfoViewDocument, options);
        }
export type UserProfileInfoViewQueryHookResult = ReturnType<typeof useUserProfileInfoViewQuery>;
export type UserProfileInfoViewLazyQueryHookResult = ReturnType<typeof useUserProfileInfoViewLazyQuery>;
export type UserProfileInfoViewQueryResult = Apollo.QueryResult<UserProfileInfoViewQuery, UserProfileInfoViewQueryVariables>;
export const UserViewDocument = gql`
    query UserView($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    onlineStatus
    ...UserHeaderRow
    ...AvatarView
  }
}
    ${UserHeaderRowFragmentDoc}
${AvatarViewFragmentDoc}`;

/**
 * __useUserViewQuery__
 *
 * To run a query within a React component, call `useUserViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserViewQuery(baseOptions: Apollo.QueryHookOptions<UserViewQuery, UserViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserViewQuery, UserViewQueryVariables>(UserViewDocument, options);
      }
export function useUserViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserViewQuery, UserViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserViewQuery, UserViewQueryVariables>(UserViewDocument, options);
        }
export type UserViewQueryHookResult = ReturnType<typeof useUserViewQuery>;
export type UserViewLazyQueryHookResult = ReturnType<typeof useUserViewLazyQuery>;
export type UserViewQueryResult = Apollo.QueryResult<UserViewQuery, UserViewQueryVariables>;
export const AcceptTermsViewDocument = gql`
    query AcceptTermsView($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
  }
}
    `;

/**
 * __useAcceptTermsViewQuery__
 *
 * To run a query within a React component, call `useAcceptTermsViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useAcceptTermsViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAcceptTermsViewQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useAcceptTermsViewQuery(baseOptions: Apollo.QueryHookOptions<AcceptTermsViewQuery, AcceptTermsViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AcceptTermsViewQuery, AcceptTermsViewQueryVariables>(AcceptTermsViewDocument, options);
      }
export function useAcceptTermsViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AcceptTermsViewQuery, AcceptTermsViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AcceptTermsViewQuery, AcceptTermsViewQueryVariables>(AcceptTermsViewDocument, options);
        }
export type AcceptTermsViewQueryHookResult = ReturnType<typeof useAcceptTermsViewQuery>;
export type AcceptTermsViewLazyQueryHookResult = ReturnType<typeof useAcceptTermsViewLazyQuery>;
export type AcceptTermsViewQueryResult = Apollo.QueryResult<AcceptTermsViewQuery, AcceptTermsViewQueryVariables>;
export const SignTermsAgreementDocument = gql`
    mutation SignTermsAgreement($agreement: AuthTermsVersionInput!) {
  signAgreements(agreements: [$agreement]) {
    emptyTypeWorkaround
  }
}
    `;
export type SignTermsAgreementMutationFn = Apollo.MutationFunction<SignTermsAgreementMutation, SignTermsAgreementMutationVariables>;

/**
 * __useSignTermsAgreementMutation__
 *
 * To run a mutation, you first call `useSignTermsAgreementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignTermsAgreementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signTermsAgreementMutation, { data, loading, error }] = useSignTermsAgreementMutation({
 *   variables: {
 *      agreement: // value for 'agreement'
 *   },
 * });
 */
export function useSignTermsAgreementMutation(baseOptions?: Apollo.MutationHookOptions<SignTermsAgreementMutation, SignTermsAgreementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignTermsAgreementMutation, SignTermsAgreementMutationVariables>(SignTermsAgreementDocument, options);
      }
export type SignTermsAgreementMutationHookResult = ReturnType<typeof useSignTermsAgreementMutation>;
export type SignTermsAgreementMutationResult = Apollo.MutationResult<SignTermsAgreementMutation>;
export type SignTermsAgreementMutationOptions = Apollo.BaseMutationOptions<SignTermsAgreementMutation, SignTermsAgreementMutationVariables>;
export const AvatarSelectorViewDocument = gql`
    query AvatarSelectorView {
  avatars {
    avatars {
      ...AvatarSelectorOption
    }
  }
}
    ${AvatarSelectorOptionFragmentDoc}`;

/**
 * __useAvatarSelectorViewQuery__
 *
 * To run a query within a React component, call `useAvatarSelectorViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useAvatarSelectorViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAvatarSelectorViewQuery({
 *   variables: {
 *   },
 * });
 */
export function useAvatarSelectorViewQuery(baseOptions?: Apollo.QueryHookOptions<AvatarSelectorViewQuery, AvatarSelectorViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AvatarSelectorViewQuery, AvatarSelectorViewQueryVariables>(AvatarSelectorViewDocument, options);
      }
export function useAvatarSelectorViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AvatarSelectorViewQuery, AvatarSelectorViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AvatarSelectorViewQuery, AvatarSelectorViewQueryVariables>(AvatarSelectorViewDocument, options);
        }
export type AvatarSelectorViewQueryHookResult = ReturnType<typeof useAvatarSelectorViewQuery>;
export type AvatarSelectorViewLazyQueryHookResult = ReturnType<typeof useAvatarSelectorViewLazyQuery>;
export type AvatarSelectorViewQueryResult = Apollo.QueryResult<AvatarSelectorViewQuery, AvatarSelectorViewQueryVariables>;
export const TestChannelQueryDocument = gql`
    query TestChannelQuery {
  channels {
    channels {
      id
      name
    }
  }
}
    `;

/**
 * __useTestChannelQueryQuery__
 *
 * To run a query within a React component, call `useTestChannelQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useTestChannelQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTestChannelQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useTestChannelQueryQuery(baseOptions?: Apollo.QueryHookOptions<TestChannelQueryQuery, TestChannelQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TestChannelQueryQuery, TestChannelQueryQueryVariables>(TestChannelQueryDocument, options);
      }
export function useTestChannelQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TestChannelQueryQuery, TestChannelQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TestChannelQueryQuery, TestChannelQueryQueryVariables>(TestChannelQueryDocument, options);
        }
export type TestChannelQueryQueryHookResult = ReturnType<typeof useTestChannelQueryQuery>;
export type TestChannelQueryLazyQueryHookResult = ReturnType<typeof useTestChannelQueryLazyQuery>;
export type TestChannelQueryQueryResult = Apollo.QueryResult<TestChannelQueryQuery, TestChannelQueryQueryVariables>;
export const ChatChannelEventsSubscriptionDocument = gql`
    subscription ChatChannelEventsSubscription($channelId: ID!) {
  channelEventsSubscribe(channelId: $channelId) {
    channelId
    createdAt
    id
    content {
      content {
        ... on ChannelAvatarItemPurchase {
          itemId
          item {
            ...ChannelEventAvatarItemPurchaseItem
          }
          user {
            userId
            ...ChannelEventContentProfile
          }
        }
        ... on ChannelSubscriptionPurchase {
          userId
          tier
          user {
            userId
            ...ChannelEventContentProfile
            ...ChannelEventSubscriptionContentProfile
          }
        }
        ... on ChannelBundlePurchase {
          bundleName
          userId
          streamerCards {
            id
            channelId
            baseCard {
              id
              name
            }
          }
          user {
            userId
            ...ChannelEventContentProfile
          }
        }
        ... on ChannelStreamerCardPurchase {
          streamerCard {
            id
            channelId
            baseCard {
              id
              name
            }
          }
          userId
          user {
            userId
            ...ChannelEventContentProfile
          }
        }
        ... on ChannelGiftSubscriptionPurchase {
          userId
          user {
            userId
            ...ChannelEventContentProfile
            ...ChannelEventSubscriptionContentProfile
          }
          recipients {
            userId
            ...ChannelEventContentProfile
            ...ChannelEventSubscriptionContentProfile
          }
        }
      }
    }
  }
}
    ${ChannelEventAvatarItemPurchaseItemFragmentDoc}
${ChannelEventContentProfileFragmentDoc}
${ChannelEventSubscriptionContentProfileFragmentDoc}`;

/**
 * __useChatChannelEventsSubscriptionSubscription__
 *
 * To run a query within a React component, call `useChatChannelEventsSubscriptionSubscription` and pass it any options that fit your needs.
 * When your component renders, `useChatChannelEventsSubscriptionSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatChannelEventsSubscriptionSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChatChannelEventsSubscriptionSubscription(baseOptions: Apollo.SubscriptionHookOptions<ChatChannelEventsSubscriptionSubscription, ChatChannelEventsSubscriptionSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ChatChannelEventsSubscriptionSubscription, ChatChannelEventsSubscriptionSubscriptionVariables>(ChatChannelEventsSubscriptionDocument, options);
      }
export type ChatChannelEventsSubscriptionSubscriptionHookResult = ReturnType<typeof useChatChannelEventsSubscriptionSubscription>;
export type ChatChannelEventsSubscriptionSubscriptionResult = Apollo.SubscriptionResult<ChatChannelEventsSubscriptionSubscription>;
export const InventoryEmojisDocument = gql`
    query InventoryEmojis($userId: ID) {
  inventory(userId: $userId, filters: {itemType: TYPE_EMOJI}) {
    items {
      itemId
      item {
        id
        details {
          ...InventoryEmoji
        }
      }
    }
  }
}
    ${InventoryEmojiFragmentDoc}`;

/**
 * __useInventoryEmojisQuery__
 *
 * To run a query within a React component, call `useInventoryEmojisQuery` and pass it any options that fit your needs.
 * When your component renders, `useInventoryEmojisQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInventoryEmojisQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useInventoryEmojisQuery(baseOptions?: Apollo.QueryHookOptions<InventoryEmojisQuery, InventoryEmojisQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InventoryEmojisQuery, InventoryEmojisQueryVariables>(InventoryEmojisDocument, options);
      }
export function useInventoryEmojisLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InventoryEmojisQuery, InventoryEmojisQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InventoryEmojisQuery, InventoryEmojisQueryVariables>(InventoryEmojisDocument, options);
        }
export type InventoryEmojisQueryHookResult = ReturnType<typeof useInventoryEmojisQuery>;
export type InventoryEmojisLazyQueryHookResult = ReturnType<typeof useInventoryEmojisLazyQuery>;
export type InventoryEmojisQueryResult = Apollo.QueryResult<InventoryEmojisQuery, InventoryEmojisQueryVariables>;
export const SocialChannelBanDocument = gql`
    mutation SocialChannelBan($userId: ID!, $channelId: ID!, $violation: ChannelViolation, $description: String, $keepRecentMessages: Boolean) {
  banChannelUser(
    userId: $userId
    channelId: $channelId
    violation: $violation
    description: $description
    keepRecentMessages: $keepRecentMessages
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialChannelBanMutationFn = Apollo.MutationFunction<SocialChannelBanMutation, SocialChannelBanMutationVariables>;

/**
 * __useSocialChannelBanMutation__
 *
 * To run a mutation, you first call `useSocialChannelBanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialChannelBanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialChannelBanMutation, { data, loading, error }] = useSocialChannelBanMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *      violation: // value for 'violation'
 *      description: // value for 'description'
 *      keepRecentMessages: // value for 'keepRecentMessages'
 *   },
 * });
 */
export function useSocialChannelBanMutation(baseOptions?: Apollo.MutationHookOptions<SocialChannelBanMutation, SocialChannelBanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialChannelBanMutation, SocialChannelBanMutationVariables>(SocialChannelBanDocument, options);
      }
export type SocialChannelBanMutationHookResult = ReturnType<typeof useSocialChannelBanMutation>;
export type SocialChannelBanMutationResult = Apollo.MutationResult<SocialChannelBanMutation>;
export type SocialChannelBanMutationOptions = Apollo.BaseMutationOptions<SocialChannelBanMutation, SocialChannelBanMutationVariables>;
export const SocialChannelUnbanDocument = gql`
    mutation SocialChannelUnban($userId: ID!, $channelId: ID!) {
  unbanChannelUser(userId: $userId, channelId: $channelId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialChannelUnbanMutationFn = Apollo.MutationFunction<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>;

/**
 * __useSocialChannelUnbanMutation__
 *
 * To run a mutation, you first call `useSocialChannelUnbanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialChannelUnbanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialChannelUnbanMutation, { data, loading, error }] = useSocialChannelUnbanMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSocialChannelUnbanMutation(baseOptions?: Apollo.MutationHookOptions<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>(SocialChannelUnbanDocument, options);
      }
export type SocialChannelUnbanMutationHookResult = ReturnType<typeof useSocialChannelUnbanMutation>;
export type SocialChannelUnbanMutationResult = Apollo.MutationResult<SocialChannelUnbanMutation>;
export type SocialChannelUnbanMutationOptions = Apollo.BaseMutationOptions<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>;