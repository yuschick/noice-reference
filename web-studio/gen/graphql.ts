// THIS FILE IS GENERATED BY graphql-codegen, DO NOT EDIT!
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Duration: { input: string; output: string; }
  InputTimestamp: { input: string; output: string; }
  Timestamp: { input: string; output: string; }
};

export type ApiAddressInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  zip?: InputMaybe<Scalars['String']['input']>;
};

export type ApiCursorInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ApiDateInput = {
  day?: InputMaybe<Scalars['Int']['input']>;
  month?: InputMaybe<Scalars['Int']['input']>;
  year?: InputMaybe<Scalars['Int']['input']>;
};

export type ApiPageInfo = {
  __typename?: 'APIPageInfo';
  endCursor: Scalars['String']['output'];
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  startCursor: Scalars['String']['output'];
};

export type AdsGetPlacementResponse = {
  __typename?: 'AdsGetPlacementResponse';
  placementId: Scalars['ID']['output'];
  referenceId: Scalars['ID']['output'];
  /** TODO: Kept while migrating and set to the first item in rewards */
  reward: AdsRewardDescription;
  rewards: Array<AdsRewardDescription>;
  state: AdsPlacementState;
  updatesAt: Scalars['Timestamp']['output'];
};

export enum AdsPlacementState {
  PlacementStateNotReady = 'PLACEMENT_STATE_NOT_READY',
  PlacementStateReady = 'PLACEMENT_STATE_READY',
  PlacementStateUnspecified = 'PLACEMENT_STATE_UNSPECIFIED'
}

export type AdsPlacementStateEvent = {
  __typename?: 'AdsPlacementStateEvent';
  placementId: Scalars['ID']['output'];
  referenceId: Scalars['ID']['output'];
  state: AdsPlacementState;
  userId: Scalars['ID']['output'];
};

export type AdsRewardDescription = {
  __typename?: 'AdsRewardDescription';
  prizes: Array<AdsRewardDescriptionPrizeDescription>;
  rarity: RarityRarity;
  readyAt: Scalars['Timestamp']['output'];
};

export type AdsRewardDescriptionPrizeDescription = {
  __typename?: 'AdsRewardDescriptionPrizeDescription';
  amount: Scalars['Int']['output'];
  kind: AdsRewardDescriptionPrizeDescriptionKind;
  max: Scalars['Int']['output'];
  min: Scalars['Int']['output'];
  value: Scalars['String']['output'];
};

export enum AdsRewardDescriptionPrizeDescriptionKind {
  KindCurrency = 'KIND_CURRENCY',
  KindExperiencePoints = 'KIND_EXPERIENCE_POINTS',
  KindUnspecified = 'KIND_UNSPECIFIED'
}

export type AdyenAmount = {
  __typename?: 'AdyenAmount';
  currency: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type AdyenSession = {
  __typename?: 'AdyenSession';
  amount: AdyenAmount;
  id: Scalars['ID']['output'];
  reference: Scalars['String']['output'];
  returnUrl: Scalars['String']['output'];
  sessionData: Scalars['String']['output'];
};

export type AgreementAgreementRevision = {
  __typename?: 'AgreementAgreementRevision';
  name: Scalars['String']['output'];
  revision: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type AgreementListAgreementResponse = {
  __typename?: 'AgreementListAgreementResponse';
  agreements: Array<AgreementAgreementRevision>;
};

export type AnnouncementAnnouncement = {
  __typename?: 'AnnouncementAnnouncement';
  category: AnnouncementAnnouncementCategory;
  createdAt: Scalars['Timestamp']['output'];
  creator: ProfileProfile;
  creatorId: Scalars['ID']['output'];
  endTime?: Maybe<Scalars['Timestamp']['output']>;
  id: Scalars['ID']['output'];
  image: Scalars['String']['output'];
  imageUrl: Scalars['String']['output'];
  published: Scalars['Boolean']['output'];
  startTime?: Maybe<Scalars['Timestamp']['output']>;
  status: AnnouncementAnnouncementStatus;
  targets: AnnouncementTargets;
  text: Scalars['String']['output'];
  title: Scalars['String']['output'];
};

export enum AnnouncementAnnouncementCategory {
  AnnouncementCategoryGameApexLegends = 'ANNOUNCEMENT_CATEGORY_GAME_APEX_LEGENDS',
  AnnouncementCategoryGameDbd = 'ANNOUNCEMENT_CATEGORY_GAME_DBD',
  AnnouncementCategoryGameDota2 = 'ANNOUNCEMENT_CATEGORY_GAME_DOTA2',
  AnnouncementCategoryGameFortnite = 'ANNOUNCEMENT_CATEGORY_GAME_FORTNITE',
  AnnouncementCategoryGameLeagueOfLegends = 'ANNOUNCEMENT_CATEGORY_GAME_LEAGUE_OF_LEGENDS',
  AnnouncementCategoryPlatform = 'ANNOUNCEMENT_CATEGORY_PLATFORM',
  AnnouncementCategorySystem = 'ANNOUNCEMENT_CATEGORY_SYSTEM',
  AnnouncementCategoryUnspecified = 'ANNOUNCEMENT_CATEGORY_UNSPECIFIED'
}

export type AnnouncementAnnouncementFilterInput = {
  statuses?: InputMaybe<Array<AnnouncementAnnouncementStatus>>;
  targets?: InputMaybe<Array<AnnouncementAnnouncementTarget>>;
};

export type AnnouncementAnnouncementInput = {
  category?: InputMaybe<AnnouncementAnnouncementCategory>;
  createdAt?: InputMaybe<Scalars['InputTimestamp']['input']>;
  creatorId?: InputMaybe<Scalars['ID']['input']>;
  endTime?: InputMaybe<Scalars['InputTimestamp']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  startTime?: InputMaybe<Scalars['InputTimestamp']['input']>;
  status?: InputMaybe<AnnouncementAnnouncementStatus>;
  targets?: InputMaybe<AnnouncementTargetsInput>;
  text?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export enum AnnouncementAnnouncementStatus {
  AnnouncementStatusActive = 'ANNOUNCEMENT_STATUS_ACTIVE',
  AnnouncementStatusDraft = 'ANNOUNCEMENT_STATUS_DRAFT',
  AnnouncementStatusPast = 'ANNOUNCEMENT_STATUS_PAST',
  AnnouncementStatusScheduled = 'ANNOUNCEMENT_STATUS_SCHEDULED',
  AnnouncementStatusUnspecified = 'ANNOUNCEMENT_STATUS_UNSPECIFIED'
}

export enum AnnouncementAnnouncementTarget {
  AnnouncementTargetMobile = 'ANNOUNCEMENT_TARGET_MOBILE',
  AnnouncementTargetStudio = 'ANNOUNCEMENT_TARGET_STUDIO',
  AnnouncementTargetUnspecified = 'ANNOUNCEMENT_TARGET_UNSPECIFIED',
  AnnouncementTargetWeb = 'ANNOUNCEMENT_TARGET_WEB'
}

export type AnnouncementCreateAnnouncementImageUploadTokenResponse = {
  __typename?: 'AnnouncementCreateAnnouncementImageUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type AnnouncementListAnnouncementsResponse = {
  __typename?: 'AnnouncementListAnnouncementsResponse';
  announcements: Array<AnnouncementAnnouncement>;
  pageInfo: ApiPageInfo;
  totalCount: Scalars['Int']['output'];
};

export type AnnouncementListUserAnnouncementsResponse = {
  __typename?: 'AnnouncementListUserAnnouncementsResponse';
  announcements: Array<AnnouncementAnnouncement>;
  pageInfo: ApiPageInfo;
};

export type AnnouncementTargets = {
  __typename?: 'AnnouncementTargets';
  mobile: Scalars['Boolean']['output'];
  studio: Scalars['Boolean']['output'];
  web: Scalars['Boolean']['output'];
};

export type AnnouncementTargetsInput = {
  mobile?: InputMaybe<Scalars['Boolean']['input']>;
  studio?: InputMaybe<Scalars['Boolean']['input']>;
  web?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ApiEntityState {
  EntityStateBlocked = 'ENTITY_STATE_BLOCKED',
  EntityStateDeleted = 'ENTITY_STATE_DELETED',
  EntityStateUnspecified = 'ENTITY_STATE_UNSPECIFIED'
}

export type ArenaArena = {
  __typename?: 'ArenaArena';
  config?: Maybe<ArenaArenaConfigUnion>;
  enabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  thumbnailUrl: Scalars['String']['output'];
};

export type ArenaArenaConfigUnion = ArenaServerSideArenaConfig;

export type ArenaClientSideArena = {
  __typename?: 'ArenaClientSideArena';
  enabled: Scalars['Boolean']['output'];
  environmentUrl: Scalars['String']['output'];
  glbUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lightmapUrl: Scalars['String']['output'];
  name: Scalars['String']['output'];
  thumbnailUrl: Scalars['String']['output'];
  version: Scalars['String']['output'];
};

export type ArenaListArenasResponse = {
  __typename?: 'ArenaListArenasResponse';
  arenas: Array<ArenaArena>;
  pageInfo: ApiPageInfo;
};

export type ArenaListClientSideArenasResponse = {
  __typename?: 'ArenaListClientSideArenasResponse';
  arenas: Array<ArenaClientSideArena>;
};

export type ArenaServerSideArenaConfig = {
  __typename?: 'ArenaServerSideArenaConfig';
  arenaConfigUrl: Scalars['String']['output'];
  contentCatalogUrl: Scalars['String']['output'];
  gameViewScreenshotUrl: Scalars['String']['output'];
};

export type AttributeAttribute = {
  __typename?: 'AttributeAttribute';
  value?: Maybe<AttributeAttributeValueUnion>;
};

export type AttributeAttributeBoolArray = {
  __typename?: 'AttributeAttributeBoolArray';
  value: Array<Scalars['Boolean']['output']>;
};

export type AttributeAttributeBoolArrayInput = {
  value?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

export type AttributeAttributeFloatArray = {
  __typename?: 'AttributeAttributeFloatArray';
  value: Array<Scalars['Float']['output']>;
};

export type AttributeAttributeFloatArrayInput = {
  value?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type AttributeAttributeInput = {
  boolArrayValue?: InputMaybe<AttributeAttributeBoolArrayInput>;
  boolValue?: InputMaybe<Scalars['Boolean']['input']>;
  floatArrayValue?: InputMaybe<AttributeAttributeFloatArrayInput>;
  floatValue?: InputMaybe<Scalars['Float']['input']>;
  intArrayValue?: InputMaybe<AttributeAttributeIntArrayInput>;
  intValue?: InputMaybe<Scalars['Int']['input']>;
  mapValue?: InputMaybe<AttributeAttributeMapInput>;
  stringArrayValue?: InputMaybe<AttributeAttributeStringArrayInput>;
  stringValue?: InputMaybe<Scalars['String']['input']>;
};

export type AttributeAttributeIntArray = {
  __typename?: 'AttributeAttributeIntArray';
  value: Array<Scalars['Int']['output']>;
};

export type AttributeAttributeIntArrayInput = {
  value?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type AttributeAttributeMap = {
  __typename?: 'AttributeAttributeMap';
  value: Array<AttributeAttributeMapValueEntry>;
};

export type AttributeAttributeMapInput = {
  value?: InputMaybe<Array<AttributeAttributeMapValueEntryInput>>;
};

export type AttributeAttributeMapValueEntry = {
  __typename?: 'AttributeAttributeMapValueEntry';
  key: Scalars['String']['output'];
  value: AttributeAttribute;
};

export type AttributeAttributeMapValueEntryInput = {
  key?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type AttributeAttributeStringArray = {
  __typename?: 'AttributeAttributeStringArray';
  value: Array<Scalars['String']['output']>;
};

export type AttributeAttributeStringArrayInput = {
  value?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type AttributeAttributeValueUnion = AttributeAttributeBoolArray | AttributeAttributeFloatArray | AttributeAttributeIntArray | AttributeAttributeMap | AttributeAttributeStringArray | BooleanType | FloatType | IntType | StringType;

export type AuthAccount = {
  __typename?: 'AuthAccount';
  acceptedTerms: Array<AuthTermsVersion>;
  birthday?: Maybe<AuthDate>;
  channelCreationEligibility: ChannelChannelCreationEligibility;
  createdAt: Scalars['Timestamp']['output'];
  email: Scalars['String']['output'];
  emailVerifiedAt?: Maybe<Scalars['Timestamp']['output']>;
  externalIds: Array<AuthIdentity>;
  flags: Array<AuthAccountStatusFlag>;
  isBot: Scalars['Boolean']['output'];
  labels: Array<Scalars['String']['output']>;
  marketingConsent: AuthConsentStatus;
  matureRatedContentAllowed: Scalars['Boolean']['output'];
  pendingAgreements: Array<AgreementAgreementRevision>;
  roles: Array<AuthPlatformRole>;
  signupLocation: Scalars['String']['output'];
  signupOrigin?: Maybe<AuthSignupOrigin>;
  staff: Scalars['Boolean']['output'];
  state: ApiEntityState;
  temporary: Scalars['Boolean']['output'];
  uid: Scalars['String']['output'];
};

export enum AuthAccountStatusFlag {
  StatusFlagBanned = 'STATUS_FLAG_BANNED',
  StatusFlagDeletionScheduled = 'STATUS_FLAG_DELETION_SCHEDULED',
  StatusFlagUnspecified = 'STATUS_FLAG_UNSPECIFIED',
  StatusFlagWaitlist = 'STATUS_FLAG_WAITLIST'
}

export type AuthAccountUpdateInput = {
  roles?: InputMaybe<Array<AuthPlatformRole>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export enum AuthConsentStatus {
  ConsentStatusAccepted = 'CONSENT_STATUS_ACCEPTED',
  ConsentStatusDeclined = 'CONSENT_STATUS_DECLINED',
  ConsentStatusUnspecified = 'CONSENT_STATUS_UNSPECIFIED'
}

export type AuthDate = {
  __typename?: 'AuthDate';
  day: Scalars['Int']['output'];
  month: Scalars['Int']['output'];
  year: Scalars['Int']['output'];
};

export type AuthDateInput = {
  day?: InputMaybe<Scalars['Int']['input']>;
  month?: InputMaybe<Scalars['Int']['input']>;
  year?: InputMaybe<Scalars['Int']['input']>;
};

export type AuthIdentity = {
  __typename?: 'AuthIdentity';
  id: Scalars['ID']['output'];
  type: AuthIdentityType;
};

export enum AuthIdentityType {
  IdentityTypeApple = 'IDENTITY_TYPE_APPLE',
  IdentityTypeDiscord = 'IDENTITY_TYPE_DISCORD',
  IdentityTypeEmail = 'IDENTITY_TYPE_EMAIL',
  IdentityTypeUnspecified = 'IDENTITY_TYPE_UNSPECIFIED'
}

export enum AuthPlatformRole {
  PlatformRoleAdmin = 'PLATFORM_ROLE_ADMIN',
  PlatformRoleBot = 'PLATFORM_ROLE_BOT',
  PlatformRoleFullUser = 'PLATFORM_ROLE_FULL_USER',
  PlatformRoleGuest = 'PLATFORM_ROLE_GUEST',
  PlatformRoleModerator = 'PLATFORM_ROLE_MODERATOR',
  PlatformRolePxAgent = 'PLATFORM_ROLE_PX_AGENT',
  PlatformRoleRoot = 'PLATFORM_ROLE_ROOT',
  PlatformRoleStreamerTooling = 'PLATFORM_ROLE_STREAMER_TOOLING',
  PlatformRoleUnspecified = 'PLATFORM_ROLE_UNSPECIFIED',
  PlatformRoleUser = 'PLATFORM_ROLE_USER'
}

export type AuthSignupOrigin = {
  __typename?: 'AuthSignupOrigin';
  origin?: Maybe<AuthSignupOriginOriginUnion>;
};

export type AuthSignupOriginCampaign = {
  __typename?: 'AuthSignupOriginCampaign';
  campaign: Scalars['String']['output'];
  content: Scalars['String']['output'];
  creator: Scalars['String']['output'];
  format: Scalars['String']['output'];
  medium: Scalars['String']['output'];
  source: Scalars['String']['output'];
  term: Scalars['String']['output'];
};

export type AuthSignupOriginChannel = {
  __typename?: 'AuthSignupOriginChannel';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
};

export type AuthSignupOriginOriginUnion = AuthSignupOriginCampaign | AuthSignupOriginChannel | AuthSignupOriginPage;

export type AuthSignupOriginPage = {
  __typename?: 'AuthSignupOriginPage';
  url: Scalars['String']['output'];
};

export type AuthTermsVersion = {
  __typename?: 'AuthTermsVersion';
  name: Scalars['String']['output'];
  revision: Scalars['String']['output'];
  signature: Scalars['String']['output'];
};

export type AuthTermsVersionInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
  signature?: InputMaybe<Scalars['String']['input']>;
};

export type AuthV4GetOAuth2ConsentResponse = {
  __typename?: 'AuthV4GetOAuth2ConsentResponse';
  clientId: Scalars['ID']['output'];
  clientName: Scalars['String']['output'];
  scopes: Array<Scalars['String']['output']>;
};

export type AvatarAnimation = {
  __typename?: 'AvatarAnimation';
  category: Array<AvatarAnimationCategory>;
  chatCommand: Scalars['String']['output'];
  config: AvatarAnimationConfig;
  enabled: Scalars['Boolean']['output'];
  glbUrl: Scalars['String']['output'];
  iconUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  mirroredGlbUrl: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export enum AvatarAnimationCategory {
  CategoryAngry = 'CATEGORY_ANGRY',
  CategoryBoosterReceived = 'CATEGORY_BOOSTER_RECEIVED',
  CategoryBoosterRequested = 'CATEGORY_BOOSTER_REQUESTED',
  CategoryBoosterSent = 'CATEGORY_BOOSTER_SENT',
  CategoryCameraDrive = 'CATEGORY_CAMERA_DRIVE',
  CategoryCameraDriveExcited = 'CATEGORY_CAMERA_DRIVE_EXCITED',
  CategoryCardFailure = 'CATEGORY_CARD_FAILURE',
  CategoryCardMaxedOut = 'CATEGORY_CARD_MAXED_OUT',
  CategoryCardSuccess = 'CATEGORY_CARD_SUCCESS',
  CategoryChatMessage = 'CATEGORY_CHAT_MESSAGE',
  CategoryCheer = 'CATEGORY_CHEER',
  CategoryDance = 'CATEGORY_DANCE',
  CategoryDefeat = 'CATEGORY_DEFEAT',
  CategoryEditorIdle = 'CATEGORY_EDITOR_IDLE',
  CategoryEditorPickBody = 'CATEGORY_EDITOR_PICK_BODY',
  CategoryEditorPickFace = 'CATEGORY_EDITOR_PICK_FACE',
  CategoryEditorPickGloves = 'CATEGORY_EDITOR_PICK_GLOVES',
  CategoryEditorPickHat = 'CATEGORY_EDITOR_PICK_HAT',
  CategoryEditorPickJacket = 'CATEGORY_EDITOR_PICK_JACKET',
  CategoryEditorPickPants = 'CATEGORY_EDITOR_PICK_PANTS',
  CategoryEditorPickShoes = 'CATEGORY_EDITOR_PICK_SHOES',
  CategoryEmoji = 'CATEGORY_EMOJI',
  CategoryEmote = 'CATEGORY_EMOTE',
  CategoryExcited = 'CATEGORY_EXCITED',
  CategoryFsInChat = 'CATEGORY_FS_IN_CHAT',
  CategoryIdle = 'CATEGORY_IDLE',
  CategoryMessage = 'CATEGORY_MESSAGE',
  CategoryPhotoPoses = 'CATEGORY_PHOTO_POSES',
  CategoryPlayerExit = 'CATEGORY_PLAYER_EXIT',
  CategoryPlayerJoin = 'CATEGORY_PLAYER_JOIN',
  CategoryPlayerPickCard = 'CATEGORY_PLAYER_PICK_CARD',
  CategoryPlayerSwapCard = 'CATEGORY_PLAYER_SWAP_CARD',
  CategoryPoseConfused = 'CATEGORY_POSE_CONFUSED',
  CategoryPoseCool = 'CATEGORY_POSE_COOL',
  CategoryPoseCrying = 'CATEGORY_POSE_CRYING',
  CategoryPoseDefault = 'CATEGORY_POSE_DEFAULT',
  CategoryPoseJustJoking = 'CATEGORY_POSE_JUST_JOKING',
  CategoryPoseLol = 'CATEGORY_POSE_LOL',
  CategoryPoseLove = 'CATEGORY_POSE_LOVE',
  CategoryPoseNoice = 'CATEGORY_POSE_NOICE',
  CategoryPoseOhno = 'CATEGORY_POSE_OHNO',
  CategoryPoseParty = 'CATEGORY_POSE_PARTY',
  CategoryPoseRage = 'CATEGORY_POSE_RAGE',
  CategoryPoseSad = 'CATEGORY_POSE_SAD',
  CategoryPoseShocked = 'CATEGORY_POSE_SHOCKED',
  CategoryPoseSick = 'CATEGORY_POSE_SICK',
  CategoryPoseSmile = 'CATEGORY_POSE_SMILE',
  CategoryPoseSurprised = 'CATEGORY_POSE_SURPRISED',
  CategoryPoseSweat = 'CATEGORY_POSE_SWEAT',
  CategoryPoseWhoa = 'CATEGORY_POSE_WHOA',
  CategorySad = 'CATEGORY_SAD',
  CategorySpotlightCrowd = 'CATEGORY_SPOTLIGHT_CROWD',
  CategorySpotlightPodium = 'CATEGORY_SPOTLIGHT_PODIUM',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED',
  CategoryVictory = 'CATEGORY_VICTORY',
  CategoryWsInChat = 'CATEGORY_WS_IN_CHAT'
}

export type AvatarAnimationConfig = {
  __typename?: 'AvatarAnimationConfig';
  clamp: Scalars['Boolean']['output'];
  fadeInTimeSec: Scalars['Float']['output'];
  handedness: AvatarAnimationHandedness;
  interruptible: Scalars['Boolean']['output'];
  maxLoops: Scalars['Int']['output'];
  randomizeLoops: Scalars['Boolean']['output'];
};

export enum AvatarAnimationHandedness {
  HandednessBoth = 'HANDEDNESS_BOTH',
  HandednessLeft = 'HANDEDNESS_LEFT',
  HandednessRight = 'HANDEDNESS_RIGHT',
  HandednessUnspecified = 'HANDEDNESS_UNSPECIFIED'
}

export type AvatarAvatar = {
  __typename?: 'AvatarAvatar';
  assets: AvatarAvatarAssets;
  avatar3D: Scalars['String']['output'];
  avatarComposition: AvatarAvatarComposition;
  avatarLods: Array<Scalars['String']['output']>;
  body: Scalars['String']['output'];
  face: Scalars['String']['output'];
  /** todo: remove or use Gender instead */
  gender: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** selectable is used to determine if the avatar is shown in the avatar picker */
  selectable: Scalars['Boolean']['output'];
};

export type AvatarAvatarAssets = {
  __typename?: 'AvatarAvatarAssets';
  images: Array<AvatarAvatarAssetsImage>;
  lods: Array<AvatarAvatarAssetsLod>;
};

export type AvatarAvatarAssetsImage = {
  __typename?: 'AvatarAvatarAssetsImage';
  category: AvatarAvatarAssetsImageCategory;
  url: Scalars['String']['output'];
};

export enum AvatarAvatarAssetsImageCategory {
  CategoryPoseConfused = 'CATEGORY_POSE_CONFUSED',
  CategoryPoseCool = 'CATEGORY_POSE_COOL',
  CategoryPoseCrying = 'CATEGORY_POSE_CRYING',
  CategoryPoseJustJoking = 'CATEGORY_POSE_JUST_JOKING',
  CategoryPoseLol = 'CATEGORY_POSE_LOL',
  CategoryPoseLove = 'CATEGORY_POSE_LOVE',
  CategoryPoseNoice = 'CATEGORY_POSE_NOICE',
  CategoryPoseOhno = 'CATEGORY_POSE_OHNO',
  CategoryPoseParty = 'CATEGORY_POSE_PARTY',
  CategoryPoseRage = 'CATEGORY_POSE_RAGE',
  CategoryPoseSad = 'CATEGORY_POSE_SAD',
  CategoryPoseShocked = 'CATEGORY_POSE_SHOCKED',
  CategoryPoseSick = 'CATEGORY_POSE_SICK',
  CategoryPoseSmile = 'CATEGORY_POSE_SMILE',
  CategoryPoseSurprised = 'CATEGORY_POSE_SURPRISED',
  CategoryPoseSweat = 'CATEGORY_POSE_SWEAT',
  CategoryPoseWhoa = 'CATEGORY_POSE_WHOA',
  CategoryProfileBody = 'CATEGORY_PROFILE_BODY',
  CategoryProfileFace = 'CATEGORY_PROFILE_FACE',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED'
}

export type AvatarAvatarAssetsImageInput = {
  category?: InputMaybe<AvatarAvatarAssetsImageCategory>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type AvatarAvatarAssetsInput = {
  images?: InputMaybe<Array<AvatarAvatarAssetsImageInput>>;
  lods?: InputMaybe<Array<AvatarAvatarAssetsLodInput>>;
};

export type AvatarAvatarAssetsLod = {
  __typename?: 'AvatarAvatarAssetsLod';
  glbUrl: Scalars['String']['output'];
  skeletonType: AvatarAvatarAssetsLodSkeletonType;
};

export type AvatarAvatarAssetsLodInput = {
  glbUrl?: InputMaybe<Scalars['String']['input']>;
  skeletonType?: InputMaybe<AvatarAvatarAssetsLodSkeletonType>;
};

export enum AvatarAvatarAssetsLodSkeletonType {
  SkeletonTypeComplex = 'SKELETON_TYPE_COMPLEX',
  SkeletonTypeSimple = 'SKELETON_TYPE_SIMPLE',
  SkeletonTypeUnspecified = 'SKELETON_TYPE_UNSPECIFIED'
}

export type AvatarAvatarComposition = {
  __typename?: 'AvatarAvatarComposition';
  generatorVersion: Scalars['String']['output'];
  partCustomizations: Array<AvatarAvatarPartCustomization>;
  partIds: Array<Scalars['String']['output']>;
};

export type AvatarAvatarCompositionInput = {
  generatorVersion?: InputMaybe<Scalars['String']['input']>;
  partCustomizations?: InputMaybe<Array<AvatarAvatarPartCustomizationInput>>;
  partIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type AvatarAvatarInput = {
  assets?: InputMaybe<AvatarAvatarAssetsInput>;
  avatar3D?: InputMaybe<Scalars['String']['input']>;
  avatarComposition?: InputMaybe<AvatarAvatarCompositionInput>;
  avatarLods?: InputMaybe<Array<Scalars['String']['input']>>;
  body?: InputMaybe<Scalars['String']['input']>;
  face?: InputMaybe<Scalars['String']['input']>;
  /** todo: remove or use Gender instead */
  gender?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  /** selectable is used to determine if the avatar is shown in the avatar picker */
  selectable?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AvatarAvatarPart = {
  __typename?: 'AvatarAvatarPart';
  category: AvatarAvatarPartCategory;
  categoryOverride: Array<AvatarAvatarPartCategory>;
  channelId: Scalars['ID']['output'];
  clothingSet: Scalars['String']['output'];
  color: Scalars['String']['output'];
  colorPresetOptions: Array<Scalars['String']['output']>;
  colors: Array<Scalars['String']['output']>;
  default: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
  experimental: Scalars['Boolean']['output'];
  gender: AvatarGender;
  glbUrl: Scalars['String']['output'];
  glbUrlOverride?: Maybe<AvatarAvatarPartGlbUrlOverride>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  previewImgUrl: Scalars['String']['output'];
  sellable: Scalars['Boolean']['output'];
  skinData?: Maybe<AvatarAvatarPartSkinData>;
  skinOptions: Array<Scalars['String']['output']>;
  uniqueBootstrap: Scalars['Boolean']['output'];
  url: Scalars['String']['output'];
  userDefault: Scalars['Boolean']['output'];
};

export enum AvatarAvatarPartCategory {
  CategoryBeard = 'CATEGORY_BEARD',
  CategoryBody = 'CATEGORY_BODY',
  CategoryColorPreset = 'CATEGORY_COLOR_PRESET',
  CategoryEyebrows = 'CATEGORY_EYEBROWS',
  CategoryEyebrowsColor = 'CATEGORY_EYEBROWS_COLOR',
  CategoryEyelashes = 'CATEGORY_EYELASHES',
  CategoryEyelashesColor = 'CATEGORY_EYELASHES_COLOR',
  CategoryEyes = 'CATEGORY_EYES',
  CategoryFaceItem = 'CATEGORY_FACE_ITEM',
  CategoryHair = 'CATEGORY_HAIR',
  CategoryHairColor = 'CATEGORY_HAIR_COLOR',
  CategoryHands = 'CATEGORY_HANDS',
  CategoryHead = 'CATEGORY_HEAD',
  CategoryHeadItem = 'CATEGORY_HEAD_ITEM',
  CategoryLegs = 'CATEGORY_LEGS',
  CategoryShoes = 'CATEGORY_SHOES',
  CategorySkin = 'CATEGORY_SKIN',
  CategorySkinColor = 'CATEGORY_SKIN_COLOR',
  CategoryTeeth = 'CATEGORY_TEETH',
  CategoryTorso = 'CATEGORY_TORSO',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED'
}

export type AvatarAvatarPartCustomization = {
  __typename?: 'AvatarAvatarPartCustomization';
  colorPreset: Scalars['String']['output'];
  partId: Scalars['ID']['output'];
  skin: Scalars['String']['output'];
};

export type AvatarAvatarPartCustomizationInput = {
  colorPreset?: InputMaybe<Scalars['String']['input']>;
  partId?: InputMaybe<Scalars['ID']['input']>;
  skin?: InputMaybe<Scalars['String']['input']>;
};

export type AvatarAvatarPartGlbUrlOverride = {
  __typename?: 'AvatarAvatarPartGlbURLOverride';
  category: AvatarAvatarPartCategory;
  glbUrl: Scalars['String']['output'];
};

export type AvatarAvatarPartSkinData = {
  __typename?: 'AvatarAvatarPartSkinData';
  baseMapUrl: Scalars['String']['output'];
  emissionMapUrl: Scalars['String']['output'];
  normalMapUrl: Scalars['String']['output'];
  ormMapUrl: Scalars['String']['output'];
};

export type AvatarBatchGetAnimationsResponse = {
  __typename?: 'AvatarBatchGetAnimationsResponse';
  animations: Array<AvatarAnimation>;
};

export type AvatarBatchGetAvatarPartsResponse = {
  __typename?: 'AvatarBatchGetAvatarPartsResponse';
  avatarParts: Array<AvatarAvatarPart>;
};

export type AvatarBatchGetAvatarsResponse = {
  __typename?: 'AvatarBatchGetAvatarsResponse';
  avatars: Array<AvatarAvatar>;
};

export enum AvatarGender {
  GenderFemale = 'GENDER_FEMALE',
  GenderMale = 'GENDER_MALE',
  GenderUnspecified = 'GENDER_UNSPECIFIED'
}

export type AvatarListAnimationsResponse = {
  __typename?: 'AvatarListAnimationsResponse';
  animations: Array<AvatarAnimation>;
};

export type AvatarListAvatarPartsResponse = {
  __typename?: 'AvatarListAvatarPartsResponse';
  avatarParts: Array<AvatarAvatarPart>;
};

export type AvatarListAvatarsResponse = {
  __typename?: 'AvatarListAvatarsResponse';
  avatars: Array<AvatarAvatar>;
  pageInfo: ApiPageInfo;
};

export type AvatarValidateAvatarCompositionResponse = {
  __typename?: 'AvatarValidateAvatarCompositionResponse';
  changes: Array<AvatarValidateAvatarCompositionResponseChange>;
  composition: AvatarAvatarComposition;
  /** @deprecated field is deprecated */
  duplicatePartIds: Array<Scalars['String']['output']>;
  isDefault: Scalars['Boolean']['output'];
  /** @deprecated field is deprecated */
  missingPartCategories: Array<AvatarAvatarPartCategory>;
  /** @deprecated field is deprecated */
  missingPartIds: Array<Scalars['String']['output']>;
};

export type AvatarValidateAvatarCompositionResponseChange = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChange';
  action?: Maybe<AvatarValidateAvatarCompositionResponseChangeActionUnion>;
};

export type AvatarValidateAvatarCompositionResponseChangeActionUnion = AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded | AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved | AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced;

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded';
  id: Scalars['ID']['output'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
};

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved';
  id: Scalars['ID']['output'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
};

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced';
  id: Scalars['ID']['output'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
  replacementId: Scalars['ID']['output'];
};

export enum AvatarValidateAvatarCompositionResponseChangeReason {
  ReasonAvatarPartBodyRequired = 'REASON_AVATAR_PART_BODY_REQUIRED',
  ReasonAvatarPartEyesRequired = 'REASON_AVATAR_PART_EYES_REQUIRED',
  ReasonAvatarPartHeadRequired = 'REASON_AVATAR_PART_HEAD_REQUIRED',
  ReasonAvatarPartLegsRequired = 'REASON_AVATAR_PART_LEGS_REQUIRED',
  ReasonAvatarPartTorsoRequired = 'REASON_AVATAR_PART_TORSO_REQUIRED',
  ReasonAvatarPartUnavailable = 'REASON_AVATAR_PART_UNAVAILABLE',
  ReasonAvatarPartUnknown = 'REASON_AVATAR_PART_UNKNOWN',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type BadgeBadge = {
  __typename?: 'BadgeBadge';
  level: Scalars['Int']['output'];
  nextLevelAt: Scalars['Timestamp']['output'];
  type: BadgeBadgeType;
};

export enum BadgeBadgeType {
  TypeChannelModerator = 'TYPE_CHANNEL_MODERATOR',
  TypeChannelSubscriber = 'TYPE_CHANNEL_SUBSCRIBER',
  TypeClosedBetaCreator = 'TYPE_CLOSED_BETA_CREATOR',
  TypeNoiceStaff = 'TYPE_NOICE_STAFF',
  TypeStreamer = 'TYPE_STREAMER',
  TypeSubsGifter = 'TYPE_SUBS_GIFTER',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type BadgeBatchGetUserBadgesResponse = {
  __typename?: 'BadgeBatchGetUserBadgesResponse';
  badges: Array<BadgeUserBadges>;
};

export type BadgeGetUserBadgesResponse = {
  __typename?: 'BadgeGetUserBadgesResponse';
  badges: Array<BadgeBadge>;
};

export type BadgeUserBadges = {
  __typename?: 'BadgeUserBadges';
  badges: Array<BadgeBadge>;
  userId: Scalars['ID']['output'];
};

export type BooleanType = {
  __typename?: 'BooleanType';
  /** The wrapped value of type Boolean */
  value: Scalars['Boolean']['output'];
};

export type ChallengeChallengeReward = {
  __typename?: 'ChallengeChallengeReward';
  gameId: Scalars['ID']['output'];
  maxPickRate: Scalars['Int']['output'];
  minPickRate: Scalars['Int']['output'];
  reward: RewardRewardType;
};

export type ChallengeChallengeUpdateInput = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChallengeGetChallengeRewardsResponse = {
  __typename?: 'ChallengeGetChallengeRewardsResponse';
  rewards: Array<ChallengeChallengeReward>;
};

export type ChallengeListChallengesResponse = {
  __typename?: 'ChallengeListChallengesResponse';
  challenges: Array<GameLogicChallenge>;
};

export type ChallengesessionChallenge = {
  __typename?: 'ChallengesessionChallenge';
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  sessionId: Scalars['ID']['output'];
  state: ChallengesessionChallengeChallengeState;
};

export enum ChallengesessionChallengeChallengeState {
  ChallengeStateFailed = 'CHALLENGE_STATE_FAILED',
  ChallengeStateSucceeded = 'CHALLENGE_STATE_SUCCEEDED',
  ChallengeStateUnresolved = 'CHALLENGE_STATE_UNRESOLVED',
  ChallengeStateUnspecified = 'CHALLENGE_STATE_UNSPECIFIED'
}

export type ChallengesessionChallengeInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  sessionId?: InputMaybe<Scalars['ID']['input']>;
  state?: InputMaybe<ChallengesessionChallengeChallengeState>;
};

export type ChallengesessionChallengePick = {
  __typename?: 'ChallengesessionChallengePick';
  challengeId: Scalars['ID']['output'];
  sessionId: Scalars['ID']['output'];
  stake: ChallengesessionStake;
  userId: Scalars['ID']['output'];
};

export type ChallengesessionChallengeSession = {
  __typename?: 'ChallengesessionChallengeSession';
  challenges: Array<ChallengesessionChallenge>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  phase: ChallengesessionChallengeSessionPhase;
  streamId: Scalars['ID']['output'];
  submissionDeadline: Scalars['Timestamp']['output'];
  submissionWindowLength: Scalars['Int']['output'];
};

export type ChallengesessionChallengeSessionEvent = {
  __typename?: 'ChallengesessionChallengeSessionEvent';
  event?: Maybe<ChallengesessionChallengeSessionEventEventUnion>;
  streamId: Scalars['ID']['output'];
};

export type ChallengesessionChallengeSessionEventChallengeStatusChange = {
  __typename?: 'ChallengesessionChallengeSessionEventChallengeStatusChange';
  challenge: ChallengesessionChallenge;
  sessionId: Scalars['ID']['output'];
};

export type ChallengesessionChallengeSessionEventEventUnion = ChallengesessionChallengeSessionEventChallengeStatusChange | ChallengesessionChallengeSessionEventInitial | ChallengesessionChallengeSessionEventPhaseChange | ChallengesessionChallengeSessionEventStakeChange;

export type ChallengesessionChallengeSessionEventInitial = {
  __typename?: 'ChallengesessionChallengeSessionEventInitial';
  session: ChallengesessionChallengeSession;
  stats: Array<ChallengesessionChallengeStats>;
  userPick: ChallengesessionChallengePick;
};

export type ChallengesessionChallengeSessionEventPhaseChange = {
  __typename?: 'ChallengesessionChallengeSessionEventPhaseChange';
  session: ChallengesessionChallengeSession;
};

export type ChallengesessionChallengeSessionEventStakeChange = {
  __typename?: 'ChallengesessionChallengeSessionEventStakeChange';
  sessionId: Scalars['ID']['output'];
  stats: Array<ChallengesessionChallengeStats>;
};

export enum ChallengesessionChallengeSessionPhase {
  PhaseActive = 'PHASE_ACTIVE',
  PhaseCancelled = 'PHASE_CANCELLED',
  PhaseCompleted = 'PHASE_COMPLETED',
  PhaseDraft = 'PHASE_DRAFT',
  PhaseSubmission = 'PHASE_SUBMISSION',
  PhaseUnspecified = 'PHASE_UNSPECIFIED'
}

export type ChallengesessionChallengeSessionUpdateInput = {
  challenges?: InputMaybe<Array<ChallengesessionChallengeInput>>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
  submissionWindowLength?: InputMaybe<Scalars['Int']['input']>;
};

export type ChallengesessionChallengeStats = {
  __typename?: 'ChallengesessionChallengeStats';
  challengeId: Scalars['ID']['output'];
  highestStakePick: ChallengesessionChallengePick;
  sessionId: Scalars['ID']['output'];
  totalPicks: Scalars['Int']['output'];
  totalStake: ChallengesessionStake;
};

export type ChallengesessionStake = {
  __typename?: 'ChallengesessionStake';
  currencyAmount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
};

export type ChallengesessionStakeInput = {
  currencyAmount?: InputMaybe<Scalars['Int']['input']>;
  currencyId?: InputMaybe<Scalars['ID']['input']>;
};

export enum ChannelAppealStatus {
  AppealStatusAccepted = 'APPEAL_STATUS_ACCEPTED',
  AppealStatusDeclined = 'APPEAL_STATUS_DECLINED',
  AppealStatusPending = 'APPEAL_STATUS_PENDING',
  AppealStatusUnspecified = 'APPEAL_STATUS_UNSPECIFIED'
}

export enum ChannelAssetType {
  AssetTypeBanner = 'ASSET_TYPE_BANNER',
  AssetTypeLogo = 'ASSET_TYPE_LOGO',
  AssetTypeUnspecified = 'ASSET_TYPE_UNSPECIFIED'
}

export type ChannelAutomodItemAccepted = {
  __typename?: 'ChannelAutomodItemAccepted';
  message: ChatMessageContent;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelAutomodItemRejected = {
  __typename?: 'ChannelAutomodItemRejected';
  message: ChatMessageContent;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelAutomodSettings = {
  __typename?: 'ChannelAutomodSettings';
  defaultDecision: ChatAutomodDecision;
  level: ChatAutomodLevel;
};

export type ChannelAutomodSettingsInput = {
  defaultDecision?: InputMaybe<ChatAutomodDecision>;
  level?: InputMaybe<ChatAutomodLevel>;
};

export type ChannelAvatarItemPurchase = {
  __typename?: 'ChannelAvatarItemPurchase';
  item: ItemItem;
  itemId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelBanAppeal = {
  __typename?: 'ChannelBanAppeal';
  appealText: Scalars['String']['output'];
  bannedAt: Scalars['Timestamp']['output'];
  channelId: Scalars['ID']['output'];
  createdAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  moderatorId: Scalars['ID']['output'];
  reviewerComment: Scalars['String']['output'];
  reviewerId: Scalars['ID']['output'];
  status: ChannelAppealStatus;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelBanAppealAccepted = {
  __typename?: 'ChannelBanAppealAccepted';
  comment: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelBanAppealInfo = {
  __typename?: 'ChannelBanAppealInfo';
  appealText: Scalars['String']['output'];
  channelId: Scalars['ID']['output'];
  createdAt: Scalars['Timestamp']['output'];
  reviewer: ProfileProfile;
  reviewerComment: Scalars['String']['output'];
  reviewerId: Scalars['ID']['output'];
  status: ChannelAppealStatus;
  userId: Scalars['ID']['output'];
};

export type ChannelBanAppealRejected = {
  __typename?: 'ChannelBanAppealRejected';
  comment: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelBannedUser = {
  __typename?: 'ChannelBannedUser';
  appeal?: Maybe<ChannelBanAppealInfo>;
  bannedAt: Scalars['Timestamp']['output'];
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  keepRecentMessages: Scalars['Boolean']['output'];
  moderator: ProfileProfile;
  moderatorId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelBatchGetChannelsResponse = {
  __typename?: 'ChannelBatchGetChannelsResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelBatchGetGameStatsResponse = {
  __typename?: 'ChannelBatchGetGameStatsResponse';
  gameStats: Array<ChannelGameStats>;
};

export type ChannelBatchGetStreamSummaryResponse = {
  __typename?: 'ChannelBatchGetStreamSummaryResponse';
  summaries: Array<ChannelStreamSummary>;
};

export type ChannelBatchGetUserBanStatusResponse = {
  __typename?: 'ChannelBatchGetUserBanStatusResponse';
  statuses: Array<ChannelUserBanStatus>;
};

export type ChannelBatchStreamGetChannelResponse = {
  __typename?: 'ChannelBatchStreamGetChannelResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelBundlePurchase = {
  __typename?: 'ChannelBundlePurchase';
  bundleName: Scalars['String']['output'];
  streamerCardIds: Array<Scalars['String']['output']>;
  streamerCards?: Maybe<Array<GameLogicStreamerCard>>;
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelChallengesFeatureStatus = {
  __typename?: 'ChannelChallengesFeatureStatus';
  enabled: Scalars['Boolean']['output'];
};

/** Public channel information */
export type ChannelChannel = {
  __typename?: 'ChannelChannel';
  activeStream?: Maybe<ChannelStreamSummary>;
  channelFriends: FriendsChannelFriends;
  createdAt: Scalars['Timestamp']['output'];
  currentChatId?: Maybe<Scalars['String']['output']>;
  currentStream?: Maybe<ChannelStream>;
  currentStreamId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  features: ChannelChannelFeatures;
  followerCount: Scalars['Int']['output'];
  following: Scalars['Boolean']['output'];
  game: GameGame;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  isPublic: Scalars['Boolean']['output'];
  itemStats: Array<ItemItemStat>;
  links: Array<ChannelChannelLink>;
  liveStatus: ChannelLiveStatus;
  logo: Scalars['String']['output'];
  matchOngoing: Scalars['Boolean']['output'];
  matureRatedContent: Scalars['Boolean']['output'];
  monetizationSettings: ChannelMonetizationSettings;
  name: Scalars['String']['output'];
  offlineBanner: Scalars['String']['output'];
  offlineBannerUrl: Scalars['String']['output'];
  playedGameIds: Array<Scalars['String']['output']>;
  priority: Scalars['Int']['output'];
  reportingId: Scalars['ID']['output'];
  riskTier: ChannelRiskTier;
  state: ApiEntityState;
  streamedGames?: Maybe<Array<GameGame>>;
  streamer: ProfileProfile;
  streamerId: Scalars['ID']['output'];
  subscriberCount: Scalars['Int']['output'];
  subscription?: Maybe<SubscriptionChannelSubscription>;
  subscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  suspension: ChannelSuspension;
  thumbnail: Scalars['String']['output'];
  title: Scalars['String']['output'];
  userBanStatus: ChannelUserBanStatus;
  viewerCount: Scalars['Int']['output'];
};

export type ChannelChannelCreationEligibility = {
  __typename?: 'ChannelChannelCreationEligibility';
  canCreateChannel: Scalars['Boolean']['output'];
};

export type ChannelChannelDetailsUpdateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  featureChallengesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  featureNoicePredictionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  links?: InputMaybe<Array<ChannelChannelLinkInput>>;
  matureRatedContent?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  riskTier?: InputMaybe<ChannelRiskTier>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelChannelEvent = {
  __typename?: 'ChannelChannelEvent';
  channelId: Scalars['ID']['output'];
  content: ChannelChannelEventContent;
  createdAt: Scalars['Timestamp']['output'];
  id: Scalars['ID']['output'];
};

export type ChannelChannelEventContent = {
  __typename?: 'ChannelChannelEventContent';
  content?: Maybe<ChannelChannelEventContentContentUnion>;
};

export type ChannelChannelEventContentContentUnion = ChannelAvatarItemPurchase | ChannelBundlePurchase | ChannelGiftSubscriptionPurchase | ChannelStreamerCardPurchase | ChannelSubscriptionPurchase | ChannelSubscriptionRenewal;

export enum ChannelChannelFeature {
  ChannelFeatureChallenges = 'CHANNEL_FEATURE_CHALLENGES',
  ChannelFeatureNoicePredictions = 'CHANNEL_FEATURE_NOICE_PREDICTIONS',
  ChannelFeatureStreaming = 'CHANNEL_FEATURE_STREAMING',
  ChannelFeatureUnspecified = 'CHANNEL_FEATURE_UNSPECIFIED'
}

export type ChannelChannelFeatures = {
  __typename?: 'ChannelChannelFeatures';
  challenges: ChannelChallengesFeatureStatus;
  noicePredictions: ChannelNoicePredictionsFeatureStatus;
  streaming: ChannelStreamingFeatureStatus;
};

export type ChannelChannelLink = {
  __typename?: 'ChannelChannelLink';
  name: Scalars['String']['output'];
  type: ChannelChannelLinkLinkType;
  url: Scalars['String']['output'];
};

export type ChannelChannelLinkInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ChannelChannelLinkLinkType>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export enum ChannelChannelLinkLinkType {
  LinkTypeCustom = 'LINK_TYPE_CUSTOM',
  LinkTypeDiscord = 'LINK_TYPE_DISCORD',
  LinkTypeFacebook = 'LINK_TYPE_FACEBOOK',
  LinkTypeInstagram = 'LINK_TYPE_INSTAGRAM',
  LinkTypeTiktok = 'LINK_TYPE_TIKTOK',
  LinkTypeTwitter = 'LINK_TYPE_TWITTER',
  LinkTypeUnspecified = 'LINK_TYPE_UNSPECIFIED',
  LinkTypeYoutube = 'LINK_TYPE_YOUTUBE'
}

export enum ChannelChannelRole {
  ChannelRoleModerator = 'CHANNEL_ROLE_MODERATOR',
  ChannelRolePlatformModerator = 'CHANNEL_ROLE_PLATFORM_MODERATOR',
  ChannelRoleStreamer = 'CHANNEL_ROLE_STREAMER',
  ChannelRoleUnspecified = 'CHANNEL_ROLE_UNSPECIFIED'
}

export type ChannelChannelRoles = {
  __typename?: 'ChannelChannelRoles';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  roles: Array<ChannelChannelRole>;
};

export type ChannelChannelStreamDetailEvent = {
  __typename?: 'ChannelChannelStreamDetailEvent';
  challengesEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  liveStatus: ChannelLiveStatus;
  matureRatedContent: Scalars['Boolean']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  serverRenderingEnabled: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
  transcodingEnabled: Scalars['Boolean']['output'];
};

export type ChannelContentRendererConfig = {
  __typename?: 'ChannelContentRendererConfig';
  arenaId: Scalars['ID']['output'];
  containerImage: Scalars['String']['output'];
  controllerContainerImage: Scalars['String']['output'];
};

export type ChannelContentRendererConfigInput = {
  arenaId?: InputMaybe<Scalars['ID']['input']>;
  containerImage?: InputMaybe<Scalars['String']['input']>;
  controllerContainerImage?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelCreateChannelAssetUploadTokenResponse = {
  __typename?: 'ChannelCreateChannelAssetUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type ChannelFollowerCountEvent = {
  __typename?: 'ChannelFollowerCountEvent';
  channelId: Scalars['ID']['output'];
  followerCount: Scalars['Int']['output'];
};

export type ChannelFollowerNotificationSettings = {
  __typename?: 'ChannelFollowerNotificationSettings';
  channelId: Scalars['ID']['output'];
  channelLiveNotificationEnabled: Scalars['Boolean']['output'];
  userId: Scalars['ID']['output'];
};

export type ChannelGameStats = {
  __typename?: 'ChannelGameStats';
  game: GameGame;
  gameId: Scalars['ID']['output'];
  liveStreams: Scalars['Int']['output'];
};

export enum ChannelGender {
  GenderFemale = 'GENDER_FEMALE',
  GenderMale = 'GENDER_MALE',
  GenderUnspecified = 'GENDER_UNSPECIFIED'
}

export type ChannelGetChannelFollowerStatusResponse = {
  __typename?: 'ChannelGetChannelFollowerStatusResponse';
  followedAt?: Maybe<Scalars['Timestamp']['output']>;
  following: Scalars['Boolean']['output'];
};

export type ChannelGetFollowStatusResponse = {
  __typename?: 'ChannelGetFollowStatusResponse';
  following: Array<Scalars['Boolean']['output']>;
};

export type ChannelGetUserFollowedChannelsResponse = {
  __typename?: 'ChannelGetUserFollowedChannelsResponse';
  channels: Array<ChannelChannel>;
  pageInfo: ApiPageInfo;
};

export type ChannelGiftSubscriptionPurchase = {
  __typename?: 'ChannelGiftSubscriptionPurchase';
  recipientUserIds: Array<Scalars['String']['output']>;
  recipients?: Maybe<Array<ProfileProfile>>;
  tier: Scalars['Int']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelIngestStatsEvent = {
  __typename?: 'ChannelIngestStatsEvent';
  audioChannelCnt: Scalars['Int']['output'];
  audioSampleRate: Scalars['Int']['output'];
  bSlices: Scalars['Int']['output'];
  bitrate: Scalars['Int']['output'];
  channelId: Scalars['ID']['output'];
  framerate: Scalars['Int']['output'];
  height: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  width: Scalars['Int']['output'];
};

export type ChannelListBanAppealsResponse = {
  __typename?: 'ChannelListBanAppealsResponse';
  appeals: Array<ChannelBanAppeal>;
  pageInfo: ApiPageInfo;
};

export type ChannelListBannedUsersResponse = {
  __typename?: 'ChannelListBannedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<ChannelBannedUser>;
};

export type ChannelListChannelPrivilegedUsersResponse = {
  __typename?: 'ChannelListChannelPrivilegedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<ChannelPrivilegedUser>;
};

export type ChannelListChannelsResponse = {
  __typename?: 'ChannelListChannelsResponse';
  channels: Array<ChannelChannel>;
  pageInfo: ApiPageInfo;
};

export type ChannelListGameStatsRequestFilterInput = {
  live?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelListGameStatsResponse = {
  __typename?: 'ChannelListGameStatsResponse';
  games: Array<ChannelGameStats>;
  pageInfo: ApiPageInfo;
};

export type ChannelListHighlightedChannelsResponse = {
  __typename?: 'ChannelListHighlightedChannelsResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelListModerationEventsResponse = {
  __typename?: 'ChannelListModerationEventsResponse';
  events: Array<ChannelModerationEvent>;
  pageInfo: ApiPageInfo;
};

export type ChannelListStreamBackendConfigsResponse = {
  __typename?: 'ChannelListStreamBackendConfigsResponse';
  configs: Array<ChannelStreamBackendConfig>;
};

export type ChannelListStreamsResponse = {
  __typename?: 'ChannelListStreamsResponse';
  pageInfo: ApiPageInfo;
  streams: Array<ChannelStream>;
};

export type ChannelListUserChannelBansResponse = {
  __typename?: 'ChannelListUserChannelBansResponse';
  bans: Array<ChannelBannedUser>;
  pageInfo: ApiPageInfo;
};

export type ChannelListUserChannelRolesResponse = {
  __typename?: 'ChannelListUserChannelRolesResponse';
  roles: Array<ChannelChannelRole>;
};

export type ChannelListUserPrivilegedChannelsResponse = {
  __typename?: 'ChannelListUserPrivilegedChannelsResponse';
  channels: Array<ChannelChannelRoles>;
};

export enum ChannelLiveStatus {
  LiveStatusLive = 'LIVE_STATUS_LIVE',
  LiveStatusOffline = 'LIVE_STATUS_OFFLINE',
  LiveStatusUnlisted = 'LIVE_STATUS_UNLISTED',
  LiveStatusUnspecified = 'LIVE_STATUS_UNSPECIFIED'
}

export type ChannelLiveStatusEvent = {
  __typename?: 'ChannelLiveStatusEvent';
  channelId: Scalars['ID']['output'];
  liveStatus: ChannelLiveStatus;
  streamId: Scalars['ID']['output'];
};

export type ChannelMachineLearningConfig = {
  __typename?: 'ChannelMachineLearningConfig';
  containerImage: Scalars['String']['output'];
  disabled: Scalars['Boolean']['output'];
};

export type ChannelMachineLearningConfigInput = {
  containerImage?: InputMaybe<Scalars['String']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelModerationEvent = {
  __typename?: 'ChannelModerationEvent';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  content: ChannelModerationEventContent;
  id: Scalars['ID']['output'];
  moderator?: Maybe<ProfileProfile>;
  moderatorId: Scalars['ID']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

export type ChannelModerationEventContent = {
  __typename?: 'ChannelModerationEventContent';
  content?: Maybe<ChannelModerationEventContentContentUnion>;
};

export type ChannelModerationEventContentContentUnion = ChannelAutomodItemAccepted | ChannelAutomodItemRejected | ChannelBanAppealAccepted | ChannelBanAppealRejected | ChannelUserBanned | ChannelUserMuted | ChannelUserUnbanned;

export enum ChannelModerationEventType {
  ModerationEventTypeAutomodItemAccepted = 'MODERATION_EVENT_TYPE_AUTOMOD_ITEM_ACCEPTED',
  ModerationEventTypeAutomodItemRejected = 'MODERATION_EVENT_TYPE_AUTOMOD_ITEM_REJECTED',
  ModerationEventTypeBanAppealAccepted = 'MODERATION_EVENT_TYPE_BAN_APPEAL_ACCEPTED',
  ModerationEventTypeBanAppealRejected = 'MODERATION_EVENT_TYPE_BAN_APPEAL_REJECTED',
  ModerationEventTypeUnspecified = 'MODERATION_EVENT_TYPE_UNSPECIFIED',
  ModerationEventTypeUserBanned = 'MODERATION_EVENT_TYPE_USER_BANNED',
  ModerationEventTypeUserMuted = 'MODERATION_EVENT_TYPE_USER_MUTED',
  ModerationEventTypeUserUnbanned = 'MODERATION_EVENT_TYPE_USER_UNBANNED'
}

export type ChannelModerationEventsFilterInput = {
  eventTypes?: InputMaybe<Array<ChannelModerationEventType>>;
};

export type ChannelModerationSettings = {
  __typename?: 'ChannelModerationSettings';
  automod: ChannelAutomodSettings;
  banAppealsEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
};

export type ChannelModerationSettingsInput = {
  automod?: InputMaybe<ChannelAutomodSettingsInput>;
  banAppealsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChannelMonetizationSettings = {
  __typename?: 'ChannelMonetizationSettings';
  channelId: Scalars['ID']['output'];
  eligible: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
};

export type ChannelMonetizationSettingsInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  eligible?: InputMaybe<Scalars['Boolean']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelNoicePredictionsFeatureStatus = {
  __typename?: 'ChannelNoicePredictionsFeatureStatus';
  enabled: Scalars['Boolean']['output'];
};

export type ChannelNotificationSettings = {
  __typename?: 'ChannelNotificationSettings';
  channelLiveNotification: ChannelNotificationStatus;
  userId: Scalars['ID']['output'];
};

export type ChannelNotificationStatus = {
  __typename?: 'ChannelNotificationStatus';
  emailEnabled: Scalars['Boolean']['output'];
  pushEnabled: Scalars['Boolean']['output'];
};

export type ChannelNotificationStatusInput = {
  emailEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  pushEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelPrivilegedUser = {
  __typename?: 'ChannelPrivilegedUser';
  roles: Array<ChannelChannelRole>;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelRestreamingConfig = {
  __typename?: 'ChannelRestreamingConfig';
  bitrate: Scalars['Int']['output'];
  channelId: Scalars['ID']['output'];
  enabled: Scalars['Boolean']['output'];
  rtmpEndpoint: Scalars['String']['output'];
  rtmpKey: Scalars['String']['output'];
};

export type ChannelRestreamingConfigInput = {
  bitrate?: InputMaybe<Scalars['Int']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  rtmpEndpoint?: InputMaybe<Scalars['String']['input']>;
  rtmpKey?: InputMaybe<Scalars['String']['input']>;
};

export enum ChannelRiskTier {
  RiskTier_0 = 'RISK_TIER_0',
  RiskTier_1 = 'RISK_TIER_1',
  RiskTier_2 = 'RISK_TIER_2',
  RiskTierUnspecified = 'RISK_TIER_UNSPECIFIED'
}

export type ChannelStream = {
  __typename?: 'ChannelStream';
  challengesEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
  matureRatedContent: Scalars['Boolean']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  segments: Array<ChannelStreamSegment>;
  serverRenderingEnabled: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
  transcodingEnabled: Scalars['Boolean']['output'];
};

export type ChannelStreamBackendConfig = {
  __typename?: 'ChannelStreamBackendConfig';
  channelId: Scalars['ID']['output'];
  crConfig?: Maybe<ChannelContentRendererConfig>;
  game: GameGame;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  mlConfig?: Maybe<ChannelMachineLearningConfig>;
  recConfig?: Maybe<ChannelStreamRecorderConfig>;
  transcoderConfig?: Maybe<ChannelStreamTranscoderConfig>;
};

export type ChannelStreamBackendConfigInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  crConfig?: InputMaybe<ChannelContentRendererConfigInput>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  mlConfig?: InputMaybe<ChannelMachineLearningConfigInput>;
  recConfig?: InputMaybe<ChannelStreamRecorderConfigInput>;
  transcoderConfig?: InputMaybe<ChannelStreamTranscoderConfigInput>;
};

export type ChannelStreamRecorderConfig = {
  __typename?: 'ChannelStreamRecorderConfig';
  containerImage: Scalars['String']['output'];
};

export type ChannelStreamRecorderConfigInput = {
  containerImage?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelStreamSegment = {
  __typename?: 'ChannelStreamSegment';
  crConfig: ChannelContentRendererConfig;
  endTime?: Maybe<Scalars['Timestamp']['output']>;
  gameId: Scalars['ID']['output'];
  mlConfig: ChannelMachineLearningConfig;
  segmentId: Scalars['ID']['output'];
  startTime: Scalars['Timestamp']['output'];
  title: Scalars['String']['output'];
};

export type ChannelStreamStatusEvent = {
  __typename?: 'ChannelStreamStatusEvent';
  channelId: Scalars['ID']['output'];
  crStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  egressStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  gameRunnerStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  liveStatus: ChannelLiveStatus;
  mlStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  recStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  restreamingStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  streamId: Scalars['ID']['output'];
  transcoderStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
};

export type ChannelStreamSummary = {
  __typename?: 'ChannelStreamSummary';
  challengesEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
  endTime?: Maybe<Scalars['Timestamp']['output']>;
  gameId: Scalars['ID']['output'];
  matureRatedContent: Scalars['Boolean']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  serverRenderingEnabled: Scalars['Boolean']['output'];
  startTime: Scalars['Timestamp']['output'];
  streamId: Scalars['ID']['output'];
  transcodingEnabled: Scalars['Boolean']['output'];
};

export type ChannelStreamTranscoderConfig = {
  __typename?: 'ChannelStreamTranscoderConfig';
  containerImage: Scalars['String']['output'];
};

export type ChannelStreamTranscoderConfigInput = {
  containerImage?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelStreamerCardPurchase = {
  __typename?: 'ChannelStreamerCardPurchase';
  streamerCard: GameLogicStreamerCard;
  streamerCardId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelStreamingFeatureStatus = {
  __typename?: 'ChannelStreamingFeatureStatus';
  enabled: Scalars['Boolean']['output'];
  suspension?: Maybe<ChannelSuspension>;
};

export type ChannelSubscriptionPurchase = {
  __typename?: 'ChannelSubscriptionPurchase';
  tier: Scalars['Int']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelSubscriptionRenewal = {
  __typename?: 'ChannelSubscriptionRenewal';
  tier: Scalars['Int']['output'];
  userId: Scalars['ID']['output'];
};

export type ChannelSuspension = {
  __typename?: 'ChannelSuspension';
  description: Scalars['String']['output'];
  moderator?: Maybe<ProfileProfile>;
  reason: ChannelSuspensionReason;
  suspendedAt: Scalars['Timestamp']['output'];
  suspendedBy: Scalars['String']['output'];
  until?: Maybe<Scalars['Timestamp']['output']>;
};

export enum ChannelSuspensionReason {
  ReasonChannelDeleted = 'REASON_CHANNEL_DELETED',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type ChannelUpdateFollowerNotificationSettingsParamsInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  channelLiveNotificationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChannelUpdateNotificationSettingsParamsInput = {
  channelLiveNotification?: InputMaybe<ChannelNotificationStatusInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChannelUserBanStatus = {
  __typename?: 'ChannelUserBanStatus';
  appeal?: Maybe<ChannelBanAppealInfo>;
  banned: Scalars['Boolean']['output'];
  bannedAt?: Maybe<Scalars['Timestamp']['output']>;
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  moderator?: Maybe<ProfileProfile>;
  moderatorId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelUserBanned = {
  __typename?: 'ChannelUserBanned';
  description: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelUserBannedNotification = {
  __typename?: 'ChannelUserBannedNotification';
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  moderatorId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelUserMuted = {
  __typename?: 'ChannelUserMuted';
  description: Scalars['String']['output'];
  duration: Scalars['Duration']['output'];
  reason: ChatReason;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelUserUnbanned = {
  __typename?: 'ChannelUserUnbanned';
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelViewerCountEvent = {
  __typename?: 'ChannelViewerCountEvent';
  channelId: Scalars['ID']['output'];
  viewerCount: Scalars['Int']['output'];
};

export enum ChannelViolation {
  ViolationOther = 'VIOLATION_OTHER',
  ViolationSpam = 'VIOLATION_SPAM',
  ViolationUnspecified = 'VIOLATION_UNSPECIFIED'
}

export type ChatAutoModQueueEvent = {
  __typename?: 'ChatAutoModQueueEvent';
  event?: Maybe<ChatAutoModQueueEventEventUnion>;
};

export type ChatAutoModQueueEventAdd = {
  __typename?: 'ChatAutoModQueueEventAdd';
  item: ChatModerationItem;
};

export type ChatAutoModQueueEventEventUnion = ChatAutoModQueueEventAdd | ChatAutoModQueueEventRemove | ChatAutoModQueueEventUpdate;

export type ChatAutoModQueueEventRemove = {
  __typename?: 'ChatAutoModQueueEventRemove';
  id: Scalars['ID']['output'];
};

export type ChatAutoModQueueEventUpdate = {
  __typename?: 'ChatAutoModQueueEventUpdate';
  item: ChatModerationItem;
};

export enum ChatAutomodDecision {
  AutomodDecisionAccepted = 'AUTOMOD_DECISION_ACCEPTED',
  AutomodDecisionRejected = 'AUTOMOD_DECISION_REJECTED',
  AutomodDecisionUnspecified = 'AUTOMOD_DECISION_UNSPECIFIED'
}

export enum ChatAutomodLevel {
  AutomodLevelHigh = 'AUTOMOD_LEVEL_HIGH',
  AutomodLevelLow = 'AUTOMOD_LEVEL_LOW',
  AutomodLevelUnspecified = 'AUTOMOD_LEVEL_UNSPECIFIED'
}

export type ChatChatDetails = {
  __typename?: 'ChatChatDetails';
  chatId: Scalars['ID']['output'];
  roles: Array<ChatChatRole>;
};

export type ChatChatEvent = {
  __typename?: 'ChatChatEvent';
  chatId: Scalars['ID']['output'];
  cid: Scalars['Int']['output'];
  event?: Maybe<ChatChatEventEventUnion>;
};

export type ChatChatEventEventUnion = ChatChatDetails | ChatChatMessage | ChatHideMessage | ChatMessageDenied | ChatPing | ChatUserBanned | ChatUserMuted | ChatUserUnmuted;

export type ChatChatMessage = {
  __typename?: 'ChatChatMessage';
  chatId: Scalars['ID']['output'];
  content: ChatMessageContent;
  createdAt: Scalars['Timestamp']['output'];
  messageId: Scalars['ID']['output'];
  moderationStatus: ChatModerationStatus;
  sender: ProfileProfile;
  senderId: Scalars['ID']['output'];
  senderInfo: ChatSenderInfo;
  state: ApiEntityState;
  textClassification: ClassificationTextClassification;
  username: Scalars['String']['output'];
};

export enum ChatChatRole {
  ChatRoleMember = 'CHAT_ROLE_MEMBER',
  ChatRoleModerator = 'CHAT_ROLE_MODERATOR',
  ChatRolePlatformModerator = 'CHAT_ROLE_PLATFORM_MODERATOR',
  ChatRoleStreamer = 'CHAT_ROLE_STREAMER',
  ChatRoleUnspecified = 'CHAT_ROLE_UNSPECIFIED'
}

export type ChatChatUser = {
  __typename?: 'ChatChatUser';
  label: ChatUserLabel;
  senderInfo: ChatSenderInfo;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChatGetChatUserStatusResponse = {
  __typename?: 'ChatGetChatUserStatusResponse';
  muteDuration?: Maybe<Scalars['Duration']['output']>;
  muted: Scalars['Boolean']['output'];
};

export type ChatHideMessage = {
  __typename?: 'ChatHideMessage';
  chatId: Scalars['ID']['output'];
  messageId: Scalars['ID']['output'];
};

export type ChatListChatUsersResponse = {
  __typename?: 'ChatListChatUsersResponse';
  users: Array<ChatChatUser>;
};

export type ChatListMessagesResponse = {
  __typename?: 'ChatListMessagesResponse';
  messages: Array<ChatChatMessage>;
  pageInfo: ApiPageInfo;
};

export type ChatMessageContent = {
  __typename?: 'ChatMessageContent';
  content?: Maybe<ChatMessageContentContentUnion>;
};

export type ChatMessageContentContentUnion = ChatTextMessage | ChatTombstone;

export type ChatMessageContentInput = {
  textContent?: InputMaybe<ChatTextMessageInput>;
  tombstone?: InputMaybe<ChatTombstoneInput>;
};

export type ChatMessageDenied = {
  __typename?: 'ChatMessageDenied';
  chatId: Scalars['ID']['output'];
  messageId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ChatModerationItem = {
  __typename?: 'ChatModerationItem';
  chatMessage: ChatChatMessage;
  expired: Scalars['Boolean']['output'];
  expiresAt: Scalars['Timestamp']['output'];
  id: Scalars['ID']['output'];
  reviewer?: Maybe<ProfileProfile>;
  reviewerId?: Maybe<Scalars['ID']['output']>;
  status: ChatModerationItemStatus;
};

export enum ChatModerationItemStatus {
  StatusAllowed = 'STATUS_ALLOWED',
  StatusDenied = 'STATUS_DENIED',
  StatusPending = 'STATUS_PENDING',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export enum ChatModerationStatus {
  ModerationStatusApproved = 'MODERATION_STATUS_APPROVED',
  ModerationStatusUnspecified = 'MODERATION_STATUS_UNSPECIFIED'
}

export type ChatPing = {
  __typename?: 'ChatPing';
  seq: Scalars['Int']['output'];
};

export enum ChatReason {
  ReasonOther = 'REASON_OTHER',
  ReasonSpam = 'REASON_SPAM',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type ChatSendMessageResponse = {
  __typename?: 'ChatSendMessageResponse';
  messageId: Scalars['ID']['output'];
};

export type ChatSenderInfo = {
  __typename?: 'ChatSenderInfo';
  avatar2D: Scalars['String']['output'];
  badges: Array<BadgeBadge>;
  label: ChatUserLabel;
  preferredColor: ProfileColor;
  roles: Array<ChatChatRole>;
  userId: Scalars['ID']['output'];
  username: Scalars['String']['output'];
};

export type ChatTextMessage = {
  __typename?: 'ChatTextMessage';
  attachments: Array<ChatTextMessageAttachment>;
  links: Array<ChatTextMessageLink>;
  text: Scalars['String']['output'];
};

export type ChatTextMessageAttachment = {
  __typename?: 'ChatTextMessageAttachment';
  endIndex: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
  label: Scalars['String']['output'];
  source: Scalars['String']['output'];
  startIndex: Scalars['Int']['output'];
};

export type ChatTextMessageAttachmentInput = {
  endIndex?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  startIndex?: InputMaybe<Scalars['Int']['input']>;
};

export type ChatTextMessageInput = {
  attachments?: InputMaybe<Array<ChatTextMessageAttachmentInput>>;
  links?: InputMaybe<Array<ChatTextMessageLinkInput>>;
  text?: InputMaybe<Scalars['String']['input']>;
};

export type ChatTextMessageLink = {
  __typename?: 'ChatTextMessageLink';
  endIndex: Scalars['Int']['output'];
  startIndex: Scalars['Int']['output'];
  url: Scalars['String']['output'];
};

export type ChatTextMessageLinkInput = {
  endIndex?: InputMaybe<Scalars['Int']['input']>;
  startIndex?: InputMaybe<Scalars['Int']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type ChatTombstone = {
  __typename?: 'ChatTombstone';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type ChatTombstoneInput = {
  emptyTypeWorkaround: Scalars['Boolean']['input'];
};

export type ChatUserBanned = {
  __typename?: 'ChatUserBanned';
  chatId: Scalars['ID']['output'];
  moderatorId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export enum ChatUserLabel {
  UserLabelModerator = 'USER_LABEL_MODERATOR',
  UserLabelStaff = 'USER_LABEL_STAFF',
  UserLabelStreamer = 'USER_LABEL_STREAMER',
  UserLabelUnspecified = 'USER_LABEL_UNSPECIFIED',
  UserLabelViewer = 'USER_LABEL_VIEWER'
}

export type ChatUserMuted = {
  __typename?: 'ChatUserMuted';
  chatId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  duration: Scalars['Duration']['output'];
  moderatorId: Scalars['ID']['output'];
  reason: ChatReason;
  userId: Scalars['ID']['output'];
};

export type ChatUserUnmuted = {
  __typename?: 'ChatUserUnmuted';
  chatId: Scalars['ID']['output'];
  moderatorId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ClassificationEvent = {
  __typename?: 'ClassificationEvent';
  event?: Maybe<ClassificationEventEventUnion>;
};

export type ClassificationEventCustomEvent = {
  __typename?: 'ClassificationEventCustomEvent';
  id: Scalars['ID']['output'];
  message: Scalars['String']['output'];
};

export type ClassificationEventEventFlooding = {
  __typename?: 'ClassificationEventEventFlooding';
  count: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  limit: Scalars['Int']['output'];
};

export type ClassificationEventEventTrustChanged = {
  __typename?: 'ClassificationEventEventTrustChanged';
  id: Scalars['ID']['output'];
  message: Scalars['String']['output'];
  oldTrustLevel: ClassificationTrustLevel;
  trustLevel: ClassificationTrustLevel;
};

export type ClassificationEventEventUnion = ClassificationEventCustomEvent | ClassificationEventEventFlooding | ClassificationEventEventTrustChanged;

export type ClassificationTextClassification = {
  __typename?: 'ClassificationTextClassification';
  escalations: Array<Scalars['String']['output']>;
  events: Array<ClassificationEvent>;
  hashed: Scalars['String']['output'];
  hashes: Array<Scalars['Int']['output']>;
  highRiskLanguage: Scalars['String']['output'];
  notableIndexes: Array<Scalars['Int']['output']>;
  response: Scalars['Boolean']['output'];
  risk: ClassificationTextRisk;
  topics: Array<ClassificationTextClassificationTopicTextRiskLevel>;
  trust: ClassificationTrustLevel;
};

export type ClassificationTextClassificationTopicTextRiskLevel = {
  __typename?: 'ClassificationTextClassificationTopicTextRiskLevel';
  risk: ClassificationTextRisk;
  topic: ClassificationTopic;
};

export enum ClassificationTextRisk {
  TextRiskDangerous = 'TEXT_RISK_DANGEROUS',
  TextRiskExplicit = 'TEXT_RISK_EXPLICIT',
  TextRiskLow = 'TEXT_RISK_LOW',
  TextRiskMature = 'TEXT_RISK_MATURE',
  TextRiskNotable = 'TEXT_RISK_NOTABLE',
  TextRiskQuestionable = 'TEXT_RISK_QUESTIONABLE',
  TextRiskSafe = 'TEXT_RISK_SAFE',
  TextRiskUnknown = 'TEXT_RISK_UNKNOWN',
  TextRiskUnspecified = 'TEXT_RISK_UNSPECIFIED'
}

export enum ClassificationTopic {
  TopicAlarm = 'TOPIC_ALARM',
  TopicBullying = 'TOPIC_BULLYING',
  TopicChildGrooming = 'TOPIC_CHILD_GROOMING',
  TopicDrugsAndAlcohol = 'TOPIC_DRUGS_AND_ALCOHOL',
  TopicExtremism = 'TOPIC_EXTREMISM',
  TopicFraud = 'TOPIC_FRAUD',
  TopicGeneralRisk = 'TOPIC_GENERAL_RISK',
  TopicHateSpeech = 'TOPIC_HATE_SPEECH',
  TopicInApp = 'TOPIC_IN_APP',
  TopicJunk = 'TOPIC_JUNK',
  TopicPersonalIdentifyingInfo = 'TOPIC_PERSONAL_IDENTIFYING_INFO',
  TopicPolitics = 'TOPIC_POLITICS',
  TopicPublicThreat = 'TOPIC_PUBLIC_THREAT',
  TopicRealName = 'TOPIC_REAL_NAME',
  TopicRelationshipAndSexualContent = 'TOPIC_RELATIONSHIP_AND_SEXUAL_CONTENT',
  TopicReligious = 'TOPIC_RELIGIOUS',
  TopicSentiment = 'TOPIC_SENTIMENT',
  TopicSubversive = 'TOPIC_SUBVERSIVE',
  TopicUnspecified = 'TOPIC_UNSPECIFIED',
  TopicViolence = 'TOPIC_VIOLENCE',
  TopicVulgarity = 'TOPIC_VULGARITY',
  TopicWebsite = 'TOPIC_WEBSITE'
}

export enum ClassificationTrustLevel {
  TrustLevelDefault = 'TRUST_LEVEL_DEFAULT',
  TrustLevelMute = 'TRUST_LEVEL_MUTE',
  TrustLevelNotTrusted = 'TRUST_LEVEL_NOT_TRUSTED',
  TrustLevelSuperuser = 'TRUST_LEVEL_SUPERUSER',
  TrustLevelTrusted = 'TRUST_LEVEL_TRUSTED',
  TrustLevelUnspecified = 'TRUST_LEVEL_UNSPECIFIED'
}

export type ConfigMetagameConfigInactivityTimeouts = {
  __typename?: 'ConfigMetagameConfigInactivityTimeouts';
  enabled: Scalars['Boolean']['output'];
  idleTimeoutSec: Scalars['Int']['output'];
  implicitOfflineTimeoutSec: Scalars['Int']['output'];
  offlineTimeoutSec: Scalars['Int']['output'];
};

export type ConfigMetagameConfigUiTimings = {
  __typename?: 'ConfigMetagameConfigUITimings';
  teamActionTimeout: Scalars['Int']['output'];
};

export type EmojiBatchGetEmojisResponse = {
  __typename?: 'EmojiBatchGetEmojisResponse';
  emojis: Array<EmojiEmoji>;
};

export type EmojiCreateEmojiUploadTokenResponse = {
  __typename?: 'EmojiCreateEmojiUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type EmojiEmoji = {
  __typename?: 'EmojiEmoji';
  channelId: Scalars['ID']['output'];
  disabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  image: Scalars['String']['output'];
  imageUrl: Scalars['String']['output'];
  label: Scalars['String']['output'];
  name: Scalars['String']['output'];
  prefabName: Scalars['String']['output'];
};

export type EmojiListChannelEmojisResponse = {
  __typename?: 'EmojiListChannelEmojisResponse';
  count?: Maybe<ItemItemTotalCount>;
  emojis: Array<EmojiEmoji>;
  pageInfo: ApiPageInfo;
};

export type EmojiListPlatformEmojisResponse = {
  __typename?: 'EmojiListPlatformEmojisResponse';
  count?: Maybe<ItemItemTotalCount>;
  emojis: Array<EmojiEmoji>;
  pageInfo: ApiPageInfo;
};

export type EmojiUpdateChannelEmojiParamsInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};

export type EmojiUpdatePlatformEmojiParamsInput = {
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlag = {
  __typename?: 'FlagFeatureFlag';
  description: Scalars['String']['output'];
  enabled: Scalars['Boolean']['output'];
  groups: Array<FlagFeatureFlagGroup>;
  name: Scalars['String']['output'];
};

export type FlagFeatureFlagConfig = {
  __typename?: 'FlagFeatureFlagConfig';
  channelFlags: FlagFeatureFlagList;
  createdAt: Scalars['Timestamp']['output'];
  revision: Scalars['String']['output'];
  userFlags: FlagFeatureFlagList;
};

export type FlagFeatureFlagConfigInput = {
  channelFlags?: InputMaybe<FlagFeatureFlagListInput>;
  createdAt?: InputMaybe<Scalars['InputTimestamp']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
  userFlags?: InputMaybe<FlagFeatureFlagListInput>;
};

export type FlagFeatureFlagGroup = {
  __typename?: 'FlagFeatureFlagGroup';
  conditions: Array<FlagFeatureFlagGroupCondition>;
  default: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  values: Array<FlagFeatureFlagGroupValue>;
};

export type FlagFeatureFlagGroupCondition = {
  __typename?: 'FlagFeatureFlagGroupCondition';
  rule?: Maybe<FlagFeatureFlagGroupConditionRuleUnion>;
};

export type FlagFeatureFlagGroupConditionAny = {
  __typename?: 'FlagFeatureFlagGroupConditionAny';
  field: Scalars['String']['output'];
  values: Array<Scalars['String']['output']>;
};

export type FlagFeatureFlagGroupConditionAnyInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type FlagFeatureFlagGroupConditionEq = {
  __typename?: 'FlagFeatureFlagGroupConditionEq';
  field: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagFeatureFlagGroupConditionEqInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagGroupConditionGte = {
  __typename?: 'FlagFeatureFlagGroupConditionGte';
  field: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagFeatureFlagGroupConditionGteInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagGroupConditionInput = {
  any?: InputMaybe<FlagFeatureFlagGroupConditionAnyInput>;
  eq?: InputMaybe<FlagFeatureFlagGroupConditionEqInput>;
  gte?: InputMaybe<FlagFeatureFlagGroupConditionGteInput>;
  lte?: InputMaybe<FlagFeatureFlagGroupConditionLteInput>;
};

export type FlagFeatureFlagGroupConditionLte = {
  __typename?: 'FlagFeatureFlagGroupConditionLte';
  field: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagFeatureFlagGroupConditionLteInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagGroupConditionRuleUnion = FlagFeatureFlagGroupConditionAny | FlagFeatureFlagGroupConditionEq | FlagFeatureFlagGroupConditionGte | FlagFeatureFlagGroupConditionLte;

export type FlagFeatureFlagGroupInput = {
  conditions?: InputMaybe<Array<FlagFeatureFlagGroupConditionInput>>;
  default?: InputMaybe<Scalars['Boolean']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  values?: InputMaybe<Array<FlagFeatureFlagGroupValueInput>>;
};

export type FlagFeatureFlagGroupValue = {
  __typename?: 'FlagFeatureFlagGroupValue';
  value: Scalars['String']['output'];
  weight: Scalars['Int']['output'];
};

export type FlagFeatureFlagGroupValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type FlagFeatureFlagInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  groups?: InputMaybe<Array<FlagFeatureFlagGroupInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagList = {
  __typename?: 'FlagFeatureFlagList';
  flags: Array<FlagFeatureFlag>;
};

export type FlagFeatureFlagListInput = {
  flags?: InputMaybe<Array<FlagFeatureFlagInput>>;
};

export type FlagFeatureFlagSchema = {
  __typename?: 'FlagFeatureFlagSchema';
  flags: Array<FlagFeatureFlagSchemaFlagsEntry>;
};

export type FlagFeatureFlagSchemaFlagsEntry = {
  __typename?: 'FlagFeatureFlagSchemaFlagsEntry';
  key: Scalars['String']['output'];
  value: FlagJsonSchema;
};

export type FlagFeatureFlagState = {
  __typename?: 'FlagFeatureFlagState';
  name: Scalars['String']['output'];
  revision: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagJsonSchema = {
  __typename?: 'FlagJSONSchema';
  description: Scalars['String']['output'];
  enum: Array<Scalars['String']['output']>;
  items: FlagJsonSchema;
  maximum: Scalars['Float']['output'];
  minimum: Scalars['Float']['output'];
  multipleOf: Scalars['Float']['output'];
  pattern: Scalars['String']['output'];
  patternProperties: Array<FlagJsonSchemaPatternPropertiesEntry>;
  properties: Array<FlagJsonSchemaPropertiesEntry>;
  type: Scalars['String']['output'];
};

export type FlagJsonSchemaPatternPropertiesEntry = {
  __typename?: 'FlagJSONSchemaPatternPropertiesEntry';
  key: Scalars['String']['output'];
  value: FlagJsonSchema;
};

export type FlagJsonSchemaPropertiesEntry = {
  __typename?: 'FlagJSONSchemaPropertiesEntry';
  key: Scalars['String']['output'];
  value: FlagJsonSchema;
};

export type FlagListChannelFeatureFlagsResponse = {
  __typename?: 'FlagListChannelFeatureFlagsResponse';
  flags: Array<FlagFeatureFlagState>;
};

export type FlagListUserFeatureFlagsResponse = {
  __typename?: 'FlagListUserFeatureFlagsResponse';
  flags: Array<FlagFeatureFlagState>;
};

export type FloatType = {
  __typename?: 'FloatType';
  /** The wrapped value of type Float */
  value: Scalars['Float']['output'];
};

export type FriendsAcceptFriendRequestResponse = {
  __typename?: 'FriendsAcceptFriendRequestResponse';
  friend: ProfileProfile;
  friendId: Scalars['ID']['output'];
};

export type FriendsActivity = {
  __typename?: 'FriendsActivity';
  channel?: Maybe<ChannelChannel>;
  channelId: Scalars['ID']['output'];
  isOnline: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
};

export type FriendsBlockUserResponse = {
  __typename?: 'FriendsBlockUserResponse';
  blockedUser: ProfileProfile;
  blockedUserId: Scalars['ID']['output'];
};

export type FriendsChannelFriends = {
  __typename?: 'FriendsChannelFriends';
  channelId: Scalars['ID']['output'];
  totalCount: Scalars['Int']['output'];
  users: Array<FriendsUser>;
};

export type FriendsFriendStatusUpdateEvent = {
  __typename?: 'FriendsFriendStatusUpdateEvent';
  actorProfile: ProfileProfile;
  actorUserId: Scalars['ID']['output'];
  targetProfile: ProfileProfile;
  targetUserId: Scalars['ID']['output'];
  type: FriendsFriendStatusUpdateEventUpdateType;
};

export enum FriendsFriendStatusUpdateEventUpdateType {
  UpdateTypeFriendInvitation = 'UPDATE_TYPE_FRIEND_INVITATION',
  UpdateTypeInvitationAccepted = 'UPDATE_TYPE_INVITATION_ACCEPTED',
  UpdateTypeInvitationCancelled = 'UPDATE_TYPE_INVITATION_CANCELLED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUserBlocked = 'UPDATE_TYPE_USER_BLOCKED',
  UpdateTypeUserUnblocked = 'UPDATE_TYPE_USER_UNBLOCKED',
  UpdateTypeUserUnfriended = 'UPDATE_TYPE_USER_UNFRIENDED'
}

export type FriendsFriendsSettings = {
  __typename?: 'FriendsFriendsSettings';
  disableFriendRequests: Scalars['Boolean']['output'];
};

export type FriendsFriendsSettingsInput = {
  disableFriendRequests?: InputMaybe<Scalars['Boolean']['input']>;
};

export type FriendsFriendshipStatus = {
  __typename?: 'FriendsFriendshipStatus';
  activity?: Maybe<FriendsActivity>;
  lastStatusChange: Scalars['Timestamp']['output'];
  status: FriendsFriendshipStatusStatus;
};

export enum FriendsFriendshipStatusStatus {
  StatusBlocked = 'STATUS_BLOCKED',
  StatusBlockedBy = 'STATUS_BLOCKED_BY',
  StatusFriend = 'STATUS_FRIEND',
  StatusFriendRequestReceived = 'STATUS_FRIEND_REQUEST_RECEIVED',
  StatusFriendRequestSent = 'STATUS_FRIEND_REQUEST_SENT',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export type FriendsGetChannelActiveFriendsResponse = {
  __typename?: 'FriendsGetChannelActiveFriendsResponse';
  channelFriends: Array<FriendsChannelFriends>;
};

export type FriendsGetFriendshipStatusResponse = {
  __typename?: 'FriendsGetFriendshipStatusResponse';
  statuses: Array<FriendsFriendshipStatus>;
};

export type FriendsListBlockedUsersResponse = {
  __typename?: 'FriendsListBlockedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListFriendsRequestFilterInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  isOnline?: InputMaybe<Scalars['Boolean']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};

export type FriendsListFriendsResponse = {
  __typename?: 'FriendsListFriendsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListReceivedFriendRequestsResponse = {
  __typename?: 'FriendsListReceivedFriendRequestsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListSentFriendRequestsResponse = {
  __typename?: 'FriendsListSentFriendRequestsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsSendFriendRequestResponse = {
  __typename?: 'FriendsSendFriendRequestResponse';
  friend: ProfileProfile;
  friendId: Scalars['ID']['output'];
};

export type FriendsUnblockUserResponse = {
  __typename?: 'FriendsUnblockUserResponse';
  unblockedUser: ProfileProfile;
  unblockedUserId: Scalars['ID']['output'];
};

export type FriendsUser = {
  __typename?: 'FriendsUser';
  activity?: Maybe<FriendsActivity>;
  lastStatusChange: Scalars['Timestamp']['output'];
  profile: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export enum FtueDismissalType {
  DismissalTypeActionTaken = 'DISMISSAL_TYPE_ACTION_TAKEN',
  DismissalTypeClosed = 'DISMISSAL_TYPE_CLOSED',
  DismissalTypeUnspecified = 'DISMISSAL_TYPE_UNSPECIFIED'
}

export type FtueListDismissedTooltipsResponse = {
  __typename?: 'FtueListDismissedTooltipsResponse';
  tooltipIds: Array<Scalars['String']['output']>;
};

export type GameBatchGetGamesResponse = {
  __typename?: 'GameBatchGetGamesResponse';
  games: Array<GameGame>;
};

export type GameBatchGetSeasonsResponse = {
  __typename?: 'GameBatchGetSeasonsResponse';
  seasons: Array<GameSeason>;
};

export enum GameCardAssetType {
  AssetTypeThumbnail = 'ASSET_TYPE_THUMBNAIL',
  AssetTypeUnspecified = 'ASSET_TYPE_UNSPECIFIED',
  AssetTypeVideo = 'ASSET_TYPE_VIDEO'
}

export type GameCardBatchGetGameCardsResponse = {
  __typename?: 'GameCardBatchGetGameCardsResponse';
  cards: Array<GameLogicCard>;
};

export type GameCardBatchGetStreamerCardsResponse = {
  __typename?: 'GameCardBatchGetStreamerCardsResponse';
  cards: Array<GameLogicStreamerCard>;
};

export type GameCardCreateStreamerCardAssetUploadTokenResponse = {
  __typename?: 'GameCardCreateStreamerCardAssetUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type GameCardHighScoringCardConfig = {
  __typename?: 'GameCardHighScoringCardConfig';
  cardRarity: RarityRarity;
  percentageOfMaxRequired: Scalars['Float']['output'];
  soloMultiplier: Scalars['Float']['output'];
  streamerCardPercentageOfMaxRequired: Scalars['Float']['output'];
};

export type GameCardHighScoringCardTimings = {
  __typename?: 'GameCardHighScoringCardTimings';
  cooldownBetweenCardScores: Scalars['Int']['output'];
  ghostWaitTime: Scalars['Int']['output'];
  speed: GameCardHighScoringCardTimingsSpeed;
};

export enum GameCardHighScoringCardTimingsSpeed {
  SpeedDefault = 'SPEED_DEFAULT',
  SpeedFast = 'SPEED_FAST',
  SpeedFastest = 'SPEED_FASTEST',
  SpeedSlow = 'SPEED_SLOW',
  SpeedSlowest = 'SPEED_SLOWEST',
  SpeedUnspecified = 'SPEED_UNSPECIFIED'
}

export type GameCardListBoostersResponse = {
  __typename?: 'GameCardListBoostersResponse';
  boosters: Array<GameLogicBooster>;
};

/** TODO: add game/stream based filtering */
export type GameCardListGameCardsResponse = {
  __typename?: 'GameCardListGameCardsResponse';
  cards: Array<GameLogicCard>;
};

export type GameCardListStreamerCardDraftsRequestFilterInput = {
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};

export type GameCardListStreamerCardDraftsResponse = {
  __typename?: 'GameCardListStreamerCardDraftsResponse';
  cards: Array<GameLogicStreamerCard>;
  pageInfo: ApiPageInfo;
};

export type GameCardListStreamerCardsRequestFilterInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};

export type GameCardListStreamerCardsResponse = {
  __typename?: 'GameCardListStreamerCardsResponse';
  cards: Array<GameLogicStreamerCard>;
  pageInfo: ApiPageInfo;
};

export type GameCardStreamerCardDraftUpdateInput = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type GameGame = {
  __typename?: 'GameGame';
  activeSeason: GameSeason;
  activeSeasonId: Scalars['ID']['output'];
  backdropUrl: Scalars['String']['output'];
  challengesEnabled: Scalars['Boolean']['output'];
  coverImageUrl: Scalars['String']['output'];
  gameEventsSource: GameGameEventsSource;
  iconUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  otherNames: Array<Scalars['String']['output']>;
  progression: GameUserProgression;
  publicAccess: Scalars['Boolean']['output'];
};

export enum GameGameEventsSource {
  GameEventsSourceGameIntegration = 'GAME_EVENTS_SOURCE_GAME_INTEGRATION',
  GameEventsSourceMl = 'GAME_EVENTS_SOURCE_ML',
  GameEventsSourceUnspecified = 'GAME_EVENTS_SOURCE_UNSPECIFIED'
}

export type GameListGamesResponse = {
  __typename?: 'GameListGamesResponse';
  games: Array<GameGame>;
};

export type GameListSeasonsResponse = {
  __typename?: 'GameListSeasonsResponse';
  seasons: Array<GameSeason>;
};

export type GameLogicActiveBooster = {
  __typename?: 'GameLogicActiveBooster';
  activationTime: Scalars['Int']['output'];
  activatorUserId: Scalars['ID']['output'];
  boosterId: Scalars['Int']['output'];
};

export type GameLogicActiveCard = {
  __typename?: 'GameLogicActiveCard';
  activeBoosters: Array<GameLogicActiveCardActiveBoostersEntry>;
  cardId: Scalars['ID']['output'];
  failureTargetValue: Scalars['Int']['output'];
  points: Scalars['Int']['output'];
  pointsMax: Scalars['Int']['output'];
  pointsMin: Scalars['Int']['output'];
  pointsTimeTarget: Scalars['Int']['output'];
  pointsUpdateTime: Scalars['Int']['output'];
  pointsUpdateTimer: GameLogicTimer;
  setTime: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
  targetValues: Array<GameLogicActiveCardTargetValuesEntry>;
  timerDuration: Scalars['Int']['output'];
};

export type GameLogicActiveCardActiveBoostersEntry = {
  __typename?: 'GameLogicActiveCardActiveBoostersEntry';
  key: Scalars['String']['output'];
  value: GameLogicActiveBooster;
};

export type GameLogicActiveCardSucceededMsg = {
  __typename?: 'GameLogicActiveCardSucceededMsg';
  allOrNothing: GameLogicAllOrNothing;
  bestPlay: GameLogicBestPlay;
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  card: GameLogicCard;
  cardId: Scalars['ID']['output'];
  groupId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type GameLogicActiveCardTargetValuesEntry = {
  __typename?: 'GameLogicActiveCardTargetValuesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type GameLogicAllOrNothing = {
  __typename?: 'GameLogicAllOrNothing';
  bestPlay: GameLogicBestPlay;
  cardActivations: Array<GameLogicCardActivationResult>;
  cardId: Scalars['ID']['output'];
  nextPoints: Scalars['Int']['output'];
  round: Scalars['Int']['output'];
  totalPoints: Scalars['Int']['output'];
  totalRounds: Scalars['Int']['output'];
};

export type GameLogicBestPlay = {
  __typename?: 'GameLogicBestPlay';
  activeBoosters: Array<GameLogicActiveBooster>;
  cardId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicBooster = {
  __typename?: 'GameLogicBooster';
  canTargetSelf: Scalars['Boolean']['output'];
  description: Scalars['String']['output'];
  descriptionCondition: Scalars['String']['output'];
  descriptionDefaultBenefit: Scalars['String']['output'];
  descriptionOtherBenefit: Scalars['String']['output'];
  descriptionTargetNoneBenefit: Scalars['String']['output'];
  descriptionTargetSelf: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  image: Scalars['String']['output'];
  isAvailableSolo: Scalars['Boolean']['output'];
  isSelfAndOtherEffect: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  removeOn: Array<Scalars['String']['output']>;
  timeActive: Scalars['Int']['output'];
  triggersOn: Array<Scalars['String']['output']>;
  valueOther: Scalars['Int']['output'];
  valueSelf: Scalars['Int']['output'];
};

export type GameLogicCard = {
  __typename?: 'GameLogicCard';
  activeStreamerCard?: Maybe<GameLogicStreamerCard>;
  activeStreamerCards: Array<GameLogicStreamerCard>;
  availableStreamerCards: Array<GameLogicStreamerCard>;
  backImage: Scalars['String']['output'];
  dealingModules: Array<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  failureModules: Array<Scalars['String']['output']>;
  failureTargetValue: Scalars['Int']['output'];
  familyId: Scalars['ID']['output'];
  frontImage: Scalars['String']['output'];
  gameModes: Array<Scalars['String']['output']>;
  icon: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isAllOrNothing: Scalars['Boolean']['output'];
  isDealtAtStart: Scalars['Boolean']['output'];
  isEnabled: Scalars['Boolean']['output'];
  isMatchCard: Scalars['Boolean']['output'];
  leveling: GameLogicCardLeveling;
  matchCardId: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  pointsMax: Scalars['Int']['output'];
  pointsMin: Scalars['Int']['output'];
  pointsTimeTarget: Scalars['Int']['output'];
  rarity: RarityRarity;
  roleCharacters: Array<Scalars['String']['output']>;
  scoredCounterIds: Array<Scalars['String']['output']>;
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
  sides: Array<Scalars['String']['output']>;
  successModules: Array<Scalars['String']['output']>;
  targetValue: Scalars['Int']['output'];
  targetValues: Array<GameLogicTargetValue>;
  timerDuration: Scalars['Int']['output'];
  unlockLevel: Scalars['Int']['output'];
};


export type GameLogicCardAvailableStreamerCardsArgs = {
  channel_id?: InputMaybe<Scalars['ID']['input']>;
};

export type GameLogicCardActivationResult = {
  __typename?: 'GameLogicCardActivationResult';
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  cardId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicCardDetails = {
  __typename?: 'GameLogicCardDetails';
  groupName: Scalars['String']['output'];
  succeedingCard: GameLogicActiveCardSucceededMsg;
};

export type GameLogicCardLeveling = {
  __typename?: 'GameLogicCardLeveling';
  currentLevel: Scalars['Int']['output'];
  nextLevelLimit: Scalars['Int']['output'];
  progressToNextLevel: Scalars['Int']['output'];
};

export type GameLogicChallenge = {
  __typename?: 'GameLogicChallenge';
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  disabled: Scalars['Boolean']['output'];
  failureModule: Scalars['String']['output'];
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  successModule: Scalars['String']['output'];
  targetValues: Array<GameLogicTargetValue>;
};

export enum GameLogicChallengeState {
  ChallengeStateFailure = 'CHALLENGE_STATE_FAILURE',
  ChallengeStateSuccess = 'CHALLENGE_STATE_SUCCESS',
  ChallengeStateUnresolved = 'CHALLENGE_STATE_UNRESOLVED',
  ChallengeStateUnspecified = 'CHALLENGE_STATE_UNSPECIFIED'
}

export type GameLogicChallengeStatus = {
  __typename?: 'GameLogicChallengeStatus';
  challenge: GameLogicChallenge;
  challengeId: Scalars['ID']['output'];
  challengeState: GameLogicChallengeState;
  pickRate: Scalars['Float']['output'];
  targetValues: Array<GameLogicTargetValue>;
};

export enum GameLogicContextualTeamActionStatus {
  ContextualTeamActionStatusFailed = 'CONTEXTUAL_TEAM_ACTION_STATUS_FAILED',
  ContextualTeamActionStatusOngoing = 'CONTEXTUAL_TEAM_ACTION_STATUS_ONGOING',
  ContextualTeamActionStatusSucceeded = 'CONTEXTUAL_TEAM_ACTION_STATUS_SUCCEEDED',
  ContextualTeamActionStatusUnspecified = 'CONTEXTUAL_TEAM_ACTION_STATUS_UNSPECIFIED'
}

export enum GameLogicContextualTeamActionType {
  ContextualTeamActionTypeHighScoringCardPromoted = 'CONTEXTUAL_TEAM_ACTION_TYPE_HIGH_SCORING_CARD_PROMOTED',
  ContextualTeamActionTypeStreamerActivated = 'CONTEXTUAL_TEAM_ACTION_TYPE_STREAMER_ACTIVATED',
  ContextualTeamActionTypeUnspecified = 'CONTEXTUAL_TEAM_ACTION_TYPE_UNSPECIFIED'
}

export type GameLogicGroup = {
  __typename?: 'GameLogicGroup';
  id: Scalars['ID']['output'];
  isParty: Scalars['Boolean']['output'];
  isSolo: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicGroupDetails = {
  __typename?: 'GameLogicGroupDetails';
  group: GameLogicGroup;
  players: Array<GameLogicPlayerDetails>;
  streamId: Scalars['ID']['output'];
};

export type GameLogicHand = {
  __typename?: 'GameLogicHand';
  cardIds: Array<Scalars['String']['output']>;
  matchEndCardIds: Array<Scalars['String']['output']>;
  previousCardIds: Array<Scalars['String']['output']>;
  votes: Array<GameLogicVote>;
};

export type GameLogicHighScoringCard = {
  __typename?: 'GameLogicHighScoringCard';
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  card: GameLogicCard;
  cardId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicHighScoringCardPromotedMsg = {
  __typename?: 'GameLogicHighScoringCardPromotedMsg';
  card: GameLogicHighScoringCard;
  groupId: Scalars['ID']['output'];
  groupName: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type GameLogicLastActiveCard = {
  __typename?: 'GameLogicLastActiveCard';
  activeCard: GameLogicActiveCard;
  status: GameLogicLastActiveCardStatus;
};

export enum GameLogicLastActiveCardStatus {
  StatusFailed = 'STATUS_FAILED',
  StatusSucceeded = 'STATUS_SUCCEEDED',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export enum GameLogicMatchBonusType {
  MatchBonusTypeUnspecified = 'MATCH_BONUS_TYPE_UNSPECIFIED',
  MatchBonusTypeVictoryRoyal = 'MATCH_BONUS_TYPE_VICTORY_ROYAL'
}

export type GameLogicMatchConfiguration = {
  __typename?: 'GameLogicMatchConfiguration';
  aonPointMultipliers: Array<Scalars['Float']['output']>;
  boosterCooldowns: Array<Scalars['Int']['output']>;
  cardGlobalRefs: Array<Scalars['String']['output']>;
  cardSwitchOutTimerDuration: Scalars['Int']['output'];
  freeReshuffleCount: Scalars['Int']['output'];
  gameId: Scalars['ID']['output'];
  handSize: Scalars['Int']['output'];
  matchBonusActivationRule: Scalars['String']['output'];
  matchBonusPoints: Scalars['Int']['output'];
  matchBonusType: GameLogicMatchBonusType;
  matchType: GameLogicStreamStateMatchType;
  pointsGainTime: Scalars['Int']['output'];
  reshuffleBaseCost: Scalars['Int']['output'];
  reshuffleCostMultiplier: Scalars['Float']['output'];
  seasonId: Scalars['ID']['output'];
};

export type GameLogicMatchEndedMsg = {
  __typename?: 'GameLogicMatchEndedMsg';
  bestCard?: Maybe<GameLogicCardDetails>;
  bestGroup?: Maybe<GameLogicGroupDetails>;
  bestPlayer?: Maybe<GameLogicPlayerDetails>;
  challengeStatuses: Array<GameLogicChallengeStatus>;
  channelId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  group: GameLogicGroup;
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  players: Array<GameLogicPlayer>;
  streamId: Scalars['ID']['output'];
};

export type GameLogicMatchPauseStateChangedMsg = {
  __typename?: 'GameLogicMatchPauseStateChangedMsg';
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  paused: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
};

export type GameLogicMatchStartedMsg = {
  __typename?: 'GameLogicMatchStartedMsg';
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  streamId: Scalars['ID']['output'];
};

export type GameLogicPlayer = {
  __typename?: 'GameLogicPlayer';
  activeCard: GameLogicActiveCard;
  activeChallengeId: Scalars['ID']['output'];
  allOrNothing: GameLogicAllOrNothing;
  bestPlay: GameLogicBestPlay;
  boosterCooldownTimer: GameLogicTimer;
  cardSwitchOutTimer: GameLogicTimer;
  fullUser: Scalars['Boolean']['output'];
  hand: GameLogicHand;
  heldBoosterId: Scalars['Int']['output'];
  inactivityWarningOn: Scalars['Boolean']['output'];
  isOnline: Scalars['Boolean']['output'];
  lastActiveCard: GameLogicLastActiveCard;
  name: Scalars['String']['output'];
  points: Scalars['Int']['output'];
  remainingInactiveSeconds: Scalars['Int']['output'];
  reshuffleCount: Scalars['Int']['output'];
  selfUsedBoosterCount: Scalars['Int']['output'];
  usedBoosterCount: Scalars['Int']['output'];
  usedMatchCards: Array<GameLogicPlayerUsedMatchCardsEntry>;
  userId: Scalars['ID']['output'];
  userName: Scalars['String']['output'];
};

export type GameLogicPlayerBoosterPoints = {
  __typename?: 'GameLogicPlayerBoosterPoints';
  boosterId: Scalars['Int']['output'];
  cardUserId: Scalars['ID']['output'];
  donatorUserId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
  userId: Scalars['ID']['output'];
};

export type GameLogicPlayerDetails = {
  __typename?: 'GameLogicPlayerDetails';
  groupName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
  user: ProfileProfile;
};

export type GameLogicPlayerJoinedMsg = {
  __typename?: 'GameLogicPlayerJoinedMsg';
  groupId: Scalars['ID']['output'];
  player: GameLogicPlayer;
  playerCardIds: Array<Scalars['String']['output']>;
  serverTime: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type GameLogicPlayerUsedMatchCardsEntry = {
  __typename?: 'GameLogicPlayerUsedMatchCardsEntry';
  key: Scalars['Int']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameLogicStreamState = {
  __typename?: 'GameLogicStreamState';
  matchSeqNum: Scalars['Int']['output'];
  matchState: GameLogicStreamStateMatchState;
  matchType: GameLogicStreamStateMatchType;
  roundNumber: Scalars['Int']['output'];
  roundPhase: GameLogicStreamStateRoundPhase;
  roundPhaseDeadline: Scalars['Int']['output'];
};

export enum GameLogicStreamStateMatchState {
  MatchStateActive = 'MATCH_STATE_ACTIVE',
  MatchStateEnded = 'MATCH_STATE_ENDED',
  MatchStatePaused = 'MATCH_STATE_PAUSED',
  MatchStateUnspecified = 'MATCH_STATE_UNSPECIFIED'
}

export enum GameLogicStreamStateMatchType {
  MatchTypeMultiRound = 'MATCH_TYPE_MULTI_ROUND',
  MatchTypeSingleRound = 'MATCH_TYPE_SINGLE_ROUND',
  MatchTypeUnspecified = 'MATCH_TYPE_UNSPECIFIED'
}

export enum GameLogicStreamStateRoundPhase {
  RoundPhaseCompetition = 'ROUND_PHASE_COMPETITION',
  RoundPhaseEnded = 'ROUND_PHASE_ENDED',
  RoundPhasePreparation = 'ROUND_PHASE_PREPARATION',
  RoundPhaseUnspecified = 'ROUND_PHASE_UNSPECIFIED'
}

export type GameLogicStreamerCard = {
  __typename?: 'GameLogicStreamerCard';
  baseCard: GameLogicCard;
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  draft: Scalars['Boolean']['output'];
  facecam: Scalars['String']['output'];
  facecamUrl: Scalars['String']['output'];
  familyId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  image: Scalars['String']['output'];
  imageUrl: Scalars['String']['output'];
  name: Scalars['String']['output'];
  saleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  video: Scalars['String']['output'];
  videoUrl: Scalars['String']['output'];
};


export type GameLogicStreamerCardBaseCardArgs = {
  season_id?: InputMaybe<Scalars['String']['input']>;
};

export type GameLogicTargetValue = {
  __typename?: 'GameLogicTargetValue';
  label: Scalars['String']['output'];
  selector?: Maybe<GameLogicTargetValueSelector>;
  value: Scalars['Int']['output'];
};

export type GameLogicTargetValueSelector = {
  __typename?: 'GameLogicTargetValueSelector';
  attribute: Scalars['String']['output'];
  value?: Maybe<GameLogicTargetValueSelectorValueUnion>;
};

export type GameLogicTargetValueSelectorDefaultValue = {
  __typename?: 'GameLogicTargetValueSelectorDefaultValue';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type GameLogicTargetValueSelectorValueUnion = BooleanType | GameLogicTargetValueSelectorDefaultValue | IntType | StringType;

export type GameLogicTimer = {
  __typename?: 'GameLogicTimer';
  endTime: Scalars['Int']['output'];
  startTime: Scalars['Int']['output'];
};

export type GameLogicVote = {
  __typename?: 'GameLogicVote';
  cardId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type GameSeason = {
  __typename?: 'GameSeason';
  badgeUrl: Scalars['String']['output'];
  cardBackgroundUrls: Array<GameSeasonCardBackgroundAsset>;
  endTime: Scalars['Timestamp']['output'];
  game: GameGame;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  progression: ProgressionSeasonProgression;
  progressionPauseReason: Scalars['String']['output'];
  progressionPaused: Scalars['Boolean']['output'];
  seasonBreak: Scalars['Boolean']['output'];
  seasonBreakReason: Scalars['String']['output'];
  /** @deprecated field is deprecated */
  seasonPauseReason: Scalars['String']['output'];
  /** @deprecated field is deprecated */
  seasonPaused: Scalars['Boolean']['output'];
  startTime: Scalars['Timestamp']['output'];
};


export type GameSeasonProgressionArgs = {
  user_id?: InputMaybe<Scalars['ID']['input']>;
};

export type GameSeasonCardBackgroundAsset = {
  __typename?: 'GameSeasonCardBackgroundAsset';
  rarity: RarityRarity;
  url: Scalars['String']['output'];
};

export type GameStateAttributesState = {
  __typename?: 'GameStateAttributesState';
  boolAttributes: Array<GameStateAttributesStateBoolAttributesEntry>;
  intAttributes: Array<GameStateAttributesStateIntAttributesEntry>;
  stringAttributes: Array<GameStateAttributesStateStringAttributesEntry>;
};

export type GameStateAttributesStateBoolAttributesEntry = {
  __typename?: 'GameStateAttributesStateBoolAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateAttributesStateIntAttributesEntry = {
  __typename?: 'GameStateAttributesStateIntAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type GameStateAttributesStateStringAttributesEntry = {
  __typename?: 'GameStateAttributesStateStringAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type GameStateBoosterState = {
  __typename?: 'GameStateBoosterState';
  activeBooster: GameLogicActiveBooster;
  booster: GameLogicBooster;
  sourcePlayerId: Scalars['ID']['output'];
  targetPlayerId: Scalars['ID']['output'];
};

export type GameStateCalModule = {
  __typename?: 'GameStateCALModule';
  expression: GameStateCalModuleExpression;
};

export type GameStateCalModuleBinaryExpression = {
  __typename?: 'GameStateCALModuleBinaryExpression';
  left: GameStateCalModuleExpression;
  op: GameStateCalModuleBinaryOp;
  right: GameStateCalModuleExpression;
};

export enum GameStateCalModuleBinaryOp {
  BinaryOpAnd = 'BINARY_OP_AND',
  BinaryOpOr = 'BINARY_OP_OR',
  BinaryOpUnspecified = 'BINARY_OP_UNSPECIFIED'
}

export type GameStateCalModuleBinding = {
  __typename?: 'GameStateCALModuleBinding';
  ident: Scalars['String']['output'];
  selector: GameStateCalModuleBinding;
};

export type GameStateCalModuleCheck = {
  __typename?: 'GameStateCALModuleCheck';
  check?: Maybe<GameStateCalModuleCheckCheckUnion>;
  label: Scalars['String']['output'];
};

export type GameStateCalModuleCheckCheckUnion = GameStateCalModuleCountEventIntAttributeCheck | GameStateCalModuleEventBoolAttributeCheck | GameStateCalModuleEventIntAttributeCheck | GameStateCalModuleEventStringAttributeCheck | GameStateCalModuleEventTypeCheck | GameStateCalModuleEventTypeCheckAfterEventIntAttributeCheck | GameStateCalModuleGlobalAnyBoolAttributeCheck | GameStateCalModuleGlobalBoolAttributeCheck | GameStateCalModuleGlobalIntAttributeCheck | GameStateCalModuleGlobalIntAttributeSumCheck | GameStateCalModuleGlobalStringAttributeCheck | GameStateCalModuleIs | GameStateCalModuleRepeatedEventBoolAttributeCheck | GameStateCalModuleRepeatedEventIntAttributeCheck | GameStateCalModuleRepeatedEventStringAttributeCheck | GameStateCalModuleRepeatedEventTypeCheck | GameStateCalModuleTimeoutCheck;

export type GameStateCalModuleCheckParam = {
  __typename?: 'GameStateCALModuleCheckParam';
  value?: Maybe<GameStateCalModuleCheckParamValueUnion>;
};

export type GameStateCalModuleCheckParamValueUnion = BooleanType | GameStateCalModuleBinding | IntType | StringType;

export type GameStateCalModuleCheckSequence = {
  __typename?: 'GameStateCALModuleCheckSequence';
  activationTimes: Array<Scalars['Int']['output']>;
  expressions: Array<GameStateCalModuleExpression>;
  intervals: Array<Scalars['Int']['output']>;
  label: Scalars['String']['output'];
};

export type GameStateCalModuleCountEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleCountEventIntAttributeCheck';
  attributes: Array<Scalars['String']['output']>;
  calculateNegative: Scalars['Boolean']['output'];
  eventName: Scalars['String']['output'];
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleEventBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleEventBoolAttributeCheck';
  attribute: Scalars['String']['output'];
  eventName: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateCalModuleEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleEventIntAttributeCheck';
  attribute: Scalars['String']['output'];
  eventName: Scalars['String']['output'];
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int']['output'];
};

export type GameStateCalModuleEventStringAttributeCheck = {
  __typename?: 'GameStateCALModuleEventStringAttributeCheck';
  attribute: Scalars['String']['output'];
  eventName: Scalars['String']['output'];
  operator: GameStateStringComparisonOperator;
  values: Array<Scalars['String']['output']>;
};

export type GameStateCalModuleEventTypeCheck = {
  __typename?: 'GameStateCALModuleEventTypeCheck';
  eventNames: Array<Scalars['String']['output']>;
};

export type GameStateCalModuleEventTypeCheckAfterEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleEventTypeCheckAfterEventIntAttributeCheck';
  firstCheck: GameStateCalModuleEventIntAttributeCheck;
  firstCheckSuccessTime: Scalars['Int']['output'];
  secondCheck: GameStateCalModuleEventTypeCheck;
  timerDuration: Scalars['Int']['output'];
};

export type GameStateCalModuleExpression = {
  __typename?: 'GameStateCALModuleExpression';
  expression?: Maybe<GameStateCalModuleExpressionExpressionUnion>;
};

export type GameStateCalModuleExpressionExpressionUnion = GameStateCalModuleBinaryExpression | GameStateCalModuleCheck | GameStateCalModuleCheckSequence | GameStateCalModuleForDuration | GameStateCalModuleGroup | GameStateCalModuleRepeat | GameStateCalModuleUnaryExpression | GameStateCalModuleWhen;

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type GameStateCalModuleForDuration = {
  __typename?: 'GameStateCALModuleForDuration';
  expression: GameStateCalModuleExpression;
  resetting: Scalars['Boolean']['output'];
  timeout: GameStateCalModuleExpression;
};

export type GameStateCalModuleGlobalAnyBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalAnyBoolAttributeCheck';
  attributes: Array<Scalars['String']['output']>;
  value: Scalars['Boolean']['output'];
};

export type GameStateCalModuleGlobalBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalBoolAttributeCheck';
  attribute: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateCalModuleGlobalIntAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalIntAttributeCheck';
  attribute: Scalars['String']['output'];
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int']['output'];
};

export type GameStateCalModuleGlobalIntAttributeSumCheck = {
  __typename?: 'GameStateCALModuleGlobalIntAttributeSumCheck';
  attributes: Array<Scalars['String']['output']>;
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int']['output'];
};

export type GameStateCalModuleGlobalStringAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalStringAttributeCheck';
  attribute: Scalars['String']['output'];
  operator: GameStateStringComparisonOperator;
  values: Array<Scalars['String']['output']>;
};

export type GameStateCalModuleGroup = {
  __typename?: 'GameStateCALModuleGroup';
  expression: GameStateCalModuleExpression;
};

export type GameStateCalModuleIs = {
  __typename?: 'GameStateCALModuleIs';
  checkParams: Array<GameStateCalModuleCheckParam>;
  op: GameStateComparisonOperator;
};

export type GameStateCalModuleRepeat = {
  __typename?: 'GameStateCALModuleRepeat';
  expression: GameStateCalModuleExpression;
  initialValue: Scalars['Int']['output'];
  label: Scalars['String']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventBoolAttributeCheck';
  check: GameStateCalModuleEventBoolAttributeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventIntAttributeCheck';
  check: GameStateCalModuleEventIntAttributeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventStringAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventStringAttributeCheck';
  check: GameStateCalModuleEventStringAttributeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventTypeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventTypeCheck';
  check: GameStateCalModuleEventTypeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleTimeoutCheck = {
  __typename?: 'GameStateCALModuleTimeoutCheck';
  duration: Scalars['Int']['output'];
  lastStateChangeTimestamp: Scalars['Int']['output'];
  lastTimestamp: Scalars['Int']['output'];
  timeLeft: Scalars['Int']['output'];
};

export type GameStateCalModuleUnaryExpression = {
  __typename?: 'GameStateCALModuleUnaryExpression';
  expression: GameStateCalModuleExpression;
  op: GameStateCalModuleUnaryOp;
};

export enum GameStateCalModuleUnaryOp {
  UnaryOpNot = 'UNARY_OP_NOT',
  UnaryOpUnspecified = 'UNARY_OP_UNSPECIFIED'
}

export type GameStateCalModuleWhen = {
  __typename?: 'GameStateCALModuleWhen';
  attribute: Scalars['String']['output'];
  cases: Array<GameStateCalModuleWhenCase>;
};

export type GameStateCalModuleWhenCase = {
  __typename?: 'GameStateCALModuleWhenCase';
  expression: GameStateCalModuleExpression;
  value?: Maybe<GameStateCalModuleWhenCaseValueUnion>;
};

export type GameStateCalModuleWhenCaseDefault = {
  __typename?: 'GameStateCALModuleWhenCaseDefault';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type GameStateCalModuleWhenCaseValueUnion = BooleanType | GameStateCalModuleWhenCaseDefault | IntType | StringType;

export type GameStateCardDealingState = {
  __typename?: 'GameStateCardDealingState';
  cardAvailability: Array<GameStateCardDealingStateCardAvailabilityEntry>;
  cardDealingModules: Array<GameStateCardDealingStateCardDealingModulesEntry>;
  cards: Array<GameStateCardDealingStateCardsEntry>;
};

export type GameStateCardDealingStateCalModulesList = {
  __typename?: 'GameStateCardDealingStateCALModulesList';
  modules: Array<GameStateCalModule>;
};

export type GameStateCardDealingStateCardAvailabilityEntry = {
  __typename?: 'GameStateCardDealingStateCardAvailabilityEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateCardDealingStateCardDealingModulesEntry = {
  __typename?: 'GameStateCardDealingStateCardDealingModulesEntry';
  key: Scalars['String']['output'];
  value: GameStateCardDealingStateCalModulesList;
};

export type GameStateCardDealingStateCardsEntry = {
  __typename?: 'GameStateCardDealingStateCardsEntry';
  key: Scalars['String']['output'];
  value: GameLogicCard;
};

export type GameStateCardState = {
  __typename?: 'GameStateCardState';
  failureModules: Array<GameStateCalModule>;
  successModules: Array<GameStateCalModule>;
};

export type GameStateChallengeState = {
  __typename?: 'GameStateChallengeState';
  challengeId: Scalars['ID']['output'];
  challengeState: GameLogicChallengeState;
  failureModule: GameStateCalModule;
  pickRate: Scalars['Float']['output'];
  successModule: GameStateCalModule;
  targetValues: Array<GameStateChallengeStateTargetValuesEntry>;
};

export type GameStateChallengeStateTargetValuesEntry = {
  __typename?: 'GameStateChallengeStateTargetValuesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type GameStateClientSession = {
  __typename?: 'GameStateClientSession';
  mailbox: Scalars['String']['output'];
  timestamp: Scalars['Int']['output'];
  token: Scalars['String']['output'];
};

export type GameStateClientSessionList = {
  __typename?: 'GameStateClientSessionList';
  sessions: Array<GameStateClientSession>;
};

export enum GameStateComparisonOperator {
  ComparisonOperatorEqual = 'COMPARISON_OPERATOR_EQUAL',
  ComparisonOperatorExists = 'COMPARISON_OPERATOR_EXISTS',
  ComparisonOperatorGreater = 'COMPARISON_OPERATOR_GREATER',
  ComparisonOperatorGreaterOrEqual = 'COMPARISON_OPERATOR_GREATER_OR_EQUAL',
  ComparisonOperatorIn = 'COMPARISON_OPERATOR_IN',
  ComparisonOperatorLess = 'COMPARISON_OPERATOR_LESS',
  ComparisonOperatorLessOrEqual = 'COMPARISON_OPERATOR_LESS_OR_EQUAL',
  ComparisonOperatorNotEqual = 'COMPARISON_OPERATOR_NOT_EQUAL',
  ComparisonOperatorNotExists = 'COMPARISON_OPERATOR_NOT_EXISTS',
  ComparisonOperatorNotIn = 'COMPARISON_OPERATOR_NOT_IN',
  ComparisonOperatorUnspecified = 'COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateContextualTeamActionState = {
  __typename?: 'GameStateContextualTeamActionState';
  deadlineMs: Scalars['Int']['output'];
  participants: Array<GameStateContextualTeamActionStateParticipantsEntry>;
  status: GameLogicContextualTeamActionStatus;
  type: GameLogicContextualTeamActionType;
};

export type GameStateContextualTeamActionStateParticipantsEntry = {
  __typename?: 'GameStateContextualTeamActionStateParticipantsEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateGameConfig = {
  __typename?: 'GameStateGameConfig';
  boosters: Array<GameStateGameConfigBoostersEntry>;
  challengeConfig: GameStateGameConfigChallengeConfig;
  featureFlags: Array<GameStateGameConfigFeatureFlagsEntry>;
  highScoringCardConfig: GameStateGameConfigHighScoringCardConfig;
  inactivityTimeouts: ConfigMetagameConfigInactivityTimeouts;
  matchConfiguration: GameLogicMatchConfiguration;
  uiTimings: ConfigMetagameConfigUiTimings;
};

export type GameStateGameConfigBoostersEntry = {
  __typename?: 'GameStateGameConfigBoostersEntry';
  key: Scalars['Int']['output'];
  value: GameLogicBooster;
};

export type GameStateGameConfigChallengeConfig = {
  __typename?: 'GameStateGameConfigChallengeConfig';
  availableChallengesCount: Scalars['Int']['output'];
  challenges: Array<GameStateGameConfigChallengeConfigChallengesEntry>;
  isEnabled: Scalars['Boolean']['output'];
};

export type GameStateGameConfigChallengeConfigChallengesEntry = {
  __typename?: 'GameStateGameConfigChallengeConfigChallengesEntry';
  key: Scalars['String']['output'];
  value: GameLogicChallenge;
};

export type GameStateGameConfigFeatureFlagsEntry = {
  __typename?: 'GameStateGameConfigFeatureFlagsEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type GameStateGameConfigHighScoringCardConfig = {
  __typename?: 'GameStateGameConfigHighScoringCardConfig';
  highScoringCardConfigs: Array<GameCardHighScoringCardConfig>;
  highScoringCardTimings: Array<GameCardHighScoringCardTimings>;
};

export type GameStateGroupRunnerState = {
  __typename?: 'GameStateGroupRunnerState';
  gameConfig: GameStateGameConfig;
  groupStartTime: Scalars['Int']['output'];
  groupState: GameStateGroupState;
  matchEndTime: Scalars['Int']['output'];
  matchPauseStartTime: Scalars['Int']['output'];
  matchPauseTimeTotal: Scalars['Int']['output'];
  matchTimeTrackerState: GameStateMatchTimeTrackerState;
  players: Array<GameStateGroupRunnerStatePlayersEntry>;
  randomState: GameStateRandomState;
  sessionTrackerState: GameStateSessionTrackerState;
  started: Scalars['Boolean']['output'];
  stepTimestamp: Scalars['Int']['output'];
  streamTrackerState: GameStateStreamTrackerState;
  timeOffset: Scalars['Int']['output'];
  timer: GameStateTimerState;
};

export type GameStateGroupRunnerStatePlayersEntry = {
  __typename?: 'GameStateGroupRunnerStatePlayersEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateGroupState = {
  __typename?: 'GameStateGroupState';
  activeChallenges: Array<GameStateChallengeState>;
  addedPlayers: Array<GameStateGroupStateAddedPlayersEntry>;
  boosterUsages: Array<GameStateGroupStateBoosterUsage>;
  contextualTeamActionState: GameStateContextualTeamActionState;
  group: GameLogicGroup;
  matchBonusActivationRule: GameStateCalModule;
  players: Array<GameStateGroupStatePlayersEntry>;
  removedPlayers: Array<GameStatePlayerState>;
  streamInfo: StreamInfoStreamInfo;
  timeTrackerState: GameStateTimeTrackerState;
};

export type GameStateGroupStateAddedPlayersEntry = {
  __typename?: 'GameStateGroupStateAddedPlayersEntry';
  key: Scalars['String']['output'];
  value: GameStatePlayerState;
};

export type GameStateGroupStateBoosterUsage = {
  __typename?: 'GameStateGroupStateBoosterUsage';
  boosterState: GameStateBoosterState;
  sourcePlayerId: Scalars['ID']['output'];
  targetPlayerId: Scalars['ID']['output'];
};

export type GameStateGroupStatePlayersEntry = {
  __typename?: 'GameStateGroupStatePlayersEntry';
  key: Scalars['String']['output'];
  value: GameStatePlayerState;
};

export type GameStateHighScoringCardState = {
  __typename?: 'GameStateHighScoringCardState';
  activeGroups: Array<GameStateHighScoringCardStateActiveGroupsEntry>;
  card: GameLogicHighScoringCard;
  deadline: Scalars['Int']['output'];
  groupId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type GameStateHighScoringCardStateActiveGroupsEntry = {
  __typename?: 'GameStateHighScoringCardStateActiveGroupsEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export enum GameStateIntComparisonOperator {
  IntComparisonOperatorEqual = 'INT_COMPARISON_OPERATOR_EQUAL',
  IntComparisonOperatorGreater = 'INT_COMPARISON_OPERATOR_GREATER',
  IntComparisonOperatorGreaterOrEqual = 'INT_COMPARISON_OPERATOR_GREATER_OR_EQUAL',
  IntComparisonOperatorLess = 'INT_COMPARISON_OPERATOR_LESS',
  IntComparisonOperatorLessOrEqual = 'INT_COMPARISON_OPERATOR_LESS_OR_EQUAL',
  IntComparisonOperatorNotEqual = 'INT_COMPARISON_OPERATOR_NOT_EQUAL',
  IntComparisonOperatorUnspecified = 'INT_COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateMatchTimeTrackerState = {
  __typename?: 'GameStateMatchTimeTrackerState';
  time: Scalars['Int']['output'];
  timeOffset: Scalars['Int']['output'];
  timer: GameStateTimerState;
};

export type GameStatePlayerState = {
  __typename?: 'GameStatePlayerState';
  cardDealingState: GameStateCardDealingState;
  cardState: GameStateCardState;
  debugEvents: Scalars['Boolean']['output'];
  groupId: Scalars['ID']['output'];
  lastHeldBoosterId: Scalars['Int']['output'];
  player: GameLogicPlayer;
  streamId: Scalars['ID']['output'];
};

export type GameStateRandomState = {
  __typename?: 'GameStateRandomState';
  seed: Scalars['Int']['output'];
};

export type GameStateSessionTrackerState = {
  __typename?: 'GameStateSessionTrackerState';
  playerSessions: Array<GameStateSessionTrackerStatePlayerSessionsEntry>;
  spectatorSessions: Array<GameStateSessionTrackerStateSpectatorSessionsEntry>;
};

export type GameStateSessionTrackerStatePlayerSessionsEntry = {
  __typename?: 'GameStateSessionTrackerStatePlayerSessionsEntry';
  key: Scalars['String']['output'];
  value: GameStateClientSessionList;
};

export type GameStateSessionTrackerStateSpectatorSessionsEntry = {
  __typename?: 'GameStateSessionTrackerStateSpectatorSessionsEntry';
  key: Scalars['String']['output'];
  value: GameStateClientSessionList;
};

export type GameStateStreamGroupsTrackerState = {
  __typename?: 'GameStateStreamGroupsTrackerState';
  bestCard: GameLogicCardDetails;
  bestGroup: GameLogicGroupDetails;
  bestPlayer: GameLogicPlayerDetails;
};

export type GameStateStreamState = {
  __typename?: 'GameStateStreamState';
  groups: Array<Scalars['String']['output']>;
  streamGroupsTracker: GameStateStreamGroupsTrackerState;
  streamInfo: StreamInfoStreamInfo;
  streamTracker: GameStateStreamTrackerState;
};

export type GameStateStreamTrackerState = {
  __typename?: 'GameStateStreamTrackerState';
  globalAttributes: GameStateAttributesState;
  globalAttributesHash: Scalars['Int']['output'];
  globalsChanged: Scalars['Boolean']['output'];
  matchEndTime: Scalars['Int']['output'];
  matchPauseStartTime: Scalars['Int']['output'];
  matchPauseTimeTotal: Scalars['Int']['output'];
  matchStartTime: Scalars['Int']['output'];
  matchStateChanged: Scalars['Boolean']['output'];
  previousMatchState: GameLogicStreamStateMatchState;
  roundPhaseChanged: Scalars['Boolean']['output'];
  streamState: GameLogicStreamState;
};

export enum GameStateStringComparisonOperator {
  StringComparisonOperatorEqual = 'STRING_COMPARISON_OPERATOR_EQUAL',
  StringComparisonOperatorIn = 'STRING_COMPARISON_OPERATOR_IN',
  StringComparisonOperatorNotEqual = 'STRING_COMPARISON_OPERATOR_NOT_EQUAL',
  StringComparisonOperatorNotIn = 'STRING_COMPARISON_OPERATOR_NOT_IN',
  StringComparisonOperatorUnspecified = 'STRING_COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateTimeTrackerState = {
  __typename?: 'GameStateTimeTrackerState';
  entries: Array<GameStateTimeTrackerStateEntriesEntry>;
  matchActive: Scalars['Boolean']['output'];
};

export type GameStateTimeTrackerStateEntriesEntry = {
  __typename?: 'GameStateTimeTrackerStateEntriesEntry';
  key: Scalars['String']['output'];
  value: GameStateTimeTrackerStateTimeTrackerEntry;
};

export type GameStateTimeTrackerStateTimeTrackerEntry = {
  __typename?: 'GameStateTimeTrackerStateTimeTrackerEntry';
  disconnectedTimestamp: Scalars['Int']['output'];
  idle: Scalars['Boolean']['output'];
  idleTimestamp: Scalars['Int']['output'];
  lastOnlineTimestamp: Scalars['Int']['output'];
  online: Scalars['Boolean']['output'];
  totalIdleTime: Scalars['Int']['output'];
  totalTime: Scalars['Int']['output'];
};

export type GameStateTimerState = {
  __typename?: 'GameStateTimerState';
  activeTimeout: GameStateTimerStateTimeout;
  /** @deprecated field is deprecated */
  activeTimerDeadline: Scalars['Int']['output'];
  /** @deprecated field is deprecated */
  timeouts: Array<Scalars['Int']['output']>;
  timeoutsWithMetadata: Array<GameStateTimerStateTimeout>;
};

export type GameStateTimerStateMetadata = {
  __typename?: 'GameStateTimerStateMetadata';
  source: Scalars['String']['output'];
};

export type GameStateTimerStateTimeout = {
  __typename?: 'GameStateTimerStateTimeout';
  expirationTimestamp: Scalars['Int']['output'];
  metadata: GameStateTimerStateMetadata;
};

export type GameUserProgression = {
  __typename?: 'GameUserProgression';
  experiencePoints: Scalars['Int']['output'];
  level: Scalars['Int']['output'];
  userId: Scalars['ID']['output'];
};

export type GoalCardBatchGetGoalCardsResponse = {
  __typename?: 'GoalCardBatchGetGoalCardsResponse';
  goalCards: Array<GoalCardGoalCard>;
};

export type GoalCardGetSlotOptionsResponse = {
  __typename?: 'GoalCardGetSlotOptionsResponse';
  cardOptions: Array<GoalCardGoalCard>;
};

export type GoalCardGoalCard = {
  __typename?: 'GoalCardGoalCard';
  cardGoalGroup: Scalars['String']['output'];
  /** counter_config_ids defines which counters the goal card is tracking */
  counterConfigIds: Array<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  disabled: Scalars['Boolean']['output'];
  game?: Maybe<GameGame>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  rarity: RarityRarity;
  requiredItemIds: Array<Scalars['String']['output']>;
  requiresTeam: Scalars['Boolean']['output'];
  reward: RewardRewardType;
  /**
   * target is the target value for the counter where an award is awarded to
   *  the user
   */
  target: Scalars['Float']['output'];
  targetType: GoalCardGoalCardTargetType;
};

export type GoalCardGoalCardSlot = {
  __typename?: 'GoalCardGoalCardSlot';
  cardOptions?: Maybe<Array<GoalCardGoalCard>>;
  goalCard?: Maybe<GoalCardGoalCard>;
  goalCardId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  progress?: Maybe<GoalCardGoalCardSlotProgress>;
  resetTime?: Maybe<Scalars['Timestamp']['output']>;
  reward?: Maybe<RewardReward>;
};

export type GoalCardGoalCardSlotProgress = {
  __typename?: 'GoalCardGoalCardSlotProgress';
  completed: Scalars['Boolean']['output'];
  percentage: Scalars['Float']['output'];
  value: Scalars['Float']['output'];
};

export enum GoalCardGoalCardTargetType {
  TargetTypeSingleUpdate = 'TARGET_TYPE_SINGLE_UPDATE',
  TargetTypeTotal = 'TARGET_TYPE_TOTAL',
  TargetTypeUnspecified = 'TARGET_TYPE_UNSPECIFIED',
  TargetTypeUpdateCount = 'TARGET_TYPE_UPDATE_COUNT'
}

export type GoalCardListGoalCardSlotsResponse = {
  __typename?: 'GoalCardListGoalCardSlotsResponse';
  slots: Array<GoalCardGoalCardSlot>;
};

export type GoalCardReshuffleSlotResponse = {
  __typename?: 'GoalCardReshuffleSlotResponse';
  cardOptions: Array<GoalCardGoalCard>;
};

export type GoalCardSetGoalCardSlotResponse = {
  __typename?: 'GoalCardSetGoalCardSlotResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

/**
 * A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *
 *      service Foo {
 *        rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *      }
 *
 *  The JSON representation for `Empty` is empty JSON object `{}`.
 */
export type GoogleProtobufEmpty = {
  __typename?: 'GoogleProtobufEmpty';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

/**
 * `FieldMask` represents a set of symbolic field paths, for example:
 *
 *      paths: "f.a"
 *      paths: "f.b.d"
 *
 *  Here `f` represents a field in some root message, `a` and `b`
 *  fields in the message found in `f`, and `d` a field found in the
 *  message in `f.b`.
 *
 *  Field masks are used to specify a subset of fields that should be
 *  returned by a get operation or modified by an update operation.
 *  Field masks also have a custom JSON encoding (see below).
 *
 *  # Field Masks in Projections
 *
 *  When used in the context of a projection, a response message or
 *  sub-message is filtered by the API to only contain those fields as
 *  specified in the mask. For example, if the mask in the previous
 *  example is applied to a response message as follows:
 *
 *      f {
 *        a : 22
 *        b {
 *          d : 1
 *          x : 2
 *        }
 *        y : 13
 *      }
 *      z: 8
 *
 *  The result will not contain specific values for fields x,y and z
 *  (their value will be set to the default, and omitted in proto text
 *  output):
 *
 *
 *      f {
 *        a : 22
 *        b {
 *          d : 1
 *        }
 *      }
 *
 *  A repeated field is not allowed except at the last position of a
 *  paths string.
 *
 *  If a FieldMask object is not present in a get operation, the
 *  operation applies to all fields (as if a FieldMask of all fields
 *  had been specified).
 *
 *  Note that a field mask does not necessarily apply to the
 *  top-level response message. In case of a REST get operation, the
 *  field mask applies directly to the response, but in case of a REST
 *  list operation, the mask instead applies to each individual message
 *  in the returned resource list. In case of a REST custom method,
 *  other definitions may be used. Where the mask applies will be
 *  clearly documented together with its declaration in the API.  In
 *  any case, the effect on the returned resource/resources is required
 *  behavior for APIs.
 *
 *  # Field Masks in Update Operations
 *
 *  A field mask in update operations specifies which fields of the
 *  targeted resource are going to be updated. The API is required
 *  to only change the values of the fields as specified in the mask
 *  and leave the others untouched. If a resource is passed in to
 *  describe the updated values, the API ignores the values of all
 *  fields not covered by the mask.
 *
 *  If a repeated field is specified for an update operation, new values will
 *  be appended to the existing repeated field in the target resource. Note that
 *  a repeated field is only allowed in the last position of a `paths` string.
 *
 *  If a sub-message is specified in the last position of the field mask for an
 *  update operation, then new value will be merged into the existing sub-message
 *  in the target resource.
 *
 *  For example, given the target message:
 *
 *      f {
 *        b {
 *          d: 1
 *          x: 2
 *        }
 *        c: [1]
 *      }
 *
 *  And an update message:
 *
 *      f {
 *        b {
 *          d: 10
 *        }
 *        c: [2]
 *      }
 *
 *  then if the field mask is:
 *
 *   paths: ["f.b", "f.c"]
 *
 *  then the result will be:
 *
 *      f {
 *        b {
 *          d: 10
 *          x: 2
 *        }
 *        c: [1, 2]
 *      }
 *
 *  An implementation may provide options to override this default behavior for
 *  repeated and message fields.
 *
 *  In order to reset a field's value to the default, the field must
 *  be in the mask and set to the default value in the provided resource.
 *  Hence, in order to reset all fields of a resource, provide a default
 *  instance of the resource and set all fields in the mask, or do
 *  not provide a mask as described below.
 *
 *  If a field mask is not present on update, the operation applies to
 *  all fields (as if a field mask of all fields has been specified).
 *  Note that in the presence of schema evolution, this may mean that
 *  fields the client does not know and has therefore not filled into
 *  the request will be reset to their default. If this is unwanted
 *  behavior, a specific service may require a client to always specify
 *  a field mask, producing an error if not.
 *
 *  As with get operations, the location of the resource which
 *  describes the updated values in the request message depends on the
 *  operation kind. In any case, the effect of the field mask is
 *  required to be honored by the API.
 *
 *  ## Considerations for HTTP REST
 *
 *  The HTTP kind of an update operation which uses a field mask must
 *  be set to PATCH instead of PUT in order to satisfy HTTP semantics
 *  (PUT must only be used for full updates).
 *
 *  # JSON Encoding of Field Masks
 *
 *  In JSON, a field mask is encoded as a single string where paths are
 *  separated by a comma. Fields name in each path are converted
 *  to/from lower-camel naming conventions.
 *
 *  As an example, consider the following message declarations:
 *
 *      message Profile {
 *        User user = 1;
 *        Photo photo = 2;
 *      }
 *      message User {
 *        string display_name = 1;
 *        string address = 2;
 *      }
 *
 *  In proto a field mask for `Profile` may look as such:
 *
 *      mask {
 *        paths: "user.display_name"
 *        paths: "photo"
 *      }
 *
 *  In JSON, the same mask is represented as below:
 *
 *      {
 *        mask: "user.displayName,photo"
 *      }
 *
 *  # Field Masks and Oneof Fields
 *
 *  Field masks treat fields in oneofs just as regular fields. Consider the
 *  following message:
 *
 *      message SampleMessage {
 *        oneof test_oneof {
 *          string name = 4;
 *          SubMessage sub_message = 9;
 *        }
 *      }
 *
 *  The field mask can be:
 *
 *      mask {
 *        paths: "name"
 *      }
 *
 *  Or:
 *
 *      mask {
 *        paths: "sub_message"
 *      }
 *
 *  Note that oneof type names ("test_oneof" in this case) cannot be used in
 *  paths.
 *
 *  ## Field Mask Verification
 *
 *  The implementation of any API method which has a FieldMask type field in the
 *  request should verify the included field paths, and return an
 *  `INVALID_ARGUMENT` error if any path is unmappable.
 */
export type GoogleProtobufFieldMaskInput = {
  /** The set of field mask paths. */
  paths?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type IntType = {
  __typename?: 'IntType';
  /** The wrapped value of type Int */
  value: Scalars['Int']['output'];
};

export type InventoryAddEntitlementsResponse = {
  __typename?: 'InventoryAddEntitlementsResponse';
  items: Array<InventoryInventoryItem>;
};

export type InventoryConsumeItemResponse = {
  __typename?: 'InventoryConsumeItemResponse';
  items: Array<InventoryInventoryItem>;
};

export type InventoryInventoryEvent = {
  __typename?: 'InventoryInventoryEvent';
  event?: Maybe<InventoryInventoryEventEventUnion>;
  id: Scalars['ID']['output'];
  reason: ReasonReason;
  userId: Scalars['ID']['output'];
};

export type InventoryInventoryEventEventUnion = InventoryItemConsumption | InventoryItemEntitlement;

export type InventoryInventoryItem = {
  __typename?: 'InventoryInventoryItem';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type InventoryInventoryUpdateEvent = {
  __typename?: 'InventoryInventoryUpdateEvent';
  events: Array<InventoryInventoryEvent>;
};

export type InventoryItemConsumption = {
  __typename?: 'InventoryItemConsumption';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type InventoryItemConsumptionInput = {
  itemCount?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
};

export type InventoryItemEntitlement = {
  __typename?: 'InventoryItemEntitlement';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type InventoryItemEntitlementInput = {
  itemCount?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
};

export type InventoryListUserInventoryRequestFilterAttributeFilterInput = {
  key?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type InventoryListUserInventoryRequestFilterInput = {
  /** attribute optional attribute filter */
  attribute?: InputMaybe<InventoryListUserInventoryRequestFilterAttributeFilterInput>;
  /** game_id optional game filter */
  gameId?: InputMaybe<Scalars['ID']['input']>;
  /** item_type optional item type filter */
  itemType?: InputMaybe<ItemItemType>;
  /** season_id optional season filter */
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

export type InventoryListUserInventoryResponse = {
  __typename?: 'InventoryListUserInventoryResponse';
  items: Array<InventoryInventoryItem>;
  pageInfo: ApiPageInfo;
};

export type InvitationCreateInvitationCodesResponse = {
  __typename?: 'InvitationCreateInvitationCodesResponse';
  codes: Array<InvitationInvitationCode>;
};

export type InvitationInvitationCode = {
  __typename?: 'InvitationInvitationCode';
  code: Scalars['String']['output'];
  createdAt: Scalars['Timestamp']['output'];
  ownerId: Scalars['ID']['output'];
  usedAt?: Maybe<Scalars['Timestamp']['output']>;
  usedBy?: Maybe<ProfileProfile>;
  usedById?: Maybe<Scalars['ID']['output']>;
};

export type InvitationInvitationCodeUpdateEvent = {
  __typename?: 'InvitationInvitationCodeUpdateEvent';
  codes: Array<InvitationInvitationCode>;
  updateType: InvitationInvitationCodeUpdateEventUpdateType;
  updatedAt: Scalars['Timestamp']['output'];
};

export enum InvitationInvitationCodeUpdateEventUpdateType {
  UpdateTypeCreated = 'UPDATE_TYPE_CREATED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUsed = 'UPDATE_TYPE_USED'
}

export type InvitationListInvitationCodesResponse = {
  __typename?: 'InvitationListInvitationCodesResponse';
  codes: Array<InvitationInvitationCode>;
};

export type ItemBatchExpandItemsResponse = {
  __typename?: 'ItemBatchExpandItemsResponse';
  items: Array<ItemItem>;
};

export type ItemBatchGetItemsResponse = {
  __typename?: 'ItemBatchGetItemsResponse';
  items: Array<ItemItem>;
};

export type ItemExpandItemResponse = {
  __typename?: 'ItemExpandItemResponse';
  items: Array<ItemItem>;
};

export type ItemGetItemResponse = {
  __typename?: 'ItemGetItemResponse';
  item: ItemItem;
};

export type ItemItem = {
  __typename?: 'ItemItem';
  attributes: AttributeAttributeMap;
  bootstraps?: Maybe<Array<ItemItemBootstrap>>;
  channel?: Maybe<ChannelChannel>;
  channelId: Scalars['ID']['output'];
  children?: Maybe<Array<ItemItem>>;
  consumable: Scalars['Boolean']['output'];
  details?: Maybe<ItemItemDetailsUnion>;
  disabled: Scalars['Boolean']['output'];
  game?: Maybe<GameGame>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  inventoryItem: InventoryInventoryItem;
  name: Scalars['String']['output'];
  /** if the parent item is owned, this item is owned as well */
  parentItemId: Scalars['ID']['output'];
  season?: Maybe<GameSeason>;
  seasonId: Scalars['ID']['output'];
  type: ItemItemType;
  /** unlock_item_id what if any item is required to unlock this item for bundles and other consumption */
  unlockItemId: Scalars['ID']['output'];
  updatedAt: Scalars['Timestamp']['output'];
};


export type ItemItemInventoryItemArgs = {
  user_id: Scalars['ID']['input'];
};

export type ItemItemBootstrap = {
  __typename?: 'ItemItemBootstrap';
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
  revision: Scalars['String']['output'];
};

export type ItemItemBootstrapInput = {
  itemCount?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
};

export type ItemItemCount = {
  __typename?: 'ItemItemCount';
  count: Scalars['Int']['output'];
  type: ItemItemType;
};

export type ItemItemDetailsUnion = AvatarAnimation | AvatarAvatarPart | EmojiEmoji | GameLogicCard | GameLogicStreamerCard;

export type ItemItemStat = {
  __typename?: 'ItemItemStat';
  counts: Array<ItemItemCount>;
  gameId: Scalars['ID']['output'];
};

export type ItemItemTotalCount = {
  __typename?: 'ItemItemTotalCount';
  disabled: Scalars['Int']['output'];
  total: Scalars['Int']['output'];
};

export enum ItemItemType {
  TypeAvatarItem = 'TYPE_AVATAR_ITEM',
  TypeBootstrap = 'TYPE_BOOTSTRAP',
  TypeDailyGoalCardSlot = 'TYPE_DAILY_GOAL_CARD_SLOT',
  TypeEmoji = 'TYPE_EMOJI',
  TypeEmote = 'TYPE_EMOTE',
  TypeGameCard = 'TYPE_GAME_CARD',
  TypeStreamerCard = 'TYPE_STREAMER_CARD',
  TypeSubscription = 'TYPE_SUBSCRIPTION',
  TypeUnlock = 'TYPE_UNLOCK',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type ItemListItemsRequestFilterAttributeInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type ItemListItemsRequestFilterInput = {
  attribute?: InputMaybe<ItemListItemsRequestFilterAttributeInput>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<ItemItemType>;
  parentId?: InputMaybe<Scalars['ID']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

export type ItemListItemsResponse = {
  __typename?: 'ItemListItemsResponse';
  count?: Maybe<ItemItemTotalCount>;
  items: Array<ItemItem>;
  pageInfo: ApiPageInfo;
};

export type MatchCardCount = {
  __typename?: 'MatchCardCount';
  card: GameLogicCard;
  cardId: Scalars['ID']['output'];
  count: Scalars['Int']['output'];
};

export type MatchChallengeUpdate = {
  __typename?: 'MatchChallengeUpdate';
  content?: Maybe<MatchChallengeUpdateContentUnion>;
};

export type MatchChallengeUpdateContentUnion = MatchChallengeUpdateReset | MatchChallengeUpdateStatusUpdate;

export type MatchChallengeUpdateReset = {
  __typename?: 'MatchChallengeUpdateReset';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type MatchChallengeUpdateStatusUpdate = {
  __typename?: 'MatchChallengeUpdateStatusUpdate';
  challenges: Array<GameLogicChallengeStatus>;
};

export type MatchGetGroupChatIdResponse = {
  __typename?: 'MatchGetGroupChatIDResponse';
  chatId: Scalars['ID']['output'];
};

export type MatchGetGroupStateResponse = {
  __typename?: 'MatchGetGroupStateResponse';
  runnerState: GameStateGroupRunnerState;
  /** @deprecated field is deprecated */
  state: GameStateGroupState;
};

export type MatchGetMatchStateResponse = {
  __typename?: 'MatchGetMatchStateResponse';
  matchState: GameLogicStreamStateMatchState;
};

export type MatchGetStreamStateResponse = {
  __typename?: 'MatchGetStreamStateResponse';
  gameConfig: GameStateGameConfig;
  groups: Array<Scalars['String']['output']>;
  highScoringCard: GameStateHighScoringCardState;
  started: Scalars['Boolean']['output'];
  streamGroupsTracker: GameStateStreamGroupsTrackerState;
  streamInfo: StreamInfoStreamInfo;
  streamTracker: GameStateStreamTrackerState;
};

export type MatchGetTopActiveCardsResponse = {
  __typename?: 'MatchGetTopActiveCardsResponse';
  topCards: Array<MatchCardCount>;
};

export type MatchStreamSpectatorChangeGroupEvent = {
  __typename?: 'MatchStreamSpectatorChangeGroupEvent';
  groupId: Scalars['ID']['output'];
};

export type MatchStreamSpectatorCoordinationEvent = {
  __typename?: 'MatchStreamSpectatorCoordinationEvent';
  event?: Maybe<MatchStreamSpectatorCoordinationEventEventUnion>;
};

export type MatchStreamSpectatorCoordinationEventEventUnion = MatchStreamSpectatorChangeGroupEvent;

export type MatchTopCardsUpdate = {
  __typename?: 'MatchTopCardsUpdate';
  content?: Maybe<MatchTopCardsUpdateContentUnion>;
};

export type MatchTopCardsUpdateCardCountUpdate = {
  __typename?: 'MatchTopCardsUpdateCardCountUpdate';
  cards: Array<MatchCardCount>;
};

export type MatchTopCardsUpdateContentUnion = MatchTopCardsUpdateCardCountUpdate | MatchTopCardsUpdateReset;

export type MatchTopCardsUpdateReset = {
  __typename?: 'MatchTopCardsUpdateReset';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type MediaBatchGetMediaUrlResponse = {
  __typename?: 'MediaBatchGetMediaURLResponse';
  urls: Array<Scalars['String']['output']>;
};

export type MediaMediaOptionsInput = {
  height?: InputMaybe<Scalars['Int']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

export type MlControllerGetHudScaleResponse = {
  __typename?: 'MlControllerGetHUDScaleResponse';
  estimatedScale: Scalars['Int']['output'];
  isScaleSufficient: Scalars['Boolean']['output'];
  mlDisabled: Scalars['Boolean']['output'];
  suggestedMinimumScale: Scalars['Int']['output'];
};

export enum ModerationAppealStatus {
  AppealStatusAccepted = 'APPEAL_STATUS_ACCEPTED',
  AppealStatusDeclined = 'APPEAL_STATUS_DECLINED',
  AppealStatusPending = 'APPEAL_STATUS_PENDING',
  AppealStatusUnspecified = 'APPEAL_STATUS_UNSPECIFIED'
}

export enum ModerationBanStatus {
  BanStatusActive = 'BAN_STATUS_ACTIVE',
  BanStatusInactive = 'BAN_STATUS_INACTIVE',
  BanStatusUnspecified = 'BAN_STATUS_UNSPECIFIED'
}

export type ModerationListPlatformBanAppealsResponse = {
  __typename?: 'ModerationListPlatformBanAppealsResponse';
  appeals: Array<ModerationPlatformBanAppeal>;
  pageInfo: ApiPageInfo;
};

export type ModerationPlatformBan = {
  __typename?: 'ModerationPlatformBan';
  appeal?: Maybe<ModerationPlatformBanAppeal>;
  appealApproved: Scalars['Boolean']['output'];
  banId: Scalars['ID']['output'];
  bannedAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  moderator: ProfileProfile;
  moderatorId: Scalars['ID']['output'];
  status: ModerationBanStatus;
  unbannedAt?: Maybe<Scalars['Timestamp']['output']>;
  unbannedBy: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
  violation: ModerationViolation;
};

export type ModerationPlatformBanAppeal = {
  __typename?: 'ModerationPlatformBanAppeal';
  appealText: Scalars['String']['output'];
  ban: ModerationPlatformBan;
  banId: Scalars['ID']['output'];
  closedAt?: Maybe<Scalars['Timestamp']['output']>;
  createdAt: Scalars['Timestamp']['output'];
  reviewer?: Maybe<ProfileProfile>;
  reviewerComment: Scalars['String']['output'];
  reviewerId: Scalars['ID']['output'];
  status: ModerationAppealStatus;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ModerationPlatformUserBannedNotification = {
  __typename?: 'ModerationPlatformUserBannedNotification';
  bannedAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  userId: Scalars['ID']['output'];
  violation: ModerationViolation;
};

export enum ModerationViolation {
  ViolationChildSafety = 'VIOLATION_CHILD_SAFETY',
  ViolationCircumventionEvasion = 'VIOLATION_CIRCUMVENTION_EVASION',
  ViolationExtremism = 'VIOLATION_EXTREMISM',
  ViolationGraphicRealWorldMedia = 'VIOLATION_GRAPHIC_REAL_WORLD_MEDIA',
  ViolationHarassmentTargetedAbuse = 'VIOLATION_HARASSMENT_TARGETED_ABUSE',
  ViolationHatefulBehavior = 'VIOLATION_HATEFUL_BEHAVIOR',
  ViolationIllegalHarmfulAndRestrictedActivity = 'VIOLATION_ILLEGAL_HARMFUL_AND_RESTRICTED_ACTIVITY',
  ViolationOffPlatformBehavior = 'VIOLATION_OFF_PLATFORM_BEHAVIOR',
  ViolationOther = 'VIOLATION_OTHER',
  ViolationPlatformManipulation = 'VIOLATION_PLATFORM_MANIPULATION',
  ViolationRepeatedCopyrightInfringement = 'VIOLATION_REPEATED_COPYRIGHT_INFRINGEMENT',
  ViolationResponsibleStreaming = 'VIOLATION_RESPONSIBLE_STREAMING',
  ViolationRestrictedGamesAndGamesWithGraphicFootage = 'VIOLATION_RESTRICTED_GAMES_AND_GAMES_WITH_GRAPHIC_FOOTAGE',
  ViolationSelfHarm = 'VIOLATION_SELF_HARM',
  ViolationSexualBehavior = 'VIOLATION_SEXUAL_BEHAVIOR',
  ViolationSpam = 'VIOLATION_SPAM',
  ViolationUnspecified = 'VIOLATION_UNSPECIFIED',
  ViolationViolence = 'VIOLATION_VIOLENCE'
}

export type Mutation = {
  __typename?: 'Mutation';
  /** FriendsService.AcceptFriendRequest */
  acceptFriendRequest?: Maybe<FriendsAcceptFriendRequestResponse>;
  /** ChannelService.AcceptMonetizationTerms */
  acceptMonetizationTerms?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.AddOAuth2Consent */
  addOAuth2Consent?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.CreatePushNotificationToken */
  addPushNotificationToken?: Maybe<GoogleProtobufEmpty>;
  /** ReactionService.AddReaction */
  addReaction?: Maybe<ReactionReactionState>;
  /** UserInventoryAdminService.AddEntitlements */
  addUserEntitlements?: Maybe<InventoryAddEntitlementsResponse>;
  /** WalletAdminService.AddCurrencies */
  addWalletCurrencies?: Maybe<WalletAddCurrenciesResponse>;
  /** ChatModerationService.AllowModerationItem */
  allowChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.BanUser */
  banChannelUser?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.BanUser */
  banPlatformUser?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.BatchDeleteNotifications */
  batchDeleteNotifications?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.BatchMarkNotificationsRead */
  batchMarkNotificationsRead?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.BlockUser */
  blockUser?: Maybe<FriendsBlockUserResponse>;
  /** StoreServiceV2.BuyWithInGameCurrency */
  buyWithInGameCurrency?: Maybe<StoreV2BuyWithInGameCurrencyResponse>;
  /** StoreServiceV2.BuyWithPayment */
  buyWithPayment?: Maybe<StoreV2BuyWithPaymentResponse>;
  /** ChannelSubscriptionService.CancelSubscription */
  cancelChannelSubscription?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.CancelDeletion */
  cancelDataDeletion?: Maybe<GoogleProtobufEmpty>;
  /** StoreServiceV2.CancelOrder */
  cancelOrder?: Maybe<GoogleProtobufEmpty>;
  /** ChannelSubscriptionService.CheckoutExistingSubscription */
  checkoutExistingChannelSubscription?: Maybe<SubscriptionCheckoutExistingSubscriptionResponse>;
  /** ChannelSubscriptionService.CheckoutNewSubscription */
  checkoutNewChannelSubscription?: Maybe<SubscriptionCheckoutNewSubscriptionResponse>;
  /** RewardService.ClaimReward */
  claimReward?: Maybe<RewardClaimRewardResponse>;
  /** ChatModerationService.ClearModerationItem */
  clearChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.ClearPushNotifications */
  clearPushNotifications?: Maybe<GoogleProtobufEmpty>;
  /** UserInventoryAdminService.ConsumeItem */
  consumeUserItem?: Maybe<InventoryConsumeItemResponse>;
  /** AuthAdminService.CreateAccount */
  createAccount?: Maybe<AuthAccount>;
  /** AnnouncementService.CreateAnnouncement */
  createAnnouncement?: Maybe<AnnouncementAnnouncement>;
  /** AnnouncementService.CreateAnnouncementImageUploadToken */
  createAnnouncementImageUploadToken?: Maybe<AnnouncementCreateAnnouncementImageUploadTokenResponse>;
  /** ChallengeService.CreateChallenge */
  createChallenge?: Maybe<GameLogicChallenge>;
  /** ChallengeSessionService.CreateChallengeSession */
  createChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelService.CreateChannel */
  createChannel?: Maybe<ChannelChannel>;
  /** ChannelService.CreateChannelAssetUploadToken */
  createChannelAssetUploadToken?: Maybe<ChannelCreateChannelAssetUploadTokenResponse>;
  /** ChannelModerationService.CreateBanAppeal */
  createChannelBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** ChannelEmojiService.CreateChannelEmoji */
  createChannelEmoji?: Maybe<EmojiEmoji>;
  /** EmojiService.CreateEmojiUploadToken */
  createEmojiUploadToken?: Maybe<EmojiCreateEmojiUploadTokenResponse>;
  /** StreamIngestConfigService.CreateIngestConfigs */
  createIngestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** InvitationService.CreateInvitationCodes */
  createInvitationCodes?: Maybe<InvitationCreateInvitationCodesResponse>;
  /** ItemService.CreateItemBootstrap */
  createItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.CreateParty */
  createParty?: Maybe<PartyParty>;
  /** PartyService.CreatePartyInvitation */
  createPartyInvitation?: Maybe<PartyPartyInvitation>;
  /** PartyService.CreatePartyMember */
  createPartyMember?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.CreateUserPlatformBanAppeal */
  createPlatformBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.CreatePlatformEmoji */
  createPlatformEmoji?: Maybe<EmojiEmoji>;
  /** SupportService.CreateReport */
  createReport?: Maybe<SupportReport>;
  /** ChannelConfigService.CreateStreamBackendConfig */
  createStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StreamerCardService.CreateStreamerCardAssetUploadToken */
  createStreamerCardAssetUploadToken?: Maybe<GameCardCreateStreamerCardAssetUploadTokenResponse>;
  /** StreamerCardService.CreateStreamerCardDraft */
  createStreamerCardDraft?: Maybe<GameLogicStreamerCard>;
  /** StoreServiceV2.CreateStreamerCardSaleConfig */
  createStreamerCardSaleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  /** SupportService.CreateTicket */
  createSupportTicket?: Maybe<GoogleProtobufEmpty>;
  /** AnnouncementService.DeleteAnnouncement */
  deleteAnnouncement?: Maybe<GoogleProtobufEmpty>;
  /** AnnouncementService.DeleteAnnouncementImage */
  deleteAnnouncementImage?: Maybe<GoogleProtobufEmpty>;
  /** ChallengeService.DeleteChallenge */
  deleteChallenge?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.DeleteChannel */
  deleteChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.DeleteChannelAsset */
  deleteChannelAsset?: Maybe<GoogleProtobufEmpty>;
  /** ChannelEmojiService.DeleteChannelEmoji */
  deleteChannelEmoji?: Maybe<GoogleProtobufEmpty>;
  /** FTUEService.DeleteDismissedTooltip */
  deleteDismissedTooltip?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.DeleteExternalAccount */
  deleteExternalAccount?: Maybe<GoogleProtobufEmpty>;
  /** StreamIngestConfigService.DeleteIngestConfigs */
  deleteIngestConfigs?: Maybe<GoogleProtobufEmpty>;
  /** ItemService.DeleteItemBootstrap */
  deleteItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.DeleteNotification */
  deleteNotification?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.DeleteOAuth2Consent */
  deleteOAuth2Consent?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.DeletePartyInvitation */
  deletePartyInvitation?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.DeletePartyMember */
  deletePartyMember?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.DeletePlatformEmoji */
  deletePlatformEmoji?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.DeletePushNotificationToken */
  deletePushNotificationToken?: Maybe<GoogleProtobufEmpty>;
  /** ChannelConfigService.DeleteStreamBackendConfig */
  deleteStreamBackendConfig?: Maybe<GoogleProtobufEmpty>;
  /** StreamerCardService.DeleteStreamerCardDraft */
  deleteStreamerCardDraft?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.DeleteUserData */
  deleteUserData?: Maybe<PrivacyDeleteUserDataResponse>;
  /** ChatModerationService.DenyModerationItem */
  denyChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** FTUEService.DismissTooltip */
  dismissTooltip?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.ExportUserData */
  exportUserData?: Maybe<PrivacyExportUserDataResponse>;
  /** ChannelService.FollowChannel - Following APIs */
  followChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.HideChatMessage */
  hideChatMessage?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.MarkNotificationRead */
  markNotificationRead?: Maybe<NotificationNotification>;
  /** MLControllerService.TriggerMatchEnd */
  mlTriggerMatchEnd?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.MuteChatUser */
  muteChatUser?: Maybe<GoogleProtobufEmpty>;
  /** ChallengeSessionService.PickChallenge */
  pickChallenge?: Maybe<ChallengesessionChallengePick>;
  /** ChallengeSessionService.ProgressChallengeSession */
  progressChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** StreamerCardService.PublishStreamerCardDraft */
  publishStreamerCardDraft?: Maybe<GoogleProtobufEmpty>;
  /** ChannelSubscriptionService.ReactivateSubscription */
  reactivateChannelSubscription?: Maybe<GoogleProtobufEmpty>;
  /** StreamIngestConfigService.RefreshIngestConfigs */
  refreshIngestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** ProfileService.RejectUsername */
  rejectUsername?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.DeleteFriend */
  removeFriend?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.DeleteFriendRequest */
  removeFriendRequest?: Maybe<GoogleProtobufEmpty>;
  /** ReactionService.RemoveReaction */
  removeReaction?: Maybe<ReactionReactionState>;
  /** GoalCardService.ReshuffleSlot */
  reshuffleGoalCardSlot?: Maybe<GoalCardReshuffleSlotResponse>;
  /** ChallengeSessionService.ResolveChallenge */
  resolveChallenge?: Maybe<ChallengesessionChallengeSession>;
  /** PlacementsService.RewardPlacement */
  rewardPlacement?: Maybe<GoogleProtobufEmpty>;
  /** ChannelConfigService.SelectStreamBackendConfig */
  selectStreamBackendConfig?: Maybe<GoogleProtobufEmpty>;
  /** ChatService.SendChatMessage */
  sendChatMessage?: Maybe<ChatSendMessageResponse>;
  /** FriendsService.SendFriendRequest */
  sendFriendRequest?: Maybe<FriendsSendFriendRequestResponse>;
  /** PushNotificationService.SendPushNotification */
  sendPushNotification?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.SetBirthday */
  setBirthday?: Maybe<GoogleProtobufEmpty>;
  /** FeatureFlagService.SetFeatureFlagConfig */
  setFeatureFlagConfig?: Maybe<FlagFeatureFlagConfig>;
  /** GoalCardService.SetGoalCardSlot */
  setGoalCardSlot?: Maybe<GoalCardSetGoalCardSlotResponse>;
  /** ChannelService.SetUserChannelRoles */
  setUserChannelRoles?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.SignAgreements */
  signAgreements?: Maybe<GoogleProtobufEmpty>;
  /** StreamerService.ActivateContextualTeamAction */
  streamerActivateContextualTeamAction?: Maybe<StreamerActivateContextualTeamActionResponse>;
  /** StreamerService.TriggerCameraTransition */
  streamerTriggerCameraTransition?: Maybe<StreamerTriggerCameraTransitionResponse>;
  /** WalletAdminService.SubtractCurrencies */
  subtractWalletCurrencies?: Maybe<WalletSubtractCurrenciesResponse>;
  /** ChannelModerationService.SuspendChannelFeature */
  suspendChannelFeature?: Maybe<GoogleProtobufEmpty>;
  /** UserActionService.TriggerEmoji */
  triggerEmoji?: Maybe<GoogleProtobufEmpty>;
  /** UserActionService.TriggerEmote */
  triggerEmote?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.UnbanUser */
  unbanChannelUser?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.UnbanUser */
  unbanPlatformUser?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.UnblockUser */
  unblockUser?: Maybe<FriendsUnblockUserResponse>;
  /** ChannelService.UnfollowChannel */
  unfollowChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.UnmuteChatUser */
  unmuteChatUser?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.UnsuspendChannelFeature */
  unsuspendChannelFeature?: Maybe<GoogleProtobufEmpty>;
  /** AuthAdminService.UpdateAccount */
  updateAccount?: Maybe<AuthAccount>;
  /** AnnouncementService.UpdateAnnouncement */
  updateAnnouncement?: Maybe<AnnouncementAnnouncement>;
  /** AvatarService.UpdateAvatar */
  updateAvatar?: Maybe<AvatarAvatar>;
  /** ChallengeService.UpdateChallenge */
  updateChallenge?: Maybe<GameLogicChallenge>;
  /** ChallengeSessionService.UpdateChallengeSession */
  updateChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelModerationService.UpdateBanAppeal */
  updateChannelBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.UpdateChannelDetails */
  updateChannelDetails?: Maybe<ChannelChannel>;
  /** ChannelEmojiService.UpdateChannelEmoji */
  updateChannelEmoji?: Maybe<EmojiEmoji>;
  /** ChannelModerationService.UpdateModerationSettings */
  updateChannelModerationSettings?: Maybe<ChannelModerationSettings>;
  /** ChannelService.UpdateMonetizationSettings */
  updateChannelMonetizationSettings?: Maybe<ChannelMonetizationSettings>;
  /** ChannelNotificationService.UpdateNotificationSettings */
  updateChannelNotificationSettings?: Maybe<ChannelNotificationSettings>;
  /** ChannelSubscriptionService.UpdateChannelSubscriptionConfig */
  updateChannelSubscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  /** ChannelNotificationService.UpdateFollowerNotificationSettings */
  updateFollowerNotificationSettings?: Maybe<ChannelFollowerNotificationSettings>;
  /** FriendsService.UpdateFriendsSettings */
  updateFriendsSettings?: Maybe<FriendsFriendsSettings>;
  /** ItemService.UpdateItemBootstrap */
  updateItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.UpdateMarketingConsent */
  updateMarketingConsent?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.UpdatePlatformBanAppeal */
  updatePlatformBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.UpdatePlatformEmoji */
  updatePlatformEmoji?: Maybe<EmojiEmoji>;
  /** ProfileService.UpdatePrivacySettings */
  updatePrivacySettings?: Maybe<ProfilePrivacySettings>;
  /** ProfileService.UpdateProfile */
  updateProfile?: Maybe<ProfileProfile>;
  /** ProfileService.UpdateProfileAvatar */
  updateProfileAvatar?: Maybe<GoogleProtobufEmpty>;
  /** ProfileService.UpdateProfileAvatarV2 */
  updateProfileAvatarV2?: Maybe<AvatarAvatar>;
  /** ChannelConfigService.UpdateRestreamingConfig */
  updateRestreamingConfig?: Maybe<ChannelRestreamingConfig>;
  /** ChannelConfigService.UpdateStreamBackendConfig */
  updateStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StreamerCardService.UpdateStreamerCardDraft */
  updateStreamerCardDraft?: Maybe<GameLogicStreamerCard>;
  /** StoreServiceV2.UpdateStreamerCardSaleConfig */
  updateStreamerCardSaleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  /** ChannelSubscriptionService.UpdateSubscriptionPaymentMethod - protolint:disable:next MAX_LINE_LENGTH */
  updateSubscriptionPaymentMethod?: Maybe<SubscriptionUpdateSubscriptionPaymentMethodResponse>;
  /** InvitationService.UseInvitationCode */
  useInvitationCode?: Maybe<GoogleProtobufEmpty>;
  /** AvatarService.ValidateAvatarComposition */
  validateAvatarComposition?: Maybe<AvatarValidateAvatarCompositionResponse>;
};


export type MutationAcceptFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAcceptMonetizationTermsArgs = {
  address?: InputMaybe<ApiAddressInput>;
  birthday?: InputMaybe<ApiDateInput>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<ChannelGender>;
  lastName?: InputMaybe<Scalars['String']['input']>;
};


export type MutationAddOAuth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']['input']>;
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAddPushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']['input']>;
  tokenType?: InputMaybe<NotificationPushNotificationTokenType>;
};


export type MutationAddReactionArgs = {
  parentId?: InputMaybe<Scalars['ID']['input']>;
  parentType?: InputMaybe<Scalars['String']['input']>;
  reactionType?: InputMaybe<ReactionReactionType>;
  resourceId?: InputMaybe<Scalars['ID']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
};


export type MutationAddUserEntitlementsArgs = {
  entitlements?: InputMaybe<Array<InventoryItemEntitlementInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAddWalletCurrenciesArgs = {
  currencies?: InputMaybe<Array<WalletWalletCurrencyInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAllowChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  moderationItemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationBanChannelUserArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  keepRecentMessages?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
  violation?: InputMaybe<ChannelViolation>;
};


export type MutationBanPlatformUserArgs = {
  description?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Duration']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
  violation?: InputMaybe<ModerationViolation>;
};


export type MutationBatchDeleteNotificationsArgs = {
  notificationIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type MutationBatchMarkNotificationsReadArgs = {
  notificationIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type MutationBlockUserArgs = {
  blockedUserId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationBuyWithInGameCurrencyArgs = {
  currencyId?: InputMaybe<Scalars['ID']['input']>;
  giftOptions?: InputMaybe<StoreV2GiftOptionsInput>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  signature?: InputMaybe<Scalars['String']['input']>;
};


export type MutationBuyWithPaymentArgs = {
  giftOptions?: InputMaybe<StoreV2GiftOptionsInput>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  paymentMethod?: InputMaybe<StoreV2PaymentMethod>;
  signature?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCancelChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCancelDataDeletionArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCancelOrderArgs = {
  orderId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCheckoutExistingChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCheckoutNewChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  tier?: InputMaybe<Scalars['Int']['input']>;
};


export type MutationClaimRewardArgs = {
  rewardId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationClearChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  moderationItemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationConsumeUserItemArgs = {
  consumptions?: InputMaybe<Array<InventoryItemConsumptionInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateAccountArgs = {
  displayName?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  isBot?: InputMaybe<Scalars['Boolean']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateAnnouncementArgs = {
  category?: InputMaybe<AnnouncementAnnouncementCategory>;
  endTime?: InputMaybe<Scalars['Timestamp']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  startTime?: InputMaybe<Scalars['Timestamp']['input']>;
  targets?: InputMaybe<AnnouncementTargetsInput>;
  text?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateAnnouncementImageUploadTokenArgs = {
  announcementId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChallengeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChallengeSessionArgs = {
  challenges?: InputMaybe<Array<ChallengesessionChallengeInput>>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
  submissionWindowLength?: InputMaybe<Scalars['Int']['input']>;
};


export type MutationCreateChannelArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
  streamerId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChannelAssetUploadTokenArgs = {
  assetType?: InputMaybe<ChannelAssetType>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChannelBanAppealArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateChannelEmojiArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateEmojiUploadTokenArgs = {
  itemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateInvitationCodesArgs = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateItemBootstrapArgs = {
  bootstrap?: InputMaybe<ItemItemBootstrapInput>;
};


export type MutationCreatePartyArgs = {
  inviteeIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type MutationCreatePartyInvitationArgs = {
  inviteeId?: InputMaybe<Scalars['ID']['input']>;
  inviterId?: InputMaybe<Scalars['ID']['input']>;
  partyId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreatePartyMemberArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreatePlatformBanAppealArgs = {
  appealText?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreatePlatformEmojiArgs = {
  label?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateReportArgs = {
  context?: InputMaybe<SupportReportContextInput>;
  description?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<SupportReportReason>;
};


export type MutationCreateStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  crConfig?: InputMaybe<ChannelContentRendererConfigInput>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  mlConfig?: InputMaybe<ChannelMachineLearningConfigInput>;
  recConfig?: InputMaybe<ChannelStreamRecorderConfigInput>;
  transcoderConfig?: InputMaybe<ChannelStreamTranscoderConfigInput>;
};


export type MutationCreateStreamerCardAssetUploadTokenArgs = {
  assetType?: InputMaybe<GameCardAssetType>;
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateStreamerCardDraftArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateStreamerCardSaleConfigArgs = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  excludeFromBundles?: InputMaybe<Scalars['Boolean']['input']>;
  period?: InputMaybe<StoreV2PeriodInput>;
};


export type MutationCreateSupportTicketArgs = {
  description?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDeleteAnnouncementArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteAnnouncementImageArgs = {
  announcementId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChannelArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChannelAssetArgs = {
  assetType?: InputMaybe<ChannelAssetType>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChannelEmojiArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteDismissedTooltipArgs = {
  tooltipId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteExternalAccountArgs = {
  idType?: InputMaybe<AuthIdentityType>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteItemBootstrapArgs = {
  itemId?: InputMaybe<Scalars['ID']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDeleteNotificationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteOAuth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePartyInvitationArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePartyMemberArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePlatformEmojiArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDeleteStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteStreamerCardDraftArgs = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteUserDataArgs = {
  gracePeriod?: InputMaybe<Scalars['Duration']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDenyChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  moderationItemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDismissTooltipArgs = {
  dismissalType?: InputMaybe<FtueDismissalType>;
  tooltipId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationFollowChannelArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationHideChatMessageArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  messageId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationMarkNotificationReadArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationMlTriggerMatchEndArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationMuteChatUserArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Duration']['input']>;
  reason?: InputMaybe<ChatReason>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationPickChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
  stake?: InputMaybe<ChallengesessionStakeInput>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationProgressChallengeSessionArgs = {
  phase?: InputMaybe<ChallengesessionChallengeSessionPhase>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationPublishStreamerCardDraftArgs = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationReactivateChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRefreshIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRejectUsernameArgs = {
  currentUsername?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<ModerationViolation>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRemoveFriendArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRemoveFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRemoveReactionArgs = {
  parentId?: InputMaybe<Scalars['ID']['input']>;
  parentType?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['ID']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
};


export type MutationReshuffleGoalCardSlotArgs = {
  slotId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationResolveChallengeArgs = {
  challenge?: InputMaybe<ChallengesessionChallengeInput>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRewardPlacementArgs = {
  placementId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSelectStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  configId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSendChatMessageArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  consentToModeration?: InputMaybe<Scalars['Boolean']['input']>;
  content?: InputMaybe<ChatMessageContentInput>;
};


export type MutationSendFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSendPushNotificationArgs = {
  body?: InputMaybe<Scalars['String']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  link?: InputMaybe<Scalars['String']['input']>;
  payload?: InputMaybe<NotificationPushNotificationPayloadInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  topic?: InputMaybe<Scalars['String']['input']>;
};


export type MutationSetBirthdayArgs = {
  birthday?: InputMaybe<AuthDateInput>;
};


export type MutationSetFeatureFlagConfigArgs = {
  config?: InputMaybe<FlagFeatureFlagConfigInput>;
  previousRevision?: InputMaybe<Scalars['String']['input']>;
  validateSchema?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationSetGoalCardSlotArgs = {
  goalCardId?: InputMaybe<Scalars['ID']['input']>;
  goalCardSlotId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSetUserChannelRolesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  roles?: InputMaybe<Array<ChannelChannelRole>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSignAgreementsArgs = {
  agreements?: InputMaybe<Array<AuthTermsVersionInput>>;
};


export type MutationStreamerActivateContextualTeamActionArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationStreamerTriggerCameraTransitionArgs = {
  cameraTransitionTarget?: InputMaybe<RenderingCameraTransitionRequestTransitionTarget>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSubtractWalletCurrenciesArgs = {
  currencies?: InputMaybe<Array<WalletWalletCurrencyInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSuspendChannelFeatureArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Duration']['input']>;
  feature?: InputMaybe<ChannelChannelFeature>;
  reason?: InputMaybe<ChannelSuspensionReason>;
};


export type MutationTriggerEmojiArgs = {
  emojiId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationTriggerEmoteArgs = {
  emoteId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnbanChannelUserArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnbanPlatformUserArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnblockUserArgs = {
  blockedUserId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnfollowChannelArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnmuteChatUserArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnsuspendChannelFeatureArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  feature?: InputMaybe<ChannelChannelFeature>;
};


export type MutationUpdateAccountArgs = {
  body?: InputMaybe<AuthAccountUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateAnnouncementArgs = {
  body?: InputMaybe<AnnouncementAnnouncementInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateAvatarArgs = {
  body?: InputMaybe<AvatarAvatarInput>;
};


export type MutationUpdateChallengeArgs = {
  body?: InputMaybe<ChallengeChallengeUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChallengeSessionArgs = {
  body?: InputMaybe<ChallengesessionChallengeSessionUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelBanAppealArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<ChannelAppealStatus>;
  text?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateChannelDetailsArgs = {
  body?: InputMaybe<ChannelChannelDetailsUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelEmojiArgs = {
  body?: InputMaybe<EmojiUpdateChannelEmojiParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelModerationSettingsArgs = {
  body?: InputMaybe<ChannelModerationSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelMonetizationSettingsArgs = {
  body?: InputMaybe<ChannelMonetizationSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelNotificationSettingsArgs = {
  body?: InputMaybe<ChannelUpdateNotificationSettingsParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelSubscriptionConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  subscriptionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationUpdateFollowerNotificationSettingsArgs = {
  body?: InputMaybe<ChannelUpdateFollowerNotificationSettingsParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateFriendsSettingsArgs = {
  body?: InputMaybe<FriendsFriendsSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateItemBootstrapArgs = {
  body?: InputMaybe<ItemItemBootstrapInput>;
};


export type MutationUpdateMarketingConsentArgs = {
  marketingConsent?: InputMaybe<AuthConsentStatus>;
};


export type MutationUpdatePlatformBanAppealArgs = {
  banId?: InputMaybe<Scalars['ID']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ModerationAppealStatus>;
};


export type MutationUpdatePlatformEmojiArgs = {
  body?: InputMaybe<EmojiUpdatePlatformEmojiParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdatePrivacySettingsArgs = {
  body?: InputMaybe<ProfilePrivacySettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateProfileArgs = {
  body?: InputMaybe<ProfileProfileUpdateInput>;
  options?: InputMaybe<ProfileUpdateProfileRequestOptionsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateProfileAvatarArgs = {
  modelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateProfileAvatarV2Args = {
  modelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateRestreamingConfigArgs = {
  body?: InputMaybe<ChannelRestreamingConfigInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamBackendConfigArgs = {
  body?: InputMaybe<ChannelStreamBackendConfigInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamerCardDraftArgs = {
  body?: InputMaybe<GameCardStreamerCardDraftUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamerCardSaleConfigArgs = {
  body?: InputMaybe<StoreV2StreamerCardSaleConfigUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUseInvitationCodeArgs = {
  code?: InputMaybe<Scalars['String']['input']>;
};


export type MutationValidateAvatarCompositionArgs = {
  composition?: InputMaybe<AvatarAvatarCompositionInput>;
};

export type NotificationForcedSignoutEvent = {
  __typename?: 'NotificationForcedSignoutEvent';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type NotificationGiftSubscription = {
  __typename?: 'NotificationGiftSubscription';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  giver?: Maybe<ProfileProfile>;
  giverId: Scalars['ID']['output'];
  tier: Scalars['Int']['output'];
};

export type NotificationListNotificationsResponse = {
  __typename?: 'NotificationListNotificationsResponse';
  notifications: Array<NotificationNotification>;
};

export type NotificationNotification = {
  __typename?: 'NotificationNotification';
  content: NotificationNotificationContent;
  createdAt: Scalars['Timestamp']['output'];
  id: Scalars['ID']['output'];
  new: Scalars['Boolean']['output'];
  persisted: Scalars['Boolean']['output'];
};

export type NotificationNotificationContent = {
  __typename?: 'NotificationNotificationContent';
  content?: Maybe<NotificationNotificationContentContentUnion>;
};

export type NotificationNotificationContentContentUnion = AdsPlacementStateEvent | ChannelUserBannedNotification | FriendsFriendStatusUpdateEvent | GoalCardGoalCardSlot | IntType | InventoryInventoryUpdateEvent | InvitationInvitationCodeUpdateEvent | ModerationPlatformUserBannedNotification | NotificationForcedSignoutEvent | NotificationGiftSubscription | PartyPartyInvitationUpdateEvent | PrivacyUserDataExportCompleteEvent | ProfileUsernameChange | ProgressionProgressionUpdateEvent | RewardReward | SubscriptionChannelSubscriptionUpdateEvent | WalletTransactionEvent;

export type NotificationPushNotificationPayloadChannelLiveInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  channelName?: InputMaybe<Scalars['String']['input']>;
};

export type NotificationPushNotificationPayloadInput = {
  channelLive?: InputMaybe<NotificationPushNotificationPayloadChannelLiveInput>;
};

export type NotificationPushNotificationToken = {
  __typename?: 'NotificationPushNotificationToken';
  token: Scalars['String']['output'];
  tokenType: NotificationPushNotificationTokenType;
  userId: Scalars['ID']['output'];
};

export enum NotificationPushNotificationTokenType {
  PushNotificationTokenTypeFirebase = 'PUSH_NOTIFICATION_TOKEN_TYPE_FIREBASE',
  PushNotificationTokenTypeUnspecified = 'PUSH_NOTIFICATION_TOKEN_TYPE_UNSPECIFIED'
}

export type PartyParty = {
  __typename?: 'PartyParty';
  channel?: Maybe<ChannelChannel>;
  id: Scalars['ID']['output'];
  leaderId: Scalars['ID']['output'];
  members: Array<PartyPartyMember>;
  name: Scalars['String']['output'];
  public: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
};

export type PartyPartyInvitation = {
  __typename?: 'PartyPartyInvitation';
  inviteeId: Scalars['ID']['output'];
  inviterId: Scalars['ID']['output'];
  partyId: Scalars['ID']['output'];
};

export type PartyPartyInvitationUpdateEvent = {
  __typename?: 'PartyPartyInvitationUpdateEvent';
  partyInvitation: PartyPartyInvitation;
  type: PartyPartyInvitationUpdateEventUpdateType;
};

export enum PartyPartyInvitationUpdateEventUpdateType {
  UpdateTypeInvitationAccepted = 'UPDATE_TYPE_INVITATION_ACCEPTED',
  UpdateTypeInvitationCreated = 'UPDATE_TYPE_INVITATION_CREATED',
  UpdateTypeInvitationDeclined = 'UPDATE_TYPE_INVITATION_DECLINED',
  UpdateTypeInvitationDeleted = 'UPDATE_TYPE_INVITATION_DELETED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED'
}

export type PartyPartyMember = {
  __typename?: 'PartyPartyMember';
  profile: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type PartyPartyUpdateEvent = {
  __typename?: 'PartyPartyUpdateEvent';
  party: PartyParty;
};

export type PaymentAmount = {
  __typename?: 'PaymentAmount';
  currency: PaymentCurrency;
  value: Scalars['Int']['output'];
};

export type PaymentAmountInput = {
  currency?: InputMaybe<PaymentCurrency>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentAppStoreSession = {
  __typename?: 'PaymentAppStoreSession';
  paymentId: Scalars['ID']['output'];
  productId: Scalars['ID']['output'];
};

export enum PaymentCurrency {
  CurrencyAed = 'CURRENCY_AED',
  CurrencyAfn = 'CURRENCY_AFN',
  CurrencyAll = 'CURRENCY_ALL',
  CurrencyAmd = 'CURRENCY_AMD',
  CurrencyAng = 'CURRENCY_ANG',
  CurrencyAoa = 'CURRENCY_AOA',
  CurrencyArs = 'CURRENCY_ARS',
  CurrencyAud = 'CURRENCY_AUD',
  CurrencyAwg = 'CURRENCY_AWG',
  CurrencyAzn = 'CURRENCY_AZN',
  CurrencyBam = 'CURRENCY_BAM',
  CurrencyBbd = 'CURRENCY_BBD',
  CurrencyBdt = 'CURRENCY_BDT',
  CurrencyBgn = 'CURRENCY_BGN',
  CurrencyBhd = 'CURRENCY_BHD',
  CurrencyBif = 'CURRENCY_BIF',
  CurrencyBmd = 'CURRENCY_BMD',
  CurrencyBnd = 'CURRENCY_BND',
  CurrencyBob = 'CURRENCY_BOB',
  CurrencyBov = 'CURRENCY_BOV',
  CurrencyBrl = 'CURRENCY_BRL',
  CurrencyBsd = 'CURRENCY_BSD',
  CurrencyBtn = 'CURRENCY_BTN',
  CurrencyBwp = 'CURRENCY_BWP',
  CurrencyByn = 'CURRENCY_BYN',
  CurrencyBzd = 'CURRENCY_BZD',
  CurrencyCad = 'CURRENCY_CAD',
  CurrencyCdf = 'CURRENCY_CDF',
  CurrencyChe = 'CURRENCY_CHE',
  CurrencyChf = 'CURRENCY_CHF',
  CurrencyChw = 'CURRENCY_CHW',
  CurrencyClf = 'CURRENCY_CLF',
  CurrencyClp = 'CURRENCY_CLP',
  CurrencyCny = 'CURRENCY_CNY',
  CurrencyCop = 'CURRENCY_COP',
  CurrencyCou = 'CURRENCY_COU',
  CurrencyCrc = 'CURRENCY_CRC',
  CurrencyCuc = 'CURRENCY_CUC',
  CurrencyCup = 'CURRENCY_CUP',
  CurrencyCve = 'CURRENCY_CVE',
  CurrencyCzk = 'CURRENCY_CZK',
  CurrencyDjf = 'CURRENCY_DJF',
  CurrencyDkk = 'CURRENCY_DKK',
  CurrencyDop = 'CURRENCY_DOP',
  CurrencyDzd = 'CURRENCY_DZD',
  CurrencyEgp = 'CURRENCY_EGP',
  CurrencyErn = 'CURRENCY_ERN',
  CurrencyEtb = 'CURRENCY_ETB',
  CurrencyEur = 'CURRENCY_EUR',
  CurrencyFjd = 'CURRENCY_FJD',
  CurrencyFkp = 'CURRENCY_FKP',
  CurrencyGbp = 'CURRENCY_GBP',
  CurrencyGel = 'CURRENCY_GEL',
  CurrencyGhs = 'CURRENCY_GHS',
  CurrencyGip = 'CURRENCY_GIP',
  CurrencyGmd = 'CURRENCY_GMD',
  CurrencyGnf = 'CURRENCY_GNF',
  CurrencyGtq = 'CURRENCY_GTQ',
  CurrencyGyd = 'CURRENCY_GYD',
  CurrencyHkd = 'CURRENCY_HKD',
  CurrencyHnl = 'CURRENCY_HNL',
  CurrencyHtg = 'CURRENCY_HTG',
  CurrencyHuf = 'CURRENCY_HUF',
  CurrencyIdr = 'CURRENCY_IDR',
  CurrencyIls = 'CURRENCY_ILS',
  CurrencyInr = 'CURRENCY_INR',
  CurrencyIqd = 'CURRENCY_IQD',
  CurrencyIrr = 'CURRENCY_IRR',
  CurrencyIsk = 'CURRENCY_ISK',
  CurrencyJmd = 'CURRENCY_JMD',
  CurrencyJod = 'CURRENCY_JOD',
  CurrencyJpy = 'CURRENCY_JPY',
  CurrencyKes = 'CURRENCY_KES',
  CurrencyKgs = 'CURRENCY_KGS',
  CurrencyKhr = 'CURRENCY_KHR',
  CurrencyKmf = 'CURRENCY_KMF',
  CurrencyKpw = 'CURRENCY_KPW',
  CurrencyKrw = 'CURRENCY_KRW',
  CurrencyKwd = 'CURRENCY_KWD',
  CurrencyKyd = 'CURRENCY_KYD',
  CurrencyKzt = 'CURRENCY_KZT',
  CurrencyLak = 'CURRENCY_LAK',
  CurrencyLbp = 'CURRENCY_LBP',
  CurrencyLkr = 'CURRENCY_LKR',
  CurrencyLrd = 'CURRENCY_LRD',
  CurrencyLsl = 'CURRENCY_LSL',
  CurrencyLyd = 'CURRENCY_LYD',
  CurrencyMad = 'CURRENCY_MAD',
  CurrencyMdl = 'CURRENCY_MDL',
  CurrencyMga = 'CURRENCY_MGA',
  CurrencyMkd = 'CURRENCY_MKD',
  CurrencyMmk = 'CURRENCY_MMK',
  CurrencyMnt = 'CURRENCY_MNT',
  CurrencyMop = 'CURRENCY_MOP',
  CurrencyMru = 'CURRENCY_MRU',
  CurrencyMur = 'CURRENCY_MUR',
  CurrencyMvr = 'CURRENCY_MVR',
  CurrencyMwk = 'CURRENCY_MWK',
  CurrencyMxn = 'CURRENCY_MXN',
  CurrencyMxv = 'CURRENCY_MXV',
  CurrencyMyr = 'CURRENCY_MYR',
  CurrencyMzn = 'CURRENCY_MZN',
  CurrencyNad = 'CURRENCY_NAD',
  CurrencyNgn = 'CURRENCY_NGN',
  CurrencyNio = 'CURRENCY_NIO',
  CurrencyNok = 'CURRENCY_NOK',
  CurrencyNpr = 'CURRENCY_NPR',
  CurrencyNzd = 'CURRENCY_NZD',
  CurrencyOmr = 'CURRENCY_OMR',
  CurrencyPab = 'CURRENCY_PAB',
  CurrencyPen = 'CURRENCY_PEN',
  CurrencyPgk = 'CURRENCY_PGK',
  CurrencyPhp = 'CURRENCY_PHP',
  CurrencyPkr = 'CURRENCY_PKR',
  CurrencyPln = 'CURRENCY_PLN',
  CurrencyPyg = 'CURRENCY_PYG',
  CurrencyQar = 'CURRENCY_QAR',
  CurrencyRon = 'CURRENCY_RON',
  CurrencyRsd = 'CURRENCY_RSD',
  CurrencyRub = 'CURRENCY_RUB',
  CurrencyRwf = 'CURRENCY_RWF',
  CurrencySar = 'CURRENCY_SAR',
  CurrencySbd = 'CURRENCY_SBD',
  CurrencyScr = 'CURRENCY_SCR',
  CurrencySdg = 'CURRENCY_SDG',
  CurrencySek = 'CURRENCY_SEK',
  CurrencySgd = 'CURRENCY_SGD',
  CurrencyShp = 'CURRENCY_SHP',
  CurrencySle = 'CURRENCY_SLE',
  CurrencySos = 'CURRENCY_SOS',
  CurrencySrd = 'CURRENCY_SRD',
  CurrencySsp = 'CURRENCY_SSP',
  CurrencyStn = 'CURRENCY_STN',
  CurrencySvc = 'CURRENCY_SVC',
  CurrencySyp = 'CURRENCY_SYP',
  CurrencySzl = 'CURRENCY_SZL',
  CurrencyThb = 'CURRENCY_THB',
  CurrencyTjs = 'CURRENCY_TJS',
  CurrencyTmt = 'CURRENCY_TMT',
  CurrencyTnd = 'CURRENCY_TND',
  CurrencyTop = 'CURRENCY_TOP',
  CurrencyTry = 'CURRENCY_TRY',
  CurrencyTtd = 'CURRENCY_TTD',
  CurrencyTwd = 'CURRENCY_TWD',
  CurrencyTzs = 'CURRENCY_TZS',
  CurrencyUah = 'CURRENCY_UAH',
  CurrencyUgx = 'CURRENCY_UGX',
  CurrencyUnspecified = 'CURRENCY_UNSPECIFIED',
  CurrencyUsd = 'CURRENCY_USD',
  CurrencyUsn = 'CURRENCY_USN',
  CurrencyUyi = 'CURRENCY_UYI',
  CurrencyUyu = 'CURRENCY_UYU',
  CurrencyUyw = 'CURRENCY_UYW',
  CurrencyUzs = 'CURRENCY_UZS',
  CurrencyVed = 'CURRENCY_VED',
  CurrencyVes = 'CURRENCY_VES',
  CurrencyVnd = 'CURRENCY_VND',
  CurrencyVuv = 'CURRENCY_VUV',
  CurrencyWst = 'CURRENCY_WST',
  CurrencyXaf = 'CURRENCY_XAF',
  CurrencyXag = 'CURRENCY_XAG',
  CurrencyXau = 'CURRENCY_XAU',
  CurrencyXba = 'CURRENCY_XBA',
  CurrencyXbb = 'CURRENCY_XBB',
  CurrencyXbc = 'CURRENCY_XBC',
  CurrencyXbd = 'CURRENCY_XBD',
  CurrencyXcd = 'CURRENCY_XCD',
  CurrencyXdr = 'CURRENCY_XDR',
  CurrencyXof = 'CURRENCY_XOF',
  CurrencyXpd = 'CURRENCY_XPD',
  CurrencyXpf = 'CURRENCY_XPF',
  CurrencyXpt = 'CURRENCY_XPT',
  CurrencyXsu = 'CURRENCY_XSU',
  CurrencyXts = 'CURRENCY_XTS',
  CurrencyXua = 'CURRENCY_XUA',
  CurrencyXxx = 'CURRENCY_XXX',
  CurrencyYer = 'CURRENCY_YER',
  CurrencyZar = 'CURRENCY_ZAR',
  CurrencyZmw = 'CURRENCY_ZMW',
  CurrencyZwl = 'CURRENCY_ZWL'
}

export type PaymentLineItem = {
  __typename?: 'PaymentLineItem';
  currency: PaymentCurrency;
  description: Scalars['String']['output'];
  price: Scalars['Int']['output'];
  quantity: Scalars['Int']['output'];
};

export type PaymentListPaymentsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  statuses?: InputMaybe<Array<PaymentPaymentStatus>>;
  to?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type PaymentListPaymentsResponse = {
  __typename?: 'PaymentListPaymentsResponse';
  pageInfo: ApiPageInfo;
  payments: Array<PaymentPayment>;
};

export type PaymentListSuccessfulPaymentsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  to?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type PaymentListSuccessfulPaymentsResponse = {
  __typename?: 'PaymentListSuccessfulPaymentsResponse';
  pageInfo: ApiPageInfo;
  payments: Array<PaymentPayment>;
};

export type PaymentPayment = {
  __typename?: 'PaymentPayment';
  amount: PaymentAmount;
  externalReference: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  info: PaymentPaymentInfo;
  items: Array<PaymentLineItem>;
  meta: PaymentSessionMeta;
  provider: PaymentPaymentProvider;
  status: PaymentPaymentStatus;
  tax: PaymentTax;
  timestamp: Scalars['Timestamp']['output'];
  userId: Scalars['ID']['output'];
};

export type PaymentPaymentInfo = {
  __typename?: 'PaymentPaymentInfo';
  cardHolderName: Scalars['String']['output'];
  cardIssuingCountry: Scalars['String']['output'];
  cardSummary: Scalars['String']['output'];
};

export enum PaymentPaymentProvider {
  PaymentProviderAdyen = 'PAYMENT_PROVIDER_ADYEN',
  PaymentProviderAppstore = 'PAYMENT_PROVIDER_APPSTORE',
  PaymentProviderUnspecified = 'PAYMENT_PROVIDER_UNSPECIFIED'
}

export enum PaymentPaymentStatus {
  PaymentStatusExpired = 'PAYMENT_STATUS_EXPIRED',
  PaymentStatusFailed = 'PAYMENT_STATUS_FAILED',
  PaymentStatusPending = 'PAYMENT_STATUS_PENDING',
  PaymentStatusReversed = 'PAYMENT_STATUS_REVERSED',
  PaymentStatusSuccess = 'PAYMENT_STATUS_SUCCESS',
  PaymentStatusUnspecified = 'PAYMENT_STATUS_UNSPECIFIED'
}

export type PaymentSession = {
  __typename?: 'PaymentSession';
  session?: Maybe<PaymentSessionSessionUnion>;
};

export type PaymentSessionMeta = {
  __typename?: 'PaymentSessionMeta';
  attributes: Array<PaymentSessionMetaAttributesEntry>;
  namespace: Scalars['String']['output'];
};

export type PaymentSessionMetaAttributesEntry = {
  __typename?: 'PaymentSessionMetaAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type PaymentSessionSessionUnion = AdyenSession | PaymentAppStoreSession;

export type PaymentTax = {
  __typename?: 'PaymentTax';
  amount?: Maybe<PaymentAmount>;
  rate: Scalars['Int']['output'];
  rateInBasisPoints: Scalars['Int']['output'];
};

export type PlayerStatsPlayerStats = {
  __typename?: 'PlayerStatsPlayerStats';
  adsWatched: Scalars['Int']['output'];
  boosterUsage?: Maybe<PlayerStatsPlayerStatsBoosterUsage>;
  cardBundlesPurchased: Scalars['Int']['output'];
  cardLevelUps: Scalars['Int']['output'];
  cardsPlayed: Scalars['Int']['output'];
  cardsSucceeded: Scalars['Int']['output'];
  currencySpending?: Maybe<PlayerStatsPlayerStatsCurrencySpending>;
  dailyGoalCardsCompleted: Scalars['Int']['output'];
  dailyGoalCardsSet: Scalars['Int']['output'];
  matchesPlayed: Scalars['Int']['output'];
  partyMatchesPlayed: Scalars['Int']['output'];
  shufflesUsed: Scalars['Int']['output'];
  soloMatchesPlayed: Scalars['Int']['output'];
  timePlayed?: Maybe<Scalars['Duration']['output']>;
};

export type PlayerStatsPlayerStatsBoosterUsage = {
  __typename?: 'PlayerStatsPlayerStatsBoosterUsage';
  doubt: Scalars['Int']['output'];
  goodCall: Scalars['Int']['output'];
  letsGo: Scalars['Int']['output'];
  nextUp: Scalars['Int']['output'];
  scavenge: Scalars['Int']['output'];
  speedUp: Scalars['Int']['output'];
  total: Scalars['Int']['output'];
};

export type PlayerStatsPlayerStatsCurrencySpending = {
  __typename?: 'PlayerStatsPlayerStatsCurrencySpending';
  channelCurrency: Scalars['Int']['output'];
  hardCurrency: Scalars['Int']['output'];
  softCurrency: Scalars['Int']['output'];
};

export type PrivacyDeleteUserDataResponse = {
  __typename?: 'PrivacyDeleteUserDataResponse';
  taskId: Scalars['ID']['output'];
};

export type PrivacyExportUserDataResponse = {
  __typename?: 'PrivacyExportUserDataResponse';
  taskId: Scalars['ID']['output'];
};

export type PrivacyUserDataExportCompleteEvent = {
  __typename?: 'PrivacyUserDataExportCompleteEvent';
  dataUrl: Scalars['String']['output'];
  taskId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ProfileBatchGetProfilesResponse = {
  __typename?: 'ProfileBatchGetProfilesResponse';
  profiles: Array<ProfileProfile>;
};

export enum ProfileColor {
  Color_6Ec9F7 = 'COLOR_6EC9F7',
  Color_56F6C0 = 'COLOR_56F6C0',
  Color_63F655 = 'COLOR_63F655',
  Color_8686F9 = 'COLOR_8686F9',
  ColorB26Afb = 'COLOR_B26AFB',
  ColorC0F656 = 'COLOR_C0F656',
  ColorF6Ce56 = 'COLOR_F6CE56',
  ColorF6F656 = 'COLOR_F6F656',
  ColorF76Ef7 = 'COLOR_F76EF7',
  ColorF69856 = 'COLOR_F69856',
  ColorUnspecified = 'COLOR_UNSPECIFIED'
}

export type ProfileGetUsernameHistoryResponse = {
  __typename?: 'ProfileGetUsernameHistoryResponse';
  changes: Array<ProfileUsernameChange>;
};

export type ProfileListPlayedGamesResponse = {
  __typename?: 'ProfileListPlayedGamesResponse';
  games: Array<ProfilePlayedGame>;
  pageInfo: ApiPageInfo;
};

export type ProfileListProfilesResponse = {
  __typename?: 'ProfileListProfilesResponse';
  pageInfo: ApiPageInfo;
  profiles: Array<ProfileProfile>;
};

export type ProfilePlayedGame = {
  __typename?: 'ProfilePlayedGame';
  game: GameGame;
  id: Scalars['ID']['output'];
  lastPlayedAt: Scalars['Timestamp']['output'];
  progression: GameUserProgression;
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export enum ProfilePresenceStatus {
  PresenceStatusOffline = 'PRESENCE_STATUS_OFFLINE',
  PresenceStatusOnline = 'PRESENCE_STATUS_ONLINE',
  PresenceStatusUnspecified = 'PRESENCE_STATUS_UNSPECIFIED'
}

export type ProfilePrivacySettings = {
  __typename?: 'ProfilePrivacySettings';
  anonymisePurchaseHighlights: Scalars['Boolean']['output'];
  discordUsernameVisibility: ProfilePrivacySettingsVisibility;
  hideOnlineStatus: Scalars['Boolean']['output'];
  showMatureContentWarning: Scalars['Boolean']['output'];
  visibility: ProfilePrivacySettingsVisibility;
};

export type ProfilePrivacySettingsInput = {
  anonymisePurchaseHighlights?: InputMaybe<Scalars['Boolean']['input']>;
  discordUsernameVisibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
  hideOnlineStatus?: InputMaybe<Scalars['Boolean']['input']>;
  showMatureContentWarning?: InputMaybe<Scalars['Boolean']['input']>;
  visibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
};

export enum ProfilePrivacySettingsVisibility {
  VisibilityAll = 'VISIBILITY_ALL',
  VisibilityFriends = 'VISIBILITY_FRIENDS',
  VisibilityOnlyMe = 'VISIBILITY_ONLY_ME',
  VisibilityUnspecified = 'VISIBILITY_UNSPECIFIED'
}

/** Profile message contains user profile information */
export type ProfileProfile = {
  __typename?: 'ProfileProfile';
  account?: Maybe<AuthAccount>;
  avatarConfig?: Maybe<ProfileProfileAvatarConfig>;
  /**
   * contains a concatenated list of different avatar urls (use avatars object instead)
   * @deprecated field is deprecated
   */
  avatarUrl: Scalars['String']['output'];
  avatars?: Maybe<ProfileProfileAvatars>;
  badges: Array<BadgeBadge>;
  bio: Scalars['String']['output'];
  canChangeUsernameAt?: Maybe<Scalars['Timestamp']['output']>;
  channel?: Maybe<ChannelChannel>;
  discordUsername?: Maybe<Scalars['String']['output']>;
  /** @deprecated field is deprecated */
  displayName: Scalars['String']['output'];
  friends: Array<ProfileProfile>;
  friendshipStatus: FriendsFriendshipStatus;
  isNewUsername: Scalars['Boolean']['output'];
  lastSeen?: Maybe<Scalars['Timestamp']['output']>;
  onlineStatus: ProfilePresenceStatus;
  playedGames: Array<ProfilePlayedGame>;
  preferredColor: ProfileColor;
  settings?: Maybe<ProfileProfileSettings>;
  state: ApiEntityState;
  stats: PlayerStatsPlayerStats;
  temporary: Scalars['Boolean']['output'];
  userId: Scalars['ID']['output'];
  userTag: Scalars['String']['output'];
  usernameHistory?: Maybe<Array<ProfileUsernameChange>>;
  visibility: ProfileProfileVisibility;
};


/** Profile message contains user profile information */
export type ProfileProfileBadgesArgs = {
  channel_id?: InputMaybe<Scalars['ID']['input']>;
};


/** Profile message contains user profile information */
export type ProfileProfileStatsArgs = {
  season_id?: InputMaybe<Scalars['String']['input']>;
};


/** Profile message contains user profile information */
export type ProfileProfileUsernameHistoryArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type ProfileProfileAvatarConfig = {
  __typename?: 'ProfileProfileAvatarConfig';
  model: AvatarAvatar;
  modelId: Scalars['ID']['output'];
};

export type ProfileProfileAvatars = {
  __typename?: 'ProfileProfileAvatars';
  avatar2D: Scalars['String']['output'];
  avatar3D: Scalars['String']['output'];
  avatarFullbody: Scalars['String']['output'];
  avatarGender: Scalars['String']['output'];
};

export type ProfileProfileSettings = {
  __typename?: 'ProfileProfileSettings';
  friends: FriendsFriendsSettings;
  privacy: ProfilePrivacySettings;
};

export type ProfileProfileUpdateInput = {
  bio?: InputMaybe<Scalars['String']['input']>;
  discordUsername?: InputMaybe<Scalars['String']['input']>;
  /** @deprecated field is deprecated */
  displayName?: InputMaybe<Scalars['String']['input']>;
  preferredColor?: InputMaybe<ProfileColor>;
  userId?: InputMaybe<Scalars['ID']['input']>;
  userTag?: InputMaybe<Scalars['String']['input']>;
};

export enum ProfileProfileVisibility {
  ProfileVisibilityPrivate = 'PROFILE_VISIBILITY_PRIVATE',
  ProfileVisibilityPublic = 'PROFILE_VISIBILITY_PUBLIC',
  ProfileVisibilityUnspecified = 'PROFILE_VISIBILITY_UNSPECIFIED'
}

export type ProfileResolveUserTagsResponse = {
  __typename?: 'ProfileResolveUserTagsResponse';
  profiles: Array<ProfileProfile>;
  userIds: Array<ProfileResolveUserTagsResponseUserIdsEntry>;
};

export type ProfileResolveUserTagsResponseUserIdsEntry = {
  __typename?: 'ProfileResolveUserTagsResponseUserIdsEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type ProfileUpdateProfileRequestOptionsInput = {
  omitNameValidation?: InputMaybe<Scalars['Boolean']['input']>;
  omitRankValidation?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProfileUsernameChange = {
  __typename?: 'ProfileUsernameChange';
  changedAt: Scalars['Timestamp']['output'];
  changedBy: Scalars['String']['output'];
  changer?: Maybe<ProfileProfile>;
  newUsername: Scalars['String']['output'];
  oldUsername: Scalars['String']['output'];
  reason: ModerationViolation;
};

export type ProgressionBatchGetSeasonProgressionRequestQueryInput = {
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ProgressionBatchGetSeasonProgressionResponse = {
  __typename?: 'ProgressionBatchGetSeasonProgressionResponse';
  progression: Array<ProgressionSeasonProgression>;
};

export type ProgressionChannel = {
  __typename?: 'ProgressionChannel';
  channelId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ProgressionExperiencePoints = {
  __typename?: 'ProgressionExperiencePoints';
  amount: Scalars['Int']['output'];
  target?: Maybe<ProgressionExperiencePointsTargetUnion>;
};

export type ProgressionExperiencePointsTargetUnion = ProgressionChannel | ProgressionFan | ProgressionSeason;

export type ProgressionFan = {
  __typename?: 'ProgressionFan';
  userId: Scalars['ID']['output'];
};

export type ProgressionGetDailyParticipationLimitResponse = {
  __typename?: 'ProgressionGetDailyParticipationLimitResponse';
  remainingDailyParticipationMinutes: Scalars['Int']['output'];
};

export type ProgressionGetDailyXpBoostLimitResponse = {
  __typename?: 'ProgressionGetDailyXPBoostLimitResponse';
  remainingDailyXpBoost: Scalars['Int']['output'];
};

export type ProgressionGetDailyXpEarningsLimitResponse = {
  __typename?: 'ProgressionGetDailyXPEarningsLimitResponse';
  remainingDailyXpEarningsMinutes: Scalars['Int']['output'];
};

export type ProgressionLevel = {
  __typename?: 'ProgressionLevel';
  number: Scalars['Int']['output'];
  target?: Maybe<ProgressionLevelTargetUnion>;
};

export type ProgressionLevelConfig = {
  __typename?: 'ProgressionLevelConfig';
  /**
   * channel_id is an optional configuration for channel loyalty related level
   *  configs
   */
  channelId: Scalars['ID']['output'];
  number: Scalars['Int']['output'];
  rewards: Array<RewardRewardType>;
  /** season_id is an optional configuration for season related level configs */
  seasonId: Scalars['ID']['output'];
  threshold: Scalars['Int']['output'];
};

export type ProgressionLevelTargetUnion = ProgressionChannel | ProgressionFan | ProgressionSeason;

export type ProgressionListLevelConfigsResponse = {
  __typename?: 'ProgressionListLevelConfigsResponse';
  levelConfigs: Array<ProgressionLevelConfig>;
};

export type ProgressionListSeasonProgressionResponse = {
  __typename?: 'ProgressionListSeasonProgressionResponse';
  progression: Array<ProgressionSeasonProgression>;
};

export type ProgressionProgressionUpdateEvent = {
  __typename?: 'ProgressionProgressionUpdateEvent';
  reason: ReasonReason;
  updates: Array<ProgressionProgressionUpdateEventUpdate>;
};

export type ProgressionProgressionUpdateEventUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdate';
  update?: Maybe<ProgressionProgressionUpdateEventUpdateUpdateUnion>;
};

export type ProgressionProgressionUpdateEventUpdateExperiencePointUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdateExperiencePointUpdate';
  newPoints: ProgressionExperiencePoints;
  oldPoints: ProgressionExperiencePoints;
};

export type ProgressionProgressionUpdateEventUpdateLevelUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdateLevelUpdate';
  newLevel: ProgressionLevel;
  oldLevel: ProgressionLevel;
};

export type ProgressionProgressionUpdateEventUpdateUpdateUnion = ProgressionProgressionUpdateEventUpdateExperiencePointUpdate | ProgressionProgressionUpdateEventUpdateLevelUpdate;

export type ProgressionSeason = {
  __typename?: 'ProgressionSeason';
  seasonId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ProgressionSeasonProgression = {
  __typename?: 'ProgressionSeasonProgression';
  level: Scalars['Int']['output'];
  nextLevel: Scalars['Int']['output'];
  nextLevelThreshold: Scalars['Int']['output'];
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
  xpAmount: Scalars['Int']['output'];
};

export type Query = {
  __typename?: 'Query';
  /** AuthServiceV4.GetAccount */
  account?: Maybe<AuthAccount>;
  /** AgreementService.ListAgreements */
  agreements?: Maybe<AgreementListAgreementResponse>;
  /** AnnouncementService.ListAnnouncements */
  announcements?: Maybe<AnnouncementListAnnouncementsResponse>;
  /** ArenaService.GetArena */
  arena?: Maybe<ArenaArena>;
  /** ArenaService.ListArenas */
  arenas?: Maybe<ArenaListArenasResponse>;
  /** AvatarService.GetAvatar */
  avatar?: Maybe<AvatarAvatar>;
  /** AvatarAnimationService.GetAnimation */
  avatarAnimation?: Maybe<AvatarAnimation>;
  /** AvatarAnimationService.BatchGetAnimations */
  avatarAnimationBatch?: Maybe<AvatarBatchGetAnimationsResponse>;
  /** AvatarAnimationService.ListAnimations */
  avatarAnimations?: Maybe<AvatarListAnimationsResponse>;
  /** StoreServiceV2.GetAvatarEditorStoreFront */
  avatarEditorStoreFront?: Maybe<StoreV2StoreFront>;
  /** AvatarService.GetAvatarPart */
  avatarPart?: Maybe<AvatarAvatarPart>;
  /** AvatarService.ListAvatarParts */
  avatarParts?: Maybe<AvatarListAvatarPartsResponse>;
  /** AvatarService.BatchGetAvatarParts */
  avatarPartsBatch?: Maybe<AvatarBatchGetAvatarPartsResponse>;
  /** AvatarService.ListAvatars */
  avatars?: Maybe<AvatarListAvatarsResponse>;
  /** AvatarService.BatchGetAvatars */
  avatarsBatch?: Maybe<AvatarBatchGetAvatarsResponse>;
  /** ProgressionService.BatchGetSeasonProgression */
  batchGetSeasonProgression?: Maybe<ProgressionBatchGetSeasonProgressionResponse>;
  /** BadgeService.BatchGetUserBadges */
  batchGetUserBadges?: Maybe<BadgeBatchGetUserBadgesResponse>;
  /** FriendsService.ListBlockedUsers */
  blockedUsers?: Maybe<FriendsListBlockedUsersResponse>;
  /** BoosterService.GetBooster */
  booster?: Maybe<GameLogicBooster>;
  /** BoosterService.ListBoosters */
  boosters?: Maybe<GameCardListBoostersResponse>;
  /** ChallengeService.GetChallenge */
  challenge?: Maybe<GameLogicChallenge>;
  /** ChallengeService.GetChallengeRewards */
  challengeRewards?: Maybe<ChallengeGetChallengeRewardsResponse>;
  /** ChallengeService.BatchGetChallenges */
  challengesBatch?: Maybe<ChallengeListChallengesResponse>;
  /** ChannelService.GetChannel */
  channel?: Maybe<ChannelChannel>;
  /** FriendsService.GetChannelActiveFriends */
  channelActiveFriends?: Maybe<FriendsGetChannelActiveFriendsResponse>;
  /** StreamerService.ListChannelActivityEvents */
  channelActivityEvents?: Maybe<StreamerListChannelActivityEventsResponse>;
  /** ChannelModerationService.ListBanAppeals */
  channelBanAppeals?: Maybe<ChannelListBanAppealsResponse>;
  /** ChannelModerationService.GetUserBanStatus */
  channelBanUserStatus?: Maybe<ChannelUserBanStatus>;
  /** ChannelModerationService.BatchGetUserBanStatus */
  channelBanUserStatuses?: Maybe<ChannelBatchGetUserBanStatusResponse>;
  /** ChannelModerationService.ListBannedUsers */
  channelBannedUsers?: Maybe<ChannelListBannedUsersResponse>;
  /** ChannelService.GetChannelByName */
  channelByName?: Maybe<ChannelChannel>;
  /** ChannelEmojiService.ListChannelEmojis */
  channelEmojis?: Maybe<EmojiListChannelEmojisResponse>;
  /** FeatureFlagService.GetChannelFeatureFlag */
  channelFeatureFlag?: Maybe<FlagFeatureFlagState>;
  /** FeatureFlagService.ListChannelFeatureFlags */
  channelFeatureFlags?: Maybe<FlagListChannelFeatureFlagsResponse>;
  /** ChannelNotificationService.GetFollowerNotificationSettings */
  channelFollowerNotificationSettings?: Maybe<ChannelFollowerNotificationSettings>;
  /** ChannelService.GetChannelFollowerStatus */
  channelFollowerStatus?: Maybe<ChannelGetChannelFollowerStatusResponse>;
  /** ChannelService.ListGameStats */
  channelGameStats?: Maybe<ChannelListGameStatsResponse>;
  /** ChannelService.BatchGetGameStats */
  channelGameStatsBatch?: Maybe<ChannelBatchGetGameStatsResponse>;
  /** ChannelModerationService.GetModerationSettings */
  channelModerationSettings?: Maybe<ChannelModerationSettings>;
  /** ChannelNotificationService.GetNotificationSettings */
  channelNotificationSettings?: Maybe<ChannelNotificationSettings>;
  /** ChannelService.ListChannelPrivilegedUsers */
  channelPrivilegedUsers?: Maybe<ChannelListChannelPrivilegedUsersResponse>;
  /** StoreServiceV2.GetChannelStoreFront */
  channelStoreFront?: Maybe<StoreV2StoreFront>;
  /** ChannelSubscriptionService.GetChannelSubscriptionConfig */
  channelSubscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  /** ChannelSubscriptionService.ListChannelSubscriptionTiers */
  channelSubscriptionTiers?: Maybe<SubscriptionListChannelSubscriptionTiersResponse>;
  /** ChannelSubscriptionService.ListChannelSubscriptions */
  channelSubscriptions?: Maybe<SubscriptionListChannelSubscriptionsResponse>;
  /** ChannelService.ListChannels */
  channels?: Maybe<ChannelListChannelsResponse>;
  /** ChatService.ListMessages */
  chatMessages?: Maybe<ChatListMessagesResponse>;
  /** ChatModerationService.GetChatUserStatus */
  chatUserStatus?: Maybe<ChatGetChatUserStatusResponse>;
  /** ChatService.ListChatUsers */
  chatUsers?: Maybe<ChatListChatUsersResponse>;
  /** ArenaService.GetClientSideArena */
  clientSideArena?: Maybe<ArenaClientSideArena>;
  /** ArenaService.ListClientSideArenas */
  clientSideArenas?: Maybe<ArenaListClientSideArenasResponse>;
  /** ProgressionService.GetDailyParticipationLimit */
  dailyParticipationLimit?: Maybe<ProgressionGetDailyParticipationLimitResponse>;
  /** ProgressionService.GetDailyXPBoostLimit */
  dailyXPBoostLimit?: Maybe<ProgressionGetDailyXpBoostLimitResponse>;
  /** ProgressionService.GetDailyXPEarningsLimit */
  dailyXPEarningsLimit?: Maybe<ProgressionGetDailyXpEarningsLimitResponse>;
  /** FTUEService.ListDismissedTooltips */
  dismissedTooltips?: Maybe<FtueListDismissedTooltipsResponse>;
  /** EmojiService.GetEmoji */
  emoji?: Maybe<EmojiEmoji>;
  /** EmojiService.BatchGetEmojis */
  emojisBatch?: Maybe<EmojiBatchGetEmojisResponse>;
  /** FeatureFlagService.GetFeatureFlagConfig */
  featureFlagConfig?: Maybe<FlagFeatureFlagConfig>;
  /** FeatureFlagService.GetFeatureFlagSchema */
  featureFlagSchema?: Maybe<FlagFeatureFlagSchema>;
  /** ChannelService.GetFollowStatus */
  followStatuses?: Maybe<ChannelGetFollowStatusResponse>;
  /** ChannelService.GetUserFollowedChannels */
  followedChannels?: Maybe<ChannelGetUserFollowedChannelsResponse>;
  /** FriendsService.ListFriends */
  friends?: Maybe<FriendsListFriendsResponse>;
  /** FriendsService.GetFriendshipStatus */
  friendshipStatuses?: Maybe<FriendsGetFriendshipStatusResponse>;
  /** GameService.GetGame */
  game?: Maybe<GameGame>;
  /** GameCardService.BatchGetGameCards */
  gameCards?: Maybe<GameCardBatchGetGameCardsResponse>;
  /** GameService.BatchGetGames */
  games?: Maybe<GameBatchGetGamesResponse>;
  /** ChallengeSessionService.GetChallengeSession */
  getChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelService.BatchGetChannels */
  getChannels?: Maybe<ChannelBatchGetChannelsResponse>;
  /** ChannelService.BatchStreamGetChannel */
  getStreamChannels?: Maybe<ChannelBatchStreamGetChannelResponse>;
  /** StoreServiceV2.ListGiftSellableItems */
  giftSellableItems?: Maybe<StoreV2ListGiftSellableItemsResponse>;
  /** GoalCardService.GetGoalCard */
  goalCard?: Maybe<GoalCardGoalCard>;
  /** GoalCardService.GetSlotOptions */
  goalCardSlotOptions?: Maybe<GoalCardGetSlotOptionsResponse>;
  /** GoalCardService.ListGoalCardSlots */
  goalCardSlots?: Maybe<GoalCardListGoalCardSlotsResponse>;
  /** GoalCardService.BatchGetGoalCards */
  goalCards?: Maybe<GoalCardBatchGetGoalCardsResponse>;
  /** ChannelService.ListHighlightedChannels */
  highlightedChannels?: Maybe<ChannelListHighlightedChannelsResponse>;
  /** StreamIngestConfigService.GetIngestConfig */
  ingestConfig?: Maybe<StreamIngestConfigChannelIngestConfig>;
  /** StreamIngestConfigService.ListIngestConfigs */
  ingestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** UserInventoryService.ListUserInventory */
  inventory?: Maybe<InventoryListUserInventoryResponse>;
  /** InvitationService.ListInvitationCodes */
  invitationCodes?: Maybe<InvitationListInvitationCodesResponse>;
  /** ItemService.GetItem */
  item?: Maybe<ItemGetItemResponse>;
  /** ItemService.ExpandItem */
  itemExpand?: Maybe<ItemExpandItemResponse>;
  /** ItemService.ListItems */
  items?: Maybe<ItemListItemsResponse>;
  /** ItemService.BatchGetItems */
  itemsBatch?: Maybe<ItemBatchGetItemsResponse>;
  /** ItemService.BatchExpandItems */
  itemsBatchExpand?: Maybe<ItemBatchExpandItemsResponse>;
  /** ChallengeService.ListChallenges */
  listChallenges?: Maybe<ChallengeListChallengesResponse>;
  /** GameCardService.ListGameCards */
  listGameCards?: Maybe<GameCardListGameCardsResponse>;
  /** GameService.ListGames */
  listGames?: Maybe<GameListGamesResponse>;
  /** ProgressionService.ListLevelConfigs */
  listLevelConfigs?: Maybe<ProgressionListLevelConfigsResponse>;
  /** ProgressionService.ListSeasonProgression */
  listSeasonProgression?: Maybe<ProgressionListSeasonProgressionResponse>;
  /** GameService.ListSeasons */
  listSeasons?: Maybe<GameListSeasonsResponse>;
  /** MatchServiceV2.GetGroupChatID */
  matchGroupChatID?: Maybe<MatchGetGroupChatIdResponse>;
  /** MatchAdminService.GetGroupState */
  matchGroupState?: Maybe<MatchGetGroupStateResponse>;
  /** MatchServiceV2.GetMatchState */
  matchState?: Maybe<MatchGetMatchStateResponse>;
  /** MatchAdminService.GetStreamState */
  matchStreamState?: Maybe<MatchGetStreamStateResponse>;
  /** MediaService.BatchGetMediaUrl */
  mediaUrlsBatch?: Maybe<MediaBatchGetMediaUrlResponse>;
  /** MLControllerService.GetHUDScale */
  mlHUDScale?: Maybe<MlControllerGetHudScaleResponse>;
  /** ChannelModerationService.ListModerationEvents */
  moderationEvents?: Maybe<ChannelListModerationEventsResponse>;
  /** NotificationService.ListNotifications */
  notifications?: Maybe<NotificationListNotificationsResponse>;
  /** AuthServiceV4.GetOAuth2Consent */
  oauth2Consent?: Maybe<AuthV4GetOAuth2ConsentResponse>;
  /** PartyService.GetParty */
  party?: Maybe<PartyParty>;
  /** PaymentService.GetPayment */
  payment?: Maybe<PaymentPayment>;
  /** PaymentService.ListPayments */
  payments?: Maybe<PaymentListPaymentsResponse>;
  /** PlacementsService.GetPlacement */
  placement?: Maybe<AdsGetPlacementResponse>;
  /** PlatformModerationService.GetUserPlatformBan */
  platformBan?: Maybe<ModerationPlatformBan>;
  /** PlatformModerationService.ListPlatformBanAppeals */
  platformBanAppeals?: Maybe<ModerationListPlatformBanAppealsResponse>;
  /** PlatformEmojiService.ListPlatformEmojis */
  platformEmojis?: Maybe<EmojiListPlatformEmojisResponse>;
  /** StoreServiceV2.GetPlatformStoreFront */
  platformStoreFront?: Maybe<StoreV2StoreFront>;
  /** ProfileService.ListPlayedGames */
  playedGames?: Maybe<ProfileListPlayedGamesResponse>;
  /** ProfileService.GetProfile - Returns user profiles based on a given userID */
  profile?: Maybe<ProfileProfile>;
  /** ProfileService.BatchGetProfiles */
  profileBatch?: Maybe<ProfileBatchGetProfilesResponse>;
  /** ProfileService.ListProfiles */
  profiles?: Maybe<ProfileListProfilesResponse>;
  /** SearchService.PublicSearch */
  publicSearch?: Maybe<SearchSearchResponse>;
  /** PushNotificationService.GetNotificationToken */
  pushNotificationToken?: Maybe<NotificationPushNotificationToken>;
  /** FriendsService.ListReceivedFriendRequests */
  receivedFriendRequests?: Maybe<FriendsListReceivedFriendRequestsResponse>;
  /** SupportService.GetReportCase */
  reportCase?: Maybe<SupportReportCase>;
  /** SupportService.ListReports */
  reports?: Maybe<SupportListReportsResponse>;
  /** ProfileService.ResolveUserTags */
  resolveUserTags?: Maybe<ProfileResolveUserTagsResponse>;
  /** ChannelConfigService.GetRestreamingConfig */
  restreamingConfig?: Maybe<ChannelRestreamingConfig>;
  /** RewardService.ListRewards */
  rewards?: Maybe<RewardListRewardsResponse>;
  /** SearchService.Search */
  search?: Maybe<SearchSearchResponse>;
  /** GameService.GetSeason */
  season?: Maybe<GameSeason>;
  /** ProgressionService.GetSeasonProgression */
  seasonProgression?: Maybe<ProgressionSeasonProgression>;
  /** GameService.BatchGetSeasons */
  seasons?: Maybe<GameBatchGetSeasonsResponse>;
  /** ChannelConfigService.GetSelectedStreamBackendConfig */
  selectedStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StoreServiceV2.GetSellableItem */
  sellableItem?: Maybe<StoreV2SellableItem>;
  /** StoreServiceV2.ListSellableItems */
  sellableItems?: Maybe<StoreV2ListSellableItemsResponse>;
  /** FriendsService.ListSentFriendRequests */
  sentFriendRequests?: Maybe<FriendsListSentFriendRequestsResponse>;
  /** ChannelService.GetStream */
  stream?: Maybe<ChannelStream>;
  /** StreamerService.GetStreamAudienceInsights */
  streamAudienceInsights?: Maybe<StreamerStreamAudienceInsights>;
  /** ChannelConfigService.GetStreamBackendConfig */
  streamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** ChannelConfigService.ListStreamBackendConfigs */
  streamBackendConfigs?: Maybe<ChannelListStreamBackendConfigsResponse>;
  /** ChannelService.GetStreamSummary */
  streamSummary?: Maybe<ChannelStreamSummary>;
  /** ChannelService.BatchGetStreamSummary */
  streamSummaryBatch?: Maybe<ChannelBatchGetStreamSummaryResponse>;
  /** MatchServiceV2.GetTopActiveCards */
  streamTopActiveCards?: Maybe<MatchGetTopActiveCardsResponse>;
  /** StreamerCardService.GetStreamerCard */
  streamerCard?: Maybe<GameLogicStreamerCard>;
  /** StreamerCardService.ListStreamerCardDrafts */
  streamerCardDrafts?: Maybe<GameCardListStreamerCardDraftsResponse>;
  /** StoreServiceV2.ListStreamerCardSaleConfigs */
  streamerCardSaleConfigs?: Maybe<StoreV2ListStreamerCardSaleConfigsResponse>;
  /** StreamerCardService.ListStreamerCards */
  streamerCards?: Maybe<GameCardListStreamerCardsResponse>;
  /** StreamerCardService.BatchGetStreamerCards */
  streamerCardsBatch?: Maybe<GameCardBatchGetStreamerCardsResponse>;
  /** ChannelService.ListStreams */
  streams?: Maybe<ChannelListStreamsResponse>;
  /** PaymentService.ListSuccessfulPayments */
  successfulPayments?: Maybe<PaymentListSuccessfulPaymentsResponse>;
  /** SupportService.GetArticle */
  supportArticle?: Maybe<SupportArticle>;
  /** StoreServiceV2.ListTopUpSellableItems */
  topUpSellableItems?: Maybe<StoreV2ListTopUpSellableItemsResponse>;
  /** AnnouncementService.ListUserAnnouncements */
  userAnnouncements?: Maybe<AnnouncementListUserAnnouncementsResponse>;
  /** BadgeService.GetUserBadges */
  userBadges?: Maybe<BadgeGetUserBadgesResponse>;
  /** ChannelService.GetUserChannel */
  userChannel?: Maybe<ChannelChannel>;
  /** ChannelModerationService.ListUserChannelBans */
  userChannelBans?: Maybe<ChannelListUserChannelBansResponse>;
  /** ChannelService.ListUserChannelRoles */
  userChannelRoles?: Maybe<ChannelListUserChannelRolesResponse>;
  /** ChannelSubscriptionService.GetUserChannelSubscription */
  userChannelSubscription?: Maybe<SubscriptionChannelSubscription>;
  /** ChannelSubscriptionService.ListUserChannelSubscriptions */
  userChannelSubscriptions?: Maybe<SubscriptionListUserChannelSubscriptionsResponse>;
  /** FeatureFlagService.GetUserFeatureFlag */
  userFeatureFlag?: Maybe<FlagFeatureFlagState>;
  /** FeatureFlagService.ListUserFeatureFlags */
  userFeatureFlags?: Maybe<FlagListUserFeatureFlagsResponse>;
  /** PartyService.GetUserParty */
  userParty?: Maybe<PartyParty>;
  /** ChannelService.ListUserPrivilegedChannels */
  userPrivilegedChannels?: Maybe<ChannelListUserPrivilegedChannelsResponse>;
  /** ProfileService.GetUsernameHistory */
  usernameHistory?: Maybe<ProfileGetUsernameHistoryResponse>;
  /** WalletService.GetWallet */
  wallet?: Maybe<WalletGetWalletResponse>;
  /** WalletService.ListWalletTransactions */
  walletTransactions?: Maybe<WalletListWalletTransactionsResponse>;
};


export type QueryAccountArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAgreementsArgs = {
  includeOldRevisions?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAnnouncementsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<AnnouncementAnnouncementFilterInput>;
};


export type QueryArenaArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryArenasArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryAvatarArgs = {
  avatarId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAvatarAnimationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAvatarAnimationBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryAvatarPartArgs = {
  avatarPartId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAvatarPartsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryAvatarsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  listAll?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAvatarsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryBatchGetSeasonProgressionArgs = {
  queries?: InputMaybe<Array<ProgressionBatchGetSeasonProgressionRequestQueryInput>>;
};


export type QueryBatchGetUserBadgesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type QueryBlockedUsersArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryBoosterArgs = {
  id?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChallengeRewardsArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChallengesBatchArgs = {
  challengeIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryChannelArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelActiveFriendsArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelActivityEventsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<StreamerChannelActivityEventFilterInput>;
};


export type QueryChannelBanAppealsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelBanUserStatusArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelBanUserStatusesArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelBannedUsersArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelByNameArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
};


export type QueryChannelEmojisArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  includeCount?: InputMaybe<Scalars['Boolean']['input']>;
  includeDisabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryChannelFeatureFlagArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  flagName?: InputMaybe<Scalars['String']['input']>;
};


export type QueryChannelFeatureFlagsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelFollowerNotificationSettingsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelFollowerStatusArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelGameStatsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<ChannelListGameStatsRequestFilterInput>>;
};


export type QueryChannelGameStatsBatchArgs = {
  gameIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryChannelModerationSettingsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelNotificationSettingsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelPrivilegedUsersArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelStoreFrontArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelSubscriptionConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelSubscriptionTiersArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelSubscriptionsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<SubscriptionListChannelSubscriptionsRequestFilterInput>>;
};


export type QueryChannelsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  liveStatus?: InputMaybe<ChannelLiveStatus>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type QueryChatMessagesArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChatUserStatusArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChatUsersArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<Scalars['String']['input']>;
  userLabel?: InputMaybe<ChatUserLabel>;
};


export type QueryClientSideArenaArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryClientSideArenasArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryDismissedTooltipsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryEmojiArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryEmojisBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryFeatureFlagConfigArgs = {
  revision?: InputMaybe<Scalars['String']['input']>;
};


export type QueryFollowStatusesArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryFollowedChannelsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  liveStatus?: InputMaybe<ChannelLiveStatus>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryFriendsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<FriendsListFriendsRequestFilterInput>>;
  priorityOrder?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryFriendshipStatusesArgs = {
  friendIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGameArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGameCardsArgs = {
  cardIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGamesArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGetChallengeSessionArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGetChannelsArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGetStreamChannelsArgs = {
  streamIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGiftSellableItemsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};


export type QueryGoalCardArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGoalCardSlotOptionsArgs = {
  slotId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGoalCardsArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryHighlightedChannelsArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIngestConfigArgs = {
  ftlId?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryInventoryArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<InventoryListUserInventoryRequestFilterInput>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryInvitationCodesArgs = {
  includeUsed?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryItemArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryItemExpandArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryItemsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<ItemListItemsRequestFilterInput>>;
};


export type QueryItemsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryItemsBatchExpandArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryListChallengesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListGameCardsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListGamesArgs = {
  gameName?: InputMaybe<Scalars['String']['input']>;
};


export type QueryListLevelConfigsArgs = {
  maxLevel?: InputMaybe<Scalars['Int']['input']>;
  minLevel?: InputMaybe<Scalars['Int']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListSeasonProgressionArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListSeasonsArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchGroupChatIdArgs = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchGroupStateArgs = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchStateArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchStreamStateArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMediaUrlsBatchArgs = {
  options?: InputMaybe<MediaMediaOptionsInput>;
  urls?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryMlHudScaleArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryModerationEventsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<ChannelModerationEventsFilterInput>;
};


export type QueryNotificationsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};


export type QueryOauth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']['input']>;
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPartyArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPaymentArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPaymentsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<PaymentListPaymentsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlacementArgs = {
  placementId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlatformBanArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlatformBanAppealsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  status?: InputMaybe<ModerationAppealStatus>;
};


export type QueryPlatformEmojisArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  includeCount?: InputMaybe<Scalars['Boolean']['input']>;
  includeDisabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryPlatformStoreFrontArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlayedGamesArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryProfileArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryProfileBatchArgs = {
  userIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryProfilesArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryPublicSearchArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  entityTypes?: InputMaybe<Array<SearchEntityType>>;
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QueryPushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']['input']>;
};


export type QueryReceivedFriendRequestsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryReportCaseArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryReportsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<SupportReportsFilterInput>;
};


export type QueryResolveUserTagsArgs = {
  userTags?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryRestreamingConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRewardsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySearchArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  entityTypes?: InputMaybe<Array<SearchEntityType>>;
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySeasonArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySeasonProgressionArgs = {
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySeasonsArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QuerySelectedStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySellableItemArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySellableItemsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<StoreV2ListSellableItemsRequestFilterInput>;
};


export type QuerySentFriendRequestsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamAudienceInsightsArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamBackendConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamSummaryArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamSummaryBatchArgs = {
  streamIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryStreamTopActiveCardsArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamerCardArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamerCardDraftsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<GameCardListStreamerCardDraftsRequestFilterInput>>;
};


export type QueryStreamerCardSaleConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryStreamerCardsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<GameCardListStreamerCardsRequestFilterInput>>;
};


export type QueryStreamerCardsBatchArgs = {
  streamerCardIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryStreamsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QuerySuccessfulPaymentsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<PaymentListSuccessfulPaymentsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySupportArticleArgs = {
  attachmentBaseUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTopUpSellableItemsArgs = {
  currencyId?: InputMaybe<Scalars['ID']['input']>;
  minAmount?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryUserAnnouncementsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  target?: InputMaybe<AnnouncementAnnouncementTarget>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserBadgesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelBansArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelRolesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelSubscriptionsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<SubscriptionListUserChannelSubscriptionsRequestFilterInput>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserFeatureFlagArgs = {
  flagName?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserFeatureFlagsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserPartyArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserPrivilegedChannelsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUsernameHistoryArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryWalletArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryWalletTransactionsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<WalletListWalletTransactionsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export enum RarityRarity {
  RarityCommon = 'RARITY_COMMON',
  RarityEpic = 'RARITY_EPIC',
  RarityLegendary = 'RARITY_LEGENDARY',
  RarityRare = 'RARITY_RARE',
  RarityUncommon = 'RARITY_UNCOMMON',
  RarityUnspecified = 'RARITY_UNSPECIFIED'
}

export type ReactionReactionEvent = {
  __typename?: 'ReactionReactionEvent';
  event?: Maybe<ReactionReactionEventEventUnion>;
  parentId: Scalars['ID']['output'];
  parentType: Scalars['String']['output'];
};

export type ReactionReactionEventAdd = {
  __typename?: 'ReactionReactionEventAdd';
  reactionType: ReactionReactionType;
  resourceId: Scalars['ID']['output'];
  resourceType: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
};

export type ReactionReactionEventEventUnion = ReactionReactionEventAdd | ReactionReactionEventInitial | ReactionReactionEventRemove;

export type ReactionReactionEventInitial = {
  __typename?: 'ReactionReactionEventInitial';
  states: Array<ReactionReactionState>;
};

export type ReactionReactionEventRemove = {
  __typename?: 'ReactionReactionEventRemove';
  reactionType: ReactionReactionType;
  resourceId: Scalars['ID']['output'];
  resourceType: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
};

export type ReactionReactionState = {
  __typename?: 'ReactionReactionState';
  /** reactions is a map of reaction type (enum string) to count */
  reactions: Array<ReactionReactionStateReactionsEntry>;
  resourceId: Scalars['ID']['output'];
  resourceType: Scalars['String']['output'];
  userHasReacted: Scalars['Boolean']['output'];
};

export type ReactionReactionStateReactionsEntry = {
  __typename?: 'ReactionReactionStateReactionsEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export enum ReactionReactionType {
  ReactionTypeLike = 'REACTION_TYPE_LIKE',
  ReactionTypeUnspecified = 'REACTION_TYPE_UNSPECIFIED'
}

export type ReasonReason = {
  __typename?: 'ReasonReason';
  metadata?: Maybe<AttributeAttributeMap>;
  reason?: Maybe<ReasonReasonReasonUnion>;
};

export type ReasonReasonAdWatched = {
  __typename?: 'ReasonReasonAdWatched';
  placementId: Scalars['ID']['output'];
};

export type ReasonReasonAdWatchedInput = {
  placementId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonAdministrative = {
  __typename?: 'ReasonReasonAdministrative';
  reason: Scalars['String']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ReasonReasonAdministrativeInput = {
  reason?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonChallengeSuccessful = {
  __typename?: 'ReasonReasonChallengeSuccessful';
  challengeId: Scalars['ID']['output'];
};

export type ReasonReasonChallengeSuccessfulInput = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonChannelOwner = {
  __typename?: 'ReasonReasonChannelOwner';
  channelId: Scalars['ID']['output'];
};

export type ReasonReasonChannelOwnerInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonChannelSubscription = {
  __typename?: 'ReasonReasonChannelSubscription';
  channelId: Scalars['ID']['output'];
};

export type ReasonReasonChannelSubscriptionInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithInGameCurrency = {
  __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID']['output'];
  revenueShares: Array<ReasonRevenueShare>;
  senderId: Scalars['ID']['output'];
  sku: Scalars['String']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithInGameCurrencyInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  senderId?: InputMaybe<Scalars['ID']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithPayment = {
  __typename?: 'ReasonReasonGiftPurchaseWithPayment';
  cardIssuingCountry: Scalars['String']['output'];
  orderId: Scalars['ID']['output'];
  price: PaymentAmount;
  reference: Scalars['String']['output'];
  senderId: Scalars['ID']['output'];
  sku: Scalars['String']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithPaymentInput = {
  cardIssuingCountry?: InputMaybe<Scalars['String']['input']>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  price?: InputMaybe<PaymentAmountInput>;
  reference?: InputMaybe<Scalars['String']['input']>;
  senderId?: InputMaybe<Scalars['ID']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type ReasonReasonGoalCardComplete = {
  __typename?: 'ReasonReasonGoalCardComplete';
  goalCard: GoalCardGoalCard;
  goalCardId: Scalars['ID']['output'];
  goalCardSlotId: Scalars['ID']['output'];
};

export type ReasonReasonGoalCardCompleteInput = {
  goalCardId?: InputMaybe<Scalars['ID']['input']>;
  goalCardSlotId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonGoalCardSlotReshuffle = {
  __typename?: 'ReasonReasonGoalCardSlotReshuffle';
  goalCardSlotId: Scalars['ID']['output'];
};

export type ReasonReasonGoalCardSlotReshuffleInput = {
  goalCardSlotId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonInput = {
  adWatched?: InputMaybe<ReasonReasonAdWatchedInput>;
  administrative?: InputMaybe<ReasonReasonAdministrativeInput>;
  challengeSuccessful?: InputMaybe<ReasonReasonChallengeSuccessfulInput>;
  channelOwner?: InputMaybe<ReasonReasonChannelOwnerInput>;
  channelSubscription?: InputMaybe<ReasonReasonChannelSubscriptionInput>;
  giftPurchaseWithInGameCurrency?: InputMaybe<ReasonReasonGiftPurchaseWithInGameCurrencyInput>;
  giftPurchaseWithPayment?: InputMaybe<ReasonReasonGiftPurchaseWithPaymentInput>;
  goalCardComplete?: InputMaybe<ReasonReasonGoalCardCompleteInput>;
  goalCardSlotReshuffle?: InputMaybe<ReasonReasonGoalCardSlotReshuffleInput>;
  levelUp?: InputMaybe<ReasonReasonLevelUpInput>;
  matchEnd?: InputMaybe<ReasonReasonMatchEndInput>;
  metadata?: InputMaybe<AttributeAttributeMapInput>;
  provision?: InputMaybe<ReasonReasonProvisionInput>;
  purchaseWithInGameCurrency?: InputMaybe<ReasonReasonPurchaseWithInGameCurrencyInput>;
  purchaseWithPayment?: InputMaybe<ReasonReasonPurchaseWithPaymentInput>;
  reshuffle?: InputMaybe<ReasonReasonReshuffleInput>;
  rewardClaimed?: InputMaybe<ReasonReasonRewardClaimedInput>;
  storeOrderPayment?: InputMaybe<ReasonReasonStoreOrderPaymentInput>;
};

export type ReasonReasonLevelUp = {
  __typename?: 'ReasonReasonLevelUp';
  level: Scalars['Int']['output'];
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
};

export type ReasonReasonLevelUpInput = {
  level?: InputMaybe<Scalars['Int']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonMatchEnd = {
  __typename?: 'ReasonReasonMatchEnd';
  groupId: Scalars['ID']['output'];
};

export type ReasonReasonMatchEndInput = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonProvision = {
  __typename?: 'ReasonReasonProvision';
  rev: Scalars['String']['output'];
  seasonId: Scalars['ID']['output'];
};

export type ReasonReasonProvisionInput = {
  rev?: InputMaybe<Scalars['String']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithInGameCurrency = {
  __typename?: 'ReasonReasonPurchaseWithInGameCurrency';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID']['output'];
  revenueShares: Array<ReasonRevenueShare>;
  sku: Scalars['String']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithInGameCurrencyInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithPayment = {
  __typename?: 'ReasonReasonPurchaseWithPayment';
  cardIssuingCountry: Scalars['String']['output'];
  orderId: Scalars['ID']['output'];
  price: PaymentAmount;
  reference: Scalars['String']['output'];
  sku: Scalars['String']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithPaymentInput = {
  cardIssuingCountry?: InputMaybe<Scalars['String']['input']>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  price?: InputMaybe<PaymentAmountInput>;
  reference?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type ReasonReasonReasonUnion = ReasonReasonAdWatched | ReasonReasonAdministrative | ReasonReasonChallengeSuccessful | ReasonReasonChannelOwner | ReasonReasonChannelSubscription | ReasonReasonGiftPurchaseWithInGameCurrency | ReasonReasonGiftPurchaseWithPayment | ReasonReasonGoalCardComplete | ReasonReasonGoalCardSlotReshuffle | ReasonReasonLevelUp | ReasonReasonMatchEnd | ReasonReasonProvision | ReasonReasonPurchaseWithInGameCurrency | ReasonReasonPurchaseWithPayment | ReasonReasonReshuffle | ReasonReasonRewardClaimed | ReasonReasonStoreOrderPayment;

export type ReasonReasonReshuffle = {
  __typename?: 'ReasonReasonReshuffle';
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  streamId: Scalars['ID']['output'];
};

export type ReasonReasonReshuffleInput = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
  matchId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonRewardClaimed = {
  __typename?: 'ReasonReasonRewardClaimed';
  rewardId: Scalars['ID']['output'];
  rewardReason: ReasonReason;
};

export type ReasonReasonRewardClaimedInput = {
  rewardId?: InputMaybe<Scalars['ID']['input']>;
  rewardReason?: InputMaybe<ReasonReasonInput>;
};

export type ReasonReasonStoreOrderPayment = {
  __typename?: 'ReasonReasonStoreOrderPayment';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID']['output'];
  revenueShares: Array<ReasonRevenueShare>;
  sku: Scalars['String']['output'];
};

export type ReasonReasonStoreOrderPaymentInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

export type ReasonRevenueRecipient = {
  __typename?: 'ReasonRevenueRecipient';
  kind: ReasonRevenueRecipientKind;
  recipientId: Scalars['ID']['output'];
};

export type ReasonRevenueRecipientInput = {
  kind?: InputMaybe<ReasonRevenueRecipientKind>;
  recipientId?: InputMaybe<Scalars['ID']['input']>;
};

export enum ReasonRevenueRecipientKind {
  KindChannel = 'KIND_CHANNEL',
  KindPlatform = 'KIND_PLATFORM',
  KindUnspecified = 'KIND_UNSPECIFIED'
}

export type ReasonRevenueShare = {
  __typename?: 'ReasonRevenueShare';
  percent: Scalars['Int']['output'];
  recipient: ReasonRevenueRecipient;
};

export type ReasonRevenueShareInput = {
  percent?: InputMaybe<Scalars['Int']['input']>;
  recipient?: InputMaybe<ReasonRevenueRecipientInput>;
};

export enum RenderingCameraTransitionRequestTransitionTarget {
  TransitionTargetArena = 'TRANSITION_TARGET_ARENA',
  TransitionTargetCameraDrive1 = 'TRANSITION_TARGET_CAMERA_DRIVE1',
  TransitionTargetSpotlight = 'TRANSITION_TARGET_SPOTLIGHT',
  TransitionTargetUnspecified = 'TRANSITION_TARGET_UNSPECIFIED'
}

export type RewardClaimRewardResponse = {
  __typename?: 'RewardClaimRewardResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type RewardListRewardsResponse = {
  __typename?: 'RewardListRewardsResponse';
  rewards: Array<RewardReward>;
};

export type RewardReward = {
  __typename?: 'RewardReward';
  id: Scalars['ID']['output'];
  reason: ReasonReason;
  rewardedAt: Scalars['Timestamp']['output'];
  type: RewardRewardType;
  userId: Scalars['ID']['output'];
};

export type RewardRewardType = {
  __typename?: 'RewardRewardType';
  reward?: Maybe<RewardRewardTypeRewardUnion>;
};

export type RewardRewardTypeCurrency = {
  __typename?: 'RewardRewardTypeCurrency';
  currencyAmount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
};

export type RewardRewardTypeItem = {
  __typename?: 'RewardRewardTypeItem';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type RewardRewardTypeRewardUnion = RewardRewardTypeCurrency | RewardRewardTypeItem;

export enum SearchEntityType {
  EntityTypeChannel = 'ENTITY_TYPE_CHANNEL',
  EntityTypeGame = 'ENTITY_TYPE_GAME',
  EntityTypeUnspecified = 'ENTITY_TYPE_UNSPECIFIED',
  EntityTypeUser = 'ENTITY_TYPE_USER'
}

export type SearchResultItem = {
  __typename?: 'SearchResultItem';
  entity?: Maybe<SearchResultItemEntityUnion>;
  entityId: Scalars['ID']['output'];
  entityType: SearchEntityType;
  matchedProperties: Array<Scalars['String']['output']>;
  score: Scalars['Float']['output'];
};

export type SearchResultItemEntityUnion = ChannelChannel | ChannelGameStats | ProfileProfile;

export type SearchSearchResponse = {
  __typename?: 'SearchSearchResponse';
  pageInfo: ApiPageInfo;
  resultItems: Array<SearchResultItem>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2BuyWithInGameCurrencyResponse = {
  __typename?: 'StoreV2BuyWithInGameCurrencyResponse';
  orderId: Scalars['ID']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2BuyWithPaymentResponse = {
  __typename?: 'StoreV2BuyWithPaymentResponse';
  orderId: Scalars['ID']['output'];
  session: PaymentSession;
};

export type StoreV2Content = {
  __typename?: 'StoreV2Content';
  value?: Maybe<StoreV2ContentValueUnion>;
};

export type StoreV2ContentValueUnion = StoreV2CurrencyRef | StoreV2ItemRef | StoreV2SubscriptionRef;

export type StoreV2CurrencyRef = {
  __typename?: 'StoreV2CurrencyRef';
  amount: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
};

export type StoreV2GiftOptionsInput = {
  giftAnonymously?: InputMaybe<Scalars['Boolean']['input']>;
  recipientIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2InGameCurrencyPrice = {
  __typename?: 'StoreV2InGameCurrencyPrice';
  amount: Scalars['Int']['output'];
  amountWithoutDiscount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
  default: Scalars['Boolean']['output'];
};

export type StoreV2ItemRef = {
  __typename?: 'StoreV2ItemRef';
  count: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  inventoryState?: Maybe<InventoryInventoryItem>;
  item: ItemItem;
};

export enum StoreV2ItemType {
  ItemTypeAvatarPart = 'ITEM_TYPE_AVATAR_PART',
  ItemTypeCurrencyPack = 'ITEM_TYPE_CURRENCY_PACK',
  ItemTypeGiftSubscription = 'ITEM_TYPE_GIFT_SUBSCRIPTION',
  ItemTypePremiumCardBundle = 'ITEM_TYPE_PREMIUM_CARD_BUNDLE',
  ItemTypeStandardCardBundle = 'ITEM_TYPE_STANDARD_CARD_BUNDLE',
  ItemTypeStreamerCard = 'ITEM_TYPE_STREAMER_CARD',
  ItemTypeUnspecified = 'ITEM_TYPE_UNSPECIFIED'
}

export type StoreV2ListGiftSellableItemsResponse = {
  __typename?: 'StoreV2ListGiftSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
};

export type StoreV2ListSellableItemsRequestChannelStoreFilterInput = {
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};

export type StoreV2ListSellableItemsRequestFilterInput = {
  channel?: InputMaybe<StoreV2ListSellableItemsRequestChannelStoreFilterInput>;
  platform?: InputMaybe<StoreV2ListSellableItemsRequestPlatformStoreFilterInput>;
};

export type StoreV2ListSellableItemsRequestPlatformStoreFilterInput = {
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};

export type StoreV2ListSellableItemsResponse = {
  __typename?: 'StoreV2ListSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
  pageInfo: ApiPageInfo;
};

export type StoreV2ListStreamerCardSaleConfigsResponse = {
  __typename?: 'StoreV2ListStreamerCardSaleConfigsResponse';
  configs: Array<StoreV2StreamerCardSaleConfig>;
  pageInfo: ApiPageInfo;
};

export type StoreV2ListTopUpSellableItemsResponse = {
  __typename?: 'StoreV2ListTopUpSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
};

export enum StoreV2PaymentMethod {
  PaymentMethodAdyen = 'PAYMENT_METHOD_ADYEN',
  PaymentMethodAppstore = 'PAYMENT_METHOD_APPSTORE',
  PaymentMethodUnspecified = 'PAYMENT_METHOD_UNSPECIFIED'
}

export type StoreV2Period = {
  __typename?: 'StoreV2Period';
  from: Scalars['Timestamp']['output'];
  until: Scalars['Timestamp']['output'];
};

export type StoreV2PeriodInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  until?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type StoreV2Price = {
  __typename?: 'StoreV2Price';
  amount: Scalars['Int']['output'];
  amountWithoutDiscount: Scalars['Int']['output'];
  currency: PaymentCurrency;
};

export type StoreV2PurchaseLimits = {
  __typename?: 'StoreV2PurchaseLimits';
  perItem: Scalars['Int']['output'];
  perUser: Scalars['Int']['output'];
};

export enum StoreV2RecipientRestriction {
  RecipientRestrictionGiftOnly = 'RECIPIENT_RESTRICTION_GIFT_ONLY',
  RecipientRestrictionSelfOnly = 'RECIPIENT_RESTRICTION_SELF_ONLY',
  RecipientRestrictionUnspecified = 'RECIPIENT_RESTRICTION_UNSPECIFIED'
}

export type StoreV2SellableItem = {
  __typename?: 'StoreV2SellableItem';
  availableUntil?: Maybe<Scalars['Timestamp']['output']>;
  content: Array<StoreV2Content>;
  discountPercent: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  igcPrices?: Maybe<Array<StoreV2InGameCurrencyPrice>>;
  meta: StoreV2SellableItemMeta;
  name: Scalars['String']['output'];
  price?: Maybe<StoreV2Price>;
  promotionName: Scalars['String']['output'];
  purchaseLimits: StoreV2PurchaseLimits;
  recipientRestriction: StoreV2RecipientRestriction;
  signature: Scalars['String']['output'];
  sku: Scalars['String']['output'];
  type: StoreV2ItemType;
};

export type StoreV2SellableItemMeta = {
  __typename?: 'StoreV2SellableItemMeta';
  channelId: Scalars['ID']['output'];
  configId: Scalars['ID']['output'];
  itemType: StoreV2ItemType;
  promotionId: Scalars['ID']['output'];
  storeFrontId: Scalars['ID']['output'];
  storeType: StoreV2StoreType;
};

export type StoreV2StoreFront = {
  __typename?: 'StoreV2StoreFront';
  categories?: Maybe<Array<StoreV2StoreFrontCategory>>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  type: StoreV2StoreType;
};

export type StoreV2StoreFrontCategory = {
  __typename?: 'StoreV2StoreFrontCategory';
  id: Scalars['ID']['output'];
  itemType: StoreV2ItemType;
  sellableItems: Array<StoreV2SellableItem>;
};

export enum StoreV2StoreType {
  StoreTypeAvatarEditor = 'STORE_TYPE_AVATAR_EDITOR',
  StoreTypeChannel = 'STORE_TYPE_CHANNEL',
  StoreTypePlatform = 'STORE_TYPE_PLATFORM',
  StoreTypeUnspecified = 'STORE_TYPE_UNSPECIFIED'
}

export type StoreV2StreamerCardSaleConfig = {
  __typename?: 'StoreV2StreamerCardSaleConfig';
  cardId: Scalars['ID']['output'];
  channelId: Scalars['ID']['output'];
  enabled: Scalars['Boolean']['output'];
  excludeFromBundles: Scalars['Boolean']['output'];
  period?: Maybe<StoreV2Period>;
};

export type StoreV2StreamerCardSaleConfigUpdateInput = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  excludeFromBundles?: InputMaybe<Scalars['Boolean']['input']>;
  period?: InputMaybe<StoreV2PeriodInput>;
  unsetPeriod?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StoreV2SubscriptionRef = {
  __typename?: 'StoreV2SubscriptionRef';
  amount: Scalars['Int']['output'];
  channelId: Scalars['ID']['output'];
  /** this is not used */
  id: Scalars['ID']['output'];
  tier: Scalars['Int']['output'];
};

export enum StreamDeploymentStreamDeploymentStatusComponentStatus {
  ComponentStatusContainersUnready = 'COMPONENT_STATUS_CONTAINERS_UNREADY',
  ComponentStatusDeployingContainers = 'COMPONENT_STATUS_DEPLOYING_CONTAINERS',
  ComponentStatusDeployingPod = 'COMPONENT_STATUS_DEPLOYING_POD',
  ComponentStatusDeploymentStarted = 'COMPONENT_STATUS_DEPLOYMENT_STARTED',
  ComponentStatusDisabled = 'COMPONENT_STATUS_DISABLED',
  ComponentStatusOffline = 'COMPONENT_STATUS_OFFLINE',
  ComponentStatusProvisioningNode = 'COMPONENT_STATUS_PROVISIONING_NODE',
  ComponentStatusReady = 'COMPONENT_STATUS_READY',
  ComponentStatusUnspecified = 'COMPONENT_STATUS_UNSPECIFIED'
}

export type StreamInfoStreamInfo = {
  __typename?: 'StreamInfoStreamInfo';
  channelId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  seasonId: Scalars['ID']['output'];
  streamId: Scalars['ID']['output'];
};

export type StreamIngestConfigChannelIngestConfig = {
  __typename?: 'StreamIngestConfigChannelIngestConfig';
  channelId: Scalars['ID']['output'];
  config: StreamIngestConfigIngestConfig;
  streamingStatus: StreamIngestConfigStreamingStatus;
};

export type StreamIngestConfigChannelIngestConfigs = {
  __typename?: 'StreamIngestConfigChannelIngestConfigs';
  channelId: Scalars['ID']['output'];
  configs: Array<StreamIngestConfigIngestConfig>;
};

export type StreamIngestConfigIngestConfig = {
  __typename?: 'StreamIngestConfigIngestConfig';
  ingest?: Maybe<StreamIngestConfigIngestConfigIngestUnion>;
};

export type StreamIngestConfigIngestConfigFtlConfig = {
  __typename?: 'StreamIngestConfigIngestConfigFTLConfig';
  sharedKey: Scalars['String']['output'];
  streamId: Scalars['Int']['output'];
  streamKey: Scalars['String']['output'];
};

export type StreamIngestConfigIngestConfigIngestUnion = StreamIngestConfigIngestConfigFtlConfig;

export enum StreamIngestConfigStreamingStatus {
  StreamingStatusStreamingDisabled = 'STREAMING_STATUS_STREAMING_DISABLED',
  StreamingStatusUnspecified = 'STREAMING_STATUS_UNSPECIFIED',
  StreamingStatusUserSuspended = 'STREAMING_STATUS_USER_SUSPENDED'
}

export type StreamerActivateContextualTeamActionResponse = {
  __typename?: 'StreamerActivateContextualTeamActionResponse';
  activated: Scalars['Boolean']['output'];
  cooldown: Scalars['Duration']['output'];
};

export type StreamerAvatarItemPurchased = {
  __typename?: 'StreamerAvatarItemPurchased';
  item: ItemItem;
  itemId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerBundlePurchased = {
  __typename?: 'StreamerBundlePurchased';
  bundleName: Scalars['String']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerChannelActivityEvent = {
  __typename?: 'StreamerChannelActivityEvent';
  content?: Maybe<StreamerChannelActivityEventContentUnion>;
  id: Scalars['ID']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

export type StreamerChannelActivityEventContentUnion = GameLogicHighScoringCardPromotedMsg | StreamerAvatarItemPurchased | StreamerBundlePurchased | StreamerChannelFollowed | StreamerChannelSubscribed | StreamerMatchEnded | StreamerMatchStarted | StreamerPlayerJoined | StreamerStreamEnded | StreamerStreamStarted | StreamerStreamTitleChanged | StreamerStreamerCardPurchased | StreamerSubscriptionGifted | StreamerSubscriptionRenewed;

export enum StreamerChannelActivityEventFilterEventType {
  EventTypeAvatarItemPurchased = 'EVENT_TYPE_AVATAR_ITEM_PURCHASED',
  EventTypeBundlePurchased = 'EVENT_TYPE_BUNDLE_PURCHASED',
  EventTypeChannelFollowed = 'EVENT_TYPE_CHANNEL_FOLLOWED',
  EventTypeChannelSubscribed = 'EVENT_TYPE_CHANNEL_SUBSCRIBED',
  EventTypeChannelSubscriptionGifted = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_GIFTED',
  EventTypeChannelSubscriptionRenewed = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_RENEWED',
  EventTypeHighScoringCardPromoted = 'EVENT_TYPE_HIGH_SCORING_CARD_PROMOTED',
  EventTypeMatchEnded = 'EVENT_TYPE_MATCH_ENDED',
  EventTypeMatchStarted = 'EVENT_TYPE_MATCH_STARTED',
  EventTypePlayerJoined = 'EVENT_TYPE_PLAYER_JOINED',
  EventTypeStreamerCardPurchased = 'EVENT_TYPE_STREAMER_CARD_PURCHASED',
  EventTypeStreamEnded = 'EVENT_TYPE_STREAM_ENDED',
  EventTypeStreamStarted = 'EVENT_TYPE_STREAM_STARTED',
  EventTypeStreamTitleChanged = 'EVENT_TYPE_STREAM_TITLE_CHANGED',
  EventTypeUnspecified = 'EVENT_TYPE_UNSPECIFIED'
}

export type StreamerChannelActivityEventFilterInput = {
  eventTypes?: InputMaybe<Array<StreamerChannelActivityEventFilterEventType>>;
};

export type StreamerChannelFollowed = {
  __typename?: 'StreamerChannelFollowed';
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type StreamerChannelSubscribed = {
  __typename?: 'StreamerChannelSubscribed';
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerListChannelActivityEventsResponse = {
  __typename?: 'StreamerListChannelActivityEventsResponse';
  events: Array<StreamerChannelActivityEvent>;
  pageInfo: ApiPageInfo;
};

export type StreamerMatchEnded = {
  __typename?: 'StreamerMatchEnded';
  bestCard?: Maybe<GameLogicCardDetails>;
  bestGroup?: Maybe<GameLogicGroupDetails>;
  bestPlayer?: Maybe<GameLogicPlayerDetails>;
  challengeStatuses?: Maybe<Array<GameLogicChallengeStatus>>;
  streamId: Scalars['ID']['output'];
};

export type StreamerMatchStarted = {
  __typename?: 'StreamerMatchStarted';
  streamId: Scalars['ID']['output'];
};

export type StreamerPlayerJoined = {
  __typename?: 'StreamerPlayerJoined';
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type StreamerStreamAudienceInsights = {
  __typename?: 'StreamerStreamAudienceInsights';
  chatters: Scalars['Int']['output'];
  followers: Scalars['Int']['output'];
  players: Scalars['Int']['output'];
  subscribers: Scalars['Int']['output'];
  viewers: Scalars['Int']['output'];
};

export type StreamerStreamDiagnosticsEvent = {
  __typename?: 'StreamerStreamDiagnosticsEvent';
  channelId: Scalars['ID']['output'];
  obsNoiceValidator: StreamerStreamDiagnosticsEventObsNoiceValidator;
  obsPluginInfo: StreamerStreamDiagnosticsEventObsPluginInfo;
  streamId: Scalars['ID']['output'];
};

export type StreamerStreamDiagnosticsEventObsNoiceValidator = {
  __typename?: 'StreamerStreamDiagnosticsEventObsNoiceValidator';
  missingValidator: Scalars['Boolean']['output'];
  occludingSourceNames: Array<Scalars['String']['output']>;
};

export type StreamerStreamDiagnosticsEventObsPluginInfo = {
  __typename?: 'StreamerStreamDiagnosticsEventObsPluginInfo';
  obsVersion: Scalars['String']['output'];
  pluginVersion: Scalars['String']['output'];
};

export type StreamerStreamDiagnosticsUpdate = {
  __typename?: 'StreamerStreamDiagnosticsUpdate';
  content?: Maybe<StreamerStreamDiagnosticsUpdateContentUnion>;
};

export type StreamerStreamDiagnosticsUpdateContentUnion = IntType | StreamerStreamDiagnosticsEvent;

export type StreamerStreamEnded = {
  __typename?: 'StreamerStreamEnded';
  streamId: Scalars['ID']['output'];
};

export type StreamerStreamEvent = {
  __typename?: 'StreamerStreamEvent';
  content?: Maybe<StreamerStreamEventContentUnion>;
  timestamp: Scalars['Timestamp']['output'];
};

export type StreamerStreamEventContentUnion = GameLogicActiveCardSucceededMsg | GameLogicHighScoringCardPromotedMsg | GameLogicMatchEndedMsg | GameLogicMatchPauseStateChangedMsg | GameLogicMatchStartedMsg | GameLogicPlayerJoinedMsg | GameStateStreamState | IntType | StreamerChannelFollowed | StreamerChannelSubscribed | StreamerSubscriptionGifted;

export enum StreamerStreamEventFilterEventType {
  EventTypeActiveCardSucceeded = 'EVENT_TYPE_ACTIVE_CARD_SUCCEEDED',
  EventTypeChannelFollowed = 'EVENT_TYPE_CHANNEL_FOLLOWED',
  EventTypeChannelSubscribed = 'EVENT_TYPE_CHANNEL_SUBSCRIBED',
  EventTypeChannelSubscriptionGifted = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_GIFTED',
  EventTypeHighScoringCardPromoted = 'EVENT_TYPE_HIGH_SCORING_CARD_PROMOTED',
  EventTypePlayerJoined = 'EVENT_TYPE_PLAYER_JOINED',
  EventTypeUnspecified = 'EVENT_TYPE_UNSPECIFIED'
}

export type StreamerStreamEventFilterInput = {
  eventTypes?: InputMaybe<Array<StreamerStreamEventFilterEventType>>;
};

export type StreamerStreamStarted = {
  __typename?: 'StreamerStreamStarted';
  streamId: Scalars['ID']['output'];
};

export type StreamerStreamTitleChanged = {
  __typename?: 'StreamerStreamTitleChanged';
  title: Scalars['String']['output'];
};

export type StreamerStreamerCardPurchased = {
  __typename?: 'StreamerStreamerCardPurchased';
  streamerCard: GameLogicStreamerCard;
  streamerCardId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerSubscriptionGifted = {
  __typename?: 'StreamerSubscriptionGifted';
  recipientUserIds: Array<Scalars['String']['output']>;
  recipients?: Maybe<Array<ProfileProfile>>;
  tier: Scalars['Int']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerSubscriptionRenewed = {
  __typename?: 'StreamerSubscriptionRenewed';
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerTriggerCameraTransitionResponse = {
  __typename?: 'StreamerTriggerCameraTransitionResponse';
  success: Scalars['Boolean']['output'];
};

export type StringType = {
  __typename?: 'StringType';
  /** The wrapped value of type String */
  value: Scalars['String']['output'];
};

export type Subscription = {
  __typename?: 'Subscription';
  /** StreamerService.ChannelActivityEvents */
  channelActivityEventsSubscribe?: Maybe<StreamerChannelActivityEvent>;
  /** ChannelService.ChannelEventStream */
  channelEventsSubscribe?: Maybe<ChannelChannelEvent>;
  /** ChannelService.FollowerCountUpdates */
  channelFollowerCountSubscribe?: Maybe<ChannelFollowerCountEvent>;
  /** ChannelService.LiveStatusUpdates - Subscription APIs */
  channelLiveStatusSubscribe?: Maybe<ChannelLiveStatusEvent>;
  /** ChannelService.ChannelStreamDetailUpdates */
  channelStreamDetailSubscribe?: Maybe<ChannelChannelStreamDetailEvent>;
  /** ChannelService.ViewerCountUpdates */
  channelViewerCountSubscribe?: Maybe<ChannelViewerCountEvent>;
  /** ChatModerationService.StreamAutoModQueue */
  chatAutoModQueueSubscribe?: Maybe<ChatAutoModQueueEvent>;
  /** ChatService.ChatMessageStream */
  chatMessageSubscribe?: Maybe<ChatChatEvent>;
  /** ChannelConfigService.IngestStatsUpdates */
  ingestStatsSubscribe?: Maybe<ChannelIngestStatsEvent>;
  /** MLControllerService.StreamHUDScaleUpdates */
  mlHUDScaleUpdatesSubscribe?: Maybe<MlControllerGetHudScaleResponse>;
  /** ChannelModerationService.ModerationEventsStream */
  moderationEventsSubscribe?: Maybe<ChannelModerationEvent>;
  /** NotificationService.Notifications */
  notificationSubscribe?: Maybe<NotificationNotification>;
  /** PartyService.StreamPartyUpdates */
  partyUpdateSubscribe?: Maybe<PartyPartyUpdateEvent>;
  /** ReactionService.StreamReactions */
  reactionsSubscription?: Maybe<ReactionReactionEvent>;
  /** ChallengeSessionService.ChallengeSessionEvents */
  streamChallengeSessionEvents?: Maybe<ChallengesessionChallengeSessionEvent>;
  /** MatchServiceV2.ChallengeUpdates */
  streamChallengeUpdatesSubscribe?: Maybe<MatchChallengeUpdate>;
  /** StreamerService.StreamDiagnosticsUpdates */
  streamDiagnosticsSubscribe?: Maybe<StreamerStreamDiagnosticsUpdate>;
  /** StreamerService.StreamEvents */
  streamEventsSubscribe?: Maybe<StreamerStreamEvent>;
  /** MatchServiceV2.StreamSpectatorCoordinationEvents */
  streamSpectatorCoordinationEventsSubscribe?: Maybe<MatchStreamSpectatorCoordinationEvent>;
  /** ChannelConfigService.StreamStatusUpdates */
  streamStatusSubscribe?: Maybe<ChannelStreamStatusEvent>;
  /** MatchServiceV2.TopCardUpdates */
  streamTopActiveCardsSubscribe?: Maybe<MatchTopCardsUpdate>;
  /** FeatureFlagService.StreamConfigUpdates */
  subscribeFeatureFlagConfigUpdates?: Maybe<FlagFeatureFlagConfig>;
};


export type SubscriptionChannelActivityEventsSubscribeArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<StreamerChannelActivityEventFilterInput>;
};


export type SubscriptionChannelEventsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelFollowerCountSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelLiveStatusSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelStreamDetailSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelViewerCountSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChatAutoModQueueSubscribeArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChatMessageSubscribeArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionIngestStatsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionMlHudScaleUpdatesSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionModerationEventsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ChannelModerationEventsFilterInput>;
};


export type SubscriptionNotificationSubscribeArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};


export type SubscriptionPartyUpdateSubscribeArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionReactionsSubscriptionArgs = {
  parentId?: InputMaybe<Scalars['ID']['input']>;
  parentType?: InputMaybe<Scalars['String']['input']>;
};


export type SubscriptionStreamChallengeSessionEventsArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamChallengeUpdatesSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamDiagnosticsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamEventsSubscribeArgs = {
  filter?: InputMaybe<StreamerStreamEventFilterInput>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamSpectatorCoordinationEventsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamStatusSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamTopActiveCardsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionSubscribeFeatureFlagConfigUpdatesArgs = {
  revision?: InputMaybe<Scalars['String']['input']>;
};

export type SubscriptionChannelSubscription = {
  __typename?: 'SubscriptionChannelSubscription';
  activatedAt?: Maybe<Scalars['Timestamp']['output']>;
  cancelReason: SubscriptionChannelSubscriptionCancelReason;
  cancelledAt?: Maybe<Scalars['Timestamp']['output']>;
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  createdAt: Scalars['Timestamp']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  externalReference: Scalars['String']['output'];
  giverId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  paymentFailedAt?: Maybe<Scalars['Timestamp']['output']>;
  paymentSucceededAt?: Maybe<Scalars['Timestamp']['output']>;
  provider: SubscriptionChannelSubscriptionProvider;
  renewedAt?: Maybe<Scalars['Timestamp']['output']>;
  state: SubscriptionChannelSubscriptionState;
  terminatedAt?: Maybe<Scalars['Timestamp']['output']>;
  tier: Scalars['Int']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export enum SubscriptionChannelSubscriptionCancelReason {
  CancelReasonCurrencyIncompatibleWithGateway = 'CANCEL_REASON_CURRENCY_INCOMPATIBLE_WITH_GATEWAY',
  CancelReasonFraudReviewFailed = 'CANCEL_REASON_FRAUD_REVIEW_FAILED',
  CancelReasonNonCompliantCustomer = 'CANCEL_REASON_NON_COMPLIANT_CUSTOMER',
  CancelReasonNonCompliantEuCustomer = 'CANCEL_REASON_NON_COMPLIANT_EU_CUSTOMER',
  CancelReasonNotPaid = 'CANCEL_REASON_NOT_PAID',
  CancelReasonNoCard = 'CANCEL_REASON_NO_CARD',
  CancelReasonTaxCalculationFailed = 'CANCEL_REASON_TAX_CALCULATION_FAILED',
  CancelReasonUnspecified = 'CANCEL_REASON_UNSPECIFIED'
}

export type SubscriptionChannelSubscriptionConfig = {
  __typename?: 'SubscriptionChannelSubscriptionConfig';
  channelId: Scalars['ID']['output'];
  subscriptionsEnabled: Scalars['Boolean']['output'];
  tiers: Array<SubscriptionChannelSubscriptionTier>;
};

export type SubscriptionChannelSubscriptionEntitlement = {
  __typename?: 'SubscriptionChannelSubscriptionEntitlement';
  amount: Scalars['Int']['output'];
  item: ItemItem;
  itemId: Scalars['ID']['output'];
};

export enum SubscriptionChannelSubscriptionProvider {
  ProviderApple = 'PROVIDER_APPLE',
  ProviderChargebee = 'PROVIDER_CHARGEBEE',
  ProviderUnspecified = 'PROVIDER_UNSPECIFIED'
}

export enum SubscriptionChannelSubscriptionState {
  StateActive = 'STATE_ACTIVE',
  StateCancelled = 'STATE_CANCELLED',
  StateExpired = 'STATE_EXPIRED',
  StateLocked = 'STATE_LOCKED',
  StatePending = 'STATE_PENDING',
  StateTerminated = 'STATE_TERMINATED',
  StateUnspecified = 'STATE_UNSPECIFIED'
}

export type SubscriptionChannelSubscriptionTier = {
  __typename?: 'SubscriptionChannelSubscriptionTier';
  description: Scalars['String']['output'];
  entitlements: Array<SubscriptionChannelSubscriptionEntitlement>;
  level: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  prices: Array<SubscriptionSubscriptionPrice>;
};

export type SubscriptionChannelSubscriptionUpdateEvent = {
  __typename?: 'SubscriptionChannelSubscriptionUpdateEvent';
  meta: SubscriptionSubscriptionUpdateMeta;
  subscription: SubscriptionChannelSubscription;
  updateType: SubscriptionChannelSubscriptionUpdateEventUpdateType;
  updatedAt: Scalars['Timestamp']['output'];
};

export enum SubscriptionChannelSubscriptionUpdateEventUpdateType {
  UpdateTypeActivated = 'UPDATE_TYPE_ACTIVATED',
  UpdateTypeCancellationRemoved = 'UPDATE_TYPE_CANCELLATION_REMOVED',
  UpdateTypeCancellationRequested = 'UPDATE_TYPE_CANCELLATION_REQUESTED',
  UpdateTypeCancelled = 'UPDATE_TYPE_CANCELLED',
  UpdateTypeCreated = 'UPDATE_TYPE_CREATED',
  UpdateTypeExpired = 'UPDATE_TYPE_EXPIRED',
  UpdateTypePaymentFailed = 'UPDATE_TYPE_PAYMENT_FAILED',
  UpdateTypePaymentSucceeded = 'UPDATE_TYPE_PAYMENT_SUCCEEDED',
  UpdateTypeRenewed = 'UPDATE_TYPE_RENEWED',
  UpdateTypeTerminated = 'UPDATE_TYPE_TERMINATED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUpgraded = 'UPDATE_TYPE_UPGRADED'
}

export type SubscriptionCheckoutExistingSubscriptionResponse = {
  __typename?: 'SubscriptionCheckoutExistingSubscriptionResponse';
  sessionData: Scalars['String']['output'];
};

export type SubscriptionCheckoutNewSubscriptionResponse = {
  __typename?: 'SubscriptionCheckoutNewSubscriptionResponse';
  sessionData: Scalars['String']['output'];
};

export type SubscriptionListChannelSubscriptionTiersResponse = {
  __typename?: 'SubscriptionListChannelSubscriptionTiersResponse';
  tiers: Array<SubscriptionChannelSubscriptionTier>;
};

export type SubscriptionListChannelSubscriptionsRequestFilterInput = {
  state?: InputMaybe<SubscriptionChannelSubscriptionState>;
};

export type SubscriptionListChannelSubscriptionsResponse = {
  __typename?: 'SubscriptionListChannelSubscriptionsResponse';
  pageInfo: ApiPageInfo;
  subscriptions: Array<SubscriptionChannelSubscription>;
};

export type SubscriptionListUserChannelSubscriptionsRequestFilterInput = {
  paymentFailed?: InputMaybe<Scalars['Boolean']['input']>;
  state?: InputMaybe<SubscriptionChannelSubscriptionState>;
};

export type SubscriptionListUserChannelSubscriptionsResponse = {
  __typename?: 'SubscriptionListUserChannelSubscriptionsResponse';
  pageInfo: ApiPageInfo;
  subscriptions: Array<SubscriptionChannelSubscription>;
};

export type SubscriptionSubscriptionPrice = {
  __typename?: 'SubscriptionSubscriptionPrice';
  currency: PaymentCurrency;
  period: SubscriptionSubscriptionPricePeriod;
  price: Scalars['Int']['output'];
};

export enum SubscriptionSubscriptionPricePeriod {
  PeriodMonth = 'PERIOD_MONTH',
  PeriodUnspecified = 'PERIOD_UNSPECIFIED',
  PeriodYear = 'PERIOD_YEAR'
}

export type SubscriptionSubscriptionUpdateMeta = {
  __typename?: 'SubscriptionSubscriptionUpdateMeta';
  giverId: Scalars['ID']['output'];
};

export type SubscriptionUpdateSubscriptionPaymentMethodResponse = {
  __typename?: 'SubscriptionUpdateSubscriptionPaymentMethodResponse';
  sessionData: Scalars['String']['output'];
};

export type SupportArticle = {
  __typename?: 'SupportArticle';
  body: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  locale: Scalars['String']['output'];
  title: Scalars['String']['output'];
};

export type SupportListReportsResponse = {
  __typename?: 'SupportListReportsResponse';
  pageInfo: ApiPageInfo;
  reports: Array<SupportReport>;
};

export type SupportReport = {
  __typename?: 'SupportReport';
  caseId: Scalars['ID']['output'];
  context: SupportReportContext;
  createdAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  reason: SupportReportReason;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type SupportReportCase = {
  __typename?: 'SupportReportCase';
  closedAt: Scalars['Timestamp']['output'];
  closedBy: Scalars['String']['output'];
  context: SupportReportContext;
  createdAt: Scalars['Timestamp']['output'];
  firstDescription: Scalars['String']['output'];
  firstReason: SupportReportReason;
  firstReporterId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  moderatorComment: Scalars['String']['output'];
  resolution: SupportReportCaseResolution;
  status: SupportReportCaseStatus;
};

export enum SupportReportCaseResolution {
  ReportCaseResolutionAllowContent = 'REPORT_CASE_RESOLUTION_ALLOW_CONTENT',
  ReportCaseResolutionRemoveContent = 'REPORT_CASE_RESOLUTION_REMOVE_CONTENT',
  ReportCaseResolutionUnspecified = 'REPORT_CASE_RESOLUTION_UNSPECIFIED'
}

export enum SupportReportCaseStatus {
  ReportCaseStatusClosed = 'REPORT_CASE_STATUS_CLOSED',
  ReportCaseStatusOpen = 'REPORT_CASE_STATUS_OPEN',
  ReportCaseStatusUnspecified = 'REPORT_CASE_STATUS_UNSPECIFIED'
}

export type SupportReportContext = {
  __typename?: 'SupportReportContext';
  value?: Maybe<SupportReportContextValueUnion>;
};

export type SupportReportContextChannel = {
  __typename?: 'SupportReportContextChannel';
  channelId: Scalars['ID']['output'];
  target: SupportReportContextChannelTarget;
};

export type SupportReportContextChannelInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  target?: InputMaybe<SupportReportContextChannelTarget>;
};

export enum SupportReportContextChannelTarget {
  TargetDescription = 'TARGET_DESCRIPTION',
  TargetName = 'TARGET_NAME',
  TargetUnspecified = 'TARGET_UNSPECIFIED'
}

export type SupportReportContextChatMessage = {
  __typename?: 'SupportReportContextChatMessage';
  channelId: Scalars['ID']['output'];
  chatId: Scalars['ID']['output'];
  messageId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type SupportReportContextChatMessageInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  chatId?: InputMaybe<Scalars['ID']['input']>;
  messageId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type SupportReportContextInput = {
  channel?: InputMaybe<SupportReportContextChannelInput>;
  chatMessage?: InputMaybe<SupportReportContextChatMessageInput>;
  stream?: InputMaybe<SupportReportContextStreamInput>;
  user?: InputMaybe<SupportReportContextUserInput>;
};

export type SupportReportContextStream = {
  __typename?: 'SupportReportContextStream';
  channelId: Scalars['ID']['output'];
  startAt: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type SupportReportContextStreamInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  startAt?: InputMaybe<Scalars['Int']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type SupportReportContextUser = {
  __typename?: 'SupportReportContextUser';
  target: SupportReportContextUserTarget;
  userId: Scalars['ID']['output'];
};

export type SupportReportContextUserInput = {
  target?: InputMaybe<SupportReportContextUserTarget>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export enum SupportReportContextUserTarget {
  TargetName = 'TARGET_NAME',
  TargetUnspecified = 'TARGET_UNSPECIFIED'
}

export type SupportReportContextValueUnion = SupportReportContextChannel | SupportReportContextChatMessage | SupportReportContextStream | SupportReportContextUser;

export enum SupportReportReason {
  ReportReasonChildSafetyChildAbuse = 'REPORT_REASON_CHILD_SAFETY_CHILD_ABUSE',
  ReportReasonChildSafetyCse = 'REPORT_REASON_CHILD_SAFETY_CSE',
  ReportReasonChildSafetyDangerous = 'REPORT_REASON_CHILD_SAFETY_DANGEROUS',
  ReportReasonChildSafetyUnderageUser = 'REPORT_REASON_CHILD_SAFETY_UNDERAGE_USER',
  ReportReasonGraphicMediaAnimalAbuse = 'REPORT_REASON_GRAPHIC_MEDIA_ANIMAL_ABUSE',
  ReportReasonGraphicMediaGore = 'REPORT_REASON_GRAPHIC_MEDIA_GORE',
  ReportReasonGraphicMediaViolence = 'REPORT_REASON_GRAPHIC_MEDIA_VIOLENCE',
  ReportReasonHarassment = 'REPORT_REASON_HARASSMENT',
  ReportReasonHarassmentBlackmail = 'REPORT_REASON_HARASSMENT_BLACKMAIL',
  ReportReasonHarassmentIncitement = 'REPORT_REASON_HARASSMENT_INCITEMENT',
  ReportReasonHarassmentNonConsensualIntimateImages = 'REPORT_REASON_HARASSMENT_NON_CONSENSUAL_INTIMATE_IMAGES',
  ReportReasonHarassmentSexualNonConsensual = 'REPORT_REASON_HARASSMENT_SEXUAL_NON_CONSENSUAL',
  ReportReasonHarassmentStalking = 'REPORT_REASON_HARASSMENT_STALKING',
  ReportReasonHatefulBehavior = 'REPORT_REASON_HATEFUL_BEHAVIOR',
  ReportReasonIllegalActivitySale = 'REPORT_REASON_ILLEGAL_ACTIVITY_SALE',
  ReportReasonIllegalActivityWeapons = 'REPORT_REASON_ILLEGAL_ACTIVITY_WEAPONS',
  ReportReasonIllegalAlcoholNicotine = 'REPORT_REASON_ILLEGAL_ALCOHOL_NICOTINE',
  ReportReasonIllegalDrugs = 'REPORT_REASON_ILLEGAL_DRUGS',
  ReportReasonIllegalManipulation = 'REPORT_REASON_ILLEGAL_MANIPULATION',
  ReportReasonIllegalSpam = 'REPORT_REASON_ILLEGAL_SPAM',
  ReportReasonImpersonation = 'REPORT_REASON_IMPERSONATION',
  ReportReasonInauthenticGameplay = 'REPORT_REASON_INAUTHENTIC_GAMEPLAY',
  ReportReasonOffPlatform = 'REPORT_REASON_OFF_PLATFORM',
  ReportReasonPlatformRulesViolation = 'REPORT_REASON_PLATFORM_RULES_VIOLATION',
  ReportReasonPossibleIllegalActivity = 'REPORT_REASON_POSSIBLE_ILLEGAL_ACTIVITY',
  ReportReasonRestrictedGamesInherentlyViolative = 'REPORT_REASON_RESTRICTED_GAMES_INHERENTLY_VIOLATIVE',
  ReportReasonRestrictedGamesMature = 'REPORT_REASON_RESTRICTED_GAMES_MATURE',
  ReportReasonSelfHarm = 'REPORT_REASON_SELF_HARM',
  ReportReasonSexualBehaviorExplicit = 'REPORT_REASON_SEXUAL_BEHAVIOR_EXPLICIT',
  ReportReasonSexualBehaviorSuggestive = 'REPORT_REASON_SEXUAL_BEHAVIOR_SUGGESTIVE',
  ReportReasonSpam = 'REPORT_REASON_SPAM',
  ReportReasonSpamSuspensionEvasion = 'REPORT_REASON_SPAM_SUSPENSION_EVASION',
  ReportReasonUnknown = 'REPORT_REASON_UNKNOWN',
  ReportReasonUnspecified = 'REPORT_REASON_UNSPECIFIED',
  ReportReasonViolenceExtremism = 'REPORT_REASON_VIOLENCE_EXTREMISM'
}

export type SupportReportsFilterInput = {
  caseId?: InputMaybe<Scalars['ID']['input']>;
};

export type WalletAddCurrenciesResponse = {
  __typename?: 'WalletAddCurrenciesResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type WalletGetWalletResponse = {
  __typename?: 'WalletGetWalletResponse';
  wallet: WalletWallet;
};

export type WalletListWalletTransactionsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  reasons?: InputMaybe<Array<WalletTransactionReason>>;
  to?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type WalletListWalletTransactionsResponse = {
  __typename?: 'WalletListWalletTransactionsResponse';
  pageInfo: ApiPageInfo;
  transactions: Array<WalletTransaction>;
};

export type WalletOperation = {
  __typename?: 'WalletOperation';
  currencyAmount: Scalars['Int']['output'];
  currencyBalance: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
  type: WalletOperationType;
};

export enum WalletOperationType {
  TypeAdd = 'TYPE_ADD',
  TypeSubtract = 'TYPE_SUBTRACT',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type WalletSubtractCurrenciesResponse = {
  __typename?: 'WalletSubtractCurrenciesResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type WalletTransaction = {
  __typename?: 'WalletTransaction';
  createdAt: Scalars['Timestamp']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  id: Scalars['ID']['output'];
  operations: Array<WalletOperation>;
  reason: ReasonReason;
  state: WalletTransactionState;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type WalletTransactionEvent = {
  __typename?: 'WalletTransactionEvent';
  transaction: WalletTransaction;
};

export enum WalletTransactionReason {
  TransactionReasonAdministrative = 'TRANSACTION_REASON_ADMINISTRATIVE',
  TransactionReasonAdWatched = 'TRANSACTION_REASON_AD_WATCHED',
  TransactionReasonChannelSubscription = 'TRANSACTION_REASON_CHANNEL_SUBSCRIPTION',
  TransactionReasonGoalCardComplete = 'TRANSACTION_REASON_GOAL_CARD_COMPLETE',
  TransactionReasonGoalCardSlotReshuffle = 'TRANSACTION_REASON_GOAL_CARD_SLOT_RESHUFFLE',
  TransactionReasonLevelUp = 'TRANSACTION_REASON_LEVEL_UP',
  TransactionReasonMatchEnd = 'TRANSACTION_REASON_MATCH_END',
  TransactionReasonProvision = 'TRANSACTION_REASON_PROVISION',
  TransactionReasonPurchaseWithInGameCurrency = 'TRANSACTION_REASON_PURCHASE_WITH_IN_GAME_CURRENCY',
  TransactionReasonPurchaseWithPayment = 'TRANSACTION_REASON_PURCHASE_WITH_PAYMENT',
  TransactionReasonReshuffle = 'TRANSACTION_REASON_RESHUFFLE',
  TransactionReasonRewardClaimed = 'TRANSACTION_REASON_REWARD_CLAIMED',
  TransactionReasonStoreOrderPayment = 'TRANSACTION_REASON_STORE_ORDER_PAYMENT',
  TransactionReasonUnspecified = 'TRANSACTION_REASON_UNSPECIFIED'
}

export enum WalletTransactionState {
  TransactionStateCancelled = 'TRANSACTION_STATE_CANCELLED',
  TransactionStateCommitted = 'TRANSACTION_STATE_COMMITTED',
  TransactionStatePending = 'TRANSACTION_STATE_PENDING',
  TransactionStateUnspecified = 'TRANSACTION_STATE_UNSPECIFIED'
}

export type WalletWallet = {
  __typename?: 'WalletWallet';
  currencies: Array<WalletWalletCurrency>;
  userId: Scalars['ID']['output'];
};

export type WalletWalletCurrency = {
  __typename?: 'WalletWalletCurrency';
  currencyAmount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
};

export type WalletWalletCurrencyInput = {
  currencyAmount?: InputMaybe<Scalars['Int']['input']>;
  currencyId?: InputMaybe<Scalars['ID']['input']>;
};

export type AuthenticatedAppDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type AuthenticatedAppDataQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null } | null };

export type AlertsChannelActivityEventsSubscriptionVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<StreamerChannelActivityEventFilterInput>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type AlertsChannelActivityEventsSubscription = { __typename?: 'Subscription', channelActivityEventsSubscribe?: { __typename?: 'StreamerChannelActivityEvent', timestamp: string, id: string, content?: { __typename?: 'GameLogicHighScoringCardPromotedMsg', hscPlayer: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null }, card: { __typename?: 'GameLogicHighScoringCard', cardId: string, points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, boosterPoints: Array<{ __typename?: 'GameLogicPlayerBoosterPoints', userId: string, boosterId: number }> } } | { __typename?: 'StreamerAvatarItemPurchased' } | { __typename?: 'StreamerBundlePurchased', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null } | { __typename?: 'StreamerChannelFollowed', userId: string, follower: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } } | { __typename?: 'StreamerChannelSubscribed', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null } | { __typename?: 'StreamerMatchEnded' } | { __typename?: 'StreamerMatchStarted' } | { __typename?: 'StreamerPlayerJoined' } | { __typename?: 'StreamerStreamEnded' } | { __typename?: 'StreamerStreamStarted' } | { __typename?: 'StreamerStreamTitleChanged' } | { __typename?: 'StreamerStreamerCardPurchased', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null } | { __typename?: 'StreamerSubscriptionGifted', userId: string, tier: number, recipientUserIds: Array<string>, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null } | { __typename?: 'StreamerSubscriptionRenewed', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null } | null } | null };

export type AlertsChannelActivityEventFragment = { __typename?: 'StreamerChannelActivityEvent', timestamp: string, id: string, content?: { __typename?: 'GameLogicHighScoringCardPromotedMsg', hscPlayer: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null }, card: { __typename?: 'GameLogicHighScoringCard', cardId: string, points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, boosterPoints: Array<{ __typename?: 'GameLogicPlayerBoosterPoints', userId: string, boosterId: number }> } } | { __typename?: 'StreamerAvatarItemPurchased' } | { __typename?: 'StreamerBundlePurchased', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null } | { __typename?: 'StreamerChannelFollowed', userId: string, follower: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } } | { __typename?: 'StreamerChannelSubscribed', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null } | { __typename?: 'StreamerMatchEnded' } | { __typename?: 'StreamerMatchStarted' } | { __typename?: 'StreamerPlayerJoined' } | { __typename?: 'StreamerStreamEnded' } | { __typename?: 'StreamerStreamStarted' } | { __typename?: 'StreamerStreamTitleChanged' } | { __typename?: 'StreamerStreamerCardPurchased', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null } | { __typename?: 'StreamerSubscriptionGifted', userId: string, tier: number, recipientUserIds: Array<string>, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null } | { __typename?: 'StreamerSubscriptionRenewed', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null } | null };

export type AlertsChannelActivityEventChannelFollowedFragment = { __typename?: 'StreamerChannelFollowed', userId: string, follower: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } };

export type AlertsChannelActivityEventSubscriptionGiftedFragment = { __typename?: 'StreamerSubscriptionGifted', userId: string, tier: number, recipientUserIds: Array<string>, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null };

export type AlertsChannelActivityEventChannelSubscribedFragment = { __typename?: 'StreamerChannelSubscribed', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null };

export type AlertsChannelActivityEventChannelSubscriptionRenewedFragment = { __typename?: 'StreamerSubscriptionRenewed', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null };

export type AlertsChannelActivityEventCreatorCardPurchasedFragment = { __typename?: 'StreamerStreamerCardPurchased', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null };

export type AlertsChannelActivityEventBundlePurchasedFragment = { __typename?: 'StreamerBundlePurchased', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null } | null };

export type AlertsChannelActivityEventHighScoringCardEventFragment = { __typename?: 'GameLogicHighScoringCardPromotedMsg', hscPlayer: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null }, card: { __typename?: 'GameLogicHighScoringCard', cardId: string, points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, boosterPoints: Array<{ __typename?: 'GameLogicPlayerBoosterPoints', userId: string, boosterId: number }> } };

export type AlertsChannelActivityEventProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string, avatarFullbody: string } | null };

export type AlertsTopPredictionsSubscriptionVariables = Exact<{
  streamId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type AlertsTopPredictionsSubscription = { __typename?: 'Subscription', streamTopActiveCardsSubscribe?: { __typename?: 'MatchTopCardsUpdate', content?: { __typename?: 'MatchTopCardsUpdateCardCountUpdate', cards: Array<{ __typename?: 'MatchCardCount', cardId: string, count: number, card: { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }>, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } } }> } | { __typename?: 'MatchTopCardsUpdateReset' } | null } | null };

export type AlertsTopPredictionsUpdateFragment = { __typename?: 'MatchTopCardsUpdateCardCountUpdate', cards: Array<{ __typename?: 'MatchCardCount', cardId: string, count: number, card: { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }>, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } } }> };

export type AlertsTopPredictionsCardCountFragment = { __typename?: 'MatchCardCount', cardId: string, count: number, card: { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }>, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } } };

export type AlertsTopPredictionsCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }>, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } };

export type UserAnnouncementsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type UserAnnouncementsQuery = { __typename?: 'Query', userAnnouncements?: { __typename?: 'AnnouncementListUserAnnouncementsResponse', announcements: Array<{ __typename?: 'AnnouncementAnnouncement', id: string, title: string, text: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, image: string }> } | null };

export type UseCategoryChallengeChallengeFragment = { __typename?: 'GameLogicChallenge', id: string, description: string, disabled: boolean };

export type CategoryChallengesQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type CategoryChallengesQuery = { __typename?: 'Query', listChallenges?: { __typename?: 'ChallengeListChallengesResponse', challenges: Array<{ __typename?: 'GameLogicChallenge', id: string, description: string, disabled: boolean }> } | null };

export type CreateChallengeMutationVariables = Exact<{
  gameId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  description: Scalars['String']['input'];
}>;


export type CreateChallengeMutation = { __typename?: 'Mutation', createChallenge?: { __typename?: 'GameLogicChallenge', id: string, description: string, disabled: boolean } | null };

export type UpdateChallengeMutationVariables = Exact<{
  gameId: Scalars['ID']['input'];
  challengeId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  description: Scalars['String']['input'];
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type UpdateChallengeMutation = { __typename?: 'Mutation', updateChallenge?: { __typename?: 'GameLogicChallenge', id: string, description: string, disabled: boolean } | null };

export type DeleteChallengeMutationVariables = Exact<{
  challengeId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type DeleteChallengeMutation = { __typename?: 'Mutation', deleteChallenge?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type NewChallengeFragment = { __typename?: 'GameLogicChallenge', id: string };

export type LatestStreamDataQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type LatestStreamDataQuery = { __typename?: 'Query', streams?: { __typename?: 'ChannelListStreamsResponse', streams: Array<{ __typename?: 'ChannelStream', streamId: string, segments: Array<{ __typename?: 'ChannelStreamSegment', segmentId: string, startTime: string }> }> } | null };

export type ChannelListQueryVariables = Exact<{
  cursor?: InputMaybe<Scalars['String']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ChannelListQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, channels: Array<{ __typename?: 'ChannelChannel', currentStreamId: string, id: string, liveStatus: ChannelLiveStatus, name: string }> } | null };

export type PrivilegedChannelListQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type PrivilegedChannelListQuery = { __typename?: 'Query', userPrivilegedChannels?: { __typename?: 'ChannelListUserPrivilegedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannelRoles', channelId: string, channel: { __typename?: 'ChannelChannel', currentStreamId: string, id: string, liveStatus: ChannelLiveStatus, name: string } }> } | null };

export type ChannelProviderDataQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type ChannelProviderDataQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, currentChatId?: string | null, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean, eligible: boolean } } | null, userChannelRoles?: { __typename?: 'ChannelListUserChannelRolesResponse', roles: Array<ChannelChannelRole> } | null, profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', acceptedTerms: Array<{ __typename?: 'AuthTermsVersion', name: string }> } | null } | null };

export type ChannelCurrentChatIdQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelCurrentChatIdQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, currentChatId?: string | null } | null };

export type ChannelProviderChannelsByNameQueryVariables = Exact<{
  channelName: Scalars['String']['input'];
}>;


export type ChannelProviderChannelsByNameQuery = { __typename?: 'Query', channelByName?: { __typename?: 'ChannelChannel', id: string } | null };

export type ChannelProviderCheckChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelProviderCheckChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, streamerId: string } | null };

export type ChannelRouteDataQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelRouteDataQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type OnboardingProviderDataQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type OnboardingProviderDataQuery = { __typename?: 'Query', streams?: { __typename?: 'ChannelListStreamsResponse', streams: Array<{ __typename?: 'ChannelStream', streamId: string }> } | null };

export type ModerationUserFragment = { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type LookerStudioReportIdQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type LookerStudioReportIdQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, reportingId: string } | null };

export type ProtectedRouteProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ProtectedRouteProfileQuery = { __typename?: 'Query', platformBan?: { __typename?: 'ModerationPlatformBan', banId: string } | null };

export type EditCategoryDataQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type EditCategoryDataQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, features: { __typename?: 'ChannelChannelFeatures', noicePredictions: { __typename?: 'ChannelNoicePredictionsFeatureStatus', enabled: boolean } } } | null, listGames?: { __typename?: 'GameListGamesResponse', games: Array<{ __typename?: 'GameGame', id: string, noicePredictionsEnabled: boolean, activeSeason: { __typename?: 'GameSeason', id: string, seasonBreak: boolean, seasonBreakReason: string } }> } | null };

export type UpdateEditStreamInfoPredictionGameMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  featureNoicePredictionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type UpdateEditStreamInfoPredictionGameMutation = { __typename?: 'Mutation', updateChannelDetails?: { __typename?: 'ChannelChannel', id: string } | null };

export type EditStreamKeyDataQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type EditStreamKeyDataQuery = { __typename?: 'Query', ingestConfigs?: { __typename?: 'StreamIngestConfigChannelIngestConfigs', channelId: string, configs: Array<{ __typename?: 'StreamIngestConfigIngestConfig', ingest?: { __typename?: 'StreamIngestConfigIngestConfigFTLConfig', streamKey: string } | null }> } | null };

export type RefreshStreamKeyMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type RefreshStreamKeyMutation = { __typename?: 'Mutation', refreshIngestConfigs?: { __typename?: 'StreamIngestConfigChannelIngestConfigs', channelId: string, configs: Array<{ __typename?: 'StreamIngestConfigIngestConfig', ingest?: { __typename?: 'StreamIngestConfigIngestConfigFTLConfig', streamKey: string } | null }> } | null };

export type EditStreamTitleChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type EditStreamTitleChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, title: string } | null };

export type UpdateStreamTitleMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
}>;


export type UpdateStreamTitleMutation = { __typename?: 'Mutation', updateChannelDetails?: { __typename?: 'ChannelChannel', title: string } | null };

export type MatureRatedContentChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type MatureRatedContentChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, matureRatedContent: boolean } | null };

export type UpdateChannelMatureRatedContentMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  matureRatedContent: Scalars['Boolean']['input'];
}>;


export type UpdateChannelMatureRatedContentMutation = { __typename?: 'Mutation', updateChannelDetails?: { __typename?: 'ChannelChannel', id: string, matureRatedContent: boolean } | null };

export type MatureRatedContentUpdatedChannelFragment = { __typename?: 'ChannelChannel', matureRatedContent: boolean };

export type StreamCategoryDataQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type StreamCategoryDataQuery = { __typename?: 'Query', streamBackendConfigs?: { __typename?: 'ChannelListStreamBackendConfigsResponse', configs: Array<{ __typename?: 'ChannelStreamBackendConfig', id: string, gameId: string }> } | null, listGames?: { __typename?: 'GameListGamesResponse', games: Array<{ __typename?: 'GameGame', id: string, name: string }> } | null, selectedStreamBackendConfig?: { __typename?: 'ChannelStreamBackendConfig', id: string, gameId: string, game: { __typename?: 'GameGame', id: string, gameEventsSource: GameGameEventsSource } } | null };

export type CreateStreamConfigMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  gameId: Scalars['ID']['input'];
}>;


export type CreateStreamConfigMutation = { __typename?: 'Mutation', createStreamBackendConfig?: { __typename?: 'ChannelStreamBackendConfig', id: string } | null };

export type SelectStreamConfigMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  configId: Scalars['ID']['input'];
}>;


export type SelectStreamConfigMutation = { __typename?: 'Mutation', selectStreamBackendConfig?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type CardGameEventHighScoringCardPlayerFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null };

export type CardGameEventMostPredictedCardCountFragment = { __typename?: 'MatchCardCount', cardId: string, count: number, card: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } };

export type StreamAlertsChannelByNameQueryVariables = Exact<{
  channelName: Scalars['String']['input'];
}>;


export type StreamAlertsChannelByNameQuery = { __typename?: 'Query', channelByName?: { __typename?: 'ChannelChannel', id: string, currentStreamId: string } | null };

export type StreamAlertsChannelLiveStatusSubscriptionVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type StreamAlertsChannelLiveStatusSubscription = { __typename?: 'Subscription', channelLiveStatusSubscribe?: { __typename?: 'ChannelLiveStatusEvent', channelId: string, liveStatus: ChannelLiveStatus, streamId: string } | null };

export type StreamAlertsChannelLiveStatusUpdateFragment = { __typename?: 'ChannelChannel', currentStreamId: string };

export type StreamChannelStatusSubscriptionVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type StreamChannelStatusSubscription = { __typename?: 'Subscription', channelStreamDetailSubscribe?: { __typename?: 'ChannelChannelStreamDetailEvent', streamId: string, channelId: string, noicePredictionsEnabled: boolean, challengesEnabled: boolean, serverRenderingEnabled: boolean } | null };

export type StreamStatusSubscriptionVariables = Exact<{
  channelId: Scalars['ID']['input'];
  streamId: Scalars['ID']['input'];
}>;


export type StreamStatusSubscription = { __typename?: 'Subscription', streamStatusSubscribe?: { __typename?: 'ChannelStreamStatusEvent', liveStatus: ChannelLiveStatus, mlStatus: StreamDeploymentStreamDeploymentStatusComponentStatus, crStatus: StreamDeploymentStreamDeploymentStatusComponentStatus, restreamingStatus: StreamDeploymentStreamDeploymentStatusComponentStatus, gameRunnerStatus: StreamDeploymentStreamDeploymentStatusComponentStatus } | null };

export type StreamIngestStatsSubscriptionVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type StreamIngestStatsSubscription = { __typename?: 'Subscription', ingestStatsSubscribe?: { __typename?: 'ChannelIngestStatsEvent', width: number, height: number, framerate: number, bitrate: number, bSlices: number, audioSampleRate: number, audioChannelCnt: number } | null };

export type StreamMatchStatusEventsSubscriptionVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type StreamMatchStatusEventsSubscription = { __typename?: 'Subscription', streamEventsSubscribe?: { __typename?: 'StreamerStreamEvent', content?: { __typename: 'GameLogicActiveCardSucceededMsg' } | { __typename: 'GameLogicHighScoringCardPromotedMsg' } | { __typename: 'GameLogicMatchEndedMsg' } | { __typename: 'GameLogicMatchPauseStateChangedMsg', paused: boolean } | { __typename: 'GameLogicMatchStartedMsg' } | { __typename: 'GameLogicPlayerJoinedMsg' } | { __typename: 'GameStateStreamState' } | { __typename: 'IntType' } | { __typename: 'StreamerChannelFollowed' } | { __typename: 'StreamerChannelSubscribed' } | { __typename: 'StreamerSubscriptionGifted' } | null } | null };

export type ChannelIngestStatsFragment = { __typename?: 'ChannelIngestStatsEvent', width: number, height: number, framerate: number, bitrate: number, bSlices: number, audioSampleRate: number, audioChannelCnt: number };

export type MatchStateQueryVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type MatchStateQuery = { __typename?: 'Query', matchState?: { __typename?: 'MatchGetMatchStateResponse', matchState: GameLogicStreamStateMatchState } | null };

export type TriggerCameraTransitionMutationVariables = Exact<{
  streamId: Scalars['ID']['input'];
  cameraTransitionTarget: RenderingCameraTransitionRequestTransitionTarget;
}>;


export type TriggerCameraTransitionMutation = { __typename?: 'Mutation', streamerTriggerCameraTransition?: { __typename?: 'StreamerTriggerCameraTransitionResponse', success: boolean } | null };

export type StreamActivityFeedHistoryQueryVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<StreamerChannelActivityEventFilterInput>;
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type StreamActivityFeedHistoryQuery = { __typename?: 'Query', channelActivityEvents?: { __typename?: 'StreamerListChannelActivityEventsResponse', events: Array<{ __typename?: 'StreamerChannelActivityEvent', timestamp: string, id: string, content?: { __typename?: 'GameLogicHighScoringCardPromotedMsg', userId: string, card: { __typename?: 'GameLogicHighScoringCard', cardId: string, points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } }, user: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } | { __typename?: 'StreamerAvatarItemPurchased', userId: string, itemId: string, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, item: { __typename?: 'ItemItem', id: string, name: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart', id: string, name: string } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } } | { __typename?: 'StreamerBundlePurchased', bundleName: string, userId: string, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null } | { __typename?: 'StreamerChannelFollowed', userId: string, follower: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } | { __typename?: 'StreamerChannelSubscribed', userId: string, subscriber?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null } | { __typename?: 'StreamerMatchEnded', streamId: string, bestPlayer?: { __typename?: 'GameLogicPlayerDetails', id: string, points: number, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } | null, bestCard?: { __typename?: 'GameLogicCardDetails', succeedingCard: { __typename?: 'GameLogicActiveCardSucceededMsg', cardId: string, points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } } | null, bestGroup?: { __typename?: 'GameLogicGroupDetails', group: { __typename?: 'GameLogicGroup', id: string, name: string, points: number }, players: Array<{ __typename?: 'GameLogicPlayerDetails', id: string, points: number, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } }> } | null, challengeStatuses?: Array<{ __typename?: 'GameLogicChallengeStatus', challengeId: string, pickRate: number, challengeState: GameLogicChallengeState, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType' } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType' } | { __typename: 'StringType' } | null } | null }> }> | null } | { __typename?: 'StreamerMatchStarted', streamId: string } | { __typename?: 'StreamerPlayerJoined', userId: string, viewer: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } | { __typename?: 'StreamerStreamEnded', streamId: string } | { __typename?: 'StreamerStreamStarted', streamId: string } | { __typename?: 'StreamerStreamTitleChanged', title: string } | { __typename?: 'StreamerStreamerCardPurchased', userId: string, streamerCardId: string, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, streamerCard: { __typename?: 'GameLogicStreamerCard', name: string } } | { __typename?: 'StreamerSubscriptionGifted', userId: string, tier: number, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, recipients?: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor }> | null } | { __typename?: 'StreamerSubscriptionRenewed', userId: string, subscriber?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null } | null }>, pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasPreviousPage: boolean } } | null };

export type StreamActivityFeedSubscriptionVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<StreamerChannelActivityEventFilterInput>;
}>;


export type StreamActivityFeedSubscription = { __typename?: 'Subscription', channelActivityEventsSubscribe?: { __typename?: 'StreamerChannelActivityEvent', timestamp: string, id: string, content?: { __typename?: 'GameLogicHighScoringCardPromotedMsg', userId: string, card: { __typename?: 'GameLogicHighScoringCard', cardId: string, points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } }, user: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } | { __typename?: 'StreamerAvatarItemPurchased', userId: string, itemId: string, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, item: { __typename?: 'ItemItem', id: string, name: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart', id: string, name: string } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } } | { __typename?: 'StreamerBundlePurchased', bundleName: string, userId: string, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null } | { __typename?: 'StreamerChannelFollowed', userId: string, follower: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } | { __typename?: 'StreamerChannelSubscribed', userId: string, subscriber?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null } | { __typename?: 'StreamerMatchEnded', streamId: string, bestPlayer?: { __typename?: 'GameLogicPlayerDetails', id: string, points: number, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } | null, bestCard?: { __typename?: 'GameLogicCardDetails', succeedingCard: { __typename?: 'GameLogicActiveCardSucceededMsg', cardId: string, points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } } | null, bestGroup?: { __typename?: 'GameLogicGroupDetails', group: { __typename?: 'GameLogicGroup', id: string, name: string, points: number }, players: Array<{ __typename?: 'GameLogicPlayerDetails', id: string, points: number, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } }> } | null, challengeStatuses?: Array<{ __typename?: 'GameLogicChallengeStatus', challengeId: string, pickRate: number, challengeState: GameLogicChallengeState, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType' } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType' } | { __typename: 'StringType' } | null } | null }> }> | null } | { __typename?: 'StreamerMatchStarted', streamId: string } | { __typename?: 'StreamerPlayerJoined', userId: string, viewer: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } | { __typename?: 'StreamerStreamEnded', streamId: string } | { __typename?: 'StreamerStreamStarted', streamId: string } | { __typename?: 'StreamerStreamTitleChanged', title: string } | { __typename?: 'StreamerStreamerCardPurchased', userId: string, streamerCardId: string, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, streamerCard: { __typename?: 'GameLogicStreamerCard', name: string } } | { __typename?: 'StreamerSubscriptionGifted', userId: string, tier: number, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, recipients?: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor }> | null } | { __typename?: 'StreamerSubscriptionRenewed', userId: string, subscriber?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null } | null } | null };

export type StreamActivityFeedAvatarItemPurchaseFragment = { __typename?: 'StreamerAvatarItemPurchased', userId: string, itemId: string, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, item: { __typename?: 'ItemItem', id: string, name: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart', id: string, name: string } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } };

export type AvatarCosmeticDetailsFragment = { __typename?: 'AvatarAvatarPart', id: string, name: string };

export type StreamActivityFeedChannelSubscriptionRenewedFragment = { __typename?: 'StreamerSubscriptionRenewed', userId: string, subscriber?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null };

export type StreamActivityFeedMatchStateUpdateStartedFragment = { __typename?: 'StreamerMatchStarted', streamId: string };

export type StreamActivityFeedMatchStateUpdateEndedFragment = { __typename?: 'StreamerMatchEnded', streamId: string, bestPlayer?: { __typename?: 'GameLogicPlayerDetails', id: string, points: number, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } | null, bestCard?: { __typename?: 'GameLogicCardDetails', succeedingCard: { __typename?: 'GameLogicActiveCardSucceededMsg', cardId: string, points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } } | null, bestGroup?: { __typename?: 'GameLogicGroupDetails', group: { __typename?: 'GameLogicGroup', id: string, name: string, points: number }, players: Array<{ __typename?: 'GameLogicPlayerDetails', id: string, points: number, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } }> } | null, challengeStatuses?: Array<{ __typename?: 'GameLogicChallengeStatus', challengeId: string, pickRate: number, challengeState: GameLogicChallengeState, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType' } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType' } | { __typename: 'StringType' } | null } | null }> }> | null };

export type StreamActivityFeedHighScoringCardFragment = { __typename?: 'GameLogicHighScoringCardPromotedMsg', userId: string, card: { __typename?: 'GameLogicHighScoringCard', cardId: string, points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } }, user: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } };

export type MatchResultsBestPlayFragment = { __typename?: 'StreamerMatchEnded', bestCard?: { __typename?: 'GameLogicCardDetails', succeedingCard: { __typename?: 'GameLogicActiveCardSucceededMsg', cardId: string, points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } } | null };

export type MatchResultsBestPlayerFragment = { __typename?: 'StreamerMatchEnded', bestPlayer?: { __typename?: 'GameLogicPlayerDetails', id: string, points: number, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } } | null };

export type MatchResultsBestTeamFragment = { __typename?: 'StreamerMatchEnded', bestGroup?: { __typename?: 'GameLogicGroupDetails', group: { __typename?: 'GameLogicGroup', id: string, name: string, points: number }, players: Array<{ __typename?: 'GameLogicPlayerDetails', id: string, points: number, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } }> } | null };

export type MatchResultsChallengesFragment = { __typename?: 'StreamerMatchEnded', challengeStatuses?: Array<{ __typename?: 'GameLogicChallengeStatus', challengeId: string, pickRate: number, challengeState: GameLogicChallengeState, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType' } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType' } | { __typename: 'StringType' } | null } | null }> }> | null };

export type ActivityFeedChallengeFragment = { __typename?: 'GameLogicChallenge', id: string, description: string, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType' } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType' } | { __typename: 'StringType' } | null } | null }> };

export type ActivityFeedChallengeDescriptionsQueryVariables = Exact<{
  challengeIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type ActivityFeedChallengeDescriptionsQuery = { __typename?: 'Query', challengesBatch?: { __typename?: 'ChallengeListChallengesResponse', challenges: Array<{ __typename?: 'GameLogicChallenge', id: string, description: string, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType' } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType' } | { __typename: 'StringType' } | null } | null }> }> } | null };

export type StreamActivityFeedNewChannelFollowerFragment = { __typename?: 'StreamerChannelFollowed', userId: string, follower: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } };

export type StreamActivityFeedNewChannelSubscriberFragment = { __typename?: 'StreamerChannelSubscribed', userId: string, subscriber?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null };

export type StreamActivityFeedNewChannelSubscriptionGiftedFragment = { __typename?: 'StreamerSubscriptionGifted', userId: string, tier: number, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, recipients?: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor }> | null };

export type StreamActivityFeedNewChannelViewerFragment = { __typename?: 'StreamerPlayerJoined', userId: string, viewer: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } };

export type StreamActivityFeedPremiumBundlePurchaseFragment = { __typename?: 'StreamerBundlePurchased', bundleName: string, userId: string, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null };

export type StreamActivityFeedStreamInfoUpdateTitleChangeFragment = { __typename?: 'StreamerStreamTitleChanged', title: string };

export type StreamActivityFeedStreamStateUpdateStartedFragment = { __typename?: 'StreamerStreamStarted', streamId: string };

export type StreamActivityFeedStreamStateUpdateEndedFragment = { __typename?: 'StreamerStreamEnded', streamId: string };

export type StreamActivityFeedStreamerCardPurchaseFragment = { __typename?: 'StreamerStreamerCardPurchased', userId: string, streamerCardId: string, buyer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, streamerCard: { __typename?: 'GameLogicStreamerCard', name: string } };

export type AudienceInsightsDataQueryVariables = Exact<{
  streamId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type AudienceInsightsDataQuery = { __typename?: 'Query', streamAudienceInsights?: { __typename?: 'StreamerStreamAudienceInsights', viewers: number, followers: number, subscribers: number, chatters: number, players: number } | null };

export type ApproveModerationItemMutationVariables = Exact<{
  chatId: Scalars['ID']['input'];
  moderationItemId: Scalars['ID']['input'];
}>;


export type ApproveModerationItemMutation = { __typename?: 'Mutation', allowChatModerationItem?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type DenyModerationItemMutationVariables = Exact<{
  chatId: Scalars['ID']['input'];
  moderationItemId: Scalars['ID']['input'];
}>;


export type DenyModerationItemMutation = { __typename?: 'Mutation', denyChatModerationItem?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type AutomodQueueChatModerationItemFragment = { __typename?: 'ChatModerationItem', expiresAt: string, expired: boolean, status: ChatModerationItemStatus, id: string, chatMessage: { __typename?: 'ChatChatMessage', createdAt: string, content: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string } | { __typename?: 'ChatTombstone', emptyTypeWorkaround: boolean } | null }, textClassification: { __typename?: 'ClassificationTextClassification', hashes: Array<number> }, sender: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }, reviewer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type AutomodQueueSubscriptionVariables = Exact<{
  chatId: Scalars['ID']['input'];
}>;


export type AutomodQueueSubscription = { __typename?: 'Subscription', chatAutoModQueueSubscribe?: { __typename?: 'ChatAutoModQueueEvent', event?: { __typename?: 'ChatAutoModQueueEventAdd', item: { __typename?: 'ChatModerationItem', expiresAt: string, expired: boolean, status: ChatModerationItemStatus, id: string, chatMessage: { __typename?: 'ChatChatMessage', createdAt: string, content: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string } | { __typename?: 'ChatTombstone', emptyTypeWorkaround: boolean } | null }, textClassification: { __typename?: 'ClassificationTextClassification', hashes: Array<number> }, sender: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }, reviewer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null } } | { __typename?: 'ChatAutoModQueueEventRemove', id: string } | { __typename?: 'ChatAutoModQueueEventUpdate', item: { __typename?: 'ChatModerationItem', expiresAt: string, expired: boolean, status: ChatModerationItemStatus, id: string, chatMessage: { __typename?: 'ChatChatMessage', createdAt: string, content: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string } | { __typename?: 'ChatTombstone', emptyTypeWorkaround: boolean } | null }, textClassification: { __typename?: 'ClassificationTextClassification', hashes: Array<number> }, sender: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }, reviewer?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null } } | null } | null };

export type ActiveSessionChallengeFragment = { __typename?: 'ChallengesessionChallenge', id: string, description: string };

export type PickingChallengesChallengeFragment = { __typename?: 'ChallengesessionChallenge', id: string, description: string };

export type SelectableChallengesChallengeFragment = { __typename?: 'ChallengesessionChallenge', id: string, description: string };

export type SetupChallengeSelectedChallengeFragment = { __typename?: 'ChallengesessionChallenge', id: string, description: string };

export type SetupChallengeChallengeFragment = { __typename?: 'ChallengesessionChallenge', id: string, description: string };

export type ChallengeFragment = { __typename?: 'ChallengesessionChallenge', id: string, description: string, state: ChallengesessionChallengeChallengeState };

export type ChallengeSessionChallengeStatusFragment = { __typename?: 'ChallengesessionChallenge', id: string, description: string };

export type ChallengeSessionFragment = { __typename?: 'ChallengesessionChallengeSession', id: string, submissionWindowLength: number, phase: ChallengesessionChallengeSessionPhase, challenges: Array<{ __typename?: 'ChallengesessionChallenge', id: string, description: string, state: ChallengesessionChallengeChallengeState }> };

export type ChallengeSessionQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  streamId: Scalars['ID']['input'];
}>;


export type ChallengeSessionQuery = { __typename?: 'Query', getChallengeSession?: { __typename?: 'ChallengesessionChallengeSession', id: string, submissionWindowLength: number, phase: ChallengesessionChallengeSessionPhase, challenges: Array<{ __typename?: 'ChallengesessionChallenge', id: string, description: string, state: ChallengesessionChallengeChallengeState }> } | null, channel?: { __typename?: 'ChannelChannel', id: string, streamedGames?: Array<{ __typename?: 'GameGame', id: string }> | null } | null };

export type CreateChallengeSessionMutationVariables = Exact<{
  gameId: Scalars['ID']['input'];
  streamId: Scalars['ID']['input'];
  challenges: Array<ChallengesessionChallengeInput> | ChallengesessionChallengeInput;
  submissionWindowLength: Scalars['Int']['input'];
}>;


export type CreateChallengeSessionMutation = { __typename?: 'Mutation', createChallengeSession?: { __typename?: 'ChallengesessionChallengeSession', id: string, submissionWindowLength: number, phase: ChallengesessionChallengeSessionPhase, challenges: Array<{ __typename?: 'ChallengesessionChallenge', id: string, description: string, state: ChallengesessionChallengeChallengeState }> } | null };

export type UpdateChallengeSessionMutationVariables = Exact<{
  gameId: Scalars['ID']['input'];
  streamId: Scalars['ID']['input'];
  challenges: Array<ChallengesessionChallengeInput> | ChallengesessionChallengeInput;
  submissionWindowLength: Scalars['Int']['input'];
}>;


export type UpdateChallengeSessionMutation = { __typename?: 'Mutation', updateChallengeSession?: { __typename?: 'ChallengesessionChallengeSession', id: string, submissionWindowLength: number, phase: ChallengesessionChallengeSessionPhase, challenges: Array<{ __typename?: 'ChallengesessionChallenge', id: string, description: string, state: ChallengesessionChallengeChallengeState }> } | null };

export type ProgressChallengeSessionMutationVariables = Exact<{
  streamId: Scalars['ID']['input'];
  phase: ChallengesessionChallengeSessionPhase;
}>;


export type ProgressChallengeSessionMutation = { __typename?: 'Mutation', progressChallengeSession?: { __typename?: 'ChallengesessionChallengeSession', id: string, submissionWindowLength: number, phase: ChallengesessionChallengeSessionPhase, challenges: Array<{ __typename?: 'ChallengesessionChallenge', id: string, description: string, state: ChallengesessionChallengeChallengeState }> } | null };

export type NewChallengeSessionFragment = { __typename?: 'ChallengesessionChallengeSession', id: string };

export type ChatUserListQueryVariables = Exact<{
  chatId: Scalars['ID']['input'];
}>;


export type ChatUserListQuery = { __typename?: 'Query', streamers?: { __typename?: 'ChatListChatUsersResponse', users: Array<{ __typename?: 'ChatChatUser', userId: string, senderInfo: { __typename?: 'ChatSenderInfo', userId: string, username: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } }> } | null, moderators?: { __typename?: 'ChatListChatUsersResponse', users: Array<{ __typename?: 'ChatChatUser', userId: string, senderInfo: { __typename?: 'ChatSenderInfo', userId: string, username: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } }> } | null, viewers?: { __typename?: 'ChatListChatUsersResponse', users: Array<{ __typename?: 'ChatChatUser', userId: string, senderInfo: { __typename?: 'ChatSenderInfo', userId: string, username: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } }> } | null };

export type ChatUserListUserFragment = { __typename?: 'ChatChatUser', userId: string, senderInfo: { __typename?: 'ChatSenderInfo', userId: string, username: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } };

export type ChatUserListItemSenderInfoFragment = { __typename?: 'ChatSenderInfo', userId: string, username: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type ChatUserListSectionSenderInfoFragment = { __typename?: 'ChatSenderInfo', userId: string, username: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type GameAndCrowdDetailsQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type GameAndCrowdDetailsQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, title: string, game: { __typename?: 'GameGame', id: string, name: string } } | null };

export type ModerationLogEventFragment = { __typename?: 'ChannelModerationEvent', id: string, channelId: string, timestamp: string, moderator?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, content: { __typename?: 'ChannelModerationEventContent', content?: { __typename?: 'ChannelAutomodItemAccepted', userId: string, message: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string } | { __typename?: 'ChatTombstone' } | null }, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelAutomodItemRejected', userId: string, message: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string } | { __typename?: 'ChatTombstone' } | null }, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelBanAppealAccepted', comment: string, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelBanAppealRejected', comment: string, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelUserBanned', description: string, violation: ChannelViolation, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelUserMuted', duration: string, reason: ChatReason, description: string, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelUserUnbanned', userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | null } };

export type ModerationLogUserFragment = { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ModerationEventsHistoryQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  filter?: InputMaybe<ChannelModerationEventsFilterInput>;
  cursor?: InputMaybe<Scalars['String']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ModerationEventsHistoryQuery = { __typename?: 'Query', moderationEvents?: { __typename?: 'ChannelListModerationEventsResponse', events: Array<{ __typename?: 'ChannelModerationEvent', id: string, channelId: string, timestamp: string, moderator?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, content: { __typename?: 'ChannelModerationEventContent', content?: { __typename?: 'ChannelAutomodItemAccepted', userId: string, message: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string } | { __typename?: 'ChatTombstone' } | null }, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelAutomodItemRejected', userId: string, message: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string } | { __typename?: 'ChatTombstone' } | null }, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelBanAppealAccepted', comment: string, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelBanAppealRejected', comment: string, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelUserBanned', description: string, violation: ChannelViolation, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelUserMuted', duration: string, reason: ChatReason, description: string, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelUserUnbanned', userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | null } }>, pageInfo: { __typename?: 'APIPageInfo', startCursor: string, hasPreviousPage: boolean } } | null };

export type ModerationEventsSubscriptionVariables = Exact<{
  channelId: Scalars['ID']['input'];
  filter?: InputMaybe<ChannelModerationEventsFilterInput>;
}>;


export type ModerationEventsSubscription = { __typename?: 'Subscription', moderationEventsSubscribe?: { __typename?: 'ChannelModerationEvent', id: string, channelId: string, timestamp: string, moderator?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, content: { __typename?: 'ChannelModerationEventContent', content?: { __typename?: 'ChannelAutomodItemAccepted', userId: string, message: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string } | { __typename?: 'ChatTombstone' } | null }, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelAutomodItemRejected', userId: string, message: { __typename?: 'ChatMessageContent', content?: { __typename?: 'ChatTextMessage', text: string } | { __typename?: 'ChatTombstone' } | null }, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelBanAppealAccepted', comment: string, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelBanAppealRejected', comment: string, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelUserBanned', description: string, violation: ChannelViolation, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelUserMuted', duration: string, reason: ChatReason, description: string, userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelUserUnbanned', userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | null } } | null };

export type EventListItemProfileFragment = { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type MatchStatusEndEventFragment = { __typename?: 'GameLogicMatchEndedMsg', streamId: string, bestCard?: { __typename?: 'GameLogicCardDetails', groupName: string, succeedingCard: { __typename?: 'GameLogicActiveCardSucceededMsg', points: number, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, card: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } } | null, bestGroup?: { __typename?: 'GameLogicGroupDetails', players: Array<{ __typename?: 'GameLogicPlayerDetails', id: string, groupName: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }>, group: { __typename?: 'GameLogicGroup', id: string, name: string, points: number } } | null, bestPlayer?: { __typename?: 'GameLogicPlayerDetails', id: string, points: number, groupName: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | null };

export type NewFollowerFragment = { __typename?: 'StreamerChannelFollowed', userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } };

export type NewGiftSubscriptionFragment = { __typename?: 'StreamerSubscriptionGifted', userId: string, gifter?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, recipients?: Array<{ __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> | null };

export type HighScoringCardEventFragment = { __typename?: 'GameLogicHighScoringCardPromotedMsg', groupName: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, card: { __typename?: 'GameLogicHighScoringCard', points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } };

export type NewSubscriberFragment = { __typename?: 'StreamerChannelSubscribed', userId: string, subscriber?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type UserHighlightProfileFragment = { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

type StreamMatchEvents_GameLogicActiveCardSucceededMsg_Fragment = { __typename?: 'GameLogicActiveCardSucceededMsg' };

type StreamMatchEvents_GameLogicHighScoringCardPromotedMsg_Fragment = { __typename?: 'GameLogicHighScoringCardPromotedMsg', groupName: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, card: { __typename?: 'GameLogicHighScoringCard', points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } };

type StreamMatchEvents_GameLogicMatchEndedMsg_Fragment = { __typename?: 'GameLogicMatchEndedMsg', streamId: string, bestCard?: { __typename?: 'GameLogicCardDetails', groupName: string, succeedingCard: { __typename?: 'GameLogicActiveCardSucceededMsg', points: number, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, card: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } } | null, bestGroup?: { __typename?: 'GameLogicGroupDetails', players: Array<{ __typename?: 'GameLogicPlayerDetails', id: string, groupName: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }>, group: { __typename?: 'GameLogicGroup', id: string, name: string, points: number } } | null, bestPlayer?: { __typename?: 'GameLogicPlayerDetails', id: string, points: number, groupName: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | null };

type StreamMatchEvents_GameLogicMatchPauseStateChangedMsg_Fragment = { __typename?: 'GameLogicMatchPauseStateChangedMsg' };

type StreamMatchEvents_GameLogicMatchStartedMsg_Fragment = { __typename?: 'GameLogicMatchStartedMsg', streamId: string };

type StreamMatchEvents_GameLogicPlayerJoinedMsg_Fragment = { __typename?: 'GameLogicPlayerJoinedMsg' };

type StreamMatchEvents_GameStateStreamState_Fragment = { __typename?: 'GameStateStreamState' };

type StreamMatchEvents_IntType_Fragment = { __typename?: 'IntType' };

type StreamMatchEvents_StreamerChannelFollowed_Fragment = { __typename?: 'StreamerChannelFollowed', userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } };

type StreamMatchEvents_StreamerChannelSubscribed_Fragment = { __typename?: 'StreamerChannelSubscribed', userId: string, subscriber?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

type StreamMatchEvents_StreamerSubscriptionGifted_Fragment = { __typename?: 'StreamerSubscriptionGifted', userId: string, gifter?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, recipients?: Array<{ __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> | null };

export type StreamMatchEventsFragment = StreamMatchEvents_GameLogicActiveCardSucceededMsg_Fragment | StreamMatchEvents_GameLogicHighScoringCardPromotedMsg_Fragment | StreamMatchEvents_GameLogicMatchEndedMsg_Fragment | StreamMatchEvents_GameLogicMatchPauseStateChangedMsg_Fragment | StreamMatchEvents_GameLogicMatchStartedMsg_Fragment | StreamMatchEvents_GameLogicPlayerJoinedMsg_Fragment | StreamMatchEvents_GameStateStreamState_Fragment | StreamMatchEvents_IntType_Fragment | StreamMatchEvents_StreamerChannelFollowed_Fragment | StreamMatchEvents_StreamerChannelSubscribed_Fragment | StreamMatchEvents_StreamerSubscriptionGifted_Fragment;

export type StreamEventsSubscriptionVariables = Exact<{
  streamId: Scalars['ID']['input'];
  filter?: InputMaybe<StreamerStreamEventFilterInput>;
  channelId: Scalars['ID']['input'];
}>;


export type StreamEventsSubscription = { __typename?: 'Subscription', streamEventsSubscribe?: { __typename?: 'StreamerStreamEvent', timestamp: string, content?: { __typename?: 'GameLogicActiveCardSucceededMsg' } | { __typename?: 'GameLogicHighScoringCardPromotedMsg', groupName: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, card: { __typename?: 'GameLogicHighScoringCard', points: number, card: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } } | { __typename?: 'GameLogicMatchEndedMsg', streamId: string, bestCard?: { __typename?: 'GameLogicCardDetails', groupName: string, succeedingCard: { __typename?: 'GameLogicActiveCardSucceededMsg', points: number, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, card: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } } } | null, bestGroup?: { __typename?: 'GameLogicGroupDetails', players: Array<{ __typename?: 'GameLogicPlayerDetails', id: string, groupName: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }>, group: { __typename?: 'GameLogicGroup', id: string, name: string, points: number } } | null, bestPlayer?: { __typename?: 'GameLogicPlayerDetails', id: string, points: number, groupName: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | null } | { __typename?: 'GameLogicMatchPauseStateChangedMsg' } | { __typename?: 'GameLogicMatchStartedMsg', streamId: string } | { __typename?: 'GameLogicPlayerJoinedMsg' } | { __typename?: 'GameStateStreamState' } | { __typename?: 'IntType' } | { __typename?: 'StreamerChannelFollowed', userId: string, user: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'StreamerChannelSubscribed', userId: string, subscriber?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null } | { __typename?: 'StreamerSubscriptionGifted', userId: string, gifter?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, recipients?: Array<{ __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> | null } | null } | null };

export type TopPredictionsSubscriptionVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type TopPredictionsSubscription = { __typename?: 'Subscription', streamTopActiveCardsSubscribe?: { __typename?: 'MatchTopCardsUpdate', content?: { __typename?: 'MatchTopCardsUpdateCardCountUpdate', cards: Array<{ __typename?: 'MatchCardCount', cardId: string, count: number, card: { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> } }> } | { __typename?: 'MatchTopCardsUpdateReset' } | null } | null };

export type TopActiveCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type TopPredictionsChallengePickRatesSubscriptionVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type TopPredictionsChallengePickRatesSubscription = { __typename?: 'Subscription', streamChallengeUpdatesSubscribe?: { __typename?: 'MatchChallengeUpdate', content?: { __typename?: 'MatchChallengeUpdateReset' } | { __typename?: 'MatchChallengeUpdateStatusUpdate', challenges: Array<{ __typename?: 'GameLogicChallengeStatus', challengeId: string, challengeState: GameLogicChallengeState, pickRate: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number }>, challenge: { __typename?: 'GameLogicChallenge', id: string, description: string, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number }> } }> } | null } | null };

export type NavigationSidebarChannelFragment = { __typename?: 'ChannelChannel', name: string, id: string, title: string, liveStatus: ChannelLiveStatus, logo: string };

export type AdminChannelListSelectorDefaultChannelsQueryVariables = Exact<{
  channelIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type AdminChannelListSelectorDefaultChannelsQuery = { __typename?: 'Query', liveChannels?: { __typename?: 'ChannelListChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus, name: string }> } | null, recentChannels?: { __typename?: 'ChannelBatchGetChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus, name: string }> } | null };

export type AdminChannelListSelectorSearchQueryVariables = Exact<{
  query?: InputMaybe<Scalars['String']['input']>;
}>;


export type AdminChannelListSelectorSearchQuery = { __typename?: 'Query', channelSearch?: { __typename?: 'SearchSearchResponse', resultItems: Array<{ __typename?: 'SearchResultItem', entityId: string, entity?: { __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus, name: string } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile' } | null }> } | null };

export type AdminChannelListSelectorChannelFragment = { __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus, name: string, logo: string };

export type ChannelSelectorOptionChannelFragment = { __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus, name: string };

export type SidebarChannelFragment = { __typename?: 'ChannelChannel', name: string, id: string, title: string, liveStatus: ChannelLiveStatus, logo: string };

export type PageWrapperChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type PageWrapperChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', subscriberCount: number, followerCount: number, isPublic: boolean, name: string, id: string, title: string, liveStatus: ChannelLiveStatus, logo: string } | null };

export type SidebarAnnouncementsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type SidebarAnnouncementsQuery = { __typename?: 'Query', userAnnouncements?: { __typename?: 'AnnouncementListUserAnnouncementsResponse', announcements: Array<{ __typename?: 'AnnouncementAnnouncement', id: string, title: string, text: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, image: string }> } | null };

export type SidebarAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', id: string, title: string, text: string, category: AnnouncementAnnouncementCategory, startTime?: string | null };

export type ProfileMenuQueryQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ProfileMenuQueryQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, lastSeen?: string | null, userTag: string, onlineStatus: ProfilePresenceStatus, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null } | null, userPrivilegedChannels?: { __typename?: 'ChannelListUserPrivilegedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannelRoles', channelId: string, roles: Array<ChannelChannelRole>, channel: { __typename?: 'ChannelChannel', id: string, name: string } }> } | null };

export type StudioTopBarFollowersSubscriptionVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type StudioTopBarFollowersSubscription = { __typename?: 'Subscription', channelFollowerCountSubscribe?: { __typename?: 'ChannelFollowerCountEvent', channelId: string, followerCount: number } | null };

export type ForceMatchEndMutationVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type ForceMatchEndMutation = { __typename?: 'Mutation', mlTriggerMatchEnd?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type TopBarChannelFragment = { __typename?: 'ChannelChannel', subscriberCount: number, followerCount: number, isPublic: boolean };

export type TopBarStreamQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type TopBarStreamQuery = { __typename?: 'Query', stream?: { __typename?: 'ChannelStream', streamId: string, segments: Array<{ __typename?: 'ChannelStreamSegment', startTime: string, segmentId: string }> } | null };

export type TopBarChannelViewerCountSubscriptionVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type TopBarChannelViewerCountSubscription = { __typename?: 'Subscription', channelViewerCountSubscribe?: { __typename?: 'ChannelViewerCountEvent', viewerCount: number } | null };

export type SelectedStreamGameQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type SelectedStreamGameQuery = { __typename?: 'Query', selectedStreamBackendConfig?: { __typename?: 'ChannelStreamBackendConfig', id: string, game: { __typename?: 'GameGame', id: string, name: string, gameEventsSource: GameGameEventsSource } } | null };

export type SufficientStreamHudScaleSubscriptionVariables = Exact<{
  streamId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type SufficientStreamHudScaleSubscription = { __typename?: 'Subscription', mlHUDScaleUpdatesSubscribe?: { __typename?: 'MlControllerGetHUDScaleResponse', mlDisabled: boolean, isScaleSufficient: boolean } | null };

export type CategoryChallengeFragment = { __typename?: 'GameLogicChallenge', id: string, description: string, disabled: boolean };

export type CategoryOverviewChallengeFragment = { __typename?: 'GameLogicChallenge', id: string, description: string, disabled: boolean };

export type ChallengesOverviewCategoryFragment = { __typename?: 'GameGame', id: string, name: string };

export type SelectedChallengeCategoryFragment = { __typename?: 'GameGame', id: string, name: string };

export type ChallengesCategoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type ChallengesCategoriesQuery = { __typename?: 'Query', listGames?: { __typename?: 'GameListGamesResponse', games: Array<{ __typename?: 'GameGame', id: string, name: string }> } | null };

export type NoicePredictionsSectionDataQueryVariables = Exact<{ [key: string]: never; }>;


export type NoicePredictionsSectionDataQuery = { __typename?: 'Query', listGames?: { __typename?: 'GameListGamesResponse', games: Array<{ __typename?: 'GameGame', id: string, gameEventsSource: GameGameEventsSource }> } | null };

export type SubmitMonetizationAgreementMutationVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  address?: InputMaybe<ApiAddressInput>;
  birthday?: InputMaybe<ApiDateInput>;
  gender?: InputMaybe<ChannelGender>;
}>;


export type SubmitMonetizationAgreementMutation = { __typename?: 'Mutation', acceptMonetizationTerms?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ListCreatorCardBaseCardsQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
  seasonId: Scalars['ID']['input'];
}>;


export type ListCreatorCardBaseCardsQuery = { __typename?: 'Query', items?: { __typename?: 'ItemListItemsResponse', items: Array<{ __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, familyId: string, name: string } | { __typename?: 'GameLogicStreamerCard' } | null }> } | null };

export type ListCreatorCardBaseCardsAllQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
  seasonId: Scalars['ID']['input'];
}>;


export type ListCreatorCardBaseCardsAllQuery = { __typename?: 'Query', items?: { __typename?: 'ItemListItemsResponse', items: Array<{ __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard', id: string, familyId: string, name: string } | { __typename?: 'GameLogicStreamerCard' } | null }> } | null };

export type ListGameLogicCardFragment = { __typename?: 'GameLogicCard', id: string, familyId: string, name: string };

export type CreatorCardFormCardBaseCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type CreatorCardFormCardBaseCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, familyId: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, season: { __typename?: 'GameSeason', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } }, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type CreatorCardFormCardStreamerCardQueryVariables = Exact<{
  cardId: Scalars['ID']['input'];
}>;


export type CreatorCardFormCardStreamerCardQuery = { __typename?: 'Query', streamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null };

export type CreatorCardFormStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } };

export type CreatorCardStatusCardFragment = { __typename?: 'GameLogicStreamerCard', draft: boolean, video: string, image: string, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, enabled: boolean, excludeFromBundles: boolean } | null };

export type ChannelPlayedGamesQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelPlayedGamesQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, streamedGames?: Array<{ __typename?: 'GameGame', id: string, name: string, noicePredictionsEnabled: boolean, activeSeason: { __typename?: 'GameSeason', id: string, name: string } }> | null } | null };

export type CreatorCardGameFragment = { __typename?: 'GameGame', id: string, name: string, noicePredictionsEnabled: boolean, activeSeason: { __typename?: 'GameSeason', id: string, name: string } };

export type CreatorCardViewCreatorCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, name: string, draft: boolean, video: string, image: string, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, enabled: boolean, excludeFromBundles: boolean } | null, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } };

export type CreatorCardViewBaseCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, season: { __typename?: 'GameSeason', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } };

export type CreatorCardAssetCreateTokenMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  cardId: Scalars['ID']['input'];
  assetType?: InputMaybe<GameCardAssetType>;
}>;


export type CreatorCardAssetCreateTokenMutation = { __typename?: 'Mutation', createStreamerCardAssetUploadToken?: { __typename?: 'GameCardCreateStreamerCardAssetUploadTokenResponse', token: string } | null };

export type UploadVideoCreatorCardFragment = { __typename?: 'GameLogicStreamerCard', video: string };

export type UploadImageCreatorCardFragment = { __typename?: 'GameLogicStreamerCard', image: string };

export type CreateCreatorCardChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type CreateCreatorCardChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } | null };

export type CreateCreatorCardDraftMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  familyId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type CreateCreatorCardDraftMutation = { __typename?: 'Mutation', createStreamerCardDraft?: { __typename?: 'GameLogicStreamerCard', id: string, name: string, draft: boolean, video: string, image: string, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, enabled: boolean, excludeFromBundles: boolean } | null, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null };

export type CreatorCardViewCreatorCardWithBaseCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, name: string, draft: boolean, video: string, image: string, baseCard: { __typename?: 'GameLogicCard', id: string }, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, enabled: boolean, excludeFromBundles: boolean } | null, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } };

export type CreatorCardPublishSectionCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, draft: boolean, video: string, image: string, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, enabled: boolean, excludeFromBundles: boolean } | null };

export type PublishDraftCreatorCardMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  cardId: Scalars['ID']['input'];
}>;


export type PublishDraftCreatorCardMutation = { __typename?: 'Mutation', publishStreamerCardDraft?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type PublishedStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', draft: boolean };

export type CreatorCardViewCardQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type CreatorCardViewCardQuery = { __typename?: 'Query', streamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, name: string, draft: boolean, video: string, image: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, season: { __typename?: 'GameSeason', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } }, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, enabled: boolean, excludeFromBundles: boolean } | null, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null };

export type CreateCreatorCardSaleConfigMutationVariables = Exact<{
  cardId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  enabled: Scalars['Boolean']['input'];
  excludeFromBundles?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type CreateCreatorCardSaleConfigMutation = { __typename?: 'Mutation', createStreamerCardSaleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string } | null };

export type CreatedCreatorCardSaleConfigFragment = { __typename?: 'GameLogicStreamerCard', saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, channelId: string, enabled: boolean, excludeFromBundles: boolean } | null };

export type DeleteDraftCardMutationVariables = Exact<{
  cardId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type DeleteDraftCardMutation = { __typename?: 'Mutation', deleteStreamerCardDraft?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type UpdateCreatorCardSaleConfigMutationVariables = Exact<{
  cardId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  excludeFromBundles?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type UpdateCreatorCardSaleConfigMutation = { __typename?: 'Mutation', updateStreamerCardSaleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string } | null };

export type UpdatedCreatorCardSaleConfigFragment = { __typename?: 'GameLogicStreamerCard', saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, enabled: boolean, excludeFromBundles: boolean } | null };

export type CreatorCardsQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  gameId: Scalars['ID']['input'];
}>;


export type CreatorCardsQuery = { __typename?: 'Query', streamerCards?: { __typename?: 'GameCardListStreamerCardsResponse', cards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, name: string, draft: boolean, video: string, image: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, enabled: boolean, excludeFromBundles: boolean } | null, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }> } | null };

export type DraftCreatorCardsQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  gameId: Scalars['ID']['input'];
}>;


export type DraftCreatorCardsQuery = { __typename?: 'Query', streamerCardDrafts?: { __typename?: 'GameCardListStreamerCardDraftsResponse', cards: Array<{ __typename?: 'GameLogicStreamerCard', id: string, name: string, draft: boolean, video: string, image: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, enabled: boolean, excludeFromBundles: boolean } | null, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } }> } | null };

export type CreatorCardListCardFragment = { __typename?: 'GameLogicStreamerCard', name: string, id: string, draft: boolean, video: string, image: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }, saleConfig?: { __typename?: 'StoreV2StreamerCardSaleConfig', cardId: string, enabled: boolean, excludeFromBundles: boolean } | null, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } };

export type StreamedGameFragment = { __typename?: 'GameGame', id: string, name: string };

export type DraftCreatorCardEditPageQueryVariables = Exact<{
  cardId: Scalars['ID']['input'];
}>;


export type DraftCreatorCardEditPageQuery = { __typename?: 'Query', streamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, draft: boolean, name: string, familyId: string, gameId: string, image: string, video: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, season: { __typename?: 'GameSeason', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } } } | null };

export type UpdateDraftCreatorCardMutationVariables = Exact<{
  cardId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  gameId?: InputMaybe<Scalars['ID']['input']>;
  familyId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
}>;


export type UpdateDraftCreatorCardMutation = { __typename?: 'Mutation', updateStreamerCardDraft?: { __typename?: 'GameLogicStreamerCard', id: string, name: string, familyId: string, gameId: string, baseCard: { __typename?: 'GameLogicCard', id: string, seasonId: string } } | null };

export type UpdatedDraftCreatorCardFragment = { __typename?: 'GameLogicStreamerCard', name: string, familyId: string, gameId: string, baseCard: { __typename?: 'GameLogicCard', id: string } };

export type ChannelSubscriptionSettingSubscriptionConfigFragment = { __typename?: 'SubscriptionChannelSubscriptionConfig', subscriptionsEnabled: boolean };

export type ChannelUpdateSubscriptionConfigMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  subscriptionsEnabled: Scalars['Boolean']['input'];
}>;


export type ChannelUpdateSubscriptionConfigMutation = { __typename?: 'Mutation', updateChannelSubscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null };

export type ChannelEmojiFormContentEmojiFragment = { __typename?: 'EmojiEmoji', label: string, image: string, disabled: boolean };

export type ChannelEmojiFormContentChannelFragment = { __typename?: 'ChannelChannel', name: string };

export type ChannelEmojisQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type ChannelEmojisQuery = { __typename?: 'Query', channelEmojis?: { __typename?: 'EmojiListChannelEmojisResponse', emojis: Array<{ __typename?: 'EmojiEmoji', id: string, image: string, label: string, disabled: boolean }>, pageInfo: { __typename?: 'APIPageInfo', hasNextPage: boolean, endCursor: string, hasPreviousPage: boolean }, count?: { __typename?: 'ItemItemTotalCount', total: number, disabled: number } | null } | null };

export type AddEmojiChannelQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type AddEmojiChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type CreateEmojiMutationVariables = Exact<{
  label: Scalars['String']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type CreateEmojiMutation = { __typename?: 'Mutation', createChannelEmoji?: { __typename?: 'EmojiEmoji', id: string, label: string, channelId: string, disabled: boolean } | null };

export type EnableCreatedEmojiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type EnableCreatedEmojiMutation = { __typename?: 'Mutation', updateChannelEmoji?: { __typename?: 'EmojiEmoji', id: string, disabled: boolean } | null };

export type ChannelEmojiQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type ChannelEmojiQuery = { __typename?: 'Query', emoji?: { __typename?: 'EmojiEmoji', id: string, channelId: string, label: string, image: string, disabled: boolean } | null, channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type EditChannelEmojiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  label?: InputMaybe<Scalars['String']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type EditChannelEmojiMutation = { __typename?: 'Mutation', updateChannelEmoji?: { __typename?: 'EmojiEmoji', id: string, label: string, disabled: boolean } | null };

export type DeleteChannelEmojiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type DeleteChannelEmojiMutation = { __typename?: 'Mutation', deleteChannelEmoji?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChannelEmojiMaxAmountQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelEmojiMaxAmountQuery = { __typename?: 'Query', channelEmojis?: { __typename?: 'EmojiListChannelEmojisResponse', count?: { __typename?: 'ItemItemTotalCount', total: number, disabled: number } | null } | null };

export type ChannelEmojiSubscriptionStateQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelEmojiSubscriptionStateQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null } | null };

export type SubscriptionsMonetizationDataQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type SubscriptionsMonetizationDataQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, subscriberCount: number, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> }> } | null, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', enabled: boolean } } | null };

export type MonetizationSubscribersQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type MonetizationSubscribersQuery = { __typename?: 'Query', channelSubscriptions?: { __typename?: 'SubscriptionListChannelSubscriptionsResponse', subscriptions: Array<{ __typename?: 'SubscriptionChannelSubscription', id: string, activatedAt?: string | null, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } }>, pageInfo: { __typename?: 'APIPageInfo', hasNextPage: boolean, endCursor: string } } | null };

export type MonetizationSubscribersCountQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type MonetizationSubscribersCountQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, subscriberCount: number } | null };

export type NoAccessUserDataQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type NoAccessUserDataQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, userPrivilegedChannels?: { __typename?: 'ChannelListUserPrivilegedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannelRoles', channelId: string }> } | null };

export type AutomodSettingsQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type AutomodSettingsQuery = { __typename?: 'Query', channelModerationSettings?: { __typename?: 'ChannelModerationSettings', automod: { __typename?: 'ChannelAutomodSettings', level: ChatAutomodLevel, defaultDecision: ChatAutomodDecision } } | null };

export type UpdateAutomodSettingsMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  automod?: InputMaybe<ChannelAutomodSettingsInput>;
}>;


export type UpdateAutomodSettingsMutation = { __typename?: 'Mutation', updateChannelModerationSettings?: { __typename?: 'ChannelModerationSettings', automod: { __typename?: 'ChannelAutomodSettings', level: ChatAutomodLevel, defaultDecision: ChatAutomodDecision } } | null };

export type BanDetailsUserFragment = { __typename?: 'ChannelBannedUser', userId: string, bannedAt: string, violation: ChannelViolation, description: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, moderator: { __typename?: 'ProfileProfile', userId: string, userTag: string }, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus, appealText: string, createdAt: string } | null };

export type BannedUserBannedUserFragment = { __typename?: 'ChannelBannedUser', userId: string, bannedAt: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus } | null };

export type SearchUserToBanQueryVariables = Exact<{
  username: Scalars['String']['input'];
}>;


export type SearchUserToBanQuery = { __typename?: 'Query', resolveUserTags?: { __typename?: 'ProfileResolveUserTagsResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string }>, userIds: Array<{ __typename?: 'ProfileResolveUserTagsResponseUserIdsEntry', key: string, value: string }> } | null };

export type SettingsBanFormUserChannelStateQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type SettingsBanFormUserChannelStateQuery = { __typename?: 'Query', channelBanUserStatus?: { __typename?: 'ChannelUserBanStatus', userId: string, channelId: string, banned: boolean } | null, userChannelRoles?: { __typename?: 'ChannelListUserChannelRolesResponse', roles: Array<ChannelChannelRole> } | null };

export type ModerationBannedListQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ModerationBannedListQuery = { __typename?: 'Query', channelBannedUsers?: { __typename?: 'ChannelListBannedUsersResponse', users: Array<{ __typename?: 'ChannelBannedUser', channelId: string, userId: string, bannedAt: string, violation: ChannelViolation, description: string, user: { __typename?: 'ProfileProfile', userTag: string, userId: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus, appealText: string, createdAt: string } | null, moderator: { __typename?: 'ProfileProfile', userId: string, userTag: string } }>, pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean } } | null };

export type ModerationUpdateChannelBanAppealMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  status: ChannelAppealStatus;
}>;


export type ModerationUpdateChannelBanAppealMutation = { __typename?: 'Mutation', updateChannelBanAppeal?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ArenaBlockArenaFragment = { __typename?: 'ArenaArena', id: string, name: string, thumbnailUrl: string, enabled: boolean };

export type ArenaBlockChannelStreamBackendConfigFragment = { __typename?: 'ChannelStreamBackendConfig', id: string, crConfig?: { __typename?: 'ChannelContentRendererConfig', arenaId: string, containerImage: string, controllerContainerImage: string } | null };

export type ArenaBlockUpdateCrConfigMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  containerImage?: InputMaybe<Scalars['String']['input']>;
  controllerContainerImage?: InputMaybe<Scalars['String']['input']>;
  arenaId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ArenaBlockUpdateCrConfigMutation = { __typename?: 'Mutation', updateStreamBackendConfig?: { __typename?: 'ChannelStreamBackendConfig', id: string, crConfig?: { __typename?: 'ChannelContentRendererConfig', arenaId: string, containerImage: string, controllerContainerImage: string } | null } | null };

export type ArenaBlockStreamSettingsQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ArenaBlockStreamSettingsQuery = { __typename?: 'Query', selectedStreamBackendConfig?: { __typename?: 'ChannelStreamBackendConfig', id: string, crConfig?: { __typename?: 'ChannelContentRendererConfig', arenaId: string, containerImage: string, controllerContainerImage: string } | null } | null, arenas?: { __typename?: 'ArenaListArenasResponse', arenas: Array<{ __typename?: 'ArenaArena', id: string, name: string, thumbnailUrl: string, enabled: boolean }> } | null };

export type DeleteLogoImageMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  assetType: ChannelAssetType;
}>;


export type DeleteLogoImageMutation = { __typename?: 'Mutation', deleteChannelAsset?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type LogoImageBlockChannelFragment = { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, logo: string, name: string };

export type DeleteBannerImageMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  assetType: ChannelAssetType;
}>;


export type DeleteBannerImageMutation = { __typename?: 'Mutation', deleteChannelAsset?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type OfflineBannerBlockChannelFragment = { __typename?: 'ChannelChannel', offlineBanner: string };

export type SettingsChannelBrandingQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type SettingsChannelBrandingQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, id: string, offlineBanner: string, logo: string, name: string } | null };

export type SettingsChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type SettingsChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, description: string, name: string, title: string, links: Array<{ __typename?: 'ChannelChannelLink', name: string, type: ChannelChannelLinkLinkType, url: string }> } | null };

export type UpdateChannelDetailsMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  links?: InputMaybe<Array<ChannelChannelLinkInput> | ChannelChannelLinkInput>;
}>;


export type UpdateChannelDetailsMutation = { __typename?: 'Mutation', updateChannelDetails?: { __typename?: 'ChannelChannel', id: string, description: string, links: Array<{ __typename?: 'ChannelChannelLink', name: string, type: ChannelChannelLinkLinkType, url: string }> } | null };

export type ChannelInfoUpdateFragment = { __typename?: 'ChannelChannel', id: string, description: string, links: Array<{ __typename?: 'ChannelChannelLink', name: string, type: ChannelChannelLinkLinkType, url: string }> };

export type OnlineUsersQueryVariables = Exact<{
  chatId: Scalars['ID']['input'];
}>;


export type OnlineUsersQuery = { __typename?: 'Query', chatUsers?: { __typename?: 'ChatListChatUsersResponse', users: Array<{ __typename?: 'ChatChatUser', userId: string, user: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', uid: string, roles: Array<AuthPlatformRole> } | null } }> } | null };

export type ModeratorDialogUsersQueryVariables = Exact<{
  userTags?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type ModeratorDialogUsersQuery = { __typename?: 'Query', resolveUserTags?: { __typename?: 'ProfileResolveUserTagsResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> } | null };

export type ModeratorDialogSuggestedUsersQueryVariables = Exact<{
  userIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type ModeratorDialogSuggestedUsersQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> } | null };

export type ModeratorProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ModeratorListPrivilegedUsersQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  pageSize: Scalars['Int']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type ModeratorListPrivilegedUsersQuery = { __typename?: 'Query', channelPrivilegedUsers?: { __typename?: 'ChannelListChannelPrivilegedUsersResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, users: Array<{ __typename?: 'ChannelPrivilegedUser', userId: string, roles: Array<ChannelChannelRole>, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> } | null };

export type SetUserRolesMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
  roles?: InputMaybe<Array<ChannelChannelRole> | ChannelChannelRole>;
}>;


export type SetUserRolesMutation = { __typename?: 'Mutation', setUserChannelRoles?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ModeratorSettingsDataQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ModeratorSettingsDataQuery = { __typename?: 'Query', channelModerationSettings?: { __typename?: 'ChannelModerationSettings', channelId: string, banAppealsEnabled: boolean } | null };

export type UpdateChannelModerationBanAppealSettingMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  banAppealsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type UpdateChannelModerationBanAppealSettingMutation = { __typename?: 'Mutation', updateChannelModerationSettings?: { __typename?: 'ChannelModerationSettings', banAppealsEnabled: boolean } | null };

export type SimulcastingDestinationPreviewConfigFragment = { __typename?: 'ChannelRestreamingConfig', channelId: string, rtmpEndpoint: string, bitrate: number, enabled: boolean };

export type SimulcastingSettingsOverviewConfigFragment = { __typename?: 'ChannelRestreamingConfig', channelId: string, rtmpEndpoint: string, bitrate: number, enabled: boolean };

export type SimulcastingDestinationConfigFragment = { __typename?: 'ChannelRestreamingConfig', channelId: string, rtmpEndpoint: string, rtmpKey: string, bitrate: number, enabled: boolean };

export type ChannelSimulcastingConfigQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelSimulcastingConfigQuery = { __typename?: 'Query', restreamingConfig?: { __typename?: 'ChannelRestreamingConfig', channelId: string, rtmpEndpoint: string, rtmpKey: string, bitrate: number, enabled: boolean } | null };

export type UpdateChannelSimulcastingConfigMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  rtmpEndpoint?: InputMaybe<Scalars['String']['input']>;
  rtmpKey?: InputMaybe<Scalars['String']['input']>;
  bitrate?: InputMaybe<Scalars['Int']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type UpdateChannelSimulcastingConfigMutation = { __typename?: 'Mutation', updateRestreamingConfig?: { __typename?: 'ChannelRestreamingConfig', channelId: string, rtmpEndpoint: string, rtmpKey: string, bitrate: number, enabled: boolean } | null };

export type RestreamingConfigFragmentFragment = { __typename?: 'ChannelRestreamingConfig', channelId: string, enabled: boolean, rtmpEndpoint: string, rtmpKey: string, bitrate: number };

export type ChannelRestreamingConfigQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelRestreamingConfigQuery = { __typename?: 'Query', restreamingConfig?: { __typename?: 'ChannelRestreamingConfig', channelId: string, enabled: boolean, rtmpEndpoint: string, rtmpKey: string, bitrate: number } | null };

export type UpdateChannelRestreamingConfigMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  rtmpEndpoint?: InputMaybe<Scalars['String']['input']>;
  rtmpKey?: InputMaybe<Scalars['String']['input']>;
  bitrate?: InputMaybe<Scalars['Int']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type UpdateChannelRestreamingConfigMutation = { __typename?: 'Mutation', updateRestreamingConfig?: { __typename?: 'ChannelRestreamingConfig', channelId: string, enabled: boolean, rtmpEndpoint: string, rtmpKey: string, bitrate: number } | null };

export type StudioChannelVisibilityChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type StudioChannelVisibilityChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, isPublic: boolean } | null };

export type StudioUpdateChannelVisibilityMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type StudioUpdateChannelVisibilityMutation = { __typename?: 'Mutation', updateChannelDetails?: { __typename?: 'ChannelChannel', id: string, isPublic: boolean } | null };

export type PrivacyUpdateChannelFragment = { __typename?: 'ChannelChannel', id: string, isPublic: boolean };

export type WidgetWrapperUserQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type WidgetWrapperUserQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', email: string } | null } | null };

export type ExternalPopoutProfileFragment = { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', email: string } | null };

export type StudioSuspendedQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type StudioSuspendedQuery = { __typename?: 'Query', platformBan?: { __typename?: 'ModerationPlatformBan', banId: string, expiresAt?: string | null, violation: ModerationViolation, description: string } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type GetMatchEndDailyBoostQueryVariables = Exact<{ [key: string]: never; }>;


export type GetMatchEndDailyBoostQuery = { __typename?: 'Query', dailyXPBoostLimit?: { __typename?: 'ProgressionGetDailyXPBoostLimitResponse', remainingDailyXpBoost: number } | null };

export type GetMatchEndLevelThresholdsQueryVariables = Exact<{
  seasonId: Scalars['ID']['input'];
  startLevel: Scalars['Int']['input'];
  endLevel: Scalars['Int']['input'];
}>;


export type GetMatchEndLevelThresholdsQuery = { __typename?: 'Query', listLevelConfigs?: { __typename?: 'ProgressionListLevelConfigsResponse', levelConfigs: Array<{ __typename?: 'ProgressionLevelConfig', threshold: number }> } | null };

export type MatchEndLevelThresholdsFragment = { __typename?: 'ProgressionLevelConfig', threshold: number };

export type GetMatchEndPlayerLevelQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  seasonId: Scalars['ID']['input'];
}>;


export type GetMatchEndPlayerLevelQuery = { __typename?: 'Query', seasonProgression?: { __typename?: 'ProgressionSeasonProgression', level: number, nextLevel: number } | null };

export type MatchEndPlayerLevelFragment = { __typename?: 'ProgressionSeasonProgression', level: number, nextLevel: number };

export type MatchResultsDialogBestPlayGameCardsQueryVariables = Exact<{
  cardIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type MatchResultsDialogBestPlayGameCardsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type MatchResultsDialogBestPlayProfilesQueryVariables = Exact<{
  userIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type MatchResultsDialogBestPlayProfilesQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> } | null };

export type MatchResultsDialogPlayerScoresProfileQueryVariables = Exact<{
  userIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type MatchResultsDialogPlayerScoresProfileQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string, avatar2D: string } | null }> } | null };

export type MatchResultsDialogRewardsGameQueryVariables = Exact<{
  gameId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type MatchResultsDialogRewardsGameQuery = { __typename?: 'Query', game?: { __typename?: 'GameGame', id: string, name: string, activeSeason: { __typename?: 'GameSeason', id: string, name: string, progression: { __typename?: 'ProgressionSeasonProgression', level: number } } } | null };

export type MatchResultsSummaryPlayerScoreProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type MatchResultsSummaryPlayerScoresProfileQueryVariables = Exact<{
  userIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type MatchResultsSummaryPlayerScoresProfileQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> } | null };

export type MatchGroupWaitingLgPlayersQueryVariables = Exact<{
  playerIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type MatchGroupWaitingLgPlayersQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } }> } | null };

export type BestPlaysDataQueryVariables = Exact<{
  cardIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
  userIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type BestPlaysDataQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null, profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null }> } | null };

export type BestPlayProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null };

export type DisplayBottomLgPlayerQueryVariables = Exact<{
  playerId: Scalars['ID']['input'];
}>;


export type DisplayBottomLgPlayerQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } | null };

export type PlayerScoreProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string };

export type AllOrNothingDialogCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type AllOrNothingDialogCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type CardSelectCardsQueryVariables = Exact<{
  cardIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type CardSelectCardsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type CardSelectMatchCardsQueryVariables = Exact<{
  cardIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type CardSelectMatchCardsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type HighScoringCardDataQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
  playerId: Scalars['ID']['input'];
}>;


export type HighScoringCardDataQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null } | null };

export type HighScoringCardPlayerFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null };

export type SpectatorPlayerDisplayProfileQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type SpectatorPlayerDisplayProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } | null };

export type SpectatorDisplayBottomProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type SpectatorPlayerInfoProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type DisplayBottomSmPlayerQueryVariables = Exact<{
  playerId: Scalars['ID']['input'];
}>;


export type DisplayBottomSmPlayerQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } | null };

export type PlayerScoreProfileQueryVariables = Exact<{
  playerId: Scalars['ID']['input'];
}>;


export type PlayerScoreProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type CardSelectSmCardsQueryVariables = Exact<{
  cardIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type CardSelectSmCardsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type ProgressionPausedSeasonQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ProgressionPausedSeasonQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, game: { __typename?: 'GameGame', id: string, activeSeason: { __typename?: 'GameSeason', id: string, progressionPaused: boolean, progressionPauseReason: string } } } | null };

export type ActiveCardSoundsQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type ActiveCardSoundsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, pointsMax: number, targetValue: number, isAllOrNothing: boolean, isMatchCard: boolean }> } | null };

export type GameCardSoundDataFragment = { __typename?: 'GameLogicCard', id: string, pointsMax: number, targetValue: number, isAllOrNothing: boolean, isMatchCard: boolean };

export type UseSpeedUpBoosterDurationQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type UseSpeedUpBoosterDurationQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, timeActive: number } | null };

export type GameStreamerBaseCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type GameStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } };

export type GameCardFragment = { __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type GameCardBackgroundArtSeasonQueryVariables = Exact<{
  seasonId: Scalars['ID']['input'];
}>;


export type GameCardBackgroundArtSeasonQuery = { __typename?: 'Query', season?: { __typename?: 'GameSeason', id: string, cardBackgroundUrls: Array<{ __typename?: 'GameSeasonCardBackgroundAsset', rarity: RarityRarity, url: string }> } | null };

export type GameCardBackgroundArtStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string };

export type GameCardBackgroundArtCardFragment = { __typename?: 'GameLogicCard', rarity: RarityRarity, seasonId: string, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } };

export type GameCardBackgroundVideoStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, video: string, channel: { __typename?: 'ChannelChannel', id: string } };

export type GameCardBottomLabelStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, channel: { __typename?: 'ChannelChannel', id: string, name: string } };

export type GameCardBottomLabelCardFragment = { __typename?: 'GameLogicCard', isAllOrNothing: boolean, isMatchCard: boolean };

export type GameCardFrameStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, image: string };

export type GameCardFrameCardFragment = { __typename?: 'GameLogicCard', leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } };

export type GameCardHeroCardFragment = { __typename?: 'GameLogicCard', icon: string, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } };

export type GameCardInfoCardFragment = { __typename?: 'GameLogicCard', name: string, description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type GameCardInfoDescriptionCardFragment = { __typename?: 'GameLogicCard', description: string, targetValue: number, timerDuration: number, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type GameCardLevelSeasonQueryVariables = Exact<{
  seasonId: Scalars['ID']['input'];
}>;


export type GameCardLevelSeasonQuery = { __typename?: 'Query', season?: { __typename?: 'GameSeason', id: string, badgeUrl: string } | null };

export type GameCardLevelCardFragment = { __typename?: 'GameLogicCard', seasonId: string, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } };

export type GameCardPointsStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string };

export type GameCardPointsCardFragment = { __typename?: 'GameLogicCard', pointsMax: number, pointsMin: number, isAllOrNothing: boolean };

export type GameCardStreamerDialogStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string } };

export type GameCardTypeBadgeStreamerCardFragment = { __typename?: 'GameLogicStreamerCard', id: string, channel: { __typename?: 'ChannelChannel', id: string, logo: string } };

export type GameCardTypeBadgeCardFragment = { __typename?: 'GameLogicCard', isAllOrNothing: boolean, isMatchCard: boolean };

export type LeaderboardItemPlayersQueryVariables = Exact<{
  playerIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type LeaderboardItemPlayersQuery = { __typename?: 'Query', profileBatch?: { __typename?: 'ProfileBatchGetProfilesResponse', profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }> } | null };

export type AllOrNothingPendingCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type AllOrNothingPendingCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type CardWithHighlightStateCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type CardWithHighlightStateCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type SwitchOutCardDetailsQueryVariables = Exact<{
  activeCardId: Scalars['String']['input'];
}>;


export type SwitchOutCardDetailsQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, isAllOrNothing: boolean }> } | null };

export type ChallengesContentChallengeFragment = { __typename?: 'GameLogicChallenge', id: string, description: string, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number }> };

export type ChallengesContentChallengesQueryVariables = Exact<{
  challengeIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type ChallengesContentChallengesQuery = { __typename?: 'Query', challengesBatch?: { __typename?: 'ChallengeListChallengesResponse', challenges: Array<{ __typename?: 'GameLogicChallenge', id: string, description: string, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number }> }> } | null };

export type PickRateRewardsQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type PickRateRewardsQuery = { __typename?: 'Query', challengeRewards?: { __typename?: 'ChallengeGetChallengeRewardsResponse', rewards: Array<{ __typename?: 'ChallengeChallengeReward', minPickRate: number, maxPickRate: number, gameId: string, reward: { __typename?: 'RewardRewardType', reward?: { __typename?: 'RewardRewardTypeCurrency', currencyId: string, currencyAmount: number } | { __typename?: 'RewardRewardTypeItem' } | null } }> } | null };

export type ActiveBoosterProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ActiveBoosterFragment = { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string, descriptionTargetSelf: string };

export type ActiveBoosterDialogContentProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ActiveBoosterDialogContentBoosterFragment = { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string, descriptionTargetSelf: string };

export type ActiveBoosterTooltipContentProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ActiveBoosterTooltipContentBoosterFragment = { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string, descriptionTargetSelf: string };

export type ActiveBoostersDataQueryVariables = Exact<{
  boosterId: Scalars['Int']['input'];
}>;


export type ActiveBoostersDataQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string, descriptionTargetSelf: string } | null };

export type ActiveBoostersProfileDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ActiveBoostersProfileDataQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type ReplacementBoosterDataQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type ReplacementBoosterDataQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string, descriptionTargetSelf: string } | null };

export type CardRowAvatarProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type LocalPlayerBoosterDialogContentQueryVariables = Exact<{
  boosterId: Scalars['Int']['input'];
}>;


export type LocalPlayerBoosterDialogContentQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string } | null };

export type LocalPlayerBoosterTooltipContentQueryVariables = Exact<{
  boosterId: Scalars['Int']['input'];
}>;


export type LocalPlayerBoosterTooltipContentQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string, descriptionTargetNoneBenefit: string } | null };

export type BoosterRequestPreviewProfileQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type BoosterRequestPreviewProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type PlayerActiveCardQueryVariables = Exact<{
  cardId: Scalars['String']['input'];
}>;


export type PlayerActiveCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, name: string, rarity: RarityRarity, seasonId: string, isAllOrNothing: boolean, isMatchCard: boolean, icon: string, pointsMax: number, pointsMin: number, description: string, targetValue: number, timerDuration: number, activeStreamerCard?: { __typename?: 'GameLogicStreamerCard', id: string, image: string, video: string, channel: { __typename?: 'ChannelChannel', id: string, name: string, logo: string, liveStatus: ChannelLiveStatus } } | null, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number }, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type TeamMateBoosterDialogContentBoosterFragment = { __typename?: 'GameLogicBooster', name: string, descriptionCondition: string, descriptionDefaultBenefit: string };

export type TeamMateBoosterDialogContentQueryVariables = Exact<{
  boosterId: Scalars['Int']['input'];
}>;


export type TeamMateBoosterDialogContentQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string } | null };

export type TeamMateBoosterTooltipContentBoosterFragment = { __typename?: 'GameLogicBooster', name: string, descriptionCondition: string, descriptionDefaultBenefit: string };

export type TeamMateBoosterTooltipContentQueryVariables = Exact<{
  boosterId: Scalars['Int']['input'];
  userId: Scalars['ID']['input'];
}>;


export type TeamMateBoosterTooltipContentQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, name: string, descriptionCondition: string, descriptionDefaultBenefit: string } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type CgActiveBoosterFragment = { __typename?: 'GameLogicBooster', id: number, timeActive: number, valueSelf: number, valueOther: number, image: string, name: string };

export type CgAvailableBoosterFragment = { __typename?: 'GameLogicBooster', id: number, canTargetSelf: boolean };

export type GameStateCardTargetValuesFragment = { __typename?: 'GameLogicCard', targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type GameStateCardFragment = { __typename?: 'GameLogicCard', id: string, pointsMin: number, pointsMax: number, pointsTimeTarget: number, timerDuration: number, targetValue: number, isMatchCard: boolean, isAllOrNothing: boolean, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> };

export type CgChallengesSystemChallengeFragment = { __typename?: 'GameLogicChallenge', id: string, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number }> };

export type CgChallengesSystemChallengesQueryVariables = Exact<{
  challengeIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type CgChallengesSystemChallengesQuery = { __typename?: 'Query', challengesBatch?: { __typename?: 'ChallengeListChallengesResponse', challenges: Array<{ __typename?: 'GameLogicChallenge', id: string, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number }> }> } | null };

export type GameStateGameCardQueryVariables = Exact<{
  ids: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type GameStateGameCardQuery = { __typename?: 'Query', gameCards?: { __typename?: 'GameCardBatchGetGameCardsResponse', cards: Array<{ __typename?: 'GameLogicCard', id: string, pointsMin: number, pointsMax: number, pointsTimeTarget: number, timerDuration: number, targetValue: number, isMatchCard: boolean, isAllOrNothing: boolean, targetValues: Array<{ __typename?: 'GameLogicTargetValue', label: string, value: number, selector?: { __typename?: 'GameLogicTargetValueSelector', attribute: string, value?: { __typename: 'BooleanType', booleanValue: boolean } | { __typename: 'GameLogicTargetValueSelectorDefaultValue' } | { __typename: 'IntType', intValue: number } | { __typename: 'StringType', stringValue: string } | null } | null }> }> } | null };

export type GameStateBoostersQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type GameStateBoostersQuery = { __typename?: 'Query', booster?: { __typename?: 'GameLogicBooster', id: number, canTargetSelf: boolean, timeActive: number, valueSelf: number, valueOther: number, image: string, name: string } | null };

export type StreamGameChannelQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StreamGameChannelQuery = { __typename?: 'Query', stream?: { __typename?: 'ChannelStream', streamId: string, channelId: string } | null };

export type ChatChannelEventsSubscriptionSubscriptionVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChatChannelEventsSubscriptionSubscription = { __typename?: 'Subscription', channelEventsSubscribe?: { __typename?: 'ChannelChannelEvent', channelId: string, createdAt: string, id: string, content: { __typename?: 'ChannelChannelEventContent', content?: { __typename?: 'ChannelAvatarItemPurchase', itemId: string, item: { __typename?: 'ItemItem', id: string, name: string }, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string } | null } | { __typename?: 'ChannelBundlePurchase', bundleName: string, userId: string, streamerCards?: Array<{ __typename?: 'GameLogicStreamerCard', id: string, channelId: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string } }> | null, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string } | null } | { __typename?: 'ChannelGiftSubscriptionPurchase', userId: string, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null, recipients?: Array<{ __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> }> | null } | { __typename?: 'ChannelStreamerCardPurchase', userId: string, streamerCard: { __typename?: 'GameLogicStreamerCard', id: string, channelId: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string } }, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string } | null } | { __typename?: 'ChannelSubscriptionPurchase', userId: string, tier: number, user?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null } | { __typename?: 'ChannelSubscriptionRenewal' } | null } } | null };

export type ChannelEventContentProfileFragment = { __typename?: 'ProfileProfile', preferredColor: ProfileColor, userId: string, userTag: string };

export type ChannelEventSubscriptionContentProfileFragment = { __typename?: 'ProfileProfile', badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type ChannelEventAvatarItemPurchaseItemFragment = { __typename?: 'ItemItem', id: string, name: string };

export type ChatMessageAttachmentsFragment = { __typename: 'ChatTextMessageAttachment', label: string, source: string, startIndex: number, endIndex: number };

export type ChatMessagesHookProfileFragment = { __typename?: 'ProfileProfile', userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type SendChatMessageProfileFragment = { __typename?: 'ProfileProfile', userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> };

export type InventoryEmojiFragment = { __typename?: 'EmojiEmoji', id: string, label: string, image: string, channelId: string };

export type InventoryEmojisQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type InventoryEmojisQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string, label: string, image: string, channelId: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } }> } | null };

export type UpdateChatSettingsProfileMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  preferredColor: ProfileColor;
}>;


export type UpdateChatSettingsProfileMutation = { __typename?: 'Mutation', updateProfile?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor } | null };

export type ChatSettingsProfileQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type ChatSettingsProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', level: number, type: BadgeBadgeType }> } | null };

export type UpdateChatSettingsProfileFragment = { __typename?: 'ProfileProfile', userId: string, preferredColor: ProfileColor };

export type AvatarMovementsQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type AvatarMovementsQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation', name: string, chatCommand: string, iconUrl: string, id: string } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji' } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } }> } | null };

export type EmoteAvatarAnimationFragment = { __typename?: 'AvatarAnimation', name: string, chatCommand: string, iconUrl: string, id: string };

export type HideChatMessageMutationVariables = Exact<{
  chatId: Scalars['ID']['input'];
  messageId: Scalars['ID']['input'];
}>;


export type HideChatMessageMutation = { __typename?: 'Mutation', hideChatMessage?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChatMeProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ChatMeProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type ChatMessagesProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string };

export type UserInventoryEmojisQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UserInventoryEmojisQuery = { __typename?: 'Query', inventory?: { __typename?: 'InventoryListUserInventoryResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemId: string, item: { __typename?: 'ItemItem', id: string, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string, label: string, image: string, channelId: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null } }> } | null };

export type EmojiDrawerChannelFragment = { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, logo: string, name: string };

export type UserInventoryEmojisChannelsQueryVariables = Exact<{
  channelIds?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type UserInventoryEmojisChannelsQuery = { __typename?: 'Query', getChannels?: { __typename?: 'ChannelBatchGetChannelsResponse', channels: Array<{ __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus, logo: string, name: string }> } | null };

export type ReceivedBoosterRequestMessageProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ReceivedBoosterRequestMessageProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type SentBoosterRequestMessageProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type SentBoosterRequestMessageProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type ChatProviderDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  chatId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type ChatProviderDataQuery = { __typename?: 'Query', chatUserStatus?: { __typename?: 'ChatGetChatUserStatusResponse', muted: boolean, muteDuration?: string | null } | null, userChannelRoles?: { __typename?: 'ChannelListUserChannelRolesResponse', roles: Array<ChannelChannelRole> } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null };

export type OwnChatSenderInfoProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type OwnChatSenderInfoProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, preferredColor: ProfileColor, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }> } | null };

export type ReasonDescriptionInputProfileFragment = { __typename?: 'ProfileProfile', userTag: string };

export type ReasonDescriptionInputChannelFragment = { __typename?: 'ChannelChannel', name: string };

export type ReasonSelectProfileFragment = { __typename?: 'ProfileProfile', userTag: string };

export type ReasonSelectChannelFragment = { __typename?: 'ChannelChannel', name: string };

export type ReportUserMutationVariables = Exact<{
  reason: SupportReportReason;
  description?: InputMaybe<Scalars['String']['input']>;
  context: SupportReportContextInput;
}>;


export type ReportUserMutation = { __typename?: 'Mutation', createReport?: { __typename?: 'SupportReport', createdAt: string } | null };

export type ReportedUserProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ReportedUserProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type ReportedChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ReportedChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string } | null };

export type ReportedChannelFragment = { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, logo: string };

export type ReportedUserProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ReportStreamTimestampQueryVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type ReportStreamTimestampQuery = { __typename?: 'Query', stream?: { __typename?: 'ChannelStream', streamId: string, segments: Array<{ __typename?: 'ChannelStreamSegment', startTime: string }> } | null };

export type SignupFlowChannelQueryVariables = Exact<{
  channelName: Scalars['String']['input'];
}>;


export type SignupFlowChannelQuery = { __typename?: 'Query', channelByName?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string } | null };

export type SignupFlowChannelFragment = { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, logo: string };

export type ChannelBannerChannelFragment = { __typename?: 'ChannelChannel', offlineBanner: string };

export type ChannelLogoChannelFragment = { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, logo: string, name: string };

export type PlatformAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', id: string, title: string, text: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, image: string };

export type ProfileImageProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ProfileImageShowOnlineStatusProfileFragment = { __typename?: 'ProfileProfile', onlineStatus: ProfilePresenceStatus, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ChannelAssetCreateTokenMutationVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
  assetType?: InputMaybe<ChannelAssetType>;
}>;


export type ChannelAssetCreateTokenMutation = { __typename?: 'Mutation', createChannelAssetUploadToken?: { __typename?: 'ChannelCreateChannelAssetUploadTokenResponse', token: string } | null };

export type LogoUpdateChannelChannelFragment = { __typename?: 'ChannelChannel', id: string, logo: string };

export type BannerUpdateChannelChannelFragment = { __typename?: 'ChannelChannel', id: string, offlineBanner: string };

export type EmojiAssetCreateTokenMutationVariables = Exact<{
  itemId: Scalars['ID']['input'];
}>;


export type EmojiAssetCreateTokenMutation = { __typename?: 'Mutation', createEmojiUploadToken?: { __typename?: 'EmojiCreateEmojiUploadTokenResponse', token: string } | null };

export type AssetUploadEmojiEmojiFragment = { __typename?: 'EmojiEmoji', image: string };

export type WalletQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type WalletQuery = { __typename?: 'Query', wallet?: { __typename?: 'WalletGetWalletResponse', wallet: { __typename?: 'WalletWallet', currencies: Array<{ __typename?: 'WalletWalletCurrency', currencyId: string, currencyAmount: number }> } } | null };

export type WalletCurrencyFragment = { __typename?: 'WalletWalletCurrency', currencyId: string, currencyAmount: number };

export type ZendeskPrefillProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null };

export type StreamSpectatorCoordinationSubscribeSubscriptionVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type StreamSpectatorCoordinationSubscribeSubscription = { __typename?: 'Subscription', streamSpectatorCoordinationEventsSubscribe?: { __typename?: 'MatchStreamSpectatorCoordinationEvent', event?: { __typename?: 'MatchStreamSpectatorChangeGroupEvent', groupId: string } | null } | null };

export type UpdateAvatarMutationVariables = Exact<{
  avatarId: Scalars['ID']['input'];
}>;


export type UpdateAvatarMutation = { __typename?: 'Mutation', updateProfileAvatar?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SubscriptionGetChannelEmojisChannelFragment = { __typename?: 'ChannelChannel', subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> }> } | null };

export type SubscriptionGetChannelEmojisChannelEmojiFragment = { __typename: 'EmojiEmoji', id: string, image: string, name: string };

export type UserBadgeFragment = { __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number };

export type SocialChannelBanMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  violation?: InputMaybe<ChannelViolation>;
  description?: InputMaybe<Scalars['String']['input']>;
  keepRecentMessages?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type SocialChannelBanMutation = { __typename?: 'Mutation', banChannelUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialChannelUnbanMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type SocialChannelUnbanMutation = { __typename?: 'Mutation', unbanChannelUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ActiveFriendsListProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type BlockUserProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type BlockedUserProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type BlockedUserProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type ChannelBanModalProfileFragment = { __typename?: 'ProfileProfile', userTag: string, userId: string };

export type MuteUserMutationVariables = Exact<{
  chatId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
  duration: Scalars['Duration']['input'];
  reason: ChatReason;
  description: Scalars['String']['input'];
}>;


export type MuteUserMutation = { __typename?: 'Mutation', muteChatUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChannelMuteModalProfileFragment = { __typename?: 'ProfileProfile', userTag: string, userId: string };

export type ChannelUnbanModalProfileFragment = { __typename?: 'ProfileProfile', userTag: string, userId: string };

export type ChannelUnbanModalChannelUserBanStatusFragment = { __typename?: 'ChannelUserBanStatus', bannedAt?: string | null, violation: ChannelViolation, description: string, moderator?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type UnmuteUserMutationVariables = Exact<{
  chatId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type UnmuteUserMutation = { __typename?: 'Mutation', unmuteChatUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChannelUnmuteModalProfileFragment = { __typename?: 'ProfileProfile', userTag: string, userId: string };

export type ChannelUnmuteModalChatStatusFragment = { __typename?: 'ChatGetChatUserStatusResponse', muteDuration?: string | null };

export type FriendRequestButtonProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, temporary: boolean, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } };

export type ResolvedAddFriendUserTagQueryVariables = Exact<{
  userTag: Scalars['String']['input'];
}>;


export type ResolvedAddFriendUserTagQuery = { __typename?: 'Query', resolveUserTags?: { __typename?: 'ProfileResolveUserTagsResponse', userIds: Array<{ __typename?: 'ProfileResolveUserTagsResponseUserIdsEntry', key: string, value: string }> } | null };

export type FriendsSidebarFriendFragment = { __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarFriendProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null };

export type FriendsSidebarFriendButtonsProfileFragment = { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type FriendsSidebarFriendPanelFriendFragment = { __typename?: 'FriendsUser', lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarFriendStatusFriendsUserFragment = { __typename?: 'FriendsUser', activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null, profile: { __typename?: 'ProfileProfile', userId: string, onlineStatus: ProfilePresenceStatus } };

export type FriendsSidebarItemExpandedFriendFragment = { __typename?: 'FriendsUser', profile: { __typename?: 'ProfileProfile', userId: string, onlineStatus: ProfilePresenceStatus, userTag: string, isNewUsername: boolean, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarItemExpandedProfileFragment = { __typename?: 'ProfileProfile', userTag: string, isNewUsername: boolean, onlineStatus: ProfilePresenceStatus, userId: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type FriendsSidebarFriendActionsFriendsUserFragment = { __typename?: 'FriendsUser', userId: string, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null } | null, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } } };

export type FriendsSidebarFriendListFriendFragment = { __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarFriendListProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null };

export type FriendSidebarFriendsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  pageSize?: Scalars['Int']['input'];
}>;


export type FriendSidebarFriendsQuery = { __typename?: 'Query', friends?: { __typename?: 'FriendsListFriendsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, users: Array<{ __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null }> } | null };

export type FriendsSidebarFriendsViewDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FriendsSidebarFriendsViewDataQuery = { __typename?: 'Query', receivedFriendRequests?: { __typename?: 'FriendsListReceivedFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string } }> } | null };

export type FriendsSidebarPartyQueryVariables = Exact<{
  partyId: Scalars['ID']['input'];
}>;


export type FriendsSidebarPartyQuery = { __typename?: 'Query', party?: { __typename?: 'PartyParty', id: string, leaderId: string, members: Array<{ __typename?: 'PartyPartyMember', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null } }>, channel?: { __typename?: 'ChannelChannel', id: string, currentStreamId: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarMenuPendingRequestsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FriendsSidebarMenuPendingRequestsQuery = { __typename?: 'Query', receivedFriendRequests?: { __typename?: 'FriendsListReceivedFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string }> } | null };

export type FriendsSidebarPartyFriendFragment = { __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null };

export type FriendsSidebarPartyProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null };

export type FriendsSidebarPendingViewDataQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FriendsSidebarPendingViewDataQuery = { __typename?: 'Query', receivedFriendRequests?: { __typename?: 'FriendsListReceivedFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null }> } | null, sentFriendRequests?: { __typename?: 'FriendsListSentFriendRequestsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, lastStatusChange: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, onlineStatus: ProfilePresenceStatus, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus }, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null }, activity?: { __typename?: 'FriendsActivity', isOnline: boolean, channel?: { __typename?: 'ChannelChannel', id: string, name: string, game: { __typename?: 'GameGame', id: string, name: string } } | null } | null }> } | null };

export type GiftSubscriptionToCommunityButtonRolesQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type GiftSubscriptionToCommunityButtonRolesQuery = { __typename?: 'Query', userChannelRoles?: { __typename?: 'ChannelListUserChannelRolesResponse', roles: Array<ChannelChannelRole> } | null };

export type MiniProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, temporary: boolean, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string, avatar2D: string } | null, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, name: string }, progression: { __typename?: 'GameUserProgression', level: number }, season: { __typename?: 'GameSeason', id: string, name: string } }>, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } };

export type MiniProfileChatStatusFragment = { __typename?: 'ChatGetChatUserStatusResponse', muted: boolean, muteDuration?: string | null };

export type MiniProfileChannelBanFragment = { __typename?: 'ChannelUserBanStatus', banned: boolean, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus } | null };

export type MiniProfileAvatarProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string } | null };

export type MiniProfileFollowingStateQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type MiniProfileFollowingStateQuery = { __typename?: 'Query', channelFollowerStatus?: { __typename?: 'ChannelGetChannelFollowerStatusResponse', following: boolean, followedAt?: string | null } | null };

export type MiniProfileDetailsProfileFragment = { __typename?: 'ProfileProfile', userId: string };

export type MiniProfileFooterProfileFragment = { __typename?: 'ProfileProfile', userId: string, temporary: boolean, userTag: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type MiniProfilePopoverMenuChannelBanFragment = { __typename?: 'ChannelUserBanStatus', banned: boolean };

export type MiniProfilePopoverMenuChatStatusFragment = { __typename?: 'ChatGetChatUserStatusResponse', muted: boolean };

export type MiniProfilePopoverMenuProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, temporary: boolean, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus } };

export type MiniProfileFriendStatusProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } };

export type MiniProfileGameRankProfileFragment = { __typename?: 'ProfileProfile', playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, name: string }, progression: { __typename?: 'GameUserProgression', level: number }, season: { __typename?: 'GameSeason', id: string, name: string } }> };

export type MiniProfileGameRankChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type MiniProfileGameRankChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, gameId: string, game: { __typename?: 'GameGame', id: string, activeSeasonId: string } } | null };

export type MiniProfileHeaderProfileFragment = { __typename?: 'ProfileProfile', userTag: string, temporary: boolean, isNewUsername: boolean, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type MiniProfileModerationStateChatStatusFragment = { __typename?: 'ChatGetChatUserStatusResponse', muted: boolean, muteDuration?: string | null };

export type MiniProfileModerationStateChannelBanFragment = { __typename?: 'ChannelUserBanStatus', banned: boolean, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus } | null };

export type MiniProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type MiniProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, temporary: boolean, isNewUsername: boolean, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string }, badges: Array<{ __typename?: 'BadgeBadge', type: BadgeBadgeType, level: number }>, avatars?: { __typename?: 'ProfileProfileAvatars', avatarFullbody: string, avatar2D: string } | null, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, seasonId: string, game: { __typename?: 'GameGame', id: string, name: string }, progression: { __typename?: 'GameUserProgression', level: number }, season: { __typename?: 'GameSeason', id: string, name: string } }> } | null };

export type MiniProfileModeratorStatusQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  chatId?: InputMaybe<Scalars['ID']['input']>;
  skipChatModerationData: Scalars['Boolean']['input'];
}>;


export type MiniProfileModeratorStatusQuery = { __typename?: 'Query', channelBanUserStatus?: { __typename?: 'ChannelUserBanStatus', userId: string, channelId: string, banned: boolean, bannedAt?: string | null, violation: ChannelViolation, description: string, moderator?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus } | null } | null, chatUserStatus?: { __typename?: 'ChatGetChatUserStatusResponse', muteDuration?: string | null, muted: boolean } | null };

export type MiniProfilePortalChannelBanFragment = { __typename?: 'ChannelUserBanStatus', bannedAt?: string | null, violation: ChannelViolation, description: string, banned: boolean, moderator?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null, appeal?: { __typename?: 'ChannelBanAppealInfo', status: ChannelAppealStatus } | null };

export type MiniProfilePortalChatStausFragment = { __typename?: 'ChatGetChatUserStatusResponse', muteDuration?: string | null, muted: boolean };

export type UserChannelRolesQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  channelId: Scalars['ID']['input'];
  skipRoles: Scalars['Boolean']['input'];
}>;


export type UserChannelRolesQuery = { __typename?: 'Query', userChannelRoles?: { __typename?: 'ChannelListUserChannelRolesResponse', roles: Array<ChannelChannelRole> } | null, channel?: { __typename?: 'ChannelChannel', id: string, currentChatId?: string | null } | null };

export type LeavePartyMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  partyId: Scalars['ID']['input'];
}>;


export type LeavePartyMutation = { __typename?: 'Mutation', deletePartyMember?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type CreatePartyMutationVariables = Exact<{ [key: string]: never; }>;


export type CreatePartyMutation = { __typename?: 'Mutation', createParty?: { __typename?: 'PartyParty', id: string } | null };

export type CreatePartyInvitationMutationVariables = Exact<{
  inviterId: Scalars['ID']['input'];
  inviteeId: Scalars['ID']['input'];
  partyId: Scalars['ID']['input'];
}>;


export type CreatePartyInvitationMutation = { __typename?: 'Mutation', createPartyInvitation?: { __typename?: 'PartyPartyInvitation', partyId: string } | null };

export type PartyInvitesCreatePartyMemberMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  partyId: Scalars['ID']['input'];
}>;


export type PartyInvitesCreatePartyMemberMutation = { __typename?: 'Mutation', createPartyMember?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type PartyInvitesDeletePartyInviteMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  partyId: Scalars['ID']['input'];
}>;


export type PartyInvitesDeletePartyInviteMutation = { __typename?: 'Mutation', deletePartyInvitation?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type PartyInvitesCurrentPartyQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type PartyInvitesCurrentPartyQuery = { __typename?: 'Query', userParty?: { __typename?: 'PartyParty', id: string, leaderId: string, streamId: string, members: Array<{ __typename?: 'PartyPartyMember', userId: string }> } | null };

export type PartyInvitesPartyUpdatesSubscriptionVariables = Exact<{
  partyId: Scalars['ID']['input'];
}>;


export type PartyInvitesPartyUpdatesSubscription = { __typename?: 'Subscription', partyUpdateSubscribe?: { __typename?: 'PartyPartyUpdateEvent', party: { __typename?: 'PartyParty', id: string, streamId: string, leaderId: string, members: Array<{ __typename?: 'PartyPartyMember', userId: string, profile: { __typename?: 'ProfileProfile', userId: string } }>, channel?: { __typename?: 'ChannelChannel', id: string } | null } } | null };

export type FriendStatusUpdateProfileFragment = { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } };

export type SocialAcceptFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  friendId: Scalars['ID']['input'];
}>;


export type SocialAcceptFriendRequestMutation = { __typename?: 'Mutation', acceptFriendRequest?: { __typename?: 'FriendsAcceptFriendRequestResponse', friendId: string, friend: { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } } } | null };

export type NewFriendRequestUserFragment = { __typename?: 'FriendsUser', userId: string };

export type SocialBlockUserMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  blockedUserId: Scalars['ID']['input'];
}>;


export type SocialBlockUserMutation = { __typename?: 'Mutation', blockUser?: { __typename?: 'FriendsBlockUserResponse', blockedUserId: string, blockedUser: { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } } } | null };

export type SocialRemoveFriendMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  friendId: Scalars['ID']['input'];
}>;


export type SocialRemoveFriendMutation = { __typename?: 'Mutation', removeFriend?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialRemoveReceivedFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  friendId: Scalars['ID']['input'];
}>;


export type SocialRemoveReceivedFriendRequestMutation = { __typename?: 'Mutation', removeFriendRequest?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialRemoveSentFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  friendId: Scalars['ID']['input'];
}>;


export type SocialRemoveSentFriendRequestMutation = { __typename?: 'Mutation', removeFriendRequest?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SocialSendFriendRequestMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  friendId: Scalars['ID']['input'];
}>;


export type SocialSendFriendRequestMutation = { __typename?: 'Mutation', sendFriendRequest?: { __typename?: 'FriendsSendFriendRequestResponse', friendId: string, friend: { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } } } | null };

export type SocialUnblockUserMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  blockedUserId: Scalars['ID']['input'];
}>;


export type SocialUnblockUserMutation = { __typename?: 'Mutation', unblockUser?: { __typename?: 'FriendsUnblockUserResponse', unblockedUserId: string, unblockedUser: { __typename?: 'ProfileProfile', userId: string, friendshipStatus: { __typename?: 'FriendsFriendshipStatus', status: FriendsFriendshipStatusStatus, lastStatusChange: string } } } | null };

export const AlertsChannelActivityEventProfileFragmentDoc = gql`
    fragment AlertsChannelActivityEventProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
    avatarFullbody
  }
}
    `;
export const GameCardBackgroundArtStreamerCardFragmentDoc = gql`
    fragment GameCardBackgroundArtStreamerCard on GameLogicStreamerCard {
  id
  image
}
    `;
export const GameCardBackgroundVideoStreamerCardFragmentDoc = gql`
    fragment GameCardBackgroundVideoStreamerCard on GameLogicStreamerCard {
  id
  video
  channel {
    id
  }
}
    `;
export const GameCardBottomLabelStreamerCardFragmentDoc = gql`
    fragment GameCardBottomLabelStreamerCard on GameLogicStreamerCard {
  id
  channel {
    id
    name
  }
}
    `;
export const GameCardFrameStreamerCardFragmentDoc = gql`
    fragment GameCardFrameStreamerCard on GameLogicStreamerCard {
  id
  image
}
    `;
export const GameCardPointsStreamerCardFragmentDoc = gql`
    fragment GameCardPointsStreamerCard on GameLogicStreamerCard {
  id
}
    `;
export const ChannelLogoChannelFragmentDoc = gql`
    fragment ChannelLogoChannel on ChannelChannel {
  liveStatus
  logo
  name
}
    `;
export const GameCardStreamerDialogStreamerCardFragmentDoc = gql`
    fragment GameCardStreamerDialogStreamerCard on GameLogicStreamerCard {
  id
  video
  channel {
    id
    name
    ...ChannelLogoChannel
  }
}
    ${ChannelLogoChannelFragmentDoc}`;
export const GameCardTypeBadgeStreamerCardFragmentDoc = gql`
    fragment GameCardTypeBadgeStreamerCard on GameLogicStreamerCard {
  id
  channel {
    id
    logo
  }
}
    `;
export const GameStreamerCardFragmentDoc = gql`
    fragment GameStreamerCard on GameLogicStreamerCard {
  id
  ...GameCardBackgroundArtStreamerCard
  ...GameCardBackgroundVideoStreamerCard
  ...GameCardBottomLabelStreamerCard
  ...GameCardFrameStreamerCard
  ...GameCardPointsStreamerCard
  ...GameCardStreamerDialogStreamerCard
  ...GameCardTypeBadgeStreamerCard
}
    ${GameCardBackgroundArtStreamerCardFragmentDoc}
${GameCardBackgroundVideoStreamerCardFragmentDoc}
${GameCardBottomLabelStreamerCardFragmentDoc}
${GameCardFrameStreamerCardFragmentDoc}
${GameCardPointsStreamerCardFragmentDoc}
${GameCardStreamerDialogStreamerCardFragmentDoc}
${GameCardTypeBadgeStreamerCardFragmentDoc}`;
export const GameCardBackgroundArtCardFragmentDoc = gql`
    fragment GameCardBackgroundArtCard on GameLogicCard {
  leveling {
    currentLevel
  }
  rarity
  seasonId
}
    `;
export const GameCardBottomLabelCardFragmentDoc = gql`
    fragment GameCardBottomLabelCard on GameLogicCard {
  isAllOrNothing
  isMatchCard
}
    `;
export const GameCardFrameCardFragmentDoc = gql`
    fragment GameCardFrameCard on GameLogicCard {
  leveling {
    currentLevel
  }
}
    `;
export const GameCardHeroCardFragmentDoc = gql`
    fragment GameCardHeroCard on GameLogicCard {
  leveling {
    currentLevel
  }
  icon
}
    `;
export const GameStateCardTargetValuesFragmentDoc = gql`
    fragment GameStateCardTargetValues on GameLogicCard {
  targetValues {
    label
    value
    selector {
      attribute
      value {
        __typename
        ... on BooleanType {
          booleanValue: value
        }
        ... on IntType {
          intValue: value
        }
        ... on StringType {
          stringValue: value
        }
      }
    }
  }
}
    `;
export const GameCardInfoDescriptionCardFragmentDoc = gql`
    fragment GameCardInfoDescriptionCard on GameLogicCard {
  description
  targetValue
  timerDuration
  ...GameStateCardTargetValues
}
    ${GameStateCardTargetValuesFragmentDoc}`;
export const GameCardInfoCardFragmentDoc = gql`
    fragment GameCardInfoCard on GameLogicCard {
  name
  ...GameCardInfoDescriptionCard
}
    ${GameCardInfoDescriptionCardFragmentDoc}`;
export const GameCardLevelCardFragmentDoc = gql`
    fragment GameCardLevelCard on GameLogicCard {
  leveling {
    currentLevel
  }
  seasonId
}
    `;
export const GameCardPointsCardFragmentDoc = gql`
    fragment GameCardPointsCard on GameLogicCard {
  pointsMax
  pointsMin
  isAllOrNothing
}
    `;
export const GameCardTypeBadgeCardFragmentDoc = gql`
    fragment GameCardTypeBadgeCard on GameLogicCard {
  isAllOrNothing
  isMatchCard
}
    `;
export const GameStreamerBaseCardFragmentDoc = gql`
    fragment GameStreamerBaseCard on GameLogicCard {
  id
  name
  ...GameCardBackgroundArtCard
  ...GameCardBottomLabelCard
  ...GameCardFrameCard
  ...GameCardHeroCard
  ...GameCardInfoCard
  ...GameCardLevelCard
  ...GameCardPointsCard
  ...GameCardTypeBadgeCard
}
    ${GameCardBackgroundArtCardFragmentDoc}
${GameCardBottomLabelCardFragmentDoc}
${GameCardFrameCardFragmentDoc}
${GameCardHeroCardFragmentDoc}
${GameCardInfoCardFragmentDoc}
${GameCardLevelCardFragmentDoc}
${GameCardPointsCardFragmentDoc}
${GameCardTypeBadgeCardFragmentDoc}`;
export const GameCardFragmentDoc = gql`
    fragment GameCard on GameLogicCard {
  id
  activeStreamerCard {
    id
    ...GameStreamerCard
  }
  ...GameStreamerBaseCard
}
    ${GameStreamerCardFragmentDoc}
${GameStreamerBaseCardFragmentDoc}`;
export const AlertsChannelActivityEventHighScoringCardEventFragmentDoc = gql`
    fragment AlertsChannelActivityEventHighScoringCardEvent on GameLogicHighScoringCardPromotedMsg {
  hscPlayer: user {
    ...AlertsChannelActivityEventProfile
  }
  card {
    cardId
    card {
      ...GameCard
    }
    points
    boosterPoints {
      userId
      boosterId
    }
  }
}
    ${AlertsChannelActivityEventProfileFragmentDoc}
${GameCardFragmentDoc}`;
export const AlertsChannelActivityEventChannelFollowedFragmentDoc = gql`
    fragment AlertsChannelActivityEventChannelFollowed on StreamerChannelFollowed {
  userId
  follower: user {
    ...AlertsChannelActivityEventProfile
  }
}
    ${AlertsChannelActivityEventProfileFragmentDoc}`;
export const AlertsChannelActivityEventSubscriptionGiftedFragmentDoc = gql`
    fragment AlertsChannelActivityEventSubscriptionGifted on StreamerSubscriptionGifted {
  userId
  tier
  user {
    ...AlertsChannelActivityEventProfile
  }
  recipientUserIds
}
    ${AlertsChannelActivityEventProfileFragmentDoc}`;
export const AlertsChannelActivityEventChannelSubscribedFragmentDoc = gql`
    fragment AlertsChannelActivityEventChannelSubscribed on StreamerChannelSubscribed {
  userId
  user {
    ...AlertsChannelActivityEventProfile
  }
}
    ${AlertsChannelActivityEventProfileFragmentDoc}`;
export const AlertsChannelActivityEventChannelSubscriptionRenewedFragmentDoc = gql`
    fragment AlertsChannelActivityEventChannelSubscriptionRenewed on StreamerSubscriptionRenewed {
  userId
  user {
    ...AlertsChannelActivityEventProfile
  }
}
    ${AlertsChannelActivityEventProfileFragmentDoc}`;
export const AlertsChannelActivityEventCreatorCardPurchasedFragmentDoc = gql`
    fragment AlertsChannelActivityEventCreatorCardPurchased on StreamerStreamerCardPurchased {
  userId
  user {
    ...AlertsChannelActivityEventProfile
  }
}
    ${AlertsChannelActivityEventProfileFragmentDoc}`;
export const AlertsChannelActivityEventBundlePurchasedFragmentDoc = gql`
    fragment AlertsChannelActivityEventBundlePurchased on StreamerBundlePurchased {
  userId
  user {
    ...AlertsChannelActivityEventProfile
  }
}
    ${AlertsChannelActivityEventProfileFragmentDoc}`;
export const AlertsChannelActivityEventFragmentDoc = gql`
    fragment AlertsChannelActivityEvent on StreamerChannelActivityEvent {
  timestamp
  id
  content {
    ...AlertsChannelActivityEventHighScoringCardEvent
    ...AlertsChannelActivityEventChannelFollowed
    ...AlertsChannelActivityEventSubscriptionGifted
    ...AlertsChannelActivityEventChannelSubscribed
    ...AlertsChannelActivityEventChannelSubscriptionRenewed
    ...AlertsChannelActivityEventCreatorCardPurchased
    ...AlertsChannelActivityEventBundlePurchased
  }
}
    ${AlertsChannelActivityEventHighScoringCardEventFragmentDoc}
${AlertsChannelActivityEventChannelFollowedFragmentDoc}
${AlertsChannelActivityEventSubscriptionGiftedFragmentDoc}
${AlertsChannelActivityEventChannelSubscribedFragmentDoc}
${AlertsChannelActivityEventChannelSubscriptionRenewedFragmentDoc}
${AlertsChannelActivityEventCreatorCardPurchasedFragmentDoc}
${AlertsChannelActivityEventBundlePurchasedFragmentDoc}`;
export const AlertsTopPredictionsCardFragmentDoc = gql`
    fragment AlertsTopPredictionsCard on GameLogicCard {
  ...GameCard
  id
  name
  description
  targetValue
  timerDuration
  ...GameStateCardTargetValues
}
    ${GameCardFragmentDoc}
${GameStateCardTargetValuesFragmentDoc}`;
export const AlertsTopPredictionsCardCountFragmentDoc = gql`
    fragment AlertsTopPredictionsCardCount on MatchCardCount {
  cardId
  card {
    id
    ...AlertsTopPredictionsCard
  }
  count
}
    ${AlertsTopPredictionsCardFragmentDoc}`;
export const AlertsTopPredictionsUpdateFragmentDoc = gql`
    fragment AlertsTopPredictionsUpdate on MatchTopCardsUpdateCardCountUpdate {
  ... on MatchTopCardsUpdateCardCountUpdate {
    cards {
      cardId
      ...AlertsTopPredictionsCardCount
    }
  }
}
    ${AlertsTopPredictionsCardCountFragmentDoc}`;
export const CategoryChallengeFragmentDoc = gql`
    fragment CategoryChallenge on GameLogicChallenge {
  id
  description
  disabled
}
    `;
export const CategoryOverviewChallengeFragmentDoc = gql`
    fragment CategoryOverviewChallenge on GameLogicChallenge {
  id
  ...CategoryChallenge
}
    ${CategoryChallengeFragmentDoc}`;
export const UseCategoryChallengeChallengeFragmentDoc = gql`
    fragment UseCategoryChallengeChallenge on GameLogicChallenge {
  id
  ...CategoryOverviewChallenge
}
    ${CategoryOverviewChallengeFragmentDoc}`;
export const NewChallengeFragmentDoc = gql`
    fragment NewChallenge on GameLogicChallenge {
  id
}
    `;
export const MatureRatedContentUpdatedChannelFragmentDoc = gql`
    fragment MatureRatedContentUpdatedChannel on ChannelChannel {
  matureRatedContent
}
    `;
export const CardGameEventHighScoringCardPlayerFragmentDoc = gql`
    fragment CardGameEventHighScoringCardPlayer on ProfileProfile {
  userId
  avatars {
    avatarFullbody
  }
  userTag
}
    `;
export const CardGameEventMostPredictedCardCountFragmentDoc = gql`
    fragment CardGameEventMostPredictedCardCount on MatchCardCount {
  cardId
  card {
    id
    ...GameCard
  }
  count
}
    ${GameCardFragmentDoc}`;
export const StreamAlertsChannelLiveStatusUpdateFragmentDoc = gql`
    fragment StreamAlertsChannelLiveStatusUpdate on ChannelChannel {
  currentStreamId
}
    `;
export const ChannelIngestStatsFragmentDoc = gql`
    fragment ChannelIngestStats on ChannelIngestStatsEvent {
  width
  height
  framerate
  bitrate
  bSlices
  audioSampleRate
  audioChannelCnt
}
    `;
export const UserBadgeFragmentDoc = gql`
    fragment UserBadge on BadgeBadge {
  type
  level
}
    `;
export const AvatarCosmeticDetailsFragmentDoc = gql`
    fragment AvatarCosmeticDetails on AvatarAvatarPart {
  id
  name
}
    `;
export const StreamActivityFeedAvatarItemPurchaseFragmentDoc = gql`
    fragment StreamActivityFeedAvatarItemPurchase on StreamerAvatarItemPurchased {
  userId
  itemId
  buyer: user {
    avatars {
      avatar2D
    }
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    preferredColor
    userId
    userTag
  }
  item {
    id
    name
    details {
      ...AvatarCosmeticDetails
    }
  }
}
    ${UserBadgeFragmentDoc}
${AvatarCosmeticDetailsFragmentDoc}`;
export const StreamActivityFeedChannelSubscriptionRenewedFragmentDoc = gql`
    fragment StreamActivityFeedChannelSubscriptionRenewed on StreamerSubscriptionRenewed {
  userId
  subscriber: user {
    avatars {
      avatar2D
    }
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    preferredColor
    userId
    userTag
  }
}
    ${UserBadgeFragmentDoc}`;
export const StreamActivityFeedMatchStateUpdateStartedFragmentDoc = gql`
    fragment StreamActivityFeedMatchStateUpdateStarted on StreamerMatchStarted {
  streamId
}
    `;
export const MatchResultsBestPlayerFragmentDoc = gql`
    fragment MatchResultsBestPlayer on StreamerMatchEnded {
  bestPlayer {
    id
    points
    user {
      userTag
      userId
      preferredColor
      badges {
        ...UserBadge
      }
    }
  }
}
    ${UserBadgeFragmentDoc}`;
export const MatchResultsBestPlayFragmentDoc = gql`
    fragment MatchResultsBestPlay on StreamerMatchEnded {
  bestCard {
    succeedingCard {
      cardId
      points
      card {
        id
        name
        description
        targetValue
        timerDuration
        ...GameStateCardTargetValues
      }
      user {
        userTag
        userId
        preferredColor
        badges {
          ...UserBadge
        }
      }
    }
  }
}
    ${GameStateCardTargetValuesFragmentDoc}
${UserBadgeFragmentDoc}`;
export const MatchResultsBestTeamFragmentDoc = gql`
    fragment MatchResultsBestTeam on StreamerMatchEnded {
  bestGroup {
    group {
      id
      name
      points
    }
    players {
      id
      points
      user {
        avatars {
          avatar2D
        }
        userTag
        userId
        preferredColor
        badges {
          ...UserBadge
        }
      }
    }
  }
}
    ${UserBadgeFragmentDoc}`;
export const MatchResultsChallengesFragmentDoc = gql`
    fragment MatchResultsChallenges on StreamerMatchEnded {
  challengeStatuses {
    challengeId
    pickRate
    challengeState
    targetValues {
      label
      value
      selector {
        attribute
        value {
          __typename
        }
      }
    }
  }
}
    `;
export const StreamActivityFeedMatchStateUpdateEndedFragmentDoc = gql`
    fragment StreamActivityFeedMatchStateUpdateEnded on StreamerMatchEnded {
  streamId
  ...MatchResultsBestPlayer
  ...MatchResultsBestPlay
  ...MatchResultsBestTeam
  ...MatchResultsChallenges
}
    ${MatchResultsBestPlayerFragmentDoc}
${MatchResultsBestPlayFragmentDoc}
${MatchResultsBestTeamFragmentDoc}
${MatchResultsChallengesFragmentDoc}`;
export const StreamActivityFeedHighScoringCardFragmentDoc = gql`
    fragment StreamActivityFeedHighScoringCard on GameLogicHighScoringCardPromotedMsg {
  card {
    cardId
    points
    card {
      id
      name
      description
      targetValue
      timerDuration
      ...GameStateCardTargetValues
    }
  }
  user {
    avatars {
      avatar2D
    }
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    preferredColor
    userId
    userTag
  }
  userId
}
    ${GameStateCardTargetValuesFragmentDoc}
${UserBadgeFragmentDoc}`;
export const ActivityFeedChallengeFragmentDoc = gql`
    fragment ActivityFeedChallenge on GameLogicChallenge {
  id
  description
  targetValues {
    label
    value
    selector {
      attribute
      value {
        __typename
      }
    }
  }
}
    `;
export const StreamActivityFeedNewChannelFollowerFragmentDoc = gql`
    fragment StreamActivityFeedNewChannelFollower on StreamerChannelFollowed {
  userId
  follower: user {
    avatars {
      avatar2D
    }
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    preferredColor
    userId
    userTag
  }
}
    ${UserBadgeFragmentDoc}`;
export const StreamActivityFeedNewChannelSubscriberFragmentDoc = gql`
    fragment StreamActivityFeedNewChannelSubscriber on StreamerChannelSubscribed {
  userId
  subscriber: user {
    avatars {
      avatar2D
    }
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    preferredColor
    userId
    userTag
  }
}
    ${UserBadgeFragmentDoc}`;
export const StreamActivityFeedNewChannelSubscriptionGiftedFragmentDoc = gql`
    fragment StreamActivityFeedNewChannelSubscriptionGifted on StreamerSubscriptionGifted {
  userId
  tier
  buyer: user {
    avatars {
      avatar2D
    }
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    preferredColor
    userId
    userTag
  }
  recipients {
    userId
    userTag
    preferredColor
  }
}
    ${UserBadgeFragmentDoc}`;
export const StreamActivityFeedNewChannelViewerFragmentDoc = gql`
    fragment StreamActivityFeedNewChannelViewer on StreamerPlayerJoined {
  userId
  viewer: user {
    avatars {
      avatar2D
    }
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    preferredColor
    userId
    userTag
  }
}
    ${UserBadgeFragmentDoc}`;
export const StreamActivityFeedPremiumBundlePurchaseFragmentDoc = gql`
    fragment StreamActivityFeedPremiumBundlePurchase on StreamerBundlePurchased {
  bundleName
  userId
  buyer: user {
    avatars {
      avatar2D
    }
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    preferredColor
    userId
    userTag
  }
}
    ${UserBadgeFragmentDoc}`;
export const StreamActivityFeedStreamInfoUpdateTitleChangeFragmentDoc = gql`
    fragment StreamActivityFeedStreamInfoUpdateTitleChange on StreamerStreamTitleChanged {
  title
}
    `;
export const StreamActivityFeedStreamStateUpdateStartedFragmentDoc = gql`
    fragment StreamActivityFeedStreamStateUpdateStarted on StreamerStreamStarted {
  streamId
}
    `;
export const StreamActivityFeedStreamStateUpdateEndedFragmentDoc = gql`
    fragment StreamActivityFeedStreamStateUpdateEnded on StreamerStreamEnded {
  streamId
}
    `;
export const StreamActivityFeedStreamerCardPurchaseFragmentDoc = gql`
    fragment StreamActivityFeedStreamerCardPurchase on StreamerStreamerCardPurchased {
  userId
  streamerCardId
  buyer: user {
    avatars {
      avatar2D
    }
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    preferredColor
    userId
    userTag
  }
  streamerCard {
    name
  }
}
    ${UserBadgeFragmentDoc}`;
export const ProfileImageProfileFragmentDoc = gql`
    fragment ProfileImageProfile on ProfileProfile {
  avatars {
    avatar2D
  }
  userTag
}
    `;
export const ModerationUserFragmentDoc = gql`
    fragment ModerationUser on ProfileProfile {
  preferredColor
  userId
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const AutomodQueueChatModerationItemFragmentDoc = gql`
    fragment AutomodQueueChatModerationItem on ChatModerationItem {
  chatMessage {
    content {
      content {
        ... on ChatTextMessage {
          text
        }
        ... on ChatTombstone {
          emptyTypeWorkaround
        }
      }
    }
    createdAt
    textClassification {
      hashes
    }
    sender {
      ...ModerationUser
    }
  }
  reviewer {
    ...ModerationUser
  }
  expiresAt
  expired
  status
  id
}
    ${ModerationUserFragmentDoc}`;
export const SelectableChallengesChallengeFragmentDoc = gql`
    fragment SelectableChallengesChallenge on ChallengesessionChallenge {
  id
  description
}
    `;
export const SetupChallengeSelectedChallengeFragmentDoc = gql`
    fragment SetupChallengeSelectedChallenge on ChallengesessionChallenge {
  id
  description
}
    `;
export const SetupChallengeChallengeFragmentDoc = gql`
    fragment SetupChallengeChallenge on ChallengesessionChallenge {
  id
  description
  ...SetupChallengeSelectedChallenge
}
    ${SetupChallengeSelectedChallengeFragmentDoc}`;
export const ActiveSessionChallengeFragmentDoc = gql`
    fragment ActiveSessionChallenge on ChallengesessionChallenge {
  id
  description
}
    `;
export const PickingChallengesChallengeFragmentDoc = gql`
    fragment PickingChallengesChallenge on ChallengesessionChallenge {
  id
  ...ActiveSessionChallenge
}
    ${ActiveSessionChallengeFragmentDoc}`;
export const ChallengeSessionChallengeStatusFragmentDoc = gql`
    fragment ChallengeSessionChallengeStatus on ChallengesessionChallenge {
  id
  ...PickingChallengesChallenge
}
    ${PickingChallengesChallengeFragmentDoc}`;
export const ChallengeFragmentDoc = gql`
    fragment Challenge on ChallengesessionChallenge {
  id
  description
  state
}
    `;
export const ChallengeSessionFragmentDoc = gql`
    fragment ChallengeSession on ChallengesessionChallengeSession {
  id
  submissionWindowLength
  phase
  challenges {
    ...Challenge
  }
}
    ${ChallengeFragmentDoc}`;
export const NewChallengeSessionFragmentDoc = gql`
    fragment NewChallengeSession on ChallengesessionChallengeSession {
  id
}
    `;
export const ChatUserListItemSenderInfoFragmentDoc = gql`
    fragment ChatUserListItemSenderInfo on ChatSenderInfo {
  userId
  username
  badges {
    ...UserBadge
  }
}
    ${UserBadgeFragmentDoc}`;
export const ChatUserListSectionSenderInfoFragmentDoc = gql`
    fragment ChatUserListSectionSenderInfo on ChatSenderInfo {
  userId
  username
  ...ChatUserListItemSenderInfo
}
    ${ChatUserListItemSenderInfoFragmentDoc}`;
export const ChatUserListUserFragmentDoc = gql`
    fragment ChatUserListUser on ChatChatUser {
  userId
  senderInfo {
    userId
    ...ChatUserListSectionSenderInfo
  }
}
    ${ChatUserListSectionSenderInfoFragmentDoc}`;
export const ModerationLogUserFragmentDoc = gql`
    fragment ModerationLogUser on ProfileProfile {
  ...ModerationUser
}
    ${ModerationUserFragmentDoc}`;
export const ModerationLogEventFragmentDoc = gql`
    fragment ModerationLogEvent on ChannelModerationEvent {
  id
  channelId
  moderator {
    ...ModerationLogUser
  }
  timestamp
  content {
    content {
      ... on ChannelUserMuted {
        duration
        reason
        description
        user {
          userId
          ...ModerationLogUser
        }
        userId
      }
      ... on ChannelUserBanned {
        description
        violation
        user {
          userId
          ...ModerationLogUser
        }
        userId
      }
      ... on ChannelUserUnbanned {
        user {
          userId
          ...ModerationLogUser
        }
        userId
      }
      ... on ChannelBanAppealAccepted {
        comment
        user {
          userId
          ...ModerationLogUser
        }
        userId
      }
      ... on ChannelBanAppealRejected {
        comment
        user {
          userId
          ...ModerationLogUser
        }
        userId
      }
      ... on ChannelAutomodItemAccepted {
        message {
          content {
            ... on ChatTextMessage {
              text
            }
          }
        }
        user {
          userId
          ...ModerationLogUser
        }
        userId
      }
      ... on ChannelAutomodItemRejected {
        message {
          content {
            ... on ChatTextMessage {
              text
            }
          }
        }
        user {
          userId
          ...ModerationLogUser
        }
        userId
      }
    }
  }
}
    ${ModerationLogUserFragmentDoc}`;
export const MatchStatusEndEventFragmentDoc = gql`
    fragment MatchStatusEndEvent on GameLogicMatchEndedMsg {
  streamId
  bestCard {
    succeedingCard {
      user {
        userId
        userTag
        avatars {
          avatar2D
        }
      }
      points
      card {
        id
        ...GameCard
      }
    }
    groupName
  }
  bestGroup {
    players {
      id
      groupName
      user {
        userId
        userTag
        avatars {
          avatar2D
        }
      }
    }
    group {
      id
      name
      points
    }
  }
  bestPlayer {
    id
    points
    groupName
    user {
      userId
      userTag
      avatars {
        avatar2D
      }
    }
  }
}
    ${GameCardFragmentDoc}`;
export const UserHighlightProfileFragmentDoc = gql`
    fragment UserHighlightProfile on ProfileProfile {
  preferredColor
  userId
  userTag
  avatars {
    avatar2D
  }
}
    `;
export const EventListItemProfileFragmentDoc = gql`
    fragment EventListItemProfile on ProfileProfile {
  preferredColor
  userId
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const HighScoringCardEventFragmentDoc = gql`
    fragment HighScoringCardEvent on GameLogicHighScoringCardPromotedMsg {
  user {
    userId
    userTag
    avatars {
      avatar2D
    }
    ...UserHighlightProfile
    ...EventListItemProfile
  }
  groupName
  card {
    points
    card {
      id
      ...GameCard
    }
  }
}
    ${UserHighlightProfileFragmentDoc}
${EventListItemProfileFragmentDoc}
${GameCardFragmentDoc}`;
export const NewFollowerFragmentDoc = gql`
    fragment NewFollower on StreamerChannelFollowed {
  userId
  user {
    userId
    ...UserHighlightProfile
    ...EventListItemProfile
  }
}
    ${UserHighlightProfileFragmentDoc}
${EventListItemProfileFragmentDoc}`;
export const NewSubscriberFragmentDoc = gql`
    fragment NewSubscriber on StreamerChannelSubscribed {
  userId
  subscriber: user {
    userId
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    ...UserHighlightProfile
    ...EventListItemProfile
  }
}
    ${UserBadgeFragmentDoc}
${UserHighlightProfileFragmentDoc}
${EventListItemProfileFragmentDoc}`;
export const NewGiftSubscriptionFragmentDoc = gql`
    fragment NewGiftSubscription on StreamerSubscriptionGifted {
  userId
  gifter: user {
    userId
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    ...UserHighlightProfile
    ...EventListItemProfile
  }
  recipients {
    userId
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    ...UserHighlightProfile
    ...EventListItemProfile
  }
}
    ${UserBadgeFragmentDoc}
${UserHighlightProfileFragmentDoc}
${EventListItemProfileFragmentDoc}`;
export const StreamMatchEventsFragmentDoc = gql`
    fragment StreamMatchEvents on StreamerStreamEventContentUnion {
  ... on GameLogicMatchStartedMsg {
    streamId
  }
  ...MatchStatusEndEvent
  ...HighScoringCardEvent
  ...NewFollower
  ...NewSubscriber
  ...NewGiftSubscription
}
    ${MatchStatusEndEventFragmentDoc}
${HighScoringCardEventFragmentDoc}
${NewFollowerFragmentDoc}
${NewSubscriberFragmentDoc}
${NewGiftSubscriptionFragmentDoc}`;
export const TopActiveCardFragmentDoc = gql`
    fragment TopActiveCard on GameLogicCard {
  id
  name
  description
  targetValue
  timerDuration
  ...GameStateCardTargetValues
}
    ${GameStateCardTargetValuesFragmentDoc}`;
export const AdminChannelListSelectorChannelFragmentDoc = gql`
    fragment AdminChannelListSelectorChannel on ChannelChannel {
  id
  liveStatus
  name
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const SidebarChannelFragmentDoc = gql`
    fragment SidebarChannel on ChannelChannel {
  name
  id
  title
  ...ChannelLogoChannel
  ...AdminChannelListSelectorChannel
}
    ${ChannelLogoChannelFragmentDoc}
${AdminChannelListSelectorChannelFragmentDoc}`;
export const NavigationSidebarChannelFragmentDoc = gql`
    fragment NavigationSidebarChannel on ChannelChannel {
  ...SidebarChannel
}
    ${SidebarChannelFragmentDoc}`;
export const ChannelSelectorOptionChannelFragmentDoc = gql`
    fragment ChannelSelectorOptionChannel on ChannelChannel {
  id
  liveStatus
  name
}
    `;
export const SidebarAnnouncementFragmentDoc = gql`
    fragment SidebarAnnouncement on AnnouncementAnnouncement {
  id
  title
  text
  category
  startTime
}
    `;
export const TopBarChannelFragmentDoc = gql`
    fragment TopBarChannel on ChannelChannel {
  subscriberCount
  followerCount
  isPublic
}
    `;
export const ChallengesOverviewCategoryFragmentDoc = gql`
    fragment ChallengesOverviewCategory on GameGame {
  id
  name
}
    `;
export const SelectedChallengeCategoryFragmentDoc = gql`
    fragment SelectedChallengeCategory on GameGame {
  id
  ...ChallengesOverviewCategory
}
    ${ChallengesOverviewCategoryFragmentDoc}`;
export const ListGameLogicCardFragmentDoc = gql`
    fragment ListGameLogicCard on GameLogicCard {
  id
  familyId
  name
}
    `;
export const CreatorCardFormStreamerCardFragmentDoc = gql`
    fragment CreatorCardFormStreamerCard on GameLogicStreamerCard {
  id
  ...GameStreamerCard
}
    ${GameStreamerCardFragmentDoc}`;
export const CreatorCardGameFragmentDoc = gql`
    fragment CreatorCardGame on GameGame {
  id
  name
  noicePredictionsEnabled
  activeSeason {
    id
    name
  }
}
    `;
export const CreatorCardViewBaseCardFragmentDoc = gql`
    fragment CreatorCardViewBaseCard on GameLogicCard {
  id
  name
  season {
    id
    name
    game {
      id
      name
    }
  }
}
    `;
export const UploadVideoCreatorCardFragmentDoc = gql`
    fragment UploadVideoCreatorCard on GameLogicStreamerCard {
  video
}
    `;
export const UploadImageCreatorCardFragmentDoc = gql`
    fragment UploadImageCreatorCard on GameLogicStreamerCard {
  image
}
    `;
export const CreatorCardPublishSectionCardFragmentDoc = gql`
    fragment CreatorCardPublishSectionCard on GameLogicStreamerCard {
  id
  draft
  saleConfig {
    cardId
    enabled
    excludeFromBundles
  }
  video
  image
}
    `;
export const CreatorCardStatusCardFragmentDoc = gql`
    fragment CreatorCardStatusCard on GameLogicStreamerCard {
  draft
  video
  image
  saleConfig {
    cardId
    enabled
    excludeFromBundles
  }
}
    `;
export const CreatorCardViewCreatorCardFragmentDoc = gql`
    fragment CreatorCardViewCreatorCard on GameLogicStreamerCard {
  id
  name
  draft
  ...CreatorCardPublishSectionCard
  ...CreatorCardStatusCard
  ...GameStreamerCard
}
    ${CreatorCardPublishSectionCardFragmentDoc}
${CreatorCardStatusCardFragmentDoc}
${GameStreamerCardFragmentDoc}`;
export const CreatorCardViewCreatorCardWithBaseCardFragmentDoc = gql`
    fragment CreatorCardViewCreatorCardWithBaseCard on GameLogicStreamerCard {
  ...CreatorCardViewCreatorCard
  baseCard {
    id
  }
}
    ${CreatorCardViewCreatorCardFragmentDoc}`;
export const PublishedStreamerCardFragmentDoc = gql`
    fragment PublishedStreamerCard on GameLogicStreamerCard {
  draft
}
    `;
export const CreatedCreatorCardSaleConfigFragmentDoc = gql`
    fragment CreatedCreatorCardSaleConfig on GameLogicStreamerCard {
  saleConfig {
    cardId
    channelId
    enabled
    excludeFromBundles
  }
}
    `;
export const UpdatedCreatorCardSaleConfigFragmentDoc = gql`
    fragment UpdatedCreatorCardSaleConfig on GameLogicStreamerCard {
  saleConfig {
    cardId
    enabled
    excludeFromBundles
  }
}
    `;
export const CreatorCardListCardFragmentDoc = gql`
    fragment CreatorCardListCard on GameLogicStreamerCard {
  name
  baseCard {
    id
    name
    ...GameStreamerBaseCard
  }
  ...GameStreamerCard
  ...CreatorCardStatusCard
}
    ${GameStreamerBaseCardFragmentDoc}
${GameStreamerCardFragmentDoc}
${CreatorCardStatusCardFragmentDoc}`;
export const StreamedGameFragmentDoc = gql`
    fragment StreamedGame on GameGame {
  id
  name
}
    `;
export const UpdatedDraftCreatorCardFragmentDoc = gql`
    fragment UpdatedDraftCreatorCard on GameLogicStreamerCard {
  name
  familyId
  gameId
  baseCard(season_id: $seasonId) {
    id
  }
}
    `;
export const ChannelSubscriptionSettingSubscriptionConfigFragmentDoc = gql`
    fragment ChannelSubscriptionSettingSubscriptionConfig on SubscriptionChannelSubscriptionConfig {
  subscriptionsEnabled
}
    `;
export const ChannelEmojiFormContentEmojiFragmentDoc = gql`
    fragment ChannelEmojiFormContentEmoji on EmojiEmoji {
  label
  image
  disabled
}
    `;
export const ChannelEmojiFormContentChannelFragmentDoc = gql`
    fragment ChannelEmojiFormContentChannel on ChannelChannel {
  name
}
    `;
export const BanDetailsUserFragmentDoc = gql`
    fragment BanDetailsUser on ChannelBannedUser {
  user {
    userId
    avatars {
      avatar2D
    }
    userTag
    ...ProfileImageProfile
  }
  userId
  bannedAt
  violation
  description
  moderator {
    userId
    userTag
  }
  appeal {
    status
    appealText
    createdAt
  }
}
    ${ProfileImageProfileFragmentDoc}`;
export const BannedUserBannedUserFragmentDoc = gql`
    fragment BannedUserBannedUser on ChannelBannedUser {
  userId
  bannedAt
  user {
    userId
    userTag
    avatars {
      avatar2D
    }
    ...ProfileImageProfile
  }
  appeal {
    status
  }
}
    ${ProfileImageProfileFragmentDoc}`;
export const ArenaBlockArenaFragmentDoc = gql`
    fragment ArenaBlockArena on ArenaArena {
  id
  name
  thumbnailUrl
  enabled
}
    `;
export const ArenaBlockChannelStreamBackendConfigFragmentDoc = gql`
    fragment ArenaBlockChannelStreamBackendConfig on ChannelStreamBackendConfig {
  id
  crConfig {
    arenaId
    containerImage
    controllerContainerImage
  }
}
    `;
export const LogoImageBlockChannelFragmentDoc = gql`
    fragment LogoImageBlockChannel on ChannelChannel {
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const ChannelBannerChannelFragmentDoc = gql`
    fragment ChannelBannerChannel on ChannelChannel {
  offlineBanner
}
    `;
export const OfflineBannerBlockChannelFragmentDoc = gql`
    fragment OfflineBannerBlockChannel on ChannelChannel {
  ...ChannelBannerChannel
}
    ${ChannelBannerChannelFragmentDoc}`;
export const ChannelInfoUpdateFragmentDoc = gql`
    fragment ChannelInfoUpdate on ChannelChannel {
  id
  description
  links {
    name
    type
    url
  }
}
    `;
export const ModeratorProfileFragmentDoc = gql`
    fragment ModeratorProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const SimulcastingDestinationPreviewConfigFragmentDoc = gql`
    fragment SimulcastingDestinationPreviewConfig on ChannelRestreamingConfig {
  channelId
  rtmpEndpoint
  bitrate
  enabled
}
    `;
export const SimulcastingSettingsOverviewConfigFragmentDoc = gql`
    fragment SimulcastingSettingsOverviewConfig on ChannelRestreamingConfig {
  channelId
  rtmpEndpoint
  bitrate
  enabled
  ...SimulcastingDestinationPreviewConfig
}
    ${SimulcastingDestinationPreviewConfigFragmentDoc}`;
export const SimulcastingDestinationConfigFragmentDoc = gql`
    fragment SimulcastingDestinationConfig on ChannelRestreamingConfig {
  channelId
  rtmpEndpoint
  rtmpKey
  bitrate
  enabled
  ...SimulcastingSettingsOverviewConfig
}
    ${SimulcastingSettingsOverviewConfigFragmentDoc}`;
export const RestreamingConfigFragmentFragmentDoc = gql`
    fragment RestreamingConfigFragment on ChannelRestreamingConfig {
  channelId
  enabled
  rtmpEndpoint
  rtmpKey
  bitrate
  enabled
}
    `;
export const PrivacyUpdateChannelFragmentDoc = gql`
    fragment PrivacyUpdateChannel on ChannelChannel {
  id
  isPublic
}
    `;
export const ExternalPopoutProfileFragmentDoc = gql`
    fragment ExternalPopoutProfile on ProfileProfile {
  userId
  account {
    email
  }
}
    `;
export const MatchEndLevelThresholdsFragmentDoc = gql`
    fragment MatchEndLevelThresholds on ProgressionLevelConfig {
  threshold
}
    `;
export const MatchEndPlayerLevelFragmentDoc = gql`
    fragment MatchEndPlayerLevel on ProgressionSeasonProgression {
  level
  nextLevel
}
    `;
export const MatchResultsSummaryPlayerScoreProfileFragmentDoc = gql`
    fragment MatchResultsSummaryPlayerScoreProfile on ProfileProfile {
  userId
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const BestPlayProfileFragmentDoc = gql`
    fragment BestPlayProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatarFullbody
  }
}
    `;
export const PlayerScoreProfileFragmentDoc = gql`
    fragment PlayerScoreProfile on ProfileProfile {
  userId
  userTag
}
    `;
export const HighScoringCardPlayerFragmentDoc = gql`
    fragment HighScoringCardPlayer on ProfileProfile {
  userId
  userTag
  avatars {
    avatarFullbody
  }
}
    `;
export const CardRowAvatarProfileFragmentDoc = gql`
    fragment CardRowAvatarProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
  friendshipStatus {
    status
  }
}
    `;
export const SpectatorPlayerInfoProfileFragmentDoc = gql`
    fragment SpectatorPlayerInfoProfile on ProfileProfile {
  userId
  userTag
  ...CardRowAvatarProfile
}
    ${CardRowAvatarProfileFragmentDoc}`;
export const SpectatorDisplayBottomProfileFragmentDoc = gql`
    fragment SpectatorDisplayBottomProfile on ProfileProfile {
  userId
  ...SpectatorPlayerInfoProfile
}
    ${SpectatorPlayerInfoProfileFragmentDoc}`;
export const GameCardSoundDataFragmentDoc = gql`
    fragment GameCardSoundData on GameLogicCard {
  id
  pointsMax
  targetValue
  isAllOrNothing
  isMatchCard
}
    `;
export const ChallengesContentChallengeFragmentDoc = gql`
    fragment ChallengesContentChallenge on GameLogicChallenge {
  id
  description
  targetValues {
    label
    value
  }
}
    `;
export const ActiveBoosterTooltipContentProfileFragmentDoc = gql`
    fragment ActiveBoosterTooltipContentProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
}
    `;
export const ActiveBoosterDialogContentProfileFragmentDoc = gql`
    fragment ActiveBoosterDialogContentProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
}
    `;
export const ActiveBoosterProfileFragmentDoc = gql`
    fragment ActiveBoosterProfile on ProfileProfile {
  ...ActiveBoosterTooltipContentProfile
  ...ActiveBoosterDialogContentProfile
}
    ${ActiveBoosterTooltipContentProfileFragmentDoc}
${ActiveBoosterDialogContentProfileFragmentDoc}`;
export const ActiveBoosterTooltipContentBoosterFragmentDoc = gql`
    fragment ActiveBoosterTooltipContentBooster on GameLogicBooster {
  id
  name
  descriptionCondition
  descriptionDefaultBenefit
  descriptionTargetNoneBenefit
  descriptionTargetSelf
}
    `;
export const ActiveBoosterDialogContentBoosterFragmentDoc = gql`
    fragment ActiveBoosterDialogContentBooster on GameLogicBooster {
  id
  name
  descriptionCondition
  descriptionDefaultBenefit
  descriptionTargetNoneBenefit
  descriptionTargetSelf
}
    `;
export const ActiveBoosterFragmentDoc = gql`
    fragment ActiveBooster on GameLogicBooster {
  id
  ...ActiveBoosterTooltipContentBooster
  ...ActiveBoosterDialogContentBooster
}
    ${ActiveBoosterTooltipContentBoosterFragmentDoc}
${ActiveBoosterDialogContentBoosterFragmentDoc}`;
export const TeamMateBoosterDialogContentBoosterFragmentDoc = gql`
    fragment TeamMateBoosterDialogContentBooster on GameLogicBooster {
  name
  descriptionCondition
  descriptionDefaultBenefit
}
    `;
export const TeamMateBoosterTooltipContentBoosterFragmentDoc = gql`
    fragment TeamMateBoosterTooltipContentBooster on GameLogicBooster {
  name
  descriptionCondition
  descriptionDefaultBenefit
}
    `;
export const CgActiveBoosterFragmentDoc = gql`
    fragment CgActiveBooster on GameLogicBooster {
  id
  timeActive
  valueSelf
  valueOther
  image
  name
}
    `;
export const CgAvailableBoosterFragmentDoc = gql`
    fragment CgAvailableBooster on GameLogicBooster {
  id
  canTargetSelf
}
    `;
export const GameStateCardFragmentDoc = gql`
    fragment GameStateCard on GameLogicCard {
  id
  pointsMin
  pointsMax
  pointsTimeTarget
  timerDuration
  targetValue
  isMatchCard
  isAllOrNothing
  ...GameStateCardTargetValues
}
    ${GameStateCardTargetValuesFragmentDoc}`;
export const CgChallengesSystemChallengeFragmentDoc = gql`
    fragment CGChallengesSystemChallenge on GameLogicChallenge {
  id
  targetValues {
    label
    value
  }
}
    `;
export const ChannelEventContentProfileFragmentDoc = gql`
    fragment ChannelEventContentProfile on ProfileProfile {
  preferredColor
  userId
  userTag
}
    `;
export const ChannelEventSubscriptionContentProfileFragmentDoc = gql`
    fragment ChannelEventSubscriptionContentProfile on ProfileProfile {
  badges(channel_id: $channelId) {
    type
    level
  }
}
    `;
export const ChannelEventAvatarItemPurchaseItemFragmentDoc = gql`
    fragment ChannelEventAvatarItemPurchaseItem on ItemItem {
  id
  name
}
    `;
export const ChatMessageAttachmentsFragmentDoc = gql`
    fragment ChatMessageAttachments on ChatTextMessageAttachment {
  label
  source
  startIndex
  endIndex
  __typename
}
    `;
export const SendChatMessageProfileFragmentDoc = gql`
    fragment SendChatMessageProfile on ProfileProfile {
  userTag
  avatars {
    avatar2D
  }
  badges(channel_id: $channelId) {
    type
    level
  }
  preferredColor
}
    `;
export const ChatMessagesHookProfileFragmentDoc = gql`
    fragment ChatMessagesHookProfile on ProfileProfile {
  ...SendChatMessageProfile
}
    ${SendChatMessageProfileFragmentDoc}`;
export const InventoryEmojiFragmentDoc = gql`
    fragment InventoryEmoji on EmojiEmoji {
  id
  label
  image
  channelId
}
    `;
export const UpdateChatSettingsProfileFragmentDoc = gql`
    fragment UpdateChatSettingsProfile on ProfileProfile {
  userId
  preferredColor
}
    `;
export const EmoteAvatarAnimationFragmentDoc = gql`
    fragment EmoteAvatarAnimation on AvatarAnimation {
  name
  chatCommand
  iconUrl
  id
}
    `;
export const ChatMessagesProfileFragmentDoc = gql`
    fragment ChatMessagesProfile on ProfileProfile {
  userId
  userTag
}
    `;
export const EmojiDrawerChannelFragmentDoc = gql`
    fragment EmojiDrawerChannel on ChannelChannel {
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const ReasonDescriptionInputProfileFragmentDoc = gql`
    fragment ReasonDescriptionInputProfile on ProfileProfile {
  userTag
}
    `;
export const ReasonSelectProfileFragmentDoc = gql`
    fragment ReasonSelectProfile on ProfileProfile {
  ...ReasonDescriptionInputProfile
}
    ${ReasonDescriptionInputProfileFragmentDoc}`;
export const ReasonDescriptionInputChannelFragmentDoc = gql`
    fragment ReasonDescriptionInputChannel on ChannelChannel {
  name
}
    `;
export const ReasonSelectChannelFragmentDoc = gql`
    fragment ReasonSelectChannel on ChannelChannel {
  ...ReasonDescriptionInputChannel
}
    ${ReasonDescriptionInputChannelFragmentDoc}`;
export const ReportedChannelFragmentDoc = gql`
    fragment ReportedChannel on ChannelChannel {
  name
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const ReportedUserProfileFragmentDoc = gql`
    fragment ReportedUserProfile on ProfileProfile {
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const SignupFlowChannelFragmentDoc = gql`
    fragment SignupFlowChannel on ChannelChannel {
  name
  liveStatus
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const PlatformAnnouncementFragmentDoc = gql`
    fragment PlatformAnnouncement on AnnouncementAnnouncement {
  id
  title
  text
  category
  startTime
  image
}
    `;
export const LogoUpdateChannelChannelFragmentDoc = gql`
    fragment LogoUpdateChannelChannel on ChannelChannel {
  id
  logo
}
    `;
export const BannerUpdateChannelChannelFragmentDoc = gql`
    fragment BannerUpdateChannelChannel on ChannelChannel {
  id
  offlineBanner
}
    `;
export const AssetUploadEmojiEmojiFragmentDoc = gql`
    fragment AssetUploadEmojiEmoji on EmojiEmoji {
  image
}
    `;
export const WalletCurrencyFragmentDoc = gql`
    fragment WalletCurrency on WalletWalletCurrency {
  currencyId
  currencyAmount
}
    `;
export const ZendeskPrefillProfileFragmentDoc = gql`
    fragment ZendeskPrefillProfile on ProfileProfile {
  userId
  userTag
  account {
    email
  }
}
    `;
export const SubscriptionGetChannelEmojisChannelEmojiFragmentDoc = gql`
    fragment SubscriptionGetChannelEmojisChannelEmoji on EmojiEmoji {
  __typename
  id
  image
  name
}
    `;
export const SubscriptionGetChannelEmojisChannelFragmentDoc = gql`
    fragment SubscriptionGetChannelEmojisChannel on ChannelChannel {
  subscriptionConfig {
    channelId
    tiers {
      level
      entitlements {
        itemId
        item {
          id
          type
          children {
            id
            type
            details {
              ... on EmojiEmoji {
                ...SubscriptionGetChannelEmojisChannelEmoji
              }
            }
          }
        }
      }
    }
  }
}
    ${SubscriptionGetChannelEmojisChannelEmojiFragmentDoc}`;
export const ActiveFriendsListProfileFragmentDoc = gql`
    fragment ActiveFriendsListProfile on ProfileProfile {
  userTag
  avatars {
    avatar2D
  }
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const BlockUserProfileFragmentDoc = gql`
    fragment BlockUserProfile on ProfileProfile {
  avatars {
    avatar2D
  }
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const ChannelBanModalProfileFragmentDoc = gql`
    fragment ChannelBanModalProfile on ProfileProfile {
  userTag
  userId
}
    `;
export const ChannelMuteModalProfileFragmentDoc = gql`
    fragment ChannelMuteModalProfile on ProfileProfile {
  userTag
  userId
}
    `;
export const ChannelUnbanModalProfileFragmentDoc = gql`
    fragment ChannelUnbanModalProfile on ProfileProfile {
  userTag
  userId
}
    `;
export const ChannelUnmuteModalProfileFragmentDoc = gql`
    fragment ChannelUnmuteModalProfile on ProfileProfile {
  userTag
  userId
}
    `;
export const FriendRequestButtonProfileFragmentDoc = gql`
    fragment FriendRequestButtonProfile on ProfileProfile {
  userId
  userTag
  friendshipStatus {
    status
    lastStatusChange
  }
  temporary
}
    `;
export const FriendsSidebarFriendButtonsProfileFragmentDoc = gql`
    fragment FriendsSidebarFriendButtonsProfile on ProfileProfile {
  userId
  friendshipStatus {
    status
  }
}
    `;
export const ProfileImageShowOnlineStatusProfileFragmentDoc = gql`
    fragment ProfileImageShowOnlineStatusProfile on ProfileProfile {
  ...ProfileImageProfile
  onlineStatus
  settings {
    privacy {
      hideOnlineStatus
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;
export const FriendsSidebarItemExpandedProfileFragmentDoc = gql`
    fragment FriendsSidebarItemExpandedProfile on ProfileProfile {
  userTag
  isNewUsername
  ...ProfileImageShowOnlineStatusProfile
  ...FriendsSidebarFriendButtonsProfile
}
    ${ProfileImageShowOnlineStatusProfileFragmentDoc}
${FriendsSidebarFriendButtonsProfileFragmentDoc}`;
export const FriendsSidebarFriendProfileFragmentDoc = gql`
    fragment FriendsSidebarFriendProfile on ProfileProfile {
  userId
  userTag
  avatars {
    avatar2D
  }
  onlineStatus
  ...FriendsSidebarFriendButtonsProfile
  ...ProfileImageProfile
  ...FriendsSidebarItemExpandedProfile
}
    ${FriendsSidebarFriendButtonsProfileFragmentDoc}
${ProfileImageProfileFragmentDoc}
${FriendsSidebarItemExpandedProfileFragmentDoc}`;
export const FriendsSidebarFriendStatusFriendsUserFragmentDoc = gql`
    fragment FriendsSidebarFriendStatusFriendsUser on FriendsUser {
  activity {
    isOnline
    channel {
      id
      name
      game {
        id
        name
      }
    }
  }
  profile {
    userId
    onlineStatus
  }
}
    `;
export const FriendsSidebarFriendPanelFriendFragmentDoc = gql`
    fragment FriendsSidebarFriendPanelFriend on FriendsUser {
  lastStatusChange
  profile {
    userId
    userTag
    avatars {
      avatar2D
    }
    onlineStatus
    userTag
    isNewUsername
    ...ProfileImageShowOnlineStatusProfile
  }
  ...FriendsSidebarFriendStatusFriendsUser
}
    ${ProfileImageShowOnlineStatusProfileFragmentDoc}
${FriendsSidebarFriendStatusFriendsUserFragmentDoc}`;
export const FriendsSidebarItemExpandedFriendFragmentDoc = gql`
    fragment FriendsSidebarItemExpandedFriend on FriendsUser {
  profile {
    userId
    ...FriendsSidebarItemExpandedProfile
  }
  ...FriendsSidebarFriendStatusFriendsUser
}
    ${FriendsSidebarItemExpandedProfileFragmentDoc}
${FriendsSidebarFriendStatusFriendsUserFragmentDoc}`;
export const FriendsSidebarFriendActionsFriendsUserFragmentDoc = gql`
    fragment FriendsSidebarFriendActionsFriendsUser on FriendsUser {
  userId
  activity {
    isOnline
    channel {
      id
      name
    }
  }
  profile {
    userId
    userTag
    friendshipStatus {
      status
    }
  }
}
    `;
export const FriendsSidebarFriendFragmentDoc = gql`
    fragment FriendsSidebarFriend on FriendsUser {
  userId
  profile {
    ...FriendsSidebarFriendProfile
    ...ProfileImageShowOnlineStatusProfile
  }
  ...FriendsSidebarFriendPanelFriend
  ...FriendsSidebarFriendStatusFriendsUser
  ...FriendsSidebarItemExpandedFriend
  ...FriendsSidebarFriendActionsFriendsUser
}
    ${FriendsSidebarFriendProfileFragmentDoc}
${ProfileImageShowOnlineStatusProfileFragmentDoc}
${FriendsSidebarFriendPanelFriendFragmentDoc}
${FriendsSidebarFriendStatusFriendsUserFragmentDoc}
${FriendsSidebarItemExpandedFriendFragmentDoc}
${FriendsSidebarFriendActionsFriendsUserFragmentDoc}`;
export const FriendsSidebarFriendListFriendFragmentDoc = gql`
    fragment FriendsSidebarFriendListFriend on FriendsUser {
  ...FriendsSidebarFriend
}
    ${FriendsSidebarFriendFragmentDoc}`;
export const FriendsSidebarFriendListProfileFragmentDoc = gql`
    fragment FriendsSidebarFriendListProfile on ProfileProfile {
  ...FriendsSidebarFriendProfile
}
    ${FriendsSidebarFriendProfileFragmentDoc}`;
export const FriendsSidebarPartyFriendFragmentDoc = gql`
    fragment FriendsSidebarPartyFriend on FriendsUser {
  ...FriendsSidebarFriend
}
    ${FriendsSidebarFriendFragmentDoc}`;
export const FriendsSidebarPartyProfileFragmentDoc = gql`
    fragment FriendsSidebarPartyProfile on ProfileProfile {
  ...FriendsSidebarFriendProfile
}
    ${FriendsSidebarFriendProfileFragmentDoc}`;
export const MiniProfileAvatarProfileFragmentDoc = gql`
    fragment MiniProfileAvatarProfile on ProfileProfile {
  avatars {
    avatarFullbody
  }
  userTag
}
    `;
export const MiniProfileHeaderProfileFragmentDoc = gql`
    fragment MiniProfileHeaderProfile on ProfileProfile {
  userTag
  temporary
  isNewUsername
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const MiniProfileDetailsProfileFragmentDoc = gql`
    fragment MiniProfileDetailsProfile on ProfileProfile {
  userId
}
    `;
export const MiniProfileGameRankProfileFragmentDoc = gql`
    fragment MiniProfileGameRankProfile on ProfileProfile {
  playedGames {
    id
    userId
    seasonId
    game {
      id
      name
    }
    progression {
      level
    }
    season {
      id
      name
    }
  }
}
    `;
export const MiniProfileFriendStatusProfileFragmentDoc = gql`
    fragment MiniProfileFriendStatusProfile on ProfileProfile {
  userId
  userTag
  friendshipStatus {
    status
    lastStatusChange
  }
}
    `;
export const MiniProfilePopoverMenuProfileFragmentDoc = gql`
    fragment MiniProfilePopoverMenuProfile on ProfileProfile {
  userId
  userTag
  friendshipStatus {
    status
  }
  temporary
}
    `;
export const MiniProfileFooterProfileFragmentDoc = gql`
    fragment MiniProfileFooterProfile on ProfileProfile {
  userId
  friendshipStatus {
    status
  }
  temporary
  ...MiniProfilePopoverMenuProfile
}
    ${MiniProfilePopoverMenuProfileFragmentDoc}`;
export const MiniProfileFragmentDoc = gql`
    fragment MiniProfile on ProfileProfile {
  userId
  ...MiniProfileAvatarProfile
  ...MiniProfileHeaderProfile
  ...MiniProfileDetailsProfile
  ...MiniProfileGameRankProfile
  ...MiniProfileFriendStatusProfile
  ...MiniProfileFooterProfile
}
    ${MiniProfileAvatarProfileFragmentDoc}
${MiniProfileHeaderProfileFragmentDoc}
${MiniProfileDetailsProfileFragmentDoc}
${MiniProfileGameRankProfileFragmentDoc}
${MiniProfileFriendStatusProfileFragmentDoc}
${MiniProfileFooterProfileFragmentDoc}`;
export const MiniProfilePopoverMenuChannelBanFragmentDoc = gql`
    fragment MiniProfilePopoverMenuChannelBan on ChannelUserBanStatus {
  banned
}
    `;
export const MiniProfileModerationStateChannelBanFragmentDoc = gql`
    fragment MiniProfileModerationStateChannelBan on ChannelUserBanStatus {
  banned
  appeal {
    status
  }
}
    `;
export const MiniProfileChannelBanFragmentDoc = gql`
    fragment MiniProfileChannelBan on ChannelUserBanStatus {
  ...MiniProfilePopoverMenuChannelBan
  ...MiniProfileModerationStateChannelBan
}
    ${MiniProfilePopoverMenuChannelBanFragmentDoc}
${MiniProfileModerationStateChannelBanFragmentDoc}`;
export const ChannelUnbanModalChannelUserBanStatusFragmentDoc = gql`
    fragment ChannelUnbanModalChannelUserBanStatus on ChannelUserBanStatus {
  bannedAt
  violation
  description
  moderator {
    userId
    userTag
  }
}
    `;
export const MiniProfilePortalChannelBanFragmentDoc = gql`
    fragment MiniProfilePortalChannelBan on ChannelUserBanStatus {
  ...MiniProfileChannelBan
  ...ChannelUnbanModalChannelUserBanStatus
}
    ${MiniProfileChannelBanFragmentDoc}
${ChannelUnbanModalChannelUserBanStatusFragmentDoc}`;
export const MiniProfileModerationStateChatStatusFragmentDoc = gql`
    fragment MiniProfileModerationStateChatStatus on ChatGetChatUserStatusResponse {
  muted
  muteDuration
}
    `;
export const MiniProfilePopoverMenuChatStatusFragmentDoc = gql`
    fragment MiniProfilePopoverMenuChatStatus on ChatGetChatUserStatusResponse {
  muted
}
    `;
export const MiniProfileChatStatusFragmentDoc = gql`
    fragment MiniProfileChatStatus on ChatGetChatUserStatusResponse {
  ...MiniProfileModerationStateChatStatus
  ...MiniProfilePopoverMenuChatStatus
}
    ${MiniProfileModerationStateChatStatusFragmentDoc}
${MiniProfilePopoverMenuChatStatusFragmentDoc}`;
export const ChannelUnmuteModalChatStatusFragmentDoc = gql`
    fragment ChannelUnmuteModalChatStatus on ChatGetChatUserStatusResponse {
  muteDuration
}
    `;
export const MiniProfilePortalChatStausFragmentDoc = gql`
    fragment MiniProfilePortalChatStaus on ChatGetChatUserStatusResponse {
  ...MiniProfileChatStatus
  ...ChannelUnmuteModalChatStatus
}
    ${MiniProfileChatStatusFragmentDoc}
${ChannelUnmuteModalChatStatusFragmentDoc}`;
export const FriendStatusUpdateProfileFragmentDoc = gql`
    fragment FriendStatusUpdateProfile on ProfileProfile {
  userId
  friendshipStatus {
    status
    lastStatusChange
  }
}
    `;
export const NewFriendRequestUserFragmentDoc = gql`
    fragment NewFriendRequestUser on FriendsUser {
  userId
}
    `;
export const AuthenticatedAppDataDocument = gql`
    query AuthenticatedAppData($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ZendeskPrefillProfile
  }
}
    ${ZendeskPrefillProfileFragmentDoc}`;

/**
 * __useAuthenticatedAppDataQuery__
 *
 * To run a query within a React component, call `useAuthenticatedAppDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useAuthenticatedAppDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAuthenticatedAppDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useAuthenticatedAppDataQuery(baseOptions: Apollo.QueryHookOptions<AuthenticatedAppDataQuery, AuthenticatedAppDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AuthenticatedAppDataQuery, AuthenticatedAppDataQueryVariables>(AuthenticatedAppDataDocument, options);
      }
export function useAuthenticatedAppDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AuthenticatedAppDataQuery, AuthenticatedAppDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AuthenticatedAppDataQuery, AuthenticatedAppDataQueryVariables>(AuthenticatedAppDataDocument, options);
        }
export type AuthenticatedAppDataQueryHookResult = ReturnType<typeof useAuthenticatedAppDataQuery>;
export type AuthenticatedAppDataLazyQueryHookResult = ReturnType<typeof useAuthenticatedAppDataLazyQuery>;
export type AuthenticatedAppDataQueryResult = Apollo.QueryResult<AuthenticatedAppDataQuery, AuthenticatedAppDataQueryVariables>;
export const AlertsChannelActivityEventsDocument = gql`
    subscription AlertsChannelActivityEvents($channelId: ID, $filter: StreamerChannelActivityEventFilterInput, $after: String) {
  channelActivityEventsSubscribe(
    channelId: $channelId
    filter: $filter
    after: $after
  ) {
    ...AlertsChannelActivityEvent
  }
}
    ${AlertsChannelActivityEventFragmentDoc}`;

/**
 * __useAlertsChannelActivityEventsSubscription__
 *
 * To run a query within a React component, call `useAlertsChannelActivityEventsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useAlertsChannelActivityEventsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAlertsChannelActivityEventsSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useAlertsChannelActivityEventsSubscription(baseOptions?: Apollo.SubscriptionHookOptions<AlertsChannelActivityEventsSubscription, AlertsChannelActivityEventsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<AlertsChannelActivityEventsSubscription, AlertsChannelActivityEventsSubscriptionVariables>(AlertsChannelActivityEventsDocument, options);
      }
export type AlertsChannelActivityEventsSubscriptionHookResult = ReturnType<typeof useAlertsChannelActivityEventsSubscription>;
export type AlertsChannelActivityEventsSubscriptionResult = Apollo.SubscriptionResult<AlertsChannelActivityEventsSubscription>;
export const AlertsTopPredictionsDocument = gql`
    subscription AlertsTopPredictions($streamId: ID) {
  streamTopActiveCardsSubscribe(streamId: $streamId) {
    content {
      ...AlertsTopPredictionsUpdate
    }
  }
}
    ${AlertsTopPredictionsUpdateFragmentDoc}`;

/**
 * __useAlertsTopPredictionsSubscription__
 *
 * To run a query within a React component, call `useAlertsTopPredictionsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useAlertsTopPredictionsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAlertsTopPredictionsSubscription({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useAlertsTopPredictionsSubscription(baseOptions?: Apollo.SubscriptionHookOptions<AlertsTopPredictionsSubscription, AlertsTopPredictionsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<AlertsTopPredictionsSubscription, AlertsTopPredictionsSubscriptionVariables>(AlertsTopPredictionsDocument, options);
      }
export type AlertsTopPredictionsSubscriptionHookResult = ReturnType<typeof useAlertsTopPredictionsSubscription>;
export type AlertsTopPredictionsSubscriptionResult = Apollo.SubscriptionResult<AlertsTopPredictionsSubscription>;
export const UserAnnouncementsDocument = gql`
    query UserAnnouncements($userId: ID!) {
  userAnnouncements(userId: $userId, target: ANNOUNCEMENT_TARGET_STUDIO) {
    announcements {
      id
      ...PlatformAnnouncement
    }
  }
}
    ${PlatformAnnouncementFragmentDoc}`;

/**
 * __useUserAnnouncementsQuery__
 *
 * To run a query within a React component, call `useUserAnnouncementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserAnnouncementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserAnnouncementsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserAnnouncementsQuery(baseOptions: Apollo.QueryHookOptions<UserAnnouncementsQuery, UserAnnouncementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserAnnouncementsQuery, UserAnnouncementsQueryVariables>(UserAnnouncementsDocument, options);
      }
export function useUserAnnouncementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserAnnouncementsQuery, UserAnnouncementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserAnnouncementsQuery, UserAnnouncementsQueryVariables>(UserAnnouncementsDocument, options);
        }
export type UserAnnouncementsQueryHookResult = ReturnType<typeof useUserAnnouncementsQuery>;
export type UserAnnouncementsLazyQueryHookResult = ReturnType<typeof useUserAnnouncementsLazyQuery>;
export type UserAnnouncementsQueryResult = Apollo.QueryResult<UserAnnouncementsQuery, UserAnnouncementsQueryVariables>;
export const CategoryChallengesDocument = gql`
    query CategoryChallenges($gameId: ID!, $channelId: ID!) {
  listChallenges(gameId: $gameId, channelId: $channelId) {
    challenges {
      ...UseCategoryChallengeChallenge
    }
  }
}
    ${UseCategoryChallengeChallengeFragmentDoc}`;

/**
 * __useCategoryChallengesQuery__
 *
 * To run a query within a React component, call `useCategoryChallengesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCategoryChallengesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCategoryChallengesQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useCategoryChallengesQuery(baseOptions: Apollo.QueryHookOptions<CategoryChallengesQuery, CategoryChallengesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CategoryChallengesQuery, CategoryChallengesQueryVariables>(CategoryChallengesDocument, options);
      }
export function useCategoryChallengesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CategoryChallengesQuery, CategoryChallengesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CategoryChallengesQuery, CategoryChallengesQueryVariables>(CategoryChallengesDocument, options);
        }
export type CategoryChallengesQueryHookResult = ReturnType<typeof useCategoryChallengesQuery>;
export type CategoryChallengesLazyQueryHookResult = ReturnType<typeof useCategoryChallengesLazyQuery>;
export type CategoryChallengesQueryResult = Apollo.QueryResult<CategoryChallengesQuery, CategoryChallengesQueryVariables>;
export const CreateChallengeDocument = gql`
    mutation CreateChallenge($gameId: ID!, $channelId: ID!, $description: String!) {
  createChallenge(
    gameId: $gameId
    channelId: $channelId
    description: $description
  ) {
    ...UseCategoryChallengeChallenge
  }
}
    ${UseCategoryChallengeChallengeFragmentDoc}`;
export type CreateChallengeMutationFn = Apollo.MutationFunction<CreateChallengeMutation, CreateChallengeMutationVariables>;

/**
 * __useCreateChallengeMutation__
 *
 * To run a mutation, you first call `useCreateChallengeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateChallengeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createChallengeMutation, { data, loading, error }] = useCreateChallengeMutation({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      channelId: // value for 'channelId'
 *      description: // value for 'description'
 *   },
 * });
 */
export function useCreateChallengeMutation(baseOptions?: Apollo.MutationHookOptions<CreateChallengeMutation, CreateChallengeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateChallengeMutation, CreateChallengeMutationVariables>(CreateChallengeDocument, options);
      }
export type CreateChallengeMutationHookResult = ReturnType<typeof useCreateChallengeMutation>;
export type CreateChallengeMutationResult = Apollo.MutationResult<CreateChallengeMutation>;
export type CreateChallengeMutationOptions = Apollo.BaseMutationOptions<CreateChallengeMutation, CreateChallengeMutationVariables>;
export const UpdateChallengeDocument = gql`
    mutation UpdateChallenge($gameId: ID!, $challengeId: ID!, $channelId: ID!, $description: String!, $disabled: Boolean) {
  updateChallenge(
    body: {gameId: $gameId, challengeId: $challengeId, channelId: $channelId, description: $description, disabled: $disabled}
  ) {
    ...UseCategoryChallengeChallenge
  }
}
    ${UseCategoryChallengeChallengeFragmentDoc}`;
export type UpdateChallengeMutationFn = Apollo.MutationFunction<UpdateChallengeMutation, UpdateChallengeMutationVariables>;

/**
 * __useUpdateChallengeMutation__
 *
 * To run a mutation, you first call `useUpdateChallengeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChallengeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChallengeMutation, { data, loading, error }] = useUpdateChallengeMutation({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      challengeId: // value for 'challengeId'
 *      channelId: // value for 'channelId'
 *      description: // value for 'description'
 *      disabled: // value for 'disabled'
 *   },
 * });
 */
export function useUpdateChallengeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChallengeMutation, UpdateChallengeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChallengeMutation, UpdateChallengeMutationVariables>(UpdateChallengeDocument, options);
      }
export type UpdateChallengeMutationHookResult = ReturnType<typeof useUpdateChallengeMutation>;
export type UpdateChallengeMutationResult = Apollo.MutationResult<UpdateChallengeMutation>;
export type UpdateChallengeMutationOptions = Apollo.BaseMutationOptions<UpdateChallengeMutation, UpdateChallengeMutationVariables>;
export const DeleteChallengeDocument = gql`
    mutation DeleteChallenge($challengeId: ID!, $channelId: ID!) {
  deleteChallenge(challengeId: $challengeId, channelId: $channelId) {
    emptyTypeWorkaround
  }
}
    `;
export type DeleteChallengeMutationFn = Apollo.MutationFunction<DeleteChallengeMutation, DeleteChallengeMutationVariables>;

/**
 * __useDeleteChallengeMutation__
 *
 * To run a mutation, you first call `useDeleteChallengeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteChallengeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteChallengeMutation, { data, loading, error }] = useDeleteChallengeMutation({
 *   variables: {
 *      challengeId: // value for 'challengeId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useDeleteChallengeMutation(baseOptions?: Apollo.MutationHookOptions<DeleteChallengeMutation, DeleteChallengeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteChallengeMutation, DeleteChallengeMutationVariables>(DeleteChallengeDocument, options);
      }
export type DeleteChallengeMutationHookResult = ReturnType<typeof useDeleteChallengeMutation>;
export type DeleteChallengeMutationResult = Apollo.MutationResult<DeleteChallengeMutation>;
export type DeleteChallengeMutationOptions = Apollo.BaseMutationOptions<DeleteChallengeMutation, DeleteChallengeMutationVariables>;
export const LatestStreamDataDocument = gql`
    query LatestStreamData($channelId: ID!) {
  streams(channelId: $channelId, cursor: {first: 1}) {
    streams {
      streamId
      segments {
        segmentId
        startTime
      }
    }
  }
}
    `;

/**
 * __useLatestStreamDataQuery__
 *
 * To run a query within a React component, call `useLatestStreamDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useLatestStreamDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLatestStreamDataQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useLatestStreamDataQuery(baseOptions: Apollo.QueryHookOptions<LatestStreamDataQuery, LatestStreamDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LatestStreamDataQuery, LatestStreamDataQueryVariables>(LatestStreamDataDocument, options);
      }
export function useLatestStreamDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LatestStreamDataQuery, LatestStreamDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LatestStreamDataQuery, LatestStreamDataQueryVariables>(LatestStreamDataDocument, options);
        }
export type LatestStreamDataQueryHookResult = ReturnType<typeof useLatestStreamDataQuery>;
export type LatestStreamDataLazyQueryHookResult = ReturnType<typeof useLatestStreamDataLazyQuery>;
export type LatestStreamDataQueryResult = Apollo.QueryResult<LatestStreamDataQuery, LatestStreamDataQueryVariables>;
export const ChannelListDocument = gql`
    query ChannelList($cursor: String, $pageSize: Int) {
  channels(cursor: {first: $pageSize, after: $cursor}) {
    pageInfo {
      endCursor
      hasNextPage
    }
    channels {
      currentStreamId
      id
      liveStatus
      name
    }
  }
}
    `;

/**
 * __useChannelListQuery__
 *
 * To run a query within a React component, call `useChannelListQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelListQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useChannelListQuery(baseOptions?: Apollo.QueryHookOptions<ChannelListQuery, ChannelListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelListQuery, ChannelListQueryVariables>(ChannelListDocument, options);
      }
export function useChannelListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelListQuery, ChannelListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelListQuery, ChannelListQueryVariables>(ChannelListDocument, options);
        }
export type ChannelListQueryHookResult = ReturnType<typeof useChannelListQuery>;
export type ChannelListLazyQueryHookResult = ReturnType<typeof useChannelListLazyQuery>;
export type ChannelListQueryResult = Apollo.QueryResult<ChannelListQuery, ChannelListQueryVariables>;
export const PrivilegedChannelListDocument = gql`
    query PrivilegedChannelList($userId: ID!) {
  userPrivilegedChannels(userId: $userId) {
    channels {
      channelId
      channel {
        currentStreamId
        id
        liveStatus
        name
      }
    }
  }
}
    `;

/**
 * __usePrivilegedChannelListQuery__
 *
 * To run a query within a React component, call `usePrivilegedChannelListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePrivilegedChannelListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePrivilegedChannelListQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function usePrivilegedChannelListQuery(baseOptions: Apollo.QueryHookOptions<PrivilegedChannelListQuery, PrivilegedChannelListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PrivilegedChannelListQuery, PrivilegedChannelListQueryVariables>(PrivilegedChannelListDocument, options);
      }
export function usePrivilegedChannelListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PrivilegedChannelListQuery, PrivilegedChannelListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PrivilegedChannelListQuery, PrivilegedChannelListQueryVariables>(PrivilegedChannelListDocument, options);
        }
export type PrivilegedChannelListQueryHookResult = ReturnType<typeof usePrivilegedChannelListQuery>;
export type PrivilegedChannelListLazyQueryHookResult = ReturnType<typeof usePrivilegedChannelListLazyQuery>;
export type PrivilegedChannelListQueryResult = Apollo.QueryResult<PrivilegedChannelListQuery, PrivilegedChannelListQueryVariables>;
export const ChannelProviderDataDocument = gql`
    query ChannelProviderData($channelId: ID!, $userId: ID!) {
  channel(id: $channelId) {
    id
    currentChatId
    monetizationSettings {
      enabled
      eligible
    }
  }
  userChannelRoles(channelId: $channelId, userId: $userId) {
    roles
  }
  profile(userId: $userId) {
    account {
      acceptedTerms {
        name
      }
    }
    userId
  }
}
    `;

/**
 * __useChannelProviderDataQuery__
 *
 * To run a query within a React component, call `useChannelProviderDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelProviderDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelProviderDataQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChannelProviderDataQuery(baseOptions: Apollo.QueryHookOptions<ChannelProviderDataQuery, ChannelProviderDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelProviderDataQuery, ChannelProviderDataQueryVariables>(ChannelProviderDataDocument, options);
      }
export function useChannelProviderDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelProviderDataQuery, ChannelProviderDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelProviderDataQuery, ChannelProviderDataQueryVariables>(ChannelProviderDataDocument, options);
        }
export type ChannelProviderDataQueryHookResult = ReturnType<typeof useChannelProviderDataQuery>;
export type ChannelProviderDataLazyQueryHookResult = ReturnType<typeof useChannelProviderDataLazyQuery>;
export type ChannelProviderDataQueryResult = Apollo.QueryResult<ChannelProviderDataQuery, ChannelProviderDataQueryVariables>;
export const ChannelCurrentChatIdDocument = gql`
    query ChannelCurrentChatId($channelId: ID!) {
  channel(id: $channelId) {
    id
    currentChatId
  }
}
    `;

/**
 * __useChannelCurrentChatIdQuery__
 *
 * To run a query within a React component, call `useChannelCurrentChatIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelCurrentChatIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelCurrentChatIdQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelCurrentChatIdQuery(baseOptions: Apollo.QueryHookOptions<ChannelCurrentChatIdQuery, ChannelCurrentChatIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelCurrentChatIdQuery, ChannelCurrentChatIdQueryVariables>(ChannelCurrentChatIdDocument, options);
      }
export function useChannelCurrentChatIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelCurrentChatIdQuery, ChannelCurrentChatIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelCurrentChatIdQuery, ChannelCurrentChatIdQueryVariables>(ChannelCurrentChatIdDocument, options);
        }
export type ChannelCurrentChatIdQueryHookResult = ReturnType<typeof useChannelCurrentChatIdQuery>;
export type ChannelCurrentChatIdLazyQueryHookResult = ReturnType<typeof useChannelCurrentChatIdLazyQuery>;
export type ChannelCurrentChatIdQueryResult = Apollo.QueryResult<ChannelCurrentChatIdQuery, ChannelCurrentChatIdQueryVariables>;
export const ChannelProviderChannelsByNameDocument = gql`
    query ChannelProviderChannelsByName($channelName: String!) {
  channelByName(name: $channelName) {
    id
  }
}
    `;

/**
 * __useChannelProviderChannelsByNameQuery__
 *
 * To run a query within a React component, call `useChannelProviderChannelsByNameQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelProviderChannelsByNameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelProviderChannelsByNameQuery({
 *   variables: {
 *      channelName: // value for 'channelName'
 *   },
 * });
 */
export function useChannelProviderChannelsByNameQuery(baseOptions: Apollo.QueryHookOptions<ChannelProviderChannelsByNameQuery, ChannelProviderChannelsByNameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelProviderChannelsByNameQuery, ChannelProviderChannelsByNameQueryVariables>(ChannelProviderChannelsByNameDocument, options);
      }
export function useChannelProviderChannelsByNameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelProviderChannelsByNameQuery, ChannelProviderChannelsByNameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelProviderChannelsByNameQuery, ChannelProviderChannelsByNameQueryVariables>(ChannelProviderChannelsByNameDocument, options);
        }
export type ChannelProviderChannelsByNameQueryHookResult = ReturnType<typeof useChannelProviderChannelsByNameQuery>;
export type ChannelProviderChannelsByNameLazyQueryHookResult = ReturnType<typeof useChannelProviderChannelsByNameLazyQuery>;
export type ChannelProviderChannelsByNameQueryResult = Apollo.QueryResult<ChannelProviderChannelsByNameQuery, ChannelProviderChannelsByNameQueryVariables>;
export const ChannelProviderCheckChannelDocument = gql`
    query ChannelProviderCheckChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
    streamerId
  }
}
    `;

/**
 * __useChannelProviderCheckChannelQuery__
 *
 * To run a query within a React component, call `useChannelProviderCheckChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelProviderCheckChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelProviderCheckChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelProviderCheckChannelQuery(baseOptions: Apollo.QueryHookOptions<ChannelProviderCheckChannelQuery, ChannelProviderCheckChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelProviderCheckChannelQuery, ChannelProviderCheckChannelQueryVariables>(ChannelProviderCheckChannelDocument, options);
      }
export function useChannelProviderCheckChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelProviderCheckChannelQuery, ChannelProviderCheckChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelProviderCheckChannelQuery, ChannelProviderCheckChannelQueryVariables>(ChannelProviderCheckChannelDocument, options);
        }
export type ChannelProviderCheckChannelQueryHookResult = ReturnType<typeof useChannelProviderCheckChannelQuery>;
export type ChannelProviderCheckChannelLazyQueryHookResult = ReturnType<typeof useChannelProviderCheckChannelLazyQuery>;
export type ChannelProviderCheckChannelQueryResult = Apollo.QueryResult<ChannelProviderCheckChannelQuery, ChannelProviderCheckChannelQueryVariables>;
export const ChannelRouteDataDocument = gql`
    query ChannelRouteData($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
  }
}
    `;

/**
 * __useChannelRouteDataQuery__
 *
 * To run a query within a React component, call `useChannelRouteDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelRouteDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelRouteDataQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelRouteDataQuery(baseOptions: Apollo.QueryHookOptions<ChannelRouteDataQuery, ChannelRouteDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelRouteDataQuery, ChannelRouteDataQueryVariables>(ChannelRouteDataDocument, options);
      }
export function useChannelRouteDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelRouteDataQuery, ChannelRouteDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelRouteDataQuery, ChannelRouteDataQueryVariables>(ChannelRouteDataDocument, options);
        }
export type ChannelRouteDataQueryHookResult = ReturnType<typeof useChannelRouteDataQuery>;
export type ChannelRouteDataLazyQueryHookResult = ReturnType<typeof useChannelRouteDataLazyQuery>;
export type ChannelRouteDataQueryResult = Apollo.QueryResult<ChannelRouteDataQuery, ChannelRouteDataQueryVariables>;
export const OnboardingProviderDataDocument = gql`
    query OnboardingProviderData($channelId: ID!) {
  streams(channelId: $channelId, cursor: {first: 1}) {
    streams {
      streamId
    }
  }
}
    `;

/**
 * __useOnboardingProviderDataQuery__
 *
 * To run a query within a React component, call `useOnboardingProviderDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useOnboardingProviderDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnboardingProviderDataQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useOnboardingProviderDataQuery(baseOptions: Apollo.QueryHookOptions<OnboardingProviderDataQuery, OnboardingProviderDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OnboardingProviderDataQuery, OnboardingProviderDataQueryVariables>(OnboardingProviderDataDocument, options);
      }
export function useOnboardingProviderDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OnboardingProviderDataQuery, OnboardingProviderDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OnboardingProviderDataQuery, OnboardingProviderDataQueryVariables>(OnboardingProviderDataDocument, options);
        }
export type OnboardingProviderDataQueryHookResult = ReturnType<typeof useOnboardingProviderDataQuery>;
export type OnboardingProviderDataLazyQueryHookResult = ReturnType<typeof useOnboardingProviderDataLazyQuery>;
export type OnboardingProviderDataQueryResult = Apollo.QueryResult<OnboardingProviderDataQuery, OnboardingProviderDataQueryVariables>;
export const LookerStudioReportIdDocument = gql`
    query LookerStudioReportId($channelId: ID!) {
  channel(id: $channelId) {
    id
    reportingId
  }
}
    `;

/**
 * __useLookerStudioReportIdQuery__
 *
 * To run a query within a React component, call `useLookerStudioReportIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useLookerStudioReportIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLookerStudioReportIdQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useLookerStudioReportIdQuery(baseOptions: Apollo.QueryHookOptions<LookerStudioReportIdQuery, LookerStudioReportIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LookerStudioReportIdQuery, LookerStudioReportIdQueryVariables>(LookerStudioReportIdDocument, options);
      }
export function useLookerStudioReportIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LookerStudioReportIdQuery, LookerStudioReportIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LookerStudioReportIdQuery, LookerStudioReportIdQueryVariables>(LookerStudioReportIdDocument, options);
        }
export type LookerStudioReportIdQueryHookResult = ReturnType<typeof useLookerStudioReportIdQuery>;
export type LookerStudioReportIdLazyQueryHookResult = ReturnType<typeof useLookerStudioReportIdLazyQuery>;
export type LookerStudioReportIdQueryResult = Apollo.QueryResult<LookerStudioReportIdQuery, LookerStudioReportIdQueryVariables>;
export const ProtectedRouteProfileDocument = gql`
    query ProtectedRouteProfile($userId: ID!) {
  platformBan(userId: $userId) {
    banId
  }
}
    `;

/**
 * __useProtectedRouteProfileQuery__
 *
 * To run a query within a React component, call `useProtectedRouteProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useProtectedRouteProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProtectedRouteProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useProtectedRouteProfileQuery(baseOptions: Apollo.QueryHookOptions<ProtectedRouteProfileQuery, ProtectedRouteProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProtectedRouteProfileQuery, ProtectedRouteProfileQueryVariables>(ProtectedRouteProfileDocument, options);
      }
export function useProtectedRouteProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProtectedRouteProfileQuery, ProtectedRouteProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProtectedRouteProfileQuery, ProtectedRouteProfileQueryVariables>(ProtectedRouteProfileDocument, options);
        }
export type ProtectedRouteProfileQueryHookResult = ReturnType<typeof useProtectedRouteProfileQuery>;
export type ProtectedRouteProfileLazyQueryHookResult = ReturnType<typeof useProtectedRouteProfileLazyQuery>;
export type ProtectedRouteProfileQueryResult = Apollo.QueryResult<ProtectedRouteProfileQuery, ProtectedRouteProfileQueryVariables>;
export const EditCategoryDataDocument = gql`
    query EditCategoryData($channelId: ID!) {
  channel(id: $channelId) {
    id
    features {
      noicePredictions {
        enabled
      }
    }
  }
  listGames {
    games {
      id
      noicePredictionsEnabled
      activeSeason {
        id
        seasonBreak
        seasonBreakReason
      }
    }
  }
}
    `;

/**
 * __useEditCategoryDataQuery__
 *
 * To run a query within a React component, call `useEditCategoryDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useEditCategoryDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEditCategoryDataQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useEditCategoryDataQuery(baseOptions: Apollo.QueryHookOptions<EditCategoryDataQuery, EditCategoryDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EditCategoryDataQuery, EditCategoryDataQueryVariables>(EditCategoryDataDocument, options);
      }
export function useEditCategoryDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EditCategoryDataQuery, EditCategoryDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EditCategoryDataQuery, EditCategoryDataQueryVariables>(EditCategoryDataDocument, options);
        }
export type EditCategoryDataQueryHookResult = ReturnType<typeof useEditCategoryDataQuery>;
export type EditCategoryDataLazyQueryHookResult = ReturnType<typeof useEditCategoryDataLazyQuery>;
export type EditCategoryDataQueryResult = Apollo.QueryResult<EditCategoryDataQuery, EditCategoryDataQueryVariables>;
export const UpdateEditStreamInfoPredictionGameDocument = gql`
    mutation UpdateEditStreamInfoPredictionGame($channelId: ID!, $featureNoicePredictionsEnabled: Boolean) {
  updateChannelDetails(
    body: {id: $channelId, featureNoicePredictionsEnabled: $featureNoicePredictionsEnabled}
  ) {
    id
  }
}
    `;
export type UpdateEditStreamInfoPredictionGameMutationFn = Apollo.MutationFunction<UpdateEditStreamInfoPredictionGameMutation, UpdateEditStreamInfoPredictionGameMutationVariables>;

/**
 * __useUpdateEditStreamInfoPredictionGameMutation__
 *
 * To run a mutation, you first call `useUpdateEditStreamInfoPredictionGameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEditStreamInfoPredictionGameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEditStreamInfoPredictionGameMutation, { data, loading, error }] = useUpdateEditStreamInfoPredictionGameMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      featureNoicePredictionsEnabled: // value for 'featureNoicePredictionsEnabled'
 *   },
 * });
 */
export function useUpdateEditStreamInfoPredictionGameMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEditStreamInfoPredictionGameMutation, UpdateEditStreamInfoPredictionGameMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEditStreamInfoPredictionGameMutation, UpdateEditStreamInfoPredictionGameMutationVariables>(UpdateEditStreamInfoPredictionGameDocument, options);
      }
export type UpdateEditStreamInfoPredictionGameMutationHookResult = ReturnType<typeof useUpdateEditStreamInfoPredictionGameMutation>;
export type UpdateEditStreamInfoPredictionGameMutationResult = Apollo.MutationResult<UpdateEditStreamInfoPredictionGameMutation>;
export type UpdateEditStreamInfoPredictionGameMutationOptions = Apollo.BaseMutationOptions<UpdateEditStreamInfoPredictionGameMutation, UpdateEditStreamInfoPredictionGameMutationVariables>;
export const EditStreamKeyDataDocument = gql`
    query EditStreamKeyData($channelId: ID!) {
  ingestConfigs(channelId: $channelId) {
    channelId
    configs {
      ingest {
        ... on StreamIngestConfigIngestConfigFTLConfig {
          streamKey
        }
      }
    }
  }
}
    `;

/**
 * __useEditStreamKeyDataQuery__
 *
 * To run a query within a React component, call `useEditStreamKeyDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useEditStreamKeyDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEditStreamKeyDataQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useEditStreamKeyDataQuery(baseOptions: Apollo.QueryHookOptions<EditStreamKeyDataQuery, EditStreamKeyDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EditStreamKeyDataQuery, EditStreamKeyDataQueryVariables>(EditStreamKeyDataDocument, options);
      }
export function useEditStreamKeyDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EditStreamKeyDataQuery, EditStreamKeyDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EditStreamKeyDataQuery, EditStreamKeyDataQueryVariables>(EditStreamKeyDataDocument, options);
        }
export type EditStreamKeyDataQueryHookResult = ReturnType<typeof useEditStreamKeyDataQuery>;
export type EditStreamKeyDataLazyQueryHookResult = ReturnType<typeof useEditStreamKeyDataLazyQuery>;
export type EditStreamKeyDataQueryResult = Apollo.QueryResult<EditStreamKeyDataQuery, EditStreamKeyDataQueryVariables>;
export const RefreshStreamKeyDocument = gql`
    mutation RefreshStreamKey($channelId: ID!) {
  refreshIngestConfigs(channelId: $channelId) {
    channelId
    configs {
      ingest {
        ... on StreamIngestConfigIngestConfigFTLConfig {
          streamKey
        }
      }
    }
  }
}
    `;
export type RefreshStreamKeyMutationFn = Apollo.MutationFunction<RefreshStreamKeyMutation, RefreshStreamKeyMutationVariables>;

/**
 * __useRefreshStreamKeyMutation__
 *
 * To run a mutation, you first call `useRefreshStreamKeyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRefreshStreamKeyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [refreshStreamKeyMutation, { data, loading, error }] = useRefreshStreamKeyMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useRefreshStreamKeyMutation(baseOptions?: Apollo.MutationHookOptions<RefreshStreamKeyMutation, RefreshStreamKeyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RefreshStreamKeyMutation, RefreshStreamKeyMutationVariables>(RefreshStreamKeyDocument, options);
      }
export type RefreshStreamKeyMutationHookResult = ReturnType<typeof useRefreshStreamKeyMutation>;
export type RefreshStreamKeyMutationResult = Apollo.MutationResult<RefreshStreamKeyMutation>;
export type RefreshStreamKeyMutationOptions = Apollo.BaseMutationOptions<RefreshStreamKeyMutation, RefreshStreamKeyMutationVariables>;
export const EditStreamTitleChannelDocument = gql`
    query EditStreamTitleChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    title
  }
}
    `;

/**
 * __useEditStreamTitleChannelQuery__
 *
 * To run a query within a React component, call `useEditStreamTitleChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useEditStreamTitleChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEditStreamTitleChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useEditStreamTitleChannelQuery(baseOptions: Apollo.QueryHookOptions<EditStreamTitleChannelQuery, EditStreamTitleChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EditStreamTitleChannelQuery, EditStreamTitleChannelQueryVariables>(EditStreamTitleChannelDocument, options);
      }
export function useEditStreamTitleChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EditStreamTitleChannelQuery, EditStreamTitleChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EditStreamTitleChannelQuery, EditStreamTitleChannelQueryVariables>(EditStreamTitleChannelDocument, options);
        }
export type EditStreamTitleChannelQueryHookResult = ReturnType<typeof useEditStreamTitleChannelQuery>;
export type EditStreamTitleChannelLazyQueryHookResult = ReturnType<typeof useEditStreamTitleChannelLazyQuery>;
export type EditStreamTitleChannelQueryResult = Apollo.QueryResult<EditStreamTitleChannelQuery, EditStreamTitleChannelQueryVariables>;
export const UpdateStreamTitleDocument = gql`
    mutation UpdateStreamTitle($channelId: ID!, $title: String) {
  updateChannelDetails(body: {id: $channelId, title: $title}) {
    title
  }
}
    `;
export type UpdateStreamTitleMutationFn = Apollo.MutationFunction<UpdateStreamTitleMutation, UpdateStreamTitleMutationVariables>;

/**
 * __useUpdateStreamTitleMutation__
 *
 * To run a mutation, you first call `useUpdateStreamTitleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStreamTitleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStreamTitleMutation, { data, loading, error }] = useUpdateStreamTitleMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      title: // value for 'title'
 *   },
 * });
 */
export function useUpdateStreamTitleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStreamTitleMutation, UpdateStreamTitleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStreamTitleMutation, UpdateStreamTitleMutationVariables>(UpdateStreamTitleDocument, options);
      }
export type UpdateStreamTitleMutationHookResult = ReturnType<typeof useUpdateStreamTitleMutation>;
export type UpdateStreamTitleMutationResult = Apollo.MutationResult<UpdateStreamTitleMutation>;
export type UpdateStreamTitleMutationOptions = Apollo.BaseMutationOptions<UpdateStreamTitleMutation, UpdateStreamTitleMutationVariables>;
export const MatureRatedContentChannelDocument = gql`
    query MatureRatedContentChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    matureRatedContent
  }
}
    `;

/**
 * __useMatureRatedContentChannelQuery__
 *
 * To run a query within a React component, call `useMatureRatedContentChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatureRatedContentChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatureRatedContentChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useMatureRatedContentChannelQuery(baseOptions: Apollo.QueryHookOptions<MatureRatedContentChannelQuery, MatureRatedContentChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatureRatedContentChannelQuery, MatureRatedContentChannelQueryVariables>(MatureRatedContentChannelDocument, options);
      }
export function useMatureRatedContentChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatureRatedContentChannelQuery, MatureRatedContentChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatureRatedContentChannelQuery, MatureRatedContentChannelQueryVariables>(MatureRatedContentChannelDocument, options);
        }
export type MatureRatedContentChannelQueryHookResult = ReturnType<typeof useMatureRatedContentChannelQuery>;
export type MatureRatedContentChannelLazyQueryHookResult = ReturnType<typeof useMatureRatedContentChannelLazyQuery>;
export type MatureRatedContentChannelQueryResult = Apollo.QueryResult<MatureRatedContentChannelQuery, MatureRatedContentChannelQueryVariables>;
export const UpdateChannelMatureRatedContentDocument = gql`
    mutation UpdateChannelMatureRatedContent($channelId: ID!, $matureRatedContent: Boolean!) {
  updateChannelDetails(
    body: {id: $channelId, matureRatedContent: $matureRatedContent}
  ) {
    id
    ...MatureRatedContentUpdatedChannel
  }
}
    ${MatureRatedContentUpdatedChannelFragmentDoc}`;
export type UpdateChannelMatureRatedContentMutationFn = Apollo.MutationFunction<UpdateChannelMatureRatedContentMutation, UpdateChannelMatureRatedContentMutationVariables>;

/**
 * __useUpdateChannelMatureRatedContentMutation__
 *
 * To run a mutation, you first call `useUpdateChannelMatureRatedContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChannelMatureRatedContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChannelMatureRatedContentMutation, { data, loading, error }] = useUpdateChannelMatureRatedContentMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      matureRatedContent: // value for 'matureRatedContent'
 *   },
 * });
 */
export function useUpdateChannelMatureRatedContentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChannelMatureRatedContentMutation, UpdateChannelMatureRatedContentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChannelMatureRatedContentMutation, UpdateChannelMatureRatedContentMutationVariables>(UpdateChannelMatureRatedContentDocument, options);
      }
export type UpdateChannelMatureRatedContentMutationHookResult = ReturnType<typeof useUpdateChannelMatureRatedContentMutation>;
export type UpdateChannelMatureRatedContentMutationResult = Apollo.MutationResult<UpdateChannelMatureRatedContentMutation>;
export type UpdateChannelMatureRatedContentMutationOptions = Apollo.BaseMutationOptions<UpdateChannelMatureRatedContentMutation, UpdateChannelMatureRatedContentMutationVariables>;
export const StreamCategoryDataDocument = gql`
    query StreamCategoryData($channelId: ID!) {
  streamBackendConfigs(channelId: $channelId) {
    configs {
      id
      gameId
    }
  }
  listGames {
    games {
      id
      name
    }
  }
  selectedStreamBackendConfig(channelId: $channelId) {
    id
    gameId
    game {
      id
      gameEventsSource
    }
  }
}
    `;

/**
 * __useStreamCategoryDataQuery__
 *
 * To run a query within a React component, call `useStreamCategoryDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamCategoryDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamCategoryDataQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStreamCategoryDataQuery(baseOptions: Apollo.QueryHookOptions<StreamCategoryDataQuery, StreamCategoryDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamCategoryDataQuery, StreamCategoryDataQueryVariables>(StreamCategoryDataDocument, options);
      }
export function useStreamCategoryDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamCategoryDataQuery, StreamCategoryDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamCategoryDataQuery, StreamCategoryDataQueryVariables>(StreamCategoryDataDocument, options);
        }
export type StreamCategoryDataQueryHookResult = ReturnType<typeof useStreamCategoryDataQuery>;
export type StreamCategoryDataLazyQueryHookResult = ReturnType<typeof useStreamCategoryDataLazyQuery>;
export type StreamCategoryDataQueryResult = Apollo.QueryResult<StreamCategoryDataQuery, StreamCategoryDataQueryVariables>;
export const CreateStreamConfigDocument = gql`
    mutation CreateStreamConfig($channelId: ID!, $gameId: ID!) {
  createStreamBackendConfig(channelId: $channelId, gameId: $gameId) {
    id
  }
}
    `;
export type CreateStreamConfigMutationFn = Apollo.MutationFunction<CreateStreamConfigMutation, CreateStreamConfigMutationVariables>;

/**
 * __useCreateStreamConfigMutation__
 *
 * To run a mutation, you first call `useCreateStreamConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateStreamConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createStreamConfigMutation, { data, loading, error }] = useCreateStreamConfigMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useCreateStreamConfigMutation(baseOptions?: Apollo.MutationHookOptions<CreateStreamConfigMutation, CreateStreamConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateStreamConfigMutation, CreateStreamConfigMutationVariables>(CreateStreamConfigDocument, options);
      }
export type CreateStreamConfigMutationHookResult = ReturnType<typeof useCreateStreamConfigMutation>;
export type CreateStreamConfigMutationResult = Apollo.MutationResult<CreateStreamConfigMutation>;
export type CreateStreamConfigMutationOptions = Apollo.BaseMutationOptions<CreateStreamConfigMutation, CreateStreamConfigMutationVariables>;
export const SelectStreamConfigDocument = gql`
    mutation SelectStreamConfig($channelId: ID!, $configId: ID!) {
  selectStreamBackendConfig(channelId: $channelId, configId: $configId) {
    emptyTypeWorkaround
  }
}
    `;
export type SelectStreamConfigMutationFn = Apollo.MutationFunction<SelectStreamConfigMutation, SelectStreamConfigMutationVariables>;

/**
 * __useSelectStreamConfigMutation__
 *
 * To run a mutation, you first call `useSelectStreamConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSelectStreamConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [selectStreamConfigMutation, { data, loading, error }] = useSelectStreamConfigMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      configId: // value for 'configId'
 *   },
 * });
 */
export function useSelectStreamConfigMutation(baseOptions?: Apollo.MutationHookOptions<SelectStreamConfigMutation, SelectStreamConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SelectStreamConfigMutation, SelectStreamConfigMutationVariables>(SelectStreamConfigDocument, options);
      }
export type SelectStreamConfigMutationHookResult = ReturnType<typeof useSelectStreamConfigMutation>;
export type SelectStreamConfigMutationResult = Apollo.MutationResult<SelectStreamConfigMutation>;
export type SelectStreamConfigMutationOptions = Apollo.BaseMutationOptions<SelectStreamConfigMutation, SelectStreamConfigMutationVariables>;
export const StreamAlertsChannelByNameDocument = gql`
    query StreamAlertsChannelByName($channelName: String!) {
  channelByName(name: $channelName) {
    id
    currentStreamId
  }
}
    `;

/**
 * __useStreamAlertsChannelByNameQuery__
 *
 * To run a query within a React component, call `useStreamAlertsChannelByNameQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamAlertsChannelByNameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamAlertsChannelByNameQuery({
 *   variables: {
 *      channelName: // value for 'channelName'
 *   },
 * });
 */
export function useStreamAlertsChannelByNameQuery(baseOptions: Apollo.QueryHookOptions<StreamAlertsChannelByNameQuery, StreamAlertsChannelByNameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamAlertsChannelByNameQuery, StreamAlertsChannelByNameQueryVariables>(StreamAlertsChannelByNameDocument, options);
      }
export function useStreamAlertsChannelByNameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamAlertsChannelByNameQuery, StreamAlertsChannelByNameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamAlertsChannelByNameQuery, StreamAlertsChannelByNameQueryVariables>(StreamAlertsChannelByNameDocument, options);
        }
export type StreamAlertsChannelByNameQueryHookResult = ReturnType<typeof useStreamAlertsChannelByNameQuery>;
export type StreamAlertsChannelByNameLazyQueryHookResult = ReturnType<typeof useStreamAlertsChannelByNameLazyQuery>;
export type StreamAlertsChannelByNameQueryResult = Apollo.QueryResult<StreamAlertsChannelByNameQuery, StreamAlertsChannelByNameQueryVariables>;
export const StreamAlertsChannelLiveStatusDocument = gql`
    subscription StreamAlertsChannelLiveStatus($channelId: ID) {
  channelLiveStatusSubscribe(channelId: $channelId) {
    channelId
    liveStatus
    streamId
  }
}
    `;

/**
 * __useStreamAlertsChannelLiveStatusSubscription__
 *
 * To run a query within a React component, call `useStreamAlertsChannelLiveStatusSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStreamAlertsChannelLiveStatusSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamAlertsChannelLiveStatusSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStreamAlertsChannelLiveStatusSubscription(baseOptions?: Apollo.SubscriptionHookOptions<StreamAlertsChannelLiveStatusSubscription, StreamAlertsChannelLiveStatusSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StreamAlertsChannelLiveStatusSubscription, StreamAlertsChannelLiveStatusSubscriptionVariables>(StreamAlertsChannelLiveStatusDocument, options);
      }
export type StreamAlertsChannelLiveStatusSubscriptionHookResult = ReturnType<typeof useStreamAlertsChannelLiveStatusSubscription>;
export type StreamAlertsChannelLiveStatusSubscriptionResult = Apollo.SubscriptionResult<StreamAlertsChannelLiveStatusSubscription>;
export const StreamChannelStatusDocument = gql`
    subscription StreamChannelStatus($channelId: ID!) {
  channelStreamDetailSubscribe(channelId: $channelId) {
    streamId
    channelId
    noicePredictionsEnabled
    challengesEnabled
    serverRenderingEnabled
  }
}
    `;

/**
 * __useStreamChannelStatusSubscription__
 *
 * To run a query within a React component, call `useStreamChannelStatusSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStreamChannelStatusSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamChannelStatusSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStreamChannelStatusSubscription(baseOptions: Apollo.SubscriptionHookOptions<StreamChannelStatusSubscription, StreamChannelStatusSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StreamChannelStatusSubscription, StreamChannelStatusSubscriptionVariables>(StreamChannelStatusDocument, options);
      }
export type StreamChannelStatusSubscriptionHookResult = ReturnType<typeof useStreamChannelStatusSubscription>;
export type StreamChannelStatusSubscriptionResult = Apollo.SubscriptionResult<StreamChannelStatusSubscription>;
export const StreamStatusDocument = gql`
    subscription StreamStatus($channelId: ID!, $streamId: ID!) {
  streamStatusSubscribe(channelId: $channelId, streamId: $streamId) {
    liveStatus
    mlStatus
    crStatus
    restreamingStatus
    gameRunnerStatus
  }
}
    `;

/**
 * __useStreamStatusSubscription__
 *
 * To run a query within a React component, call `useStreamStatusSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStreamStatusSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamStatusSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useStreamStatusSubscription(baseOptions: Apollo.SubscriptionHookOptions<StreamStatusSubscription, StreamStatusSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StreamStatusSubscription, StreamStatusSubscriptionVariables>(StreamStatusDocument, options);
      }
export type StreamStatusSubscriptionHookResult = ReturnType<typeof useStreamStatusSubscription>;
export type StreamStatusSubscriptionResult = Apollo.SubscriptionResult<StreamStatusSubscription>;
export const StreamIngestStatsDocument = gql`
    subscription StreamIngestStats($channelId: ID!) {
  ingestStatsSubscribe(channelId: $channelId) {
    ...ChannelIngestStats
  }
}
    ${ChannelIngestStatsFragmentDoc}`;

/**
 * __useStreamIngestStatsSubscription__
 *
 * To run a query within a React component, call `useStreamIngestStatsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStreamIngestStatsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamIngestStatsSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStreamIngestStatsSubscription(baseOptions: Apollo.SubscriptionHookOptions<StreamIngestStatsSubscription, StreamIngestStatsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StreamIngestStatsSubscription, StreamIngestStatsSubscriptionVariables>(StreamIngestStatsDocument, options);
      }
export type StreamIngestStatsSubscriptionHookResult = ReturnType<typeof useStreamIngestStatsSubscription>;
export type StreamIngestStatsSubscriptionResult = Apollo.SubscriptionResult<StreamIngestStatsSubscription>;
export const StreamMatchStatusEventsDocument = gql`
    subscription StreamMatchStatusEvents($streamId: ID!) {
  streamEventsSubscribe(streamId: $streamId) {
    content {
      __typename
      ... on GameLogicMatchPauseStateChangedMsg {
        paused
      }
    }
  }
}
    `;

/**
 * __useStreamMatchStatusEventsSubscription__
 *
 * To run a query within a React component, call `useStreamMatchStatusEventsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStreamMatchStatusEventsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamMatchStatusEventsSubscription({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useStreamMatchStatusEventsSubscription(baseOptions: Apollo.SubscriptionHookOptions<StreamMatchStatusEventsSubscription, StreamMatchStatusEventsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StreamMatchStatusEventsSubscription, StreamMatchStatusEventsSubscriptionVariables>(StreamMatchStatusEventsDocument, options);
      }
export type StreamMatchStatusEventsSubscriptionHookResult = ReturnType<typeof useStreamMatchStatusEventsSubscription>;
export type StreamMatchStatusEventsSubscriptionResult = Apollo.SubscriptionResult<StreamMatchStatusEventsSubscription>;
export const MatchStateDocument = gql`
    query MatchState($streamId: ID!) {
  matchState(streamId: $streamId) {
    matchState
  }
}
    `;

/**
 * __useMatchStateQuery__
 *
 * To run a query within a React component, call `useMatchStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchStateQuery({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useMatchStateQuery(baseOptions: Apollo.QueryHookOptions<MatchStateQuery, MatchStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchStateQuery, MatchStateQueryVariables>(MatchStateDocument, options);
      }
export function useMatchStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchStateQuery, MatchStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchStateQuery, MatchStateQueryVariables>(MatchStateDocument, options);
        }
export type MatchStateQueryHookResult = ReturnType<typeof useMatchStateQuery>;
export type MatchStateLazyQueryHookResult = ReturnType<typeof useMatchStateLazyQuery>;
export type MatchStateQueryResult = Apollo.QueryResult<MatchStateQuery, MatchStateQueryVariables>;
export const TriggerCameraTransitionDocument = gql`
    mutation TriggerCameraTransition($streamId: ID!, $cameraTransitionTarget: RenderingCameraTransitionRequestTransitionTarget!) {
  streamerTriggerCameraTransition(
    streamId: $streamId
    cameraTransitionTarget: $cameraTransitionTarget
  ) {
    success
  }
}
    `;
export type TriggerCameraTransitionMutationFn = Apollo.MutationFunction<TriggerCameraTransitionMutation, TriggerCameraTransitionMutationVariables>;

/**
 * __useTriggerCameraTransitionMutation__
 *
 * To run a mutation, you first call `useTriggerCameraTransitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTriggerCameraTransitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [triggerCameraTransitionMutation, { data, loading, error }] = useTriggerCameraTransitionMutation({
 *   variables: {
 *      streamId: // value for 'streamId'
 *      cameraTransitionTarget: // value for 'cameraTransitionTarget'
 *   },
 * });
 */
export function useTriggerCameraTransitionMutation(baseOptions?: Apollo.MutationHookOptions<TriggerCameraTransitionMutation, TriggerCameraTransitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TriggerCameraTransitionMutation, TriggerCameraTransitionMutationVariables>(TriggerCameraTransitionDocument, options);
      }
export type TriggerCameraTransitionMutationHookResult = ReturnType<typeof useTriggerCameraTransitionMutation>;
export type TriggerCameraTransitionMutationResult = Apollo.MutationResult<TriggerCameraTransitionMutation>;
export type TriggerCameraTransitionMutationOptions = Apollo.BaseMutationOptions<TriggerCameraTransitionMutation, TriggerCameraTransitionMutationVariables>;
export const StreamActivityFeedHistoryDocument = gql`
    query StreamActivityFeedHistory($channelId: ID, $filter: StreamerChannelActivityEventFilterInput, $cursor: APICursorInput) {
  channelActivityEvents(channelId: $channelId, filter: $filter, cursor: $cursor) {
    events {
      timestamp
      id
      content {
        ...StreamActivityFeedStreamerCardPurchase
        ...StreamActivityFeedNewChannelFollower
        ...StreamActivityFeedNewChannelViewer
        ...StreamActivityFeedNewChannelSubscriber
        ...StreamActivityFeedStreamStateUpdateStarted
        ...StreamActivityFeedStreamStateUpdateEnded
        ...StreamActivityFeedMatchStateUpdateStarted
        ...StreamActivityFeedMatchStateUpdateEnded
        ...StreamActivityFeedNewChannelSubscriptionGifted
        ...StreamActivityFeedStreamInfoUpdateTitleChange
        ...StreamActivityFeedPremiumBundlePurchase
        ...StreamActivityFeedChannelSubscriptionRenewed
        ...StreamActivityFeedHighScoringCard
        ...StreamActivityFeedAvatarItemPurchase
      }
    }
    pageInfo {
      endCursor
      hasPreviousPage
    }
  }
}
    ${StreamActivityFeedStreamerCardPurchaseFragmentDoc}
${StreamActivityFeedNewChannelFollowerFragmentDoc}
${StreamActivityFeedNewChannelViewerFragmentDoc}
${StreamActivityFeedNewChannelSubscriberFragmentDoc}
${StreamActivityFeedStreamStateUpdateStartedFragmentDoc}
${StreamActivityFeedStreamStateUpdateEndedFragmentDoc}
${StreamActivityFeedMatchStateUpdateStartedFragmentDoc}
${StreamActivityFeedMatchStateUpdateEndedFragmentDoc}
${StreamActivityFeedNewChannelSubscriptionGiftedFragmentDoc}
${StreamActivityFeedStreamInfoUpdateTitleChangeFragmentDoc}
${StreamActivityFeedPremiumBundlePurchaseFragmentDoc}
${StreamActivityFeedChannelSubscriptionRenewedFragmentDoc}
${StreamActivityFeedHighScoringCardFragmentDoc}
${StreamActivityFeedAvatarItemPurchaseFragmentDoc}`;

/**
 * __useStreamActivityFeedHistoryQuery__
 *
 * To run a query within a React component, call `useStreamActivityFeedHistoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamActivityFeedHistoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamActivityFeedHistoryQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      filter: // value for 'filter'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useStreamActivityFeedHistoryQuery(baseOptions?: Apollo.QueryHookOptions<StreamActivityFeedHistoryQuery, StreamActivityFeedHistoryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamActivityFeedHistoryQuery, StreamActivityFeedHistoryQueryVariables>(StreamActivityFeedHistoryDocument, options);
      }
export function useStreamActivityFeedHistoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamActivityFeedHistoryQuery, StreamActivityFeedHistoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamActivityFeedHistoryQuery, StreamActivityFeedHistoryQueryVariables>(StreamActivityFeedHistoryDocument, options);
        }
export type StreamActivityFeedHistoryQueryHookResult = ReturnType<typeof useStreamActivityFeedHistoryQuery>;
export type StreamActivityFeedHistoryLazyQueryHookResult = ReturnType<typeof useStreamActivityFeedHistoryLazyQuery>;
export type StreamActivityFeedHistoryQueryResult = Apollo.QueryResult<StreamActivityFeedHistoryQuery, StreamActivityFeedHistoryQueryVariables>;
export const StreamActivityFeedDocument = gql`
    subscription StreamActivityFeed($after: String, $channelId: ID, $filter: StreamerChannelActivityEventFilterInput) {
  channelActivityEventsSubscribe(
    after: $after
    channelId: $channelId
    filter: $filter
  ) {
    timestamp
    id
    content {
      ...StreamActivityFeedStreamerCardPurchase
      ...StreamActivityFeedNewChannelFollower
      ...StreamActivityFeedNewChannelViewer
      ...StreamActivityFeedNewChannelSubscriber
      ...StreamActivityFeedStreamStateUpdateStarted
      ...StreamActivityFeedStreamStateUpdateEnded
      ...StreamActivityFeedMatchStateUpdateStarted
      ...StreamActivityFeedMatchStateUpdateEnded
      ...StreamActivityFeedNewChannelSubscriptionGifted
      ...StreamActivityFeedStreamInfoUpdateTitleChange
      ...StreamActivityFeedPremiumBundlePurchase
      ...StreamActivityFeedChannelSubscriptionRenewed
      ...StreamActivityFeedHighScoringCard
      ...StreamActivityFeedAvatarItemPurchase
    }
  }
}
    ${StreamActivityFeedStreamerCardPurchaseFragmentDoc}
${StreamActivityFeedNewChannelFollowerFragmentDoc}
${StreamActivityFeedNewChannelViewerFragmentDoc}
${StreamActivityFeedNewChannelSubscriberFragmentDoc}
${StreamActivityFeedStreamStateUpdateStartedFragmentDoc}
${StreamActivityFeedStreamStateUpdateEndedFragmentDoc}
${StreamActivityFeedMatchStateUpdateStartedFragmentDoc}
${StreamActivityFeedMatchStateUpdateEndedFragmentDoc}
${StreamActivityFeedNewChannelSubscriptionGiftedFragmentDoc}
${StreamActivityFeedStreamInfoUpdateTitleChangeFragmentDoc}
${StreamActivityFeedPremiumBundlePurchaseFragmentDoc}
${StreamActivityFeedChannelSubscriptionRenewedFragmentDoc}
${StreamActivityFeedHighScoringCardFragmentDoc}
${StreamActivityFeedAvatarItemPurchaseFragmentDoc}`;

/**
 * __useStreamActivityFeedSubscription__
 *
 * To run a query within a React component, call `useStreamActivityFeedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStreamActivityFeedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamActivityFeedSubscription({
 *   variables: {
 *      after: // value for 'after'
 *      channelId: // value for 'channelId'
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useStreamActivityFeedSubscription(baseOptions?: Apollo.SubscriptionHookOptions<StreamActivityFeedSubscription, StreamActivityFeedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StreamActivityFeedSubscription, StreamActivityFeedSubscriptionVariables>(StreamActivityFeedDocument, options);
      }
export type StreamActivityFeedSubscriptionHookResult = ReturnType<typeof useStreamActivityFeedSubscription>;
export type StreamActivityFeedSubscriptionResult = Apollo.SubscriptionResult<StreamActivityFeedSubscription>;
export const ActivityFeedChallengeDescriptionsDocument = gql`
    query ActivityFeedChallengeDescriptions($challengeIds: [String!]!) {
  challengesBatch(challengeIds: $challengeIds) {
    challenges {
      ...ActivityFeedChallenge
    }
  }
}
    ${ActivityFeedChallengeFragmentDoc}`;

/**
 * __useActivityFeedChallengeDescriptionsQuery__
 *
 * To run a query within a React component, call `useActivityFeedChallengeDescriptionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useActivityFeedChallengeDescriptionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActivityFeedChallengeDescriptionsQuery({
 *   variables: {
 *      challengeIds: // value for 'challengeIds'
 *   },
 * });
 */
export function useActivityFeedChallengeDescriptionsQuery(baseOptions: Apollo.QueryHookOptions<ActivityFeedChallengeDescriptionsQuery, ActivityFeedChallengeDescriptionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActivityFeedChallengeDescriptionsQuery, ActivityFeedChallengeDescriptionsQueryVariables>(ActivityFeedChallengeDescriptionsDocument, options);
      }
export function useActivityFeedChallengeDescriptionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActivityFeedChallengeDescriptionsQuery, ActivityFeedChallengeDescriptionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActivityFeedChallengeDescriptionsQuery, ActivityFeedChallengeDescriptionsQueryVariables>(ActivityFeedChallengeDescriptionsDocument, options);
        }
export type ActivityFeedChallengeDescriptionsQueryHookResult = ReturnType<typeof useActivityFeedChallengeDescriptionsQuery>;
export type ActivityFeedChallengeDescriptionsLazyQueryHookResult = ReturnType<typeof useActivityFeedChallengeDescriptionsLazyQuery>;
export type ActivityFeedChallengeDescriptionsQueryResult = Apollo.QueryResult<ActivityFeedChallengeDescriptionsQuery, ActivityFeedChallengeDescriptionsQueryVariables>;
export const AudienceInsightsDataDocument = gql`
    query AudienceInsightsData($streamId: ID) {
  streamAudienceInsights(streamId: $streamId) {
    viewers
    followers
    subscribers
    chatters
    players
  }
}
    `;

/**
 * __useAudienceInsightsDataQuery__
 *
 * To run a query within a React component, call `useAudienceInsightsDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useAudienceInsightsDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAudienceInsightsDataQuery({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useAudienceInsightsDataQuery(baseOptions?: Apollo.QueryHookOptions<AudienceInsightsDataQuery, AudienceInsightsDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AudienceInsightsDataQuery, AudienceInsightsDataQueryVariables>(AudienceInsightsDataDocument, options);
      }
export function useAudienceInsightsDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AudienceInsightsDataQuery, AudienceInsightsDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AudienceInsightsDataQuery, AudienceInsightsDataQueryVariables>(AudienceInsightsDataDocument, options);
        }
export type AudienceInsightsDataQueryHookResult = ReturnType<typeof useAudienceInsightsDataQuery>;
export type AudienceInsightsDataLazyQueryHookResult = ReturnType<typeof useAudienceInsightsDataLazyQuery>;
export type AudienceInsightsDataQueryResult = Apollo.QueryResult<AudienceInsightsDataQuery, AudienceInsightsDataQueryVariables>;
export const ApproveModerationItemDocument = gql`
    mutation ApproveModerationItem($chatId: ID!, $moderationItemId: ID!) {
  allowChatModerationItem(chatId: $chatId, moderationItemId: $moderationItemId) {
    emptyTypeWorkaround
  }
}
    `;
export type ApproveModerationItemMutationFn = Apollo.MutationFunction<ApproveModerationItemMutation, ApproveModerationItemMutationVariables>;

/**
 * __useApproveModerationItemMutation__
 *
 * To run a mutation, you first call `useApproveModerationItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveModerationItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveModerationItemMutation, { data, loading, error }] = useApproveModerationItemMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      moderationItemId: // value for 'moderationItemId'
 *   },
 * });
 */
export function useApproveModerationItemMutation(baseOptions?: Apollo.MutationHookOptions<ApproveModerationItemMutation, ApproveModerationItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveModerationItemMutation, ApproveModerationItemMutationVariables>(ApproveModerationItemDocument, options);
      }
export type ApproveModerationItemMutationHookResult = ReturnType<typeof useApproveModerationItemMutation>;
export type ApproveModerationItemMutationResult = Apollo.MutationResult<ApproveModerationItemMutation>;
export type ApproveModerationItemMutationOptions = Apollo.BaseMutationOptions<ApproveModerationItemMutation, ApproveModerationItemMutationVariables>;
export const DenyModerationItemDocument = gql`
    mutation DenyModerationItem($chatId: ID!, $moderationItemId: ID!) {
  denyChatModerationItem(chatId: $chatId, moderationItemId: $moderationItemId) {
    emptyTypeWorkaround
  }
}
    `;
export type DenyModerationItemMutationFn = Apollo.MutationFunction<DenyModerationItemMutation, DenyModerationItemMutationVariables>;

/**
 * __useDenyModerationItemMutation__
 *
 * To run a mutation, you first call `useDenyModerationItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDenyModerationItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [denyModerationItemMutation, { data, loading, error }] = useDenyModerationItemMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      moderationItemId: // value for 'moderationItemId'
 *   },
 * });
 */
export function useDenyModerationItemMutation(baseOptions?: Apollo.MutationHookOptions<DenyModerationItemMutation, DenyModerationItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DenyModerationItemMutation, DenyModerationItemMutationVariables>(DenyModerationItemDocument, options);
      }
export type DenyModerationItemMutationHookResult = ReturnType<typeof useDenyModerationItemMutation>;
export type DenyModerationItemMutationResult = Apollo.MutationResult<DenyModerationItemMutation>;
export type DenyModerationItemMutationOptions = Apollo.BaseMutationOptions<DenyModerationItemMutation, DenyModerationItemMutationVariables>;
export const AutomodQueueDocument = gql`
    subscription AutomodQueue($chatId: ID!) {
  chatAutoModQueueSubscribe(chatId: $chatId) {
    event {
      ... on ChatAutoModQueueEventRemove {
        id
      }
      ... on ChatAutoModQueueEventUpdate {
        item {
          ...AutomodQueueChatModerationItem
        }
      }
      ... on ChatAutoModQueueEventAdd {
        item {
          ...AutomodQueueChatModerationItem
        }
      }
    }
  }
}
    ${AutomodQueueChatModerationItemFragmentDoc}`;

/**
 * __useAutomodQueueSubscription__
 *
 * To run a query within a React component, call `useAutomodQueueSubscription` and pass it any options that fit your needs.
 * When your component renders, `useAutomodQueueSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAutomodQueueSubscription({
 *   variables: {
 *      chatId: // value for 'chatId'
 *   },
 * });
 */
export function useAutomodQueueSubscription(baseOptions: Apollo.SubscriptionHookOptions<AutomodQueueSubscription, AutomodQueueSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<AutomodQueueSubscription, AutomodQueueSubscriptionVariables>(AutomodQueueDocument, options);
      }
export type AutomodQueueSubscriptionHookResult = ReturnType<typeof useAutomodQueueSubscription>;
export type AutomodQueueSubscriptionResult = Apollo.SubscriptionResult<AutomodQueueSubscription>;
export const ChallengeSessionDocument = gql`
    query ChallengeSession($channelId: ID!, $streamId: ID!) {
  getChallengeSession(streamId: $streamId) {
    ...ChallengeSession
  }
  channel(id: $channelId) {
    id
    streamedGames {
      id
    }
  }
}
    ${ChallengeSessionFragmentDoc}`;

/**
 * __useChallengeSessionQuery__
 *
 * To run a query within a React component, call `useChallengeSessionQuery` and pass it any options that fit your needs.
 * When your component renders, `useChallengeSessionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChallengeSessionQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useChallengeSessionQuery(baseOptions: Apollo.QueryHookOptions<ChallengeSessionQuery, ChallengeSessionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChallengeSessionQuery, ChallengeSessionQueryVariables>(ChallengeSessionDocument, options);
      }
export function useChallengeSessionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChallengeSessionQuery, ChallengeSessionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChallengeSessionQuery, ChallengeSessionQueryVariables>(ChallengeSessionDocument, options);
        }
export type ChallengeSessionQueryHookResult = ReturnType<typeof useChallengeSessionQuery>;
export type ChallengeSessionLazyQueryHookResult = ReturnType<typeof useChallengeSessionLazyQuery>;
export type ChallengeSessionQueryResult = Apollo.QueryResult<ChallengeSessionQuery, ChallengeSessionQueryVariables>;
export const CreateChallengeSessionDocument = gql`
    mutation CreateChallengeSession($gameId: ID!, $streamId: ID!, $challenges: [ChallengesessionChallengeInput!]!, $submissionWindowLength: Int!) {
  createChallengeSession(
    gameId: $gameId
    streamId: $streamId
    challenges: $challenges
    submissionWindowLength: $submissionWindowLength
  ) {
    ...ChallengeSession
  }
}
    ${ChallengeSessionFragmentDoc}`;
export type CreateChallengeSessionMutationFn = Apollo.MutationFunction<CreateChallengeSessionMutation, CreateChallengeSessionMutationVariables>;

/**
 * __useCreateChallengeSessionMutation__
 *
 * To run a mutation, you first call `useCreateChallengeSessionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateChallengeSessionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createChallengeSessionMutation, { data, loading, error }] = useCreateChallengeSessionMutation({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      streamId: // value for 'streamId'
 *      challenges: // value for 'challenges'
 *      submissionWindowLength: // value for 'submissionWindowLength'
 *   },
 * });
 */
export function useCreateChallengeSessionMutation(baseOptions?: Apollo.MutationHookOptions<CreateChallengeSessionMutation, CreateChallengeSessionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateChallengeSessionMutation, CreateChallengeSessionMutationVariables>(CreateChallengeSessionDocument, options);
      }
export type CreateChallengeSessionMutationHookResult = ReturnType<typeof useCreateChallengeSessionMutation>;
export type CreateChallengeSessionMutationResult = Apollo.MutationResult<CreateChallengeSessionMutation>;
export type CreateChallengeSessionMutationOptions = Apollo.BaseMutationOptions<CreateChallengeSessionMutation, CreateChallengeSessionMutationVariables>;
export const UpdateChallengeSessionDocument = gql`
    mutation UpdateChallengeSession($gameId: ID!, $streamId: ID!, $challenges: [ChallengesessionChallengeInput!]!, $submissionWindowLength: Int!) {
  updateChallengeSession(
    body: {streamId: $streamId, gameId: $gameId, challenges: $challenges, submissionWindowLength: $submissionWindowLength}
  ) {
    ...ChallengeSession
  }
}
    ${ChallengeSessionFragmentDoc}`;
export type UpdateChallengeSessionMutationFn = Apollo.MutationFunction<UpdateChallengeSessionMutation, UpdateChallengeSessionMutationVariables>;

/**
 * __useUpdateChallengeSessionMutation__
 *
 * To run a mutation, you first call `useUpdateChallengeSessionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChallengeSessionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChallengeSessionMutation, { data, loading, error }] = useUpdateChallengeSessionMutation({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      streamId: // value for 'streamId'
 *      challenges: // value for 'challenges'
 *      submissionWindowLength: // value for 'submissionWindowLength'
 *   },
 * });
 */
export function useUpdateChallengeSessionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChallengeSessionMutation, UpdateChallengeSessionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChallengeSessionMutation, UpdateChallengeSessionMutationVariables>(UpdateChallengeSessionDocument, options);
      }
export type UpdateChallengeSessionMutationHookResult = ReturnType<typeof useUpdateChallengeSessionMutation>;
export type UpdateChallengeSessionMutationResult = Apollo.MutationResult<UpdateChallengeSessionMutation>;
export type UpdateChallengeSessionMutationOptions = Apollo.BaseMutationOptions<UpdateChallengeSessionMutation, UpdateChallengeSessionMutationVariables>;
export const ProgressChallengeSessionDocument = gql`
    mutation ProgressChallengeSession($streamId: ID!, $phase: ChallengesessionChallengeSessionPhase!) {
  progressChallengeSession(streamId: $streamId, phase: $phase) {
    ...ChallengeSession
  }
}
    ${ChallengeSessionFragmentDoc}`;
export type ProgressChallengeSessionMutationFn = Apollo.MutationFunction<ProgressChallengeSessionMutation, ProgressChallengeSessionMutationVariables>;

/**
 * __useProgressChallengeSessionMutation__
 *
 * To run a mutation, you first call `useProgressChallengeSessionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProgressChallengeSessionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [progressChallengeSessionMutation, { data, loading, error }] = useProgressChallengeSessionMutation({
 *   variables: {
 *      streamId: // value for 'streamId'
 *      phase: // value for 'phase'
 *   },
 * });
 */
export function useProgressChallengeSessionMutation(baseOptions?: Apollo.MutationHookOptions<ProgressChallengeSessionMutation, ProgressChallengeSessionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProgressChallengeSessionMutation, ProgressChallengeSessionMutationVariables>(ProgressChallengeSessionDocument, options);
      }
export type ProgressChallengeSessionMutationHookResult = ReturnType<typeof useProgressChallengeSessionMutation>;
export type ProgressChallengeSessionMutationResult = Apollo.MutationResult<ProgressChallengeSessionMutation>;
export type ProgressChallengeSessionMutationOptions = Apollo.BaseMutationOptions<ProgressChallengeSessionMutation, ProgressChallengeSessionMutationVariables>;
export const ChatUserListDocument = gql`
    query ChatUserList($chatId: ID!) {
  streamers: chatUsers(
    chatId: $chatId
    userLabel: USER_LABEL_STREAMER
    sortBy: "lastActivity"
    limit: 100
  ) {
    users {
      ...ChatUserListUser
    }
  }
  moderators: chatUsers(
    chatId: $chatId
    userLabel: USER_LABEL_MODERATOR
    sortBy: "lastActivity"
    limit: 100
  ) {
    users {
      ...ChatUserListUser
    }
  }
  viewers: chatUsers(
    chatId: $chatId
    userLabel: USER_LABEL_VIEWER
    sortBy: "lastActivity"
    limit: 100
  ) {
    users {
      ...ChatUserListUser
    }
  }
}
    ${ChatUserListUserFragmentDoc}`;

/**
 * __useChatUserListQuery__
 *
 * To run a query within a React component, call `useChatUserListQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatUserListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatUserListQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *   },
 * });
 */
export function useChatUserListQuery(baseOptions: Apollo.QueryHookOptions<ChatUserListQuery, ChatUserListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatUserListQuery, ChatUserListQueryVariables>(ChatUserListDocument, options);
      }
export function useChatUserListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatUserListQuery, ChatUserListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatUserListQuery, ChatUserListQueryVariables>(ChatUserListDocument, options);
        }
export type ChatUserListQueryHookResult = ReturnType<typeof useChatUserListQuery>;
export type ChatUserListLazyQueryHookResult = ReturnType<typeof useChatUserListLazyQuery>;
export type ChatUserListQueryResult = Apollo.QueryResult<ChatUserListQuery, ChatUserListQueryVariables>;
export const GameAndCrowdDetailsDocument = gql`
    query GameAndCrowdDetails($channelId: ID!) {
  channel(id: $channelId) {
    game {
      id
      name
    }
    id
    title
  }
}
    `;

/**
 * __useGameAndCrowdDetailsQuery__
 *
 * To run a query within a React component, call `useGameAndCrowdDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameAndCrowdDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameAndCrowdDetailsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useGameAndCrowdDetailsQuery(baseOptions: Apollo.QueryHookOptions<GameAndCrowdDetailsQuery, GameAndCrowdDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameAndCrowdDetailsQuery, GameAndCrowdDetailsQueryVariables>(GameAndCrowdDetailsDocument, options);
      }
export function useGameAndCrowdDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameAndCrowdDetailsQuery, GameAndCrowdDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameAndCrowdDetailsQuery, GameAndCrowdDetailsQueryVariables>(GameAndCrowdDetailsDocument, options);
        }
export type GameAndCrowdDetailsQueryHookResult = ReturnType<typeof useGameAndCrowdDetailsQuery>;
export type GameAndCrowdDetailsLazyQueryHookResult = ReturnType<typeof useGameAndCrowdDetailsLazyQuery>;
export type GameAndCrowdDetailsQueryResult = Apollo.QueryResult<GameAndCrowdDetailsQuery, GameAndCrowdDetailsQueryVariables>;
export const ModerationEventsHistoryDocument = gql`
    query ModerationEventsHistory($channelId: ID!, $filter: ChannelModerationEventsFilterInput, $cursor: String, $pageSize: Int) {
  moderationEvents(
    channelId: $channelId
    filter: $filter
    cursor: {last: $pageSize, before: $cursor}
  ) {
    events {
      ...ModerationLogEvent
    }
    pageInfo {
      startCursor
      hasPreviousPage
    }
  }
}
    ${ModerationLogEventFragmentDoc}`;

/**
 * __useModerationEventsHistoryQuery__
 *
 * To run a query within a React component, call `useModerationEventsHistoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useModerationEventsHistoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useModerationEventsHistoryQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      filter: // value for 'filter'
 *      cursor: // value for 'cursor'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useModerationEventsHistoryQuery(baseOptions: Apollo.QueryHookOptions<ModerationEventsHistoryQuery, ModerationEventsHistoryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ModerationEventsHistoryQuery, ModerationEventsHistoryQueryVariables>(ModerationEventsHistoryDocument, options);
      }
export function useModerationEventsHistoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ModerationEventsHistoryQuery, ModerationEventsHistoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ModerationEventsHistoryQuery, ModerationEventsHistoryQueryVariables>(ModerationEventsHistoryDocument, options);
        }
export type ModerationEventsHistoryQueryHookResult = ReturnType<typeof useModerationEventsHistoryQuery>;
export type ModerationEventsHistoryLazyQueryHookResult = ReturnType<typeof useModerationEventsHistoryLazyQuery>;
export type ModerationEventsHistoryQueryResult = Apollo.QueryResult<ModerationEventsHistoryQuery, ModerationEventsHistoryQueryVariables>;
export const ModerationEventsDocument = gql`
    subscription ModerationEvents($channelId: ID!, $filter: ChannelModerationEventsFilterInput) {
  moderationEventsSubscribe(channelId: $channelId, filter: $filter) {
    ...ModerationLogEvent
  }
}
    ${ModerationLogEventFragmentDoc}`;

/**
 * __useModerationEventsSubscription__
 *
 * To run a query within a React component, call `useModerationEventsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useModerationEventsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useModerationEventsSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useModerationEventsSubscription(baseOptions: Apollo.SubscriptionHookOptions<ModerationEventsSubscription, ModerationEventsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ModerationEventsSubscription, ModerationEventsSubscriptionVariables>(ModerationEventsDocument, options);
      }
export type ModerationEventsSubscriptionHookResult = ReturnType<typeof useModerationEventsSubscription>;
export type ModerationEventsSubscriptionResult = Apollo.SubscriptionResult<ModerationEventsSubscription>;
export const StreamEventsDocument = gql`
    subscription StreamEvents($streamId: ID!, $filter: StreamerStreamEventFilterInput, $channelId: ID!) {
  streamEventsSubscribe(streamId: $streamId, filter: $filter) {
    timestamp
    content {
      ...StreamMatchEvents
    }
  }
}
    ${StreamMatchEventsFragmentDoc}`;

/**
 * __useStreamEventsSubscription__
 *
 * To run a query within a React component, call `useStreamEventsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStreamEventsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamEventsSubscription({
 *   variables: {
 *      streamId: // value for 'streamId'
 *      filter: // value for 'filter'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStreamEventsSubscription(baseOptions: Apollo.SubscriptionHookOptions<StreamEventsSubscription, StreamEventsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StreamEventsSubscription, StreamEventsSubscriptionVariables>(StreamEventsDocument, options);
      }
export type StreamEventsSubscriptionHookResult = ReturnType<typeof useStreamEventsSubscription>;
export type StreamEventsSubscriptionResult = Apollo.SubscriptionResult<StreamEventsSubscription>;
export const TopPredictionsDocument = gql`
    subscription TopPredictions($streamId: ID!) {
  streamTopActiveCardsSubscribe(streamId: $streamId) {
    content {
      ... on MatchTopCardsUpdateCardCountUpdate {
        cards {
          cardId
          card {
            id
            ...TopActiveCard
          }
          count
        }
      }
    }
  }
}
    ${TopActiveCardFragmentDoc}`;

/**
 * __useTopPredictionsSubscription__
 *
 * To run a query within a React component, call `useTopPredictionsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useTopPredictionsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTopPredictionsSubscription({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useTopPredictionsSubscription(baseOptions: Apollo.SubscriptionHookOptions<TopPredictionsSubscription, TopPredictionsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<TopPredictionsSubscription, TopPredictionsSubscriptionVariables>(TopPredictionsDocument, options);
      }
export type TopPredictionsSubscriptionHookResult = ReturnType<typeof useTopPredictionsSubscription>;
export type TopPredictionsSubscriptionResult = Apollo.SubscriptionResult<TopPredictionsSubscription>;
export const TopPredictionsChallengePickRatesDocument = gql`
    subscription TopPredictionsChallengePickRates($streamId: ID!) {
  streamChallengeUpdatesSubscribe(streamId: $streamId) {
    content {
      ... on MatchChallengeUpdateStatusUpdate {
        challenges {
          challengeId
          challengeState
          pickRate
          targetValues {
            label
            value
          }
          challenge {
            id
            description
            targetValues {
              label
              value
            }
          }
        }
      }
    }
  }
}
    `;

/**
 * __useTopPredictionsChallengePickRatesSubscription__
 *
 * To run a query within a React component, call `useTopPredictionsChallengePickRatesSubscription` and pass it any options that fit your needs.
 * When your component renders, `useTopPredictionsChallengePickRatesSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTopPredictionsChallengePickRatesSubscription({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useTopPredictionsChallengePickRatesSubscription(baseOptions: Apollo.SubscriptionHookOptions<TopPredictionsChallengePickRatesSubscription, TopPredictionsChallengePickRatesSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<TopPredictionsChallengePickRatesSubscription, TopPredictionsChallengePickRatesSubscriptionVariables>(TopPredictionsChallengePickRatesDocument, options);
      }
export type TopPredictionsChallengePickRatesSubscriptionHookResult = ReturnType<typeof useTopPredictionsChallengePickRatesSubscription>;
export type TopPredictionsChallengePickRatesSubscriptionResult = Apollo.SubscriptionResult<TopPredictionsChallengePickRatesSubscription>;
export const AdminChannelListSelectorDefaultChannelsDocument = gql`
    query AdminChannelListSelectorDefaultChannels($channelIds: [String!]) {
  liveChannels: channels(liveStatus: LIVE_STATUS_LIVE) {
    channels {
      ...ChannelSelectorOptionChannel
    }
  }
  recentChannels: getChannels(channelIds: $channelIds) {
    channels {
      ...ChannelSelectorOptionChannel
    }
  }
}
    ${ChannelSelectorOptionChannelFragmentDoc}`;

/**
 * __useAdminChannelListSelectorDefaultChannelsQuery__
 *
 * To run a query within a React component, call `useAdminChannelListSelectorDefaultChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAdminChannelListSelectorDefaultChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAdminChannelListSelectorDefaultChannelsQuery({
 *   variables: {
 *      channelIds: // value for 'channelIds'
 *   },
 * });
 */
export function useAdminChannelListSelectorDefaultChannelsQuery(baseOptions?: Apollo.QueryHookOptions<AdminChannelListSelectorDefaultChannelsQuery, AdminChannelListSelectorDefaultChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AdminChannelListSelectorDefaultChannelsQuery, AdminChannelListSelectorDefaultChannelsQueryVariables>(AdminChannelListSelectorDefaultChannelsDocument, options);
      }
export function useAdminChannelListSelectorDefaultChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AdminChannelListSelectorDefaultChannelsQuery, AdminChannelListSelectorDefaultChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AdminChannelListSelectorDefaultChannelsQuery, AdminChannelListSelectorDefaultChannelsQueryVariables>(AdminChannelListSelectorDefaultChannelsDocument, options);
        }
export type AdminChannelListSelectorDefaultChannelsQueryHookResult = ReturnType<typeof useAdminChannelListSelectorDefaultChannelsQuery>;
export type AdminChannelListSelectorDefaultChannelsLazyQueryHookResult = ReturnType<typeof useAdminChannelListSelectorDefaultChannelsLazyQuery>;
export type AdminChannelListSelectorDefaultChannelsQueryResult = Apollo.QueryResult<AdminChannelListSelectorDefaultChannelsQuery, AdminChannelListSelectorDefaultChannelsQueryVariables>;
export const AdminChannelListSelectorSearchDocument = gql`
    query AdminChannelListSelectorSearch($query: String) {
  channelSearch: search(
    query: $query
    entityTypes: [ENTITY_TYPE_CHANNEL]
    cursor: {first: 10}
  ) {
    resultItems {
      entityId
      entity {
        ... on ChannelChannel {
          ...ChannelSelectorOptionChannel
        }
      }
    }
  }
}
    ${ChannelSelectorOptionChannelFragmentDoc}`;

/**
 * __useAdminChannelListSelectorSearchQuery__
 *
 * To run a query within a React component, call `useAdminChannelListSelectorSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useAdminChannelListSelectorSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAdminChannelListSelectorSearchQuery({
 *   variables: {
 *      query: // value for 'query'
 *   },
 * });
 */
export function useAdminChannelListSelectorSearchQuery(baseOptions?: Apollo.QueryHookOptions<AdminChannelListSelectorSearchQuery, AdminChannelListSelectorSearchQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AdminChannelListSelectorSearchQuery, AdminChannelListSelectorSearchQueryVariables>(AdminChannelListSelectorSearchDocument, options);
      }
export function useAdminChannelListSelectorSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AdminChannelListSelectorSearchQuery, AdminChannelListSelectorSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AdminChannelListSelectorSearchQuery, AdminChannelListSelectorSearchQueryVariables>(AdminChannelListSelectorSearchDocument, options);
        }
export type AdminChannelListSelectorSearchQueryHookResult = ReturnType<typeof useAdminChannelListSelectorSearchQuery>;
export type AdminChannelListSelectorSearchLazyQueryHookResult = ReturnType<typeof useAdminChannelListSelectorSearchLazyQuery>;
export type AdminChannelListSelectorSearchQueryResult = Apollo.QueryResult<AdminChannelListSelectorSearchQuery, AdminChannelListSelectorSearchQueryVariables>;
export const PageWrapperChannelDocument = gql`
    query PageWrapperChannel($channelId: ID!) {
  channel(id: $channelId) {
    ...NavigationSidebarChannel
    ...TopBarChannel
  }
}
    ${NavigationSidebarChannelFragmentDoc}
${TopBarChannelFragmentDoc}`;

/**
 * __usePageWrapperChannelQuery__
 *
 * To run a query within a React component, call `usePageWrapperChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `usePageWrapperChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePageWrapperChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function usePageWrapperChannelQuery(baseOptions: Apollo.QueryHookOptions<PageWrapperChannelQuery, PageWrapperChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PageWrapperChannelQuery, PageWrapperChannelQueryVariables>(PageWrapperChannelDocument, options);
      }
export function usePageWrapperChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PageWrapperChannelQuery, PageWrapperChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PageWrapperChannelQuery, PageWrapperChannelQueryVariables>(PageWrapperChannelDocument, options);
        }
export type PageWrapperChannelQueryHookResult = ReturnType<typeof usePageWrapperChannelQuery>;
export type PageWrapperChannelLazyQueryHookResult = ReturnType<typeof usePageWrapperChannelLazyQuery>;
export type PageWrapperChannelQueryResult = Apollo.QueryResult<PageWrapperChannelQuery, PageWrapperChannelQueryVariables>;
export const SidebarAnnouncementsDocument = gql`
    query SidebarAnnouncements($userId: ID!) {
  userAnnouncements(userId: $userId, target: ANNOUNCEMENT_TARGET_STUDIO) {
    announcements {
      id
      ...SidebarAnnouncement
      ...PlatformAnnouncement
    }
  }
}
    ${SidebarAnnouncementFragmentDoc}
${PlatformAnnouncementFragmentDoc}`;

/**
 * __useSidebarAnnouncementsQuery__
 *
 * To run a query within a React component, call `useSidebarAnnouncementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSidebarAnnouncementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSidebarAnnouncementsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSidebarAnnouncementsQuery(baseOptions: Apollo.QueryHookOptions<SidebarAnnouncementsQuery, SidebarAnnouncementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SidebarAnnouncementsQuery, SidebarAnnouncementsQueryVariables>(SidebarAnnouncementsDocument, options);
      }
export function useSidebarAnnouncementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SidebarAnnouncementsQuery, SidebarAnnouncementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SidebarAnnouncementsQuery, SidebarAnnouncementsQueryVariables>(SidebarAnnouncementsDocument, options);
        }
export type SidebarAnnouncementsQueryHookResult = ReturnType<typeof useSidebarAnnouncementsQuery>;
export type SidebarAnnouncementsLazyQueryHookResult = ReturnType<typeof useSidebarAnnouncementsLazyQuery>;
export type SidebarAnnouncementsQueryResult = Apollo.QueryResult<SidebarAnnouncementsQuery, SidebarAnnouncementsQueryVariables>;
export const ProfileMenuQueryDocument = gql`
    query ProfileMenuQuery($userId: ID!) {
  profile(userId: $userId) {
    userId
    lastSeen
    userTag
    avatars {
      avatar2D
    }
    ...ProfileImageShowOnlineStatusProfile
  }
  userPrivilegedChannels(userId: $userId) {
    channels {
      channelId
      roles
      channel {
        id
        name
      }
    }
  }
}
    ${ProfileImageShowOnlineStatusProfileFragmentDoc}`;

/**
 * __useProfileMenuQueryQuery__
 *
 * To run a query within a React component, call `useProfileMenuQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileMenuQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileMenuQueryQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useProfileMenuQueryQuery(baseOptions: Apollo.QueryHookOptions<ProfileMenuQueryQuery, ProfileMenuQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileMenuQueryQuery, ProfileMenuQueryQueryVariables>(ProfileMenuQueryDocument, options);
      }
export function useProfileMenuQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileMenuQueryQuery, ProfileMenuQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileMenuQueryQuery, ProfileMenuQueryQueryVariables>(ProfileMenuQueryDocument, options);
        }
export type ProfileMenuQueryQueryHookResult = ReturnType<typeof useProfileMenuQueryQuery>;
export type ProfileMenuQueryLazyQueryHookResult = ReturnType<typeof useProfileMenuQueryLazyQuery>;
export type ProfileMenuQueryQueryResult = Apollo.QueryResult<ProfileMenuQueryQuery, ProfileMenuQueryQueryVariables>;
export const StudioTopBarFollowersDocument = gql`
    subscription StudioTopBarFollowers($channelId: ID) {
  channelFollowerCountSubscribe(channelId: $channelId) {
    channelId
    followerCount
  }
}
    `;

/**
 * __useStudioTopBarFollowersSubscription__
 *
 * To run a query within a React component, call `useStudioTopBarFollowersSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStudioTopBarFollowersSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStudioTopBarFollowersSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStudioTopBarFollowersSubscription(baseOptions?: Apollo.SubscriptionHookOptions<StudioTopBarFollowersSubscription, StudioTopBarFollowersSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StudioTopBarFollowersSubscription, StudioTopBarFollowersSubscriptionVariables>(StudioTopBarFollowersDocument, options);
      }
export type StudioTopBarFollowersSubscriptionHookResult = ReturnType<typeof useStudioTopBarFollowersSubscription>;
export type StudioTopBarFollowersSubscriptionResult = Apollo.SubscriptionResult<StudioTopBarFollowersSubscription>;
export const ForceMatchEndDocument = gql`
    mutation ForceMatchEnd($streamId: ID!) {
  mlTriggerMatchEnd(streamId: $streamId) {
    emptyTypeWorkaround
  }
}
    `;
export type ForceMatchEndMutationFn = Apollo.MutationFunction<ForceMatchEndMutation, ForceMatchEndMutationVariables>;

/**
 * __useForceMatchEndMutation__
 *
 * To run a mutation, you first call `useForceMatchEndMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useForceMatchEndMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [forceMatchEndMutation, { data, loading, error }] = useForceMatchEndMutation({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useForceMatchEndMutation(baseOptions?: Apollo.MutationHookOptions<ForceMatchEndMutation, ForceMatchEndMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ForceMatchEndMutation, ForceMatchEndMutationVariables>(ForceMatchEndDocument, options);
      }
export type ForceMatchEndMutationHookResult = ReturnType<typeof useForceMatchEndMutation>;
export type ForceMatchEndMutationResult = Apollo.MutationResult<ForceMatchEndMutation>;
export type ForceMatchEndMutationOptions = Apollo.BaseMutationOptions<ForceMatchEndMutation, ForceMatchEndMutationVariables>;
export const TopBarStreamDocument = gql`
    query TopBarStream($id: ID!) {
  stream(id: $id) {
    streamId
    segments {
      startTime
      segmentId
    }
  }
}
    `;

/**
 * __useTopBarStreamQuery__
 *
 * To run a query within a React component, call `useTopBarStreamQuery` and pass it any options that fit your needs.
 * When your component renders, `useTopBarStreamQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTopBarStreamQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useTopBarStreamQuery(baseOptions: Apollo.QueryHookOptions<TopBarStreamQuery, TopBarStreamQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TopBarStreamQuery, TopBarStreamQueryVariables>(TopBarStreamDocument, options);
      }
export function useTopBarStreamLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TopBarStreamQuery, TopBarStreamQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TopBarStreamQuery, TopBarStreamQueryVariables>(TopBarStreamDocument, options);
        }
export type TopBarStreamQueryHookResult = ReturnType<typeof useTopBarStreamQuery>;
export type TopBarStreamLazyQueryHookResult = ReturnType<typeof useTopBarStreamLazyQuery>;
export type TopBarStreamQueryResult = Apollo.QueryResult<TopBarStreamQuery, TopBarStreamQueryVariables>;
export const TopBarChannelViewerCountDocument = gql`
    subscription TopBarChannelViewerCount($channelId: ID!) {
  channelViewerCountSubscribe(channelId: $channelId) {
    viewerCount
  }
}
    `;

/**
 * __useTopBarChannelViewerCountSubscription__
 *
 * To run a query within a React component, call `useTopBarChannelViewerCountSubscription` and pass it any options that fit your needs.
 * When your component renders, `useTopBarChannelViewerCountSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTopBarChannelViewerCountSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useTopBarChannelViewerCountSubscription(baseOptions: Apollo.SubscriptionHookOptions<TopBarChannelViewerCountSubscription, TopBarChannelViewerCountSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<TopBarChannelViewerCountSubscription, TopBarChannelViewerCountSubscriptionVariables>(TopBarChannelViewerCountDocument, options);
      }
export type TopBarChannelViewerCountSubscriptionHookResult = ReturnType<typeof useTopBarChannelViewerCountSubscription>;
export type TopBarChannelViewerCountSubscriptionResult = Apollo.SubscriptionResult<TopBarChannelViewerCountSubscription>;
export const SelectedStreamGameDocument = gql`
    query SelectedStreamGame($channelId: ID!) {
  selectedStreamBackendConfig(channelId: $channelId) {
    id
    game {
      id
      name
      gameEventsSource
    }
  }
}
    `;

/**
 * __useSelectedStreamGameQuery__
 *
 * To run a query within a React component, call `useSelectedStreamGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectedStreamGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectedStreamGameQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSelectedStreamGameQuery(baseOptions: Apollo.QueryHookOptions<SelectedStreamGameQuery, SelectedStreamGameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectedStreamGameQuery, SelectedStreamGameQueryVariables>(SelectedStreamGameDocument, options);
      }
export function useSelectedStreamGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectedStreamGameQuery, SelectedStreamGameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectedStreamGameQuery, SelectedStreamGameQueryVariables>(SelectedStreamGameDocument, options);
        }
export type SelectedStreamGameQueryHookResult = ReturnType<typeof useSelectedStreamGameQuery>;
export type SelectedStreamGameLazyQueryHookResult = ReturnType<typeof useSelectedStreamGameLazyQuery>;
export type SelectedStreamGameQueryResult = Apollo.QueryResult<SelectedStreamGameQuery, SelectedStreamGameQueryVariables>;
export const SufficientStreamHudScaleDocument = gql`
    subscription SufficientStreamHUDScale($streamId: ID) {
  mlHUDScaleUpdatesSubscribe(streamId: $streamId) {
    mlDisabled
    isScaleSufficient
  }
}
    `;

/**
 * __useSufficientStreamHudScaleSubscription__
 *
 * To run a query within a React component, call `useSufficientStreamHudScaleSubscription` and pass it any options that fit your needs.
 * When your component renders, `useSufficientStreamHudScaleSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSufficientStreamHudScaleSubscription({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useSufficientStreamHudScaleSubscription(baseOptions?: Apollo.SubscriptionHookOptions<SufficientStreamHudScaleSubscription, SufficientStreamHudScaleSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<SufficientStreamHudScaleSubscription, SufficientStreamHudScaleSubscriptionVariables>(SufficientStreamHudScaleDocument, options);
      }
export type SufficientStreamHudScaleSubscriptionHookResult = ReturnType<typeof useSufficientStreamHudScaleSubscription>;
export type SufficientStreamHudScaleSubscriptionResult = Apollo.SubscriptionResult<SufficientStreamHudScaleSubscription>;
export const ChallengesCategoriesDocument = gql`
    query ChallengesCategories {
  listGames {
    games {
      ...SelectedChallengeCategory
    }
  }
}
    ${SelectedChallengeCategoryFragmentDoc}`;

/**
 * __useChallengesCategoriesQuery__
 *
 * To run a query within a React component, call `useChallengesCategoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useChallengesCategoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChallengesCategoriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useChallengesCategoriesQuery(baseOptions?: Apollo.QueryHookOptions<ChallengesCategoriesQuery, ChallengesCategoriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChallengesCategoriesQuery, ChallengesCategoriesQueryVariables>(ChallengesCategoriesDocument, options);
      }
export function useChallengesCategoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChallengesCategoriesQuery, ChallengesCategoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChallengesCategoriesQuery, ChallengesCategoriesQueryVariables>(ChallengesCategoriesDocument, options);
        }
export type ChallengesCategoriesQueryHookResult = ReturnType<typeof useChallengesCategoriesQuery>;
export type ChallengesCategoriesLazyQueryHookResult = ReturnType<typeof useChallengesCategoriesLazyQuery>;
export type ChallengesCategoriesQueryResult = Apollo.QueryResult<ChallengesCategoriesQuery, ChallengesCategoriesQueryVariables>;
export const NoicePredictionsSectionDataDocument = gql`
    query NoicePredictionsSectionData {
  listGames {
    games {
      id
      gameEventsSource
    }
  }
}
    `;

/**
 * __useNoicePredictionsSectionDataQuery__
 *
 * To run a query within a React component, call `useNoicePredictionsSectionDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useNoicePredictionsSectionDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNoicePredictionsSectionDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useNoicePredictionsSectionDataQuery(baseOptions?: Apollo.QueryHookOptions<NoicePredictionsSectionDataQuery, NoicePredictionsSectionDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NoicePredictionsSectionDataQuery, NoicePredictionsSectionDataQueryVariables>(NoicePredictionsSectionDataDocument, options);
      }
export function useNoicePredictionsSectionDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NoicePredictionsSectionDataQuery, NoicePredictionsSectionDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NoicePredictionsSectionDataQuery, NoicePredictionsSectionDataQueryVariables>(NoicePredictionsSectionDataDocument, options);
        }
export type NoicePredictionsSectionDataQueryHookResult = ReturnType<typeof useNoicePredictionsSectionDataQuery>;
export type NoicePredictionsSectionDataLazyQueryHookResult = ReturnType<typeof useNoicePredictionsSectionDataLazyQuery>;
export type NoicePredictionsSectionDataQueryResult = Apollo.QueryResult<NoicePredictionsSectionDataQuery, NoicePredictionsSectionDataQueryVariables>;
export const SubmitMonetizationAgreementDocument = gql`
    mutation SubmitMonetizationAgreement($channelId: ID, $firstName: String, $lastName: String, $address: APIAddressInput, $birthday: APIDateInput, $gender: ChannelGender) {
  acceptMonetizationTerms(
    channelId: $channelId
    firstName: $firstName
    lastName: $lastName
    address: $address
    birthday: $birthday
    gender: $gender
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type SubmitMonetizationAgreementMutationFn = Apollo.MutationFunction<SubmitMonetizationAgreementMutation, SubmitMonetizationAgreementMutationVariables>;

/**
 * __useSubmitMonetizationAgreementMutation__
 *
 * To run a mutation, you first call `useSubmitMonetizationAgreementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitMonetizationAgreementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitMonetizationAgreementMutation, { data, loading, error }] = useSubmitMonetizationAgreementMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      firstName: // value for 'firstName'
 *      lastName: // value for 'lastName'
 *      address: // value for 'address'
 *      birthday: // value for 'birthday'
 *      gender: // value for 'gender'
 *   },
 * });
 */
export function useSubmitMonetizationAgreementMutation(baseOptions?: Apollo.MutationHookOptions<SubmitMonetizationAgreementMutation, SubmitMonetizationAgreementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubmitMonetizationAgreementMutation, SubmitMonetizationAgreementMutationVariables>(SubmitMonetizationAgreementDocument, options);
      }
export type SubmitMonetizationAgreementMutationHookResult = ReturnType<typeof useSubmitMonetizationAgreementMutation>;
export type SubmitMonetizationAgreementMutationResult = Apollo.MutationResult<SubmitMonetizationAgreementMutation>;
export type SubmitMonetizationAgreementMutationOptions = Apollo.BaseMutationOptions<SubmitMonetizationAgreementMutation, SubmitMonetizationAgreementMutationVariables>;
export const ListCreatorCardBaseCardsDocument = gql`
    query ListCreatorCardBaseCards($gameId: ID!, $seasonId: ID!) {
  items(
    filters: [{gameId: $gameId}, {seasonId: $seasonId}, {itemType: TYPE_GAME_CARD}, {attribute: {name: "unlock_level", value: {intValue: 1}}}]
  ) {
    items {
      id
      details {
        ...ListGameLogicCard
      }
    }
  }
}
    ${ListGameLogicCardFragmentDoc}`;

/**
 * __useListCreatorCardBaseCardsQuery__
 *
 * To run a query within a React component, call `useListCreatorCardBaseCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListCreatorCardBaseCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListCreatorCardBaseCardsQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useListCreatorCardBaseCardsQuery(baseOptions: Apollo.QueryHookOptions<ListCreatorCardBaseCardsQuery, ListCreatorCardBaseCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListCreatorCardBaseCardsQuery, ListCreatorCardBaseCardsQueryVariables>(ListCreatorCardBaseCardsDocument, options);
      }
export function useListCreatorCardBaseCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListCreatorCardBaseCardsQuery, ListCreatorCardBaseCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListCreatorCardBaseCardsQuery, ListCreatorCardBaseCardsQueryVariables>(ListCreatorCardBaseCardsDocument, options);
        }
export type ListCreatorCardBaseCardsQueryHookResult = ReturnType<typeof useListCreatorCardBaseCardsQuery>;
export type ListCreatorCardBaseCardsLazyQueryHookResult = ReturnType<typeof useListCreatorCardBaseCardsLazyQuery>;
export type ListCreatorCardBaseCardsQueryResult = Apollo.QueryResult<ListCreatorCardBaseCardsQuery, ListCreatorCardBaseCardsQueryVariables>;
export const ListCreatorCardBaseCardsAllDocument = gql`
    query ListCreatorCardBaseCardsAll($gameId: ID!, $seasonId: ID!) {
  items(
    filters: [{gameId: $gameId}, {seasonId: $seasonId}, {itemType: TYPE_GAME_CARD}]
  ) {
    items {
      id
      details {
        ...ListGameLogicCard
      }
    }
  }
}
    ${ListGameLogicCardFragmentDoc}`;

/**
 * __useListCreatorCardBaseCardsAllQuery__
 *
 * To run a query within a React component, call `useListCreatorCardBaseCardsAllQuery` and pass it any options that fit your needs.
 * When your component renders, `useListCreatorCardBaseCardsAllQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListCreatorCardBaseCardsAllQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useListCreatorCardBaseCardsAllQuery(baseOptions: Apollo.QueryHookOptions<ListCreatorCardBaseCardsAllQuery, ListCreatorCardBaseCardsAllQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListCreatorCardBaseCardsAllQuery, ListCreatorCardBaseCardsAllQueryVariables>(ListCreatorCardBaseCardsAllDocument, options);
      }
export function useListCreatorCardBaseCardsAllLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListCreatorCardBaseCardsAllQuery, ListCreatorCardBaseCardsAllQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListCreatorCardBaseCardsAllQuery, ListCreatorCardBaseCardsAllQueryVariables>(ListCreatorCardBaseCardsAllDocument, options);
        }
export type ListCreatorCardBaseCardsAllQueryHookResult = ReturnType<typeof useListCreatorCardBaseCardsAllQuery>;
export type ListCreatorCardBaseCardsAllLazyQueryHookResult = ReturnType<typeof useListCreatorCardBaseCardsAllLazyQuery>;
export type ListCreatorCardBaseCardsAllQueryResult = Apollo.QueryResult<ListCreatorCardBaseCardsAllQuery, ListCreatorCardBaseCardsAllQueryVariables>;
export const CreatorCardFormCardBaseCardDocument = gql`
    query CreatorCardFormCardBaseCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      familyId
      ...GameCard
      ...CreatorCardViewBaseCard
    }
  }
}
    ${GameCardFragmentDoc}
${CreatorCardViewBaseCardFragmentDoc}`;

/**
 * __useCreatorCardFormCardBaseCardQuery__
 *
 * To run a query within a React component, call `useCreatorCardFormCardBaseCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreatorCardFormCardBaseCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreatorCardFormCardBaseCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useCreatorCardFormCardBaseCardQuery(baseOptions: Apollo.QueryHookOptions<CreatorCardFormCardBaseCardQuery, CreatorCardFormCardBaseCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreatorCardFormCardBaseCardQuery, CreatorCardFormCardBaseCardQueryVariables>(CreatorCardFormCardBaseCardDocument, options);
      }
export function useCreatorCardFormCardBaseCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreatorCardFormCardBaseCardQuery, CreatorCardFormCardBaseCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreatorCardFormCardBaseCardQuery, CreatorCardFormCardBaseCardQueryVariables>(CreatorCardFormCardBaseCardDocument, options);
        }
export type CreatorCardFormCardBaseCardQueryHookResult = ReturnType<typeof useCreatorCardFormCardBaseCardQuery>;
export type CreatorCardFormCardBaseCardLazyQueryHookResult = ReturnType<typeof useCreatorCardFormCardBaseCardLazyQuery>;
export type CreatorCardFormCardBaseCardQueryResult = Apollo.QueryResult<CreatorCardFormCardBaseCardQuery, CreatorCardFormCardBaseCardQueryVariables>;
export const CreatorCardFormCardStreamerCardDocument = gql`
    query CreatorCardFormCardStreamerCard($cardId: ID!) {
  streamerCard(id: $cardId) {
    id
    ...CreatorCardFormStreamerCard
    baseCard {
      id
      ...GameCard
    }
  }
}
    ${CreatorCardFormStreamerCardFragmentDoc}
${GameCardFragmentDoc}`;

/**
 * __useCreatorCardFormCardStreamerCardQuery__
 *
 * To run a query within a React component, call `useCreatorCardFormCardStreamerCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreatorCardFormCardStreamerCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreatorCardFormCardStreamerCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useCreatorCardFormCardStreamerCardQuery(baseOptions: Apollo.QueryHookOptions<CreatorCardFormCardStreamerCardQuery, CreatorCardFormCardStreamerCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreatorCardFormCardStreamerCardQuery, CreatorCardFormCardStreamerCardQueryVariables>(CreatorCardFormCardStreamerCardDocument, options);
      }
export function useCreatorCardFormCardStreamerCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreatorCardFormCardStreamerCardQuery, CreatorCardFormCardStreamerCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreatorCardFormCardStreamerCardQuery, CreatorCardFormCardStreamerCardQueryVariables>(CreatorCardFormCardStreamerCardDocument, options);
        }
export type CreatorCardFormCardStreamerCardQueryHookResult = ReturnType<typeof useCreatorCardFormCardStreamerCardQuery>;
export type CreatorCardFormCardStreamerCardLazyQueryHookResult = ReturnType<typeof useCreatorCardFormCardStreamerCardLazyQuery>;
export type CreatorCardFormCardStreamerCardQueryResult = Apollo.QueryResult<CreatorCardFormCardStreamerCardQuery, CreatorCardFormCardStreamerCardQueryVariables>;
export const ChannelPlayedGamesDocument = gql`
    query ChannelPlayedGames($channelId: ID!) {
  channel(id: $channelId) {
    id
    streamedGames {
      id
      ...CreatorCardGame
    }
  }
}
    ${CreatorCardGameFragmentDoc}`;

/**
 * __useChannelPlayedGamesQuery__
 *
 * To run a query within a React component, call `useChannelPlayedGamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelPlayedGamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelPlayedGamesQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelPlayedGamesQuery(baseOptions: Apollo.QueryHookOptions<ChannelPlayedGamesQuery, ChannelPlayedGamesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelPlayedGamesQuery, ChannelPlayedGamesQueryVariables>(ChannelPlayedGamesDocument, options);
      }
export function useChannelPlayedGamesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelPlayedGamesQuery, ChannelPlayedGamesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelPlayedGamesQuery, ChannelPlayedGamesQueryVariables>(ChannelPlayedGamesDocument, options);
        }
export type ChannelPlayedGamesQueryHookResult = ReturnType<typeof useChannelPlayedGamesQuery>;
export type ChannelPlayedGamesLazyQueryHookResult = ReturnType<typeof useChannelPlayedGamesLazyQuery>;
export type ChannelPlayedGamesQueryResult = Apollo.QueryResult<ChannelPlayedGamesQuery, ChannelPlayedGamesQueryVariables>;
export const CreatorCardAssetCreateTokenDocument = gql`
    mutation CreatorCardAssetCreateToken($channelId: ID!, $cardId: ID!, $assetType: GameCardAssetType) {
  createStreamerCardAssetUploadToken(
    channelId: $channelId
    cardId: $cardId
    assetType: $assetType
  ) {
    token
  }
}
    `;
export type CreatorCardAssetCreateTokenMutationFn = Apollo.MutationFunction<CreatorCardAssetCreateTokenMutation, CreatorCardAssetCreateTokenMutationVariables>;

/**
 * __useCreatorCardAssetCreateTokenMutation__
 *
 * To run a mutation, you first call `useCreatorCardAssetCreateTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatorCardAssetCreateTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [creatorCardAssetCreateTokenMutation, { data, loading, error }] = useCreatorCardAssetCreateTokenMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      cardId: // value for 'cardId'
 *      assetType: // value for 'assetType'
 *   },
 * });
 */
export function useCreatorCardAssetCreateTokenMutation(baseOptions?: Apollo.MutationHookOptions<CreatorCardAssetCreateTokenMutation, CreatorCardAssetCreateTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatorCardAssetCreateTokenMutation, CreatorCardAssetCreateTokenMutationVariables>(CreatorCardAssetCreateTokenDocument, options);
      }
export type CreatorCardAssetCreateTokenMutationHookResult = ReturnType<typeof useCreatorCardAssetCreateTokenMutation>;
export type CreatorCardAssetCreateTokenMutationResult = Apollo.MutationResult<CreatorCardAssetCreateTokenMutation>;
export type CreatorCardAssetCreateTokenMutationOptions = Apollo.BaseMutationOptions<CreatorCardAssetCreateTokenMutation, CreatorCardAssetCreateTokenMutationVariables>;
export const CreateCreatorCardChannelDocument = gql`
    query CreateCreatorCardChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
    logo
    liveStatus
  }
}
    `;

/**
 * __useCreateCreatorCardChannelQuery__
 *
 * To run a query within a React component, call `useCreateCreatorCardChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateCreatorCardChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateCreatorCardChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useCreateCreatorCardChannelQuery(baseOptions: Apollo.QueryHookOptions<CreateCreatorCardChannelQuery, CreateCreatorCardChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreateCreatorCardChannelQuery, CreateCreatorCardChannelQueryVariables>(CreateCreatorCardChannelDocument, options);
      }
export function useCreateCreatorCardChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateCreatorCardChannelQuery, CreateCreatorCardChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreateCreatorCardChannelQuery, CreateCreatorCardChannelQueryVariables>(CreateCreatorCardChannelDocument, options);
        }
export type CreateCreatorCardChannelQueryHookResult = ReturnType<typeof useCreateCreatorCardChannelQuery>;
export type CreateCreatorCardChannelLazyQueryHookResult = ReturnType<typeof useCreateCreatorCardChannelLazyQuery>;
export type CreateCreatorCardChannelQueryResult = Apollo.QueryResult<CreateCreatorCardChannelQuery, CreateCreatorCardChannelQueryVariables>;
export const CreateCreatorCardDraftDocument = gql`
    mutation CreateCreatorCardDraft($channelId: ID!, $familyId: ID, $name: String, $gameId: ID) {
  createStreamerCardDraft(
    channelId: $channelId
    familyId: $familyId
    name: $name
    gameId: $gameId
  ) {
    id
    ...CreatorCardViewCreatorCard
  }
}
    ${CreatorCardViewCreatorCardFragmentDoc}`;
export type CreateCreatorCardDraftMutationFn = Apollo.MutationFunction<CreateCreatorCardDraftMutation, CreateCreatorCardDraftMutationVariables>;

/**
 * __useCreateCreatorCardDraftMutation__
 *
 * To run a mutation, you first call `useCreateCreatorCardDraftMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCreatorCardDraftMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCreatorCardDraftMutation, { data, loading, error }] = useCreateCreatorCardDraftMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      familyId: // value for 'familyId'
 *      name: // value for 'name'
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useCreateCreatorCardDraftMutation(baseOptions?: Apollo.MutationHookOptions<CreateCreatorCardDraftMutation, CreateCreatorCardDraftMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCreatorCardDraftMutation, CreateCreatorCardDraftMutationVariables>(CreateCreatorCardDraftDocument, options);
      }
export type CreateCreatorCardDraftMutationHookResult = ReturnType<typeof useCreateCreatorCardDraftMutation>;
export type CreateCreatorCardDraftMutationResult = Apollo.MutationResult<CreateCreatorCardDraftMutation>;
export type CreateCreatorCardDraftMutationOptions = Apollo.BaseMutationOptions<CreateCreatorCardDraftMutation, CreateCreatorCardDraftMutationVariables>;
export const PublishDraftCreatorCardDocument = gql`
    mutation PublishDraftCreatorCard($channelId: ID!, $cardId: ID!) {
  publishStreamerCardDraft(channelId: $channelId, cardId: $cardId) {
    emptyTypeWorkaround
  }
}
    `;
export type PublishDraftCreatorCardMutationFn = Apollo.MutationFunction<PublishDraftCreatorCardMutation, PublishDraftCreatorCardMutationVariables>;

/**
 * __usePublishDraftCreatorCardMutation__
 *
 * To run a mutation, you first call `usePublishDraftCreatorCardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePublishDraftCreatorCardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [publishDraftCreatorCardMutation, { data, loading, error }] = usePublishDraftCreatorCardMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function usePublishDraftCreatorCardMutation(baseOptions?: Apollo.MutationHookOptions<PublishDraftCreatorCardMutation, PublishDraftCreatorCardMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PublishDraftCreatorCardMutation, PublishDraftCreatorCardMutationVariables>(PublishDraftCreatorCardDocument, options);
      }
export type PublishDraftCreatorCardMutationHookResult = ReturnType<typeof usePublishDraftCreatorCardMutation>;
export type PublishDraftCreatorCardMutationResult = Apollo.MutationResult<PublishDraftCreatorCardMutation>;
export type PublishDraftCreatorCardMutationOptions = Apollo.BaseMutationOptions<PublishDraftCreatorCardMutation, PublishDraftCreatorCardMutationVariables>;
export const CreatorCardViewCardDocument = gql`
    query CreatorCardViewCard($id: ID!) {
  streamerCard(id: $id) {
    id
    ...CreatorCardViewCreatorCard
    baseCard {
      id
      ...CreatorCardViewBaseCard
    }
  }
}
    ${CreatorCardViewCreatorCardFragmentDoc}
${CreatorCardViewBaseCardFragmentDoc}`;

/**
 * __useCreatorCardViewCardQuery__
 *
 * To run a query within a React component, call `useCreatorCardViewCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreatorCardViewCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreatorCardViewCardQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCreatorCardViewCardQuery(baseOptions: Apollo.QueryHookOptions<CreatorCardViewCardQuery, CreatorCardViewCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreatorCardViewCardQuery, CreatorCardViewCardQueryVariables>(CreatorCardViewCardDocument, options);
      }
export function useCreatorCardViewCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreatorCardViewCardQuery, CreatorCardViewCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreatorCardViewCardQuery, CreatorCardViewCardQueryVariables>(CreatorCardViewCardDocument, options);
        }
export type CreatorCardViewCardQueryHookResult = ReturnType<typeof useCreatorCardViewCardQuery>;
export type CreatorCardViewCardLazyQueryHookResult = ReturnType<typeof useCreatorCardViewCardLazyQuery>;
export type CreatorCardViewCardQueryResult = Apollo.QueryResult<CreatorCardViewCardQuery, CreatorCardViewCardQueryVariables>;
export const CreateCreatorCardSaleConfigDocument = gql`
    mutation CreateCreatorCardSaleConfig($cardId: ID!, $channelId: ID!, $enabled: Boolean!, $excludeFromBundles: Boolean) {
  createStreamerCardSaleConfig(
    excludeFromBundles: $excludeFromBundles
    cardId: $cardId
    channelId: $channelId
    enabled: $enabled
  ) {
    cardId
  }
}
    `;
export type CreateCreatorCardSaleConfigMutationFn = Apollo.MutationFunction<CreateCreatorCardSaleConfigMutation, CreateCreatorCardSaleConfigMutationVariables>;

/**
 * __useCreateCreatorCardSaleConfigMutation__
 *
 * To run a mutation, you first call `useCreateCreatorCardSaleConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCreatorCardSaleConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCreatorCardSaleConfigMutation, { data, loading, error }] = useCreateCreatorCardSaleConfigMutation({
 *   variables: {
 *      cardId: // value for 'cardId'
 *      channelId: // value for 'channelId'
 *      enabled: // value for 'enabled'
 *      excludeFromBundles: // value for 'excludeFromBundles'
 *   },
 * });
 */
export function useCreateCreatorCardSaleConfigMutation(baseOptions?: Apollo.MutationHookOptions<CreateCreatorCardSaleConfigMutation, CreateCreatorCardSaleConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCreatorCardSaleConfigMutation, CreateCreatorCardSaleConfigMutationVariables>(CreateCreatorCardSaleConfigDocument, options);
      }
export type CreateCreatorCardSaleConfigMutationHookResult = ReturnType<typeof useCreateCreatorCardSaleConfigMutation>;
export type CreateCreatorCardSaleConfigMutationResult = Apollo.MutationResult<CreateCreatorCardSaleConfigMutation>;
export type CreateCreatorCardSaleConfigMutationOptions = Apollo.BaseMutationOptions<CreateCreatorCardSaleConfigMutation, CreateCreatorCardSaleConfigMutationVariables>;
export const DeleteDraftCardDocument = gql`
    mutation DeleteDraftCard($cardId: ID!, $channelId: ID!) {
  deleteStreamerCardDraft(cardId: $cardId, channelId: $channelId) {
    emptyTypeWorkaround
  }
}
    `;
export type DeleteDraftCardMutationFn = Apollo.MutationFunction<DeleteDraftCardMutation, DeleteDraftCardMutationVariables>;

/**
 * __useDeleteDraftCardMutation__
 *
 * To run a mutation, you first call `useDeleteDraftCardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteDraftCardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteDraftCardMutation, { data, loading, error }] = useDeleteDraftCardMutation({
 *   variables: {
 *      cardId: // value for 'cardId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useDeleteDraftCardMutation(baseOptions?: Apollo.MutationHookOptions<DeleteDraftCardMutation, DeleteDraftCardMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteDraftCardMutation, DeleteDraftCardMutationVariables>(DeleteDraftCardDocument, options);
      }
export type DeleteDraftCardMutationHookResult = ReturnType<typeof useDeleteDraftCardMutation>;
export type DeleteDraftCardMutationResult = Apollo.MutationResult<DeleteDraftCardMutation>;
export type DeleteDraftCardMutationOptions = Apollo.BaseMutationOptions<DeleteDraftCardMutation, DeleteDraftCardMutationVariables>;
export const UpdateCreatorCardSaleConfigDocument = gql`
    mutation UpdateCreatorCardSaleConfig($cardId: ID!, $channelId: ID!, $enabled: Boolean, $excludeFromBundles: Boolean) {
  updateStreamerCardSaleConfig(
    body: {excludeFromBundles: $excludeFromBundles, cardId: $cardId, channelId: $channelId, enabled: $enabled}
  ) {
    cardId
  }
}
    `;
export type UpdateCreatorCardSaleConfigMutationFn = Apollo.MutationFunction<UpdateCreatorCardSaleConfigMutation, UpdateCreatorCardSaleConfigMutationVariables>;

/**
 * __useUpdateCreatorCardSaleConfigMutation__
 *
 * To run a mutation, you first call `useUpdateCreatorCardSaleConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCreatorCardSaleConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCreatorCardSaleConfigMutation, { data, loading, error }] = useUpdateCreatorCardSaleConfigMutation({
 *   variables: {
 *      cardId: // value for 'cardId'
 *      channelId: // value for 'channelId'
 *      enabled: // value for 'enabled'
 *      excludeFromBundles: // value for 'excludeFromBundles'
 *   },
 * });
 */
export function useUpdateCreatorCardSaleConfigMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCreatorCardSaleConfigMutation, UpdateCreatorCardSaleConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCreatorCardSaleConfigMutation, UpdateCreatorCardSaleConfigMutationVariables>(UpdateCreatorCardSaleConfigDocument, options);
      }
export type UpdateCreatorCardSaleConfigMutationHookResult = ReturnType<typeof useUpdateCreatorCardSaleConfigMutation>;
export type UpdateCreatorCardSaleConfigMutationResult = Apollo.MutationResult<UpdateCreatorCardSaleConfigMutation>;
export type UpdateCreatorCardSaleConfigMutationOptions = Apollo.BaseMutationOptions<UpdateCreatorCardSaleConfigMutation, UpdateCreatorCardSaleConfigMutationVariables>;
export const CreatorCardsDocument = gql`
    query CreatorCards($channelId: ID!, $gameId: ID!) {
  streamerCards(filters: [{channelId: $channelId}, {gameId: $gameId}]) {
    cards {
      id
      ...CreatorCardListCard
    }
  }
}
    ${CreatorCardListCardFragmentDoc}`;

/**
 * __useCreatorCardsQuery__
 *
 * To run a query within a React component, call `useCreatorCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreatorCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreatorCardsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useCreatorCardsQuery(baseOptions: Apollo.QueryHookOptions<CreatorCardsQuery, CreatorCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreatorCardsQuery, CreatorCardsQueryVariables>(CreatorCardsDocument, options);
      }
export function useCreatorCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreatorCardsQuery, CreatorCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreatorCardsQuery, CreatorCardsQueryVariables>(CreatorCardsDocument, options);
        }
export type CreatorCardsQueryHookResult = ReturnType<typeof useCreatorCardsQuery>;
export type CreatorCardsLazyQueryHookResult = ReturnType<typeof useCreatorCardsLazyQuery>;
export type CreatorCardsQueryResult = Apollo.QueryResult<CreatorCardsQuery, CreatorCardsQueryVariables>;
export const DraftCreatorCardsDocument = gql`
    query DraftCreatorCards($channelId: ID!, $gameId: ID!) {
  streamerCardDrafts(channelId: $channelId, filters: [{gameId: $gameId}]) {
    cards {
      id
      ...CreatorCardListCard
    }
  }
}
    ${CreatorCardListCardFragmentDoc}`;

/**
 * __useDraftCreatorCardsQuery__
 *
 * To run a query within a React component, call `useDraftCreatorCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useDraftCreatorCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDraftCreatorCardsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useDraftCreatorCardsQuery(baseOptions: Apollo.QueryHookOptions<DraftCreatorCardsQuery, DraftCreatorCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DraftCreatorCardsQuery, DraftCreatorCardsQueryVariables>(DraftCreatorCardsDocument, options);
      }
export function useDraftCreatorCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DraftCreatorCardsQuery, DraftCreatorCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DraftCreatorCardsQuery, DraftCreatorCardsQueryVariables>(DraftCreatorCardsDocument, options);
        }
export type DraftCreatorCardsQueryHookResult = ReturnType<typeof useDraftCreatorCardsQuery>;
export type DraftCreatorCardsLazyQueryHookResult = ReturnType<typeof useDraftCreatorCardsLazyQuery>;
export type DraftCreatorCardsQueryResult = Apollo.QueryResult<DraftCreatorCardsQuery, DraftCreatorCardsQueryVariables>;
export const DraftCreatorCardEditPageDocument = gql`
    query DraftCreatorCardEditPage($cardId: ID!) {
  streamerCard(id: $cardId) {
    id
    draft
    name
    familyId
    gameId
    image
    video
    baseCard {
      id
      name
      season {
        id
        name
        game {
          id
          name
        }
      }
    }
  }
}
    `;

/**
 * __useDraftCreatorCardEditPageQuery__
 *
 * To run a query within a React component, call `useDraftCreatorCardEditPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useDraftCreatorCardEditPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDraftCreatorCardEditPageQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useDraftCreatorCardEditPageQuery(baseOptions: Apollo.QueryHookOptions<DraftCreatorCardEditPageQuery, DraftCreatorCardEditPageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DraftCreatorCardEditPageQuery, DraftCreatorCardEditPageQueryVariables>(DraftCreatorCardEditPageDocument, options);
      }
export function useDraftCreatorCardEditPageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DraftCreatorCardEditPageQuery, DraftCreatorCardEditPageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DraftCreatorCardEditPageQuery, DraftCreatorCardEditPageQueryVariables>(DraftCreatorCardEditPageDocument, options);
        }
export type DraftCreatorCardEditPageQueryHookResult = ReturnType<typeof useDraftCreatorCardEditPageQuery>;
export type DraftCreatorCardEditPageLazyQueryHookResult = ReturnType<typeof useDraftCreatorCardEditPageLazyQuery>;
export type DraftCreatorCardEditPageQueryResult = Apollo.QueryResult<DraftCreatorCardEditPageQuery, DraftCreatorCardEditPageQueryVariables>;
export const UpdateDraftCreatorCardDocument = gql`
    mutation UpdateDraftCreatorCard($cardId: ID!, $channelId: ID!, $gameId: ID, $familyId: ID, $name: String) {
  updateStreamerCardDraft(
    body: {cardId: $cardId, channelId: $channelId, gameId: $gameId, familyId: $familyId, name: $name}
  ) {
    id
    name
    familyId
    gameId
    baseCard {
      id
      seasonId
    }
  }
}
    `;
export type UpdateDraftCreatorCardMutationFn = Apollo.MutationFunction<UpdateDraftCreatorCardMutation, UpdateDraftCreatorCardMutationVariables>;

/**
 * __useUpdateDraftCreatorCardMutation__
 *
 * To run a mutation, you first call `useUpdateDraftCreatorCardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDraftCreatorCardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDraftCreatorCardMutation, { data, loading, error }] = useUpdateDraftCreatorCardMutation({
 *   variables: {
 *      cardId: // value for 'cardId'
 *      channelId: // value for 'channelId'
 *      gameId: // value for 'gameId'
 *      familyId: // value for 'familyId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useUpdateDraftCreatorCardMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDraftCreatorCardMutation, UpdateDraftCreatorCardMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDraftCreatorCardMutation, UpdateDraftCreatorCardMutationVariables>(UpdateDraftCreatorCardDocument, options);
      }
export type UpdateDraftCreatorCardMutationHookResult = ReturnType<typeof useUpdateDraftCreatorCardMutation>;
export type UpdateDraftCreatorCardMutationResult = Apollo.MutationResult<UpdateDraftCreatorCardMutation>;
export type UpdateDraftCreatorCardMutationOptions = Apollo.BaseMutationOptions<UpdateDraftCreatorCardMutation, UpdateDraftCreatorCardMutationVariables>;
export const ChannelUpdateSubscriptionConfigDocument = gql`
    mutation ChannelUpdateSubscriptionConfig($channelId: ID!, $subscriptionsEnabled: Boolean!) {
  updateChannelSubscriptionConfig(
    channelId: $channelId
    subscriptionsEnabled: $subscriptionsEnabled
  ) {
    channelId
    subscriptionsEnabled
  }
}
    `;
export type ChannelUpdateSubscriptionConfigMutationFn = Apollo.MutationFunction<ChannelUpdateSubscriptionConfigMutation, ChannelUpdateSubscriptionConfigMutationVariables>;

/**
 * __useChannelUpdateSubscriptionConfigMutation__
 *
 * To run a mutation, you first call `useChannelUpdateSubscriptionConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelUpdateSubscriptionConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelUpdateSubscriptionConfigMutation, { data, loading, error }] = useChannelUpdateSubscriptionConfigMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      subscriptionsEnabled: // value for 'subscriptionsEnabled'
 *   },
 * });
 */
export function useChannelUpdateSubscriptionConfigMutation(baseOptions?: Apollo.MutationHookOptions<ChannelUpdateSubscriptionConfigMutation, ChannelUpdateSubscriptionConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelUpdateSubscriptionConfigMutation, ChannelUpdateSubscriptionConfigMutationVariables>(ChannelUpdateSubscriptionConfigDocument, options);
      }
export type ChannelUpdateSubscriptionConfigMutationHookResult = ReturnType<typeof useChannelUpdateSubscriptionConfigMutation>;
export type ChannelUpdateSubscriptionConfigMutationResult = Apollo.MutationResult<ChannelUpdateSubscriptionConfigMutation>;
export type ChannelUpdateSubscriptionConfigMutationOptions = Apollo.BaseMutationOptions<ChannelUpdateSubscriptionConfigMutation, ChannelUpdateSubscriptionConfigMutationVariables>;
export const ChannelEmojisDocument = gql`
    query ChannelEmojis($channelId: ID!, $cursor: String) {
  channelEmojis(
    channelId: $channelId
    cursor: {first: 16, after: $cursor}
    includeDisabled: true
    includeCount: true
  ) {
    emojis {
      id
      image
      label
      disabled
    }
    pageInfo {
      hasNextPage
      endCursor
      hasPreviousPage
    }
    count {
      total
      disabled
    }
  }
}
    `;

/**
 * __useChannelEmojisQuery__
 *
 * To run a query within a React component, call `useChannelEmojisQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelEmojisQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelEmojisQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useChannelEmojisQuery(baseOptions: Apollo.QueryHookOptions<ChannelEmojisQuery, ChannelEmojisQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelEmojisQuery, ChannelEmojisQueryVariables>(ChannelEmojisDocument, options);
      }
export function useChannelEmojisLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelEmojisQuery, ChannelEmojisQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelEmojisQuery, ChannelEmojisQueryVariables>(ChannelEmojisDocument, options);
        }
export type ChannelEmojisQueryHookResult = ReturnType<typeof useChannelEmojisQuery>;
export type ChannelEmojisLazyQueryHookResult = ReturnType<typeof useChannelEmojisLazyQuery>;
export type ChannelEmojisQueryResult = Apollo.QueryResult<ChannelEmojisQuery, ChannelEmojisQueryVariables>;
export const AddEmojiChannelDocument = gql`
    query AddEmojiChannel($id: ID!) {
  channel(id: $id) {
    id
    name
  }
}
    `;

/**
 * __useAddEmojiChannelQuery__
 *
 * To run a query within a React component, call `useAddEmojiChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEmojiChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEmojiChannelQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useAddEmojiChannelQuery(baseOptions: Apollo.QueryHookOptions<AddEmojiChannelQuery, AddEmojiChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEmojiChannelQuery, AddEmojiChannelQueryVariables>(AddEmojiChannelDocument, options);
      }
export function useAddEmojiChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEmojiChannelQuery, AddEmojiChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEmojiChannelQuery, AddEmojiChannelQueryVariables>(AddEmojiChannelDocument, options);
        }
export type AddEmojiChannelQueryHookResult = ReturnType<typeof useAddEmojiChannelQuery>;
export type AddEmojiChannelLazyQueryHookResult = ReturnType<typeof useAddEmojiChannelLazyQuery>;
export type AddEmojiChannelQueryResult = Apollo.QueryResult<AddEmojiChannelQuery, AddEmojiChannelQueryVariables>;
export const CreateEmojiDocument = gql`
    mutation CreateEmoji($label: String!, $channelId: ID!) {
  createChannelEmoji(label: $label, channelId: $channelId) {
    id
    label
    channelId
    disabled
  }
}
    `;
export type CreateEmojiMutationFn = Apollo.MutationFunction<CreateEmojiMutation, CreateEmojiMutationVariables>;

/**
 * __useCreateEmojiMutation__
 *
 * To run a mutation, you first call `useCreateEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createEmojiMutation, { data, loading, error }] = useCreateEmojiMutation({
 *   variables: {
 *      label: // value for 'label'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useCreateEmojiMutation(baseOptions?: Apollo.MutationHookOptions<CreateEmojiMutation, CreateEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateEmojiMutation, CreateEmojiMutationVariables>(CreateEmojiDocument, options);
      }
export type CreateEmojiMutationHookResult = ReturnType<typeof useCreateEmojiMutation>;
export type CreateEmojiMutationResult = Apollo.MutationResult<CreateEmojiMutation>;
export type CreateEmojiMutationOptions = Apollo.BaseMutationOptions<CreateEmojiMutation, CreateEmojiMutationVariables>;
export const EnableCreatedEmojiDocument = gql`
    mutation EnableCreatedEmoji($id: ID!, $channelId: ID!) {
  updateChannelEmoji(body: {id: $id, channelId: $channelId, disabled: false}) {
    id
    disabled
  }
}
    `;
export type EnableCreatedEmojiMutationFn = Apollo.MutationFunction<EnableCreatedEmojiMutation, EnableCreatedEmojiMutationVariables>;

/**
 * __useEnableCreatedEmojiMutation__
 *
 * To run a mutation, you first call `useEnableCreatedEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEnableCreatedEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [enableCreatedEmojiMutation, { data, loading, error }] = useEnableCreatedEmojiMutation({
 *   variables: {
 *      id: // value for 'id'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useEnableCreatedEmojiMutation(baseOptions?: Apollo.MutationHookOptions<EnableCreatedEmojiMutation, EnableCreatedEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EnableCreatedEmojiMutation, EnableCreatedEmojiMutationVariables>(EnableCreatedEmojiDocument, options);
      }
export type EnableCreatedEmojiMutationHookResult = ReturnType<typeof useEnableCreatedEmojiMutation>;
export type EnableCreatedEmojiMutationResult = Apollo.MutationResult<EnableCreatedEmojiMutation>;
export type EnableCreatedEmojiMutationOptions = Apollo.BaseMutationOptions<EnableCreatedEmojiMutation, EnableCreatedEmojiMutationVariables>;
export const ChannelEmojiDocument = gql`
    query ChannelEmoji($id: ID!, $channelId: ID!) {
  emoji(id: $id) {
    id
    channelId
    ...ChannelEmojiFormContentEmoji
  }
  channel(id: $channelId) {
    id
    ...ChannelEmojiFormContentChannel
  }
}
    ${ChannelEmojiFormContentEmojiFragmentDoc}
${ChannelEmojiFormContentChannelFragmentDoc}`;

/**
 * __useChannelEmojiQuery__
 *
 * To run a query within a React component, call `useChannelEmojiQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelEmojiQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelEmojiQuery({
 *   variables: {
 *      id: // value for 'id'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelEmojiQuery(baseOptions: Apollo.QueryHookOptions<ChannelEmojiQuery, ChannelEmojiQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelEmojiQuery, ChannelEmojiQueryVariables>(ChannelEmojiDocument, options);
      }
export function useChannelEmojiLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelEmojiQuery, ChannelEmojiQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelEmojiQuery, ChannelEmojiQueryVariables>(ChannelEmojiDocument, options);
        }
export type ChannelEmojiQueryHookResult = ReturnType<typeof useChannelEmojiQuery>;
export type ChannelEmojiLazyQueryHookResult = ReturnType<typeof useChannelEmojiLazyQuery>;
export type ChannelEmojiQueryResult = Apollo.QueryResult<ChannelEmojiQuery, ChannelEmojiQueryVariables>;
export const EditChannelEmojiDocument = gql`
    mutation EditChannelEmoji($id: ID!, $channelId: ID!, $label: String, $disabled: Boolean) {
  updateChannelEmoji(
    body: {id: $id, channelId: $channelId, label: $label, disabled: $disabled}
  ) {
    id
    label
    disabled
  }
}
    `;
export type EditChannelEmojiMutationFn = Apollo.MutationFunction<EditChannelEmojiMutation, EditChannelEmojiMutationVariables>;

/**
 * __useEditChannelEmojiMutation__
 *
 * To run a mutation, you first call `useEditChannelEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditChannelEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editChannelEmojiMutation, { data, loading, error }] = useEditChannelEmojiMutation({
 *   variables: {
 *      id: // value for 'id'
 *      channelId: // value for 'channelId'
 *      label: // value for 'label'
 *      disabled: // value for 'disabled'
 *   },
 * });
 */
export function useEditChannelEmojiMutation(baseOptions?: Apollo.MutationHookOptions<EditChannelEmojiMutation, EditChannelEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditChannelEmojiMutation, EditChannelEmojiMutationVariables>(EditChannelEmojiDocument, options);
      }
export type EditChannelEmojiMutationHookResult = ReturnType<typeof useEditChannelEmojiMutation>;
export type EditChannelEmojiMutationResult = Apollo.MutationResult<EditChannelEmojiMutation>;
export type EditChannelEmojiMutationOptions = Apollo.BaseMutationOptions<EditChannelEmojiMutation, EditChannelEmojiMutationVariables>;
export const DeleteChannelEmojiDocument = gql`
    mutation DeleteChannelEmoji($id: ID!, $channelId: ID!) {
  deleteChannelEmoji(id: $id, channelId: $channelId) {
    emptyTypeWorkaround
  }
}
    `;
export type DeleteChannelEmojiMutationFn = Apollo.MutationFunction<DeleteChannelEmojiMutation, DeleteChannelEmojiMutationVariables>;

/**
 * __useDeleteChannelEmojiMutation__
 *
 * To run a mutation, you first call `useDeleteChannelEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteChannelEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteChannelEmojiMutation, { data, loading, error }] = useDeleteChannelEmojiMutation({
 *   variables: {
 *      id: // value for 'id'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useDeleteChannelEmojiMutation(baseOptions?: Apollo.MutationHookOptions<DeleteChannelEmojiMutation, DeleteChannelEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteChannelEmojiMutation, DeleteChannelEmojiMutationVariables>(DeleteChannelEmojiDocument, options);
      }
export type DeleteChannelEmojiMutationHookResult = ReturnType<typeof useDeleteChannelEmojiMutation>;
export type DeleteChannelEmojiMutationResult = Apollo.MutationResult<DeleteChannelEmojiMutation>;
export type DeleteChannelEmojiMutationOptions = Apollo.BaseMutationOptions<DeleteChannelEmojiMutation, DeleteChannelEmojiMutationVariables>;
export const ChannelEmojiMaxAmountDocument = gql`
    query ChannelEmojiMaxAmount($channelId: ID!) {
  channelEmojis(channelId: $channelId, includeCount: true) {
    count {
      total
      disabled
    }
  }
}
    `;

/**
 * __useChannelEmojiMaxAmountQuery__
 *
 * To run a query within a React component, call `useChannelEmojiMaxAmountQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelEmojiMaxAmountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelEmojiMaxAmountQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelEmojiMaxAmountQuery(baseOptions: Apollo.QueryHookOptions<ChannelEmojiMaxAmountQuery, ChannelEmojiMaxAmountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelEmojiMaxAmountQuery, ChannelEmojiMaxAmountQueryVariables>(ChannelEmojiMaxAmountDocument, options);
      }
export function useChannelEmojiMaxAmountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelEmojiMaxAmountQuery, ChannelEmojiMaxAmountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelEmojiMaxAmountQuery, ChannelEmojiMaxAmountQueryVariables>(ChannelEmojiMaxAmountDocument, options);
        }
export type ChannelEmojiMaxAmountQueryHookResult = ReturnType<typeof useChannelEmojiMaxAmountQuery>;
export type ChannelEmojiMaxAmountLazyQueryHookResult = ReturnType<typeof useChannelEmojiMaxAmountLazyQuery>;
export type ChannelEmojiMaxAmountQueryResult = Apollo.QueryResult<ChannelEmojiMaxAmountQuery, ChannelEmojiMaxAmountQueryVariables>;
export const ChannelEmojiSubscriptionStateDocument = gql`
    query ChannelEmojiSubscriptionState($channelId: ID!) {
  channel(id: $channelId) {
    id
    subscriptionConfig {
      channelId
      subscriptionsEnabled
    }
  }
}
    `;

/**
 * __useChannelEmojiSubscriptionStateQuery__
 *
 * To run a query within a React component, call `useChannelEmojiSubscriptionStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelEmojiSubscriptionStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelEmojiSubscriptionStateQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelEmojiSubscriptionStateQuery(baseOptions: Apollo.QueryHookOptions<ChannelEmojiSubscriptionStateQuery, ChannelEmojiSubscriptionStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelEmojiSubscriptionStateQuery, ChannelEmojiSubscriptionStateQueryVariables>(ChannelEmojiSubscriptionStateDocument, options);
      }
export function useChannelEmojiSubscriptionStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelEmojiSubscriptionStateQuery, ChannelEmojiSubscriptionStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelEmojiSubscriptionStateQuery, ChannelEmojiSubscriptionStateQueryVariables>(ChannelEmojiSubscriptionStateDocument, options);
        }
export type ChannelEmojiSubscriptionStateQueryHookResult = ReturnType<typeof useChannelEmojiSubscriptionStateQuery>;
export type ChannelEmojiSubscriptionStateLazyQueryHookResult = ReturnType<typeof useChannelEmojiSubscriptionStateLazyQuery>;
export type ChannelEmojiSubscriptionStateQueryResult = Apollo.QueryResult<ChannelEmojiSubscriptionStateQuery, ChannelEmojiSubscriptionStateQueryVariables>;
export const SubscriptionsMonetizationDataDocument = gql`
    query SubscriptionsMonetizationData($channelId: ID!) {
  channel(id: $channelId) {
    id
    subscriberCount
    subscriptionConfig {
      channelId
      subscriptionsEnabled
    }
    monetizationSettings {
      enabled
    }
    ...SubscriptionGetChannelEmojisChannel
  }
}
    ${SubscriptionGetChannelEmojisChannelFragmentDoc}`;

/**
 * __useSubscriptionsMonetizationDataQuery__
 *
 * To run a query within a React component, call `useSubscriptionsMonetizationDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionsMonetizationDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionsMonetizationDataQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSubscriptionsMonetizationDataQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionsMonetizationDataQuery, SubscriptionsMonetizationDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionsMonetizationDataQuery, SubscriptionsMonetizationDataQueryVariables>(SubscriptionsMonetizationDataDocument, options);
      }
export function useSubscriptionsMonetizationDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionsMonetizationDataQuery, SubscriptionsMonetizationDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionsMonetizationDataQuery, SubscriptionsMonetizationDataQueryVariables>(SubscriptionsMonetizationDataDocument, options);
        }
export type SubscriptionsMonetizationDataQueryHookResult = ReturnType<typeof useSubscriptionsMonetizationDataQuery>;
export type SubscriptionsMonetizationDataLazyQueryHookResult = ReturnType<typeof useSubscriptionsMonetizationDataLazyQuery>;
export type SubscriptionsMonetizationDataQueryResult = Apollo.QueryResult<SubscriptionsMonetizationDataQuery, SubscriptionsMonetizationDataQueryVariables>;
export const MonetizationSubscribersDocument = gql`
    query MonetizationSubscribers($channelId: ID!, $cursor: String) {
  channelSubscriptions(
    channelId: $channelId
    cursor: {first: 16, after: $cursor}
    filters: [{state: STATE_ACTIVE}, {state: STATE_CANCELLED}]
  ) {
    subscriptions {
      id
      activatedAt
      user {
        userId
        userTag
        badges(channel_id: $channelId) {
          ...UserBadge
        }
      }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
    ${UserBadgeFragmentDoc}`;

/**
 * __useMonetizationSubscribersQuery__
 *
 * To run a query within a React component, call `useMonetizationSubscribersQuery` and pass it any options that fit your needs.
 * When your component renders, `useMonetizationSubscribersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMonetizationSubscribersQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useMonetizationSubscribersQuery(baseOptions: Apollo.QueryHookOptions<MonetizationSubscribersQuery, MonetizationSubscribersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MonetizationSubscribersQuery, MonetizationSubscribersQueryVariables>(MonetizationSubscribersDocument, options);
      }
export function useMonetizationSubscribersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MonetizationSubscribersQuery, MonetizationSubscribersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MonetizationSubscribersQuery, MonetizationSubscribersQueryVariables>(MonetizationSubscribersDocument, options);
        }
export type MonetizationSubscribersQueryHookResult = ReturnType<typeof useMonetizationSubscribersQuery>;
export type MonetizationSubscribersLazyQueryHookResult = ReturnType<typeof useMonetizationSubscribersLazyQuery>;
export type MonetizationSubscribersQueryResult = Apollo.QueryResult<MonetizationSubscribersQuery, MonetizationSubscribersQueryVariables>;
export const MonetizationSubscribersCountDocument = gql`
    query MonetizationSubscribersCount($channelId: ID!) {
  channel(id: $channelId) {
    id
    subscriberCount
  }
}
    `;

/**
 * __useMonetizationSubscribersCountQuery__
 *
 * To run a query within a React component, call `useMonetizationSubscribersCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useMonetizationSubscribersCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMonetizationSubscribersCountQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useMonetizationSubscribersCountQuery(baseOptions: Apollo.QueryHookOptions<MonetizationSubscribersCountQuery, MonetizationSubscribersCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MonetizationSubscribersCountQuery, MonetizationSubscribersCountQueryVariables>(MonetizationSubscribersCountDocument, options);
      }
export function useMonetizationSubscribersCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MonetizationSubscribersCountQuery, MonetizationSubscribersCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MonetizationSubscribersCountQuery, MonetizationSubscribersCountQueryVariables>(MonetizationSubscribersCountDocument, options);
        }
export type MonetizationSubscribersCountQueryHookResult = ReturnType<typeof useMonetizationSubscribersCountQuery>;
export type MonetizationSubscribersCountLazyQueryHookResult = ReturnType<typeof useMonetizationSubscribersCountLazyQuery>;
export type MonetizationSubscribersCountQueryResult = Apollo.QueryResult<MonetizationSubscribersCountQuery, MonetizationSubscribersCountQueryVariables>;
export const NoAccessUserDataDocument = gql`
    query NoAccessUserData($userId: ID) {
  profile(userId: $userId) {
    preferredColor
    userId
    userTag
    ...ProfileImageProfile
  }
  userPrivilegedChannels(userId: $userId) {
    channels {
      channelId
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useNoAccessUserDataQuery__
 *
 * To run a query within a React component, call `useNoAccessUserDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useNoAccessUserDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNoAccessUserDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useNoAccessUserDataQuery(baseOptions?: Apollo.QueryHookOptions<NoAccessUserDataQuery, NoAccessUserDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NoAccessUserDataQuery, NoAccessUserDataQueryVariables>(NoAccessUserDataDocument, options);
      }
export function useNoAccessUserDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NoAccessUserDataQuery, NoAccessUserDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NoAccessUserDataQuery, NoAccessUserDataQueryVariables>(NoAccessUserDataDocument, options);
        }
export type NoAccessUserDataQueryHookResult = ReturnType<typeof useNoAccessUserDataQuery>;
export type NoAccessUserDataLazyQueryHookResult = ReturnType<typeof useNoAccessUserDataLazyQuery>;
export type NoAccessUserDataQueryResult = Apollo.QueryResult<NoAccessUserDataQuery, NoAccessUserDataQueryVariables>;
export const AutomodSettingsDocument = gql`
    query AutomodSettings($channelId: ID!) {
  channelModerationSettings(channelId: $channelId) {
    automod {
      level
      defaultDecision
    }
  }
}
    `;

/**
 * __useAutomodSettingsQuery__
 *
 * To run a query within a React component, call `useAutomodSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAutomodSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAutomodSettingsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useAutomodSettingsQuery(baseOptions: Apollo.QueryHookOptions<AutomodSettingsQuery, AutomodSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AutomodSettingsQuery, AutomodSettingsQueryVariables>(AutomodSettingsDocument, options);
      }
export function useAutomodSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AutomodSettingsQuery, AutomodSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AutomodSettingsQuery, AutomodSettingsQueryVariables>(AutomodSettingsDocument, options);
        }
export type AutomodSettingsQueryHookResult = ReturnType<typeof useAutomodSettingsQuery>;
export type AutomodSettingsLazyQueryHookResult = ReturnType<typeof useAutomodSettingsLazyQuery>;
export type AutomodSettingsQueryResult = Apollo.QueryResult<AutomodSettingsQuery, AutomodSettingsQueryVariables>;
export const UpdateAutomodSettingsDocument = gql`
    mutation UpdateAutomodSettings($channelId: ID!, $automod: ChannelAutomodSettingsInput) {
  updateChannelModerationSettings(
    body: {channelId: $channelId, automod: $automod}
  ) {
    automod {
      level
      defaultDecision
    }
  }
}
    `;
export type UpdateAutomodSettingsMutationFn = Apollo.MutationFunction<UpdateAutomodSettingsMutation, UpdateAutomodSettingsMutationVariables>;

/**
 * __useUpdateAutomodSettingsMutation__
 *
 * To run a mutation, you first call `useUpdateAutomodSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAutomodSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAutomodSettingsMutation, { data, loading, error }] = useUpdateAutomodSettingsMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      automod: // value for 'automod'
 *   },
 * });
 */
export function useUpdateAutomodSettingsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAutomodSettingsMutation, UpdateAutomodSettingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAutomodSettingsMutation, UpdateAutomodSettingsMutationVariables>(UpdateAutomodSettingsDocument, options);
      }
export type UpdateAutomodSettingsMutationHookResult = ReturnType<typeof useUpdateAutomodSettingsMutation>;
export type UpdateAutomodSettingsMutationResult = Apollo.MutationResult<UpdateAutomodSettingsMutation>;
export type UpdateAutomodSettingsMutationOptions = Apollo.BaseMutationOptions<UpdateAutomodSettingsMutation, UpdateAutomodSettingsMutationVariables>;
export const SearchUserToBanDocument = gql`
    query SearchUserToBan($username: String!) {
  resolveUserTags(userTags: [$username]) {
    profiles {
      userId
      ...ChannelBanModalProfile
    }
    userIds {
      key
      value
    }
  }
}
    ${ChannelBanModalProfileFragmentDoc}`;

/**
 * __useSearchUserToBanQuery__
 *
 * To run a query within a React component, call `useSearchUserToBanQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchUserToBanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchUserToBanQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useSearchUserToBanQuery(baseOptions: Apollo.QueryHookOptions<SearchUserToBanQuery, SearchUserToBanQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchUserToBanQuery, SearchUserToBanQueryVariables>(SearchUserToBanDocument, options);
      }
export function useSearchUserToBanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchUserToBanQuery, SearchUserToBanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchUserToBanQuery, SearchUserToBanQueryVariables>(SearchUserToBanDocument, options);
        }
export type SearchUserToBanQueryHookResult = ReturnType<typeof useSearchUserToBanQuery>;
export type SearchUserToBanLazyQueryHookResult = ReturnType<typeof useSearchUserToBanLazyQuery>;
export type SearchUserToBanQueryResult = Apollo.QueryResult<SearchUserToBanQuery, SearchUserToBanQueryVariables>;
export const SettingsBanFormUserChannelStateDocument = gql`
    query SettingsBanFormUserChannelState($userId: ID!, $channelId: ID!) {
  channelBanUserStatus(userId: $userId, channelId: $channelId) {
    userId
    channelId
    banned
  }
  userChannelRoles(userId: $userId, channelId: $channelId) {
    roles
  }
}
    `;

/**
 * __useSettingsBanFormUserChannelStateQuery__
 *
 * To run a query within a React component, call `useSettingsBanFormUserChannelStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useSettingsBanFormUserChannelStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSettingsBanFormUserChannelStateQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSettingsBanFormUserChannelStateQuery(baseOptions: Apollo.QueryHookOptions<SettingsBanFormUserChannelStateQuery, SettingsBanFormUserChannelStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SettingsBanFormUserChannelStateQuery, SettingsBanFormUserChannelStateQueryVariables>(SettingsBanFormUserChannelStateDocument, options);
      }
export function useSettingsBanFormUserChannelStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SettingsBanFormUserChannelStateQuery, SettingsBanFormUserChannelStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SettingsBanFormUserChannelStateQuery, SettingsBanFormUserChannelStateQueryVariables>(SettingsBanFormUserChannelStateDocument, options);
        }
export type SettingsBanFormUserChannelStateQueryHookResult = ReturnType<typeof useSettingsBanFormUserChannelStateQuery>;
export type SettingsBanFormUserChannelStateLazyQueryHookResult = ReturnType<typeof useSettingsBanFormUserChannelStateLazyQuery>;
export type SettingsBanFormUserChannelStateQueryResult = Apollo.QueryResult<SettingsBanFormUserChannelStateQuery, SettingsBanFormUserChannelStateQueryVariables>;
export const ModerationBannedListDocument = gql`
    query ModerationBannedList($channelId: ID!, $cursor: String, $pageSize: Int) {
  channelBannedUsers(
    channelId: $channelId
    cursor: {first: $pageSize, after: $cursor}
  ) {
    users {
      channelId
      ...BannedUserBannedUser
      ...BanDetailsUser
      user {
        userTag
      }
      userId
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
    ${BannedUserBannedUserFragmentDoc}
${BanDetailsUserFragmentDoc}`;

/**
 * __useModerationBannedListQuery__
 *
 * To run a query within a React component, call `useModerationBannedListQuery` and pass it any options that fit your needs.
 * When your component renders, `useModerationBannedListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useModerationBannedListQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      cursor: // value for 'cursor'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useModerationBannedListQuery(baseOptions: Apollo.QueryHookOptions<ModerationBannedListQuery, ModerationBannedListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ModerationBannedListQuery, ModerationBannedListQueryVariables>(ModerationBannedListDocument, options);
      }
export function useModerationBannedListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ModerationBannedListQuery, ModerationBannedListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ModerationBannedListQuery, ModerationBannedListQueryVariables>(ModerationBannedListDocument, options);
        }
export type ModerationBannedListQueryHookResult = ReturnType<typeof useModerationBannedListQuery>;
export type ModerationBannedListLazyQueryHookResult = ReturnType<typeof useModerationBannedListLazyQuery>;
export type ModerationBannedListQueryResult = Apollo.QueryResult<ModerationBannedListQuery, ModerationBannedListQueryVariables>;
export const ModerationUpdateChannelBanAppealDocument = gql`
    mutation ModerationUpdateChannelBanAppeal($userId: ID!, $channelId: ID!, $status: ChannelAppealStatus!) {
  updateChannelBanAppeal(userId: $userId, channelId: $channelId, status: $status) {
    emptyTypeWorkaround
  }
}
    `;
export type ModerationUpdateChannelBanAppealMutationFn = Apollo.MutationFunction<ModerationUpdateChannelBanAppealMutation, ModerationUpdateChannelBanAppealMutationVariables>;

/**
 * __useModerationUpdateChannelBanAppealMutation__
 *
 * To run a mutation, you first call `useModerationUpdateChannelBanAppealMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useModerationUpdateChannelBanAppealMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [moderationUpdateChannelBanAppealMutation, { data, loading, error }] = useModerationUpdateChannelBanAppealMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useModerationUpdateChannelBanAppealMutation(baseOptions?: Apollo.MutationHookOptions<ModerationUpdateChannelBanAppealMutation, ModerationUpdateChannelBanAppealMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ModerationUpdateChannelBanAppealMutation, ModerationUpdateChannelBanAppealMutationVariables>(ModerationUpdateChannelBanAppealDocument, options);
      }
export type ModerationUpdateChannelBanAppealMutationHookResult = ReturnType<typeof useModerationUpdateChannelBanAppealMutation>;
export type ModerationUpdateChannelBanAppealMutationResult = Apollo.MutationResult<ModerationUpdateChannelBanAppealMutation>;
export type ModerationUpdateChannelBanAppealMutationOptions = Apollo.BaseMutationOptions<ModerationUpdateChannelBanAppealMutation, ModerationUpdateChannelBanAppealMutationVariables>;
export const ArenaBlockUpdateCrConfigDocument = gql`
    mutation ArenaBlockUpdateCrConfig($id: ID!, $channelId: ID!, $containerImage: String, $controllerContainerImage: String, $arenaId: ID) {
  updateStreamBackendConfig(
    body: {id: $id, channelId: $channelId, crConfig: {containerImage: $containerImage, controllerContainerImage: $controllerContainerImage, arenaId: $arenaId}}
  ) {
    ...ArenaBlockChannelStreamBackendConfig
  }
}
    ${ArenaBlockChannelStreamBackendConfigFragmentDoc}`;
export type ArenaBlockUpdateCrConfigMutationFn = Apollo.MutationFunction<ArenaBlockUpdateCrConfigMutation, ArenaBlockUpdateCrConfigMutationVariables>;

/**
 * __useArenaBlockUpdateCrConfigMutation__
 *
 * To run a mutation, you first call `useArenaBlockUpdateCrConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useArenaBlockUpdateCrConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [arenaBlockUpdateCrConfigMutation, { data, loading, error }] = useArenaBlockUpdateCrConfigMutation({
 *   variables: {
 *      id: // value for 'id'
 *      channelId: // value for 'channelId'
 *      containerImage: // value for 'containerImage'
 *      controllerContainerImage: // value for 'controllerContainerImage'
 *      arenaId: // value for 'arenaId'
 *   },
 * });
 */
export function useArenaBlockUpdateCrConfigMutation(baseOptions?: Apollo.MutationHookOptions<ArenaBlockUpdateCrConfigMutation, ArenaBlockUpdateCrConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ArenaBlockUpdateCrConfigMutation, ArenaBlockUpdateCrConfigMutationVariables>(ArenaBlockUpdateCrConfigDocument, options);
      }
export type ArenaBlockUpdateCrConfigMutationHookResult = ReturnType<typeof useArenaBlockUpdateCrConfigMutation>;
export type ArenaBlockUpdateCrConfigMutationResult = Apollo.MutationResult<ArenaBlockUpdateCrConfigMutation>;
export type ArenaBlockUpdateCrConfigMutationOptions = Apollo.BaseMutationOptions<ArenaBlockUpdateCrConfigMutation, ArenaBlockUpdateCrConfigMutationVariables>;
export const ArenaBlockStreamSettingsDocument = gql`
    query ArenaBlockStreamSettings($channelId: ID!) {
  selectedStreamBackendConfig(channelId: $channelId) {
    id
    ...ArenaBlockChannelStreamBackendConfig
  }
  arenas(channelId: $channelId) {
    arenas {
      ...ArenaBlockArena
    }
  }
}
    ${ArenaBlockChannelStreamBackendConfigFragmentDoc}
${ArenaBlockArenaFragmentDoc}`;

/**
 * __useArenaBlockStreamSettingsQuery__
 *
 * To run a query within a React component, call `useArenaBlockStreamSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useArenaBlockStreamSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useArenaBlockStreamSettingsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useArenaBlockStreamSettingsQuery(baseOptions: Apollo.QueryHookOptions<ArenaBlockStreamSettingsQuery, ArenaBlockStreamSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ArenaBlockStreamSettingsQuery, ArenaBlockStreamSettingsQueryVariables>(ArenaBlockStreamSettingsDocument, options);
      }
export function useArenaBlockStreamSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ArenaBlockStreamSettingsQuery, ArenaBlockStreamSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ArenaBlockStreamSettingsQuery, ArenaBlockStreamSettingsQueryVariables>(ArenaBlockStreamSettingsDocument, options);
        }
export type ArenaBlockStreamSettingsQueryHookResult = ReturnType<typeof useArenaBlockStreamSettingsQuery>;
export type ArenaBlockStreamSettingsLazyQueryHookResult = ReturnType<typeof useArenaBlockStreamSettingsLazyQuery>;
export type ArenaBlockStreamSettingsQueryResult = Apollo.QueryResult<ArenaBlockStreamSettingsQuery, ArenaBlockStreamSettingsQueryVariables>;
export const DeleteLogoImageDocument = gql`
    mutation DeleteLogoImage($channelId: ID!, $assetType: ChannelAssetType!) {
  deleteChannelAsset(channelId: $channelId, assetType: $assetType) {
    emptyTypeWorkaround
  }
}
    `;
export type DeleteLogoImageMutationFn = Apollo.MutationFunction<DeleteLogoImageMutation, DeleteLogoImageMutationVariables>;

/**
 * __useDeleteLogoImageMutation__
 *
 * To run a mutation, you first call `useDeleteLogoImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteLogoImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteLogoImageMutation, { data, loading, error }] = useDeleteLogoImageMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      assetType: // value for 'assetType'
 *   },
 * });
 */
export function useDeleteLogoImageMutation(baseOptions?: Apollo.MutationHookOptions<DeleteLogoImageMutation, DeleteLogoImageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteLogoImageMutation, DeleteLogoImageMutationVariables>(DeleteLogoImageDocument, options);
      }
export type DeleteLogoImageMutationHookResult = ReturnType<typeof useDeleteLogoImageMutation>;
export type DeleteLogoImageMutationResult = Apollo.MutationResult<DeleteLogoImageMutation>;
export type DeleteLogoImageMutationOptions = Apollo.BaseMutationOptions<DeleteLogoImageMutation, DeleteLogoImageMutationVariables>;
export const DeleteBannerImageDocument = gql`
    mutation DeleteBannerImage($channelId: ID!, $assetType: ChannelAssetType!) {
  deleteChannelAsset(channelId: $channelId, assetType: $assetType) {
    emptyTypeWorkaround
  }
}
    `;
export type DeleteBannerImageMutationFn = Apollo.MutationFunction<DeleteBannerImageMutation, DeleteBannerImageMutationVariables>;

/**
 * __useDeleteBannerImageMutation__
 *
 * To run a mutation, you first call `useDeleteBannerImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBannerImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBannerImageMutation, { data, loading, error }] = useDeleteBannerImageMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      assetType: // value for 'assetType'
 *   },
 * });
 */
export function useDeleteBannerImageMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBannerImageMutation, DeleteBannerImageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBannerImageMutation, DeleteBannerImageMutationVariables>(DeleteBannerImageDocument, options);
      }
export type DeleteBannerImageMutationHookResult = ReturnType<typeof useDeleteBannerImageMutation>;
export type DeleteBannerImageMutationResult = Apollo.MutationResult<DeleteBannerImageMutation>;
export type DeleteBannerImageMutationOptions = Apollo.BaseMutationOptions<DeleteBannerImageMutation, DeleteBannerImageMutationVariables>;
export const SettingsChannelBrandingDocument = gql`
    query SettingsChannelBranding($channelId: ID!) {
  channel(id: $channelId) {
    liveStatus
    id
    offlineBanner
    logo
    ...OfflineBannerBlockChannel
    ...LogoImageBlockChannel
  }
}
    ${OfflineBannerBlockChannelFragmentDoc}
${LogoImageBlockChannelFragmentDoc}`;

/**
 * __useSettingsChannelBrandingQuery__
 *
 * To run a query within a React component, call `useSettingsChannelBrandingQuery` and pass it any options that fit your needs.
 * When your component renders, `useSettingsChannelBrandingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSettingsChannelBrandingQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSettingsChannelBrandingQuery(baseOptions: Apollo.QueryHookOptions<SettingsChannelBrandingQuery, SettingsChannelBrandingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SettingsChannelBrandingQuery, SettingsChannelBrandingQueryVariables>(SettingsChannelBrandingDocument, options);
      }
export function useSettingsChannelBrandingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SettingsChannelBrandingQuery, SettingsChannelBrandingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SettingsChannelBrandingQuery, SettingsChannelBrandingQueryVariables>(SettingsChannelBrandingDocument, options);
        }
export type SettingsChannelBrandingQueryHookResult = ReturnType<typeof useSettingsChannelBrandingQuery>;
export type SettingsChannelBrandingLazyQueryHookResult = ReturnType<typeof useSettingsChannelBrandingLazyQuery>;
export type SettingsChannelBrandingQueryResult = Apollo.QueryResult<SettingsChannelBrandingQuery, SettingsChannelBrandingQueryVariables>;
export const SettingsChannelDocument = gql`
    query SettingsChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    description
    name
    title
    links {
      name
      type
      url
    }
  }
}
    `;

/**
 * __useSettingsChannelQuery__
 *
 * To run a query within a React component, call `useSettingsChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useSettingsChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSettingsChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSettingsChannelQuery(baseOptions: Apollo.QueryHookOptions<SettingsChannelQuery, SettingsChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SettingsChannelQuery, SettingsChannelQueryVariables>(SettingsChannelDocument, options);
      }
export function useSettingsChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SettingsChannelQuery, SettingsChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SettingsChannelQuery, SettingsChannelQueryVariables>(SettingsChannelDocument, options);
        }
export type SettingsChannelQueryHookResult = ReturnType<typeof useSettingsChannelQuery>;
export type SettingsChannelLazyQueryHookResult = ReturnType<typeof useSettingsChannelLazyQuery>;
export type SettingsChannelQueryResult = Apollo.QueryResult<SettingsChannelQuery, SettingsChannelQueryVariables>;
export const UpdateChannelDetailsDocument = gql`
    mutation UpdateChannelDetails($channelId: ID!, $title: String, $description: String, $links: [ChannelChannelLinkInput!]) {
  updateChannelDetails(
    body: {id: $channelId, title: $title, description: $description, links: $links}
  ) {
    ...ChannelInfoUpdate
  }
}
    ${ChannelInfoUpdateFragmentDoc}`;
export type UpdateChannelDetailsMutationFn = Apollo.MutationFunction<UpdateChannelDetailsMutation, UpdateChannelDetailsMutationVariables>;

/**
 * __useUpdateChannelDetailsMutation__
 *
 * To run a mutation, you first call `useUpdateChannelDetailsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChannelDetailsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChannelDetailsMutation, { data, loading, error }] = useUpdateChannelDetailsMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      title: // value for 'title'
 *      description: // value for 'description'
 *      links: // value for 'links'
 *   },
 * });
 */
export function useUpdateChannelDetailsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChannelDetailsMutation, UpdateChannelDetailsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChannelDetailsMutation, UpdateChannelDetailsMutationVariables>(UpdateChannelDetailsDocument, options);
      }
export type UpdateChannelDetailsMutationHookResult = ReturnType<typeof useUpdateChannelDetailsMutation>;
export type UpdateChannelDetailsMutationResult = Apollo.MutationResult<UpdateChannelDetailsMutation>;
export type UpdateChannelDetailsMutationOptions = Apollo.BaseMutationOptions<UpdateChannelDetailsMutation, UpdateChannelDetailsMutationVariables>;
export const OnlineUsersDocument = gql`
    query OnlineUsers($chatId: ID!) {
  chatUsers(
    chatId: $chatId
    userLabel: USER_LABEL_VIEWER
    sortBy: "lastActivity"
    limit: 10
  ) {
    users {
      user {
        userId
        account {
          uid
          roles
        }
      }
      userId
    }
  }
}
    `;

/**
 * __useOnlineUsersQuery__
 *
 * To run a query within a React component, call `useOnlineUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useOnlineUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnlineUsersQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *   },
 * });
 */
export function useOnlineUsersQuery(baseOptions: Apollo.QueryHookOptions<OnlineUsersQuery, OnlineUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OnlineUsersQuery, OnlineUsersQueryVariables>(OnlineUsersDocument, options);
      }
export function useOnlineUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OnlineUsersQuery, OnlineUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OnlineUsersQuery, OnlineUsersQueryVariables>(OnlineUsersDocument, options);
        }
export type OnlineUsersQueryHookResult = ReturnType<typeof useOnlineUsersQuery>;
export type OnlineUsersLazyQueryHookResult = ReturnType<typeof useOnlineUsersLazyQuery>;
export type OnlineUsersQueryResult = Apollo.QueryResult<OnlineUsersQuery, OnlineUsersQueryVariables>;
export const ModeratorDialogUsersDocument = gql`
    query ModeratorDialogUsers($userTags: [String!]) {
  resolveUserTags(userTags: $userTags) {
    profiles {
      userId
      userTag
      avatars {
        avatar2D
      }
      ...ProfileImageProfile
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useModeratorDialogUsersQuery__
 *
 * To run a query within a React component, call `useModeratorDialogUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useModeratorDialogUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useModeratorDialogUsersQuery({
 *   variables: {
 *      userTags: // value for 'userTags'
 *   },
 * });
 */
export function useModeratorDialogUsersQuery(baseOptions?: Apollo.QueryHookOptions<ModeratorDialogUsersQuery, ModeratorDialogUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ModeratorDialogUsersQuery, ModeratorDialogUsersQueryVariables>(ModeratorDialogUsersDocument, options);
      }
export function useModeratorDialogUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ModeratorDialogUsersQuery, ModeratorDialogUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ModeratorDialogUsersQuery, ModeratorDialogUsersQueryVariables>(ModeratorDialogUsersDocument, options);
        }
export type ModeratorDialogUsersQueryHookResult = ReturnType<typeof useModeratorDialogUsersQuery>;
export type ModeratorDialogUsersLazyQueryHookResult = ReturnType<typeof useModeratorDialogUsersLazyQuery>;
export type ModeratorDialogUsersQueryResult = Apollo.QueryResult<ModeratorDialogUsersQuery, ModeratorDialogUsersQueryVariables>;
export const ModeratorDialogSuggestedUsersDocument = gql`
    query ModeratorDialogSuggestedUsers($userIds: [String!]) {
  profileBatch(userIds: $userIds) {
    profiles {
      userId
      userTag
      avatars {
        avatar2D
      }
      ...ProfileImageProfile
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useModeratorDialogSuggestedUsersQuery__
 *
 * To run a query within a React component, call `useModeratorDialogSuggestedUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useModeratorDialogSuggestedUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useModeratorDialogSuggestedUsersQuery({
 *   variables: {
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useModeratorDialogSuggestedUsersQuery(baseOptions?: Apollo.QueryHookOptions<ModeratorDialogSuggestedUsersQuery, ModeratorDialogSuggestedUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ModeratorDialogSuggestedUsersQuery, ModeratorDialogSuggestedUsersQueryVariables>(ModeratorDialogSuggestedUsersDocument, options);
      }
export function useModeratorDialogSuggestedUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ModeratorDialogSuggestedUsersQuery, ModeratorDialogSuggestedUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ModeratorDialogSuggestedUsersQuery, ModeratorDialogSuggestedUsersQueryVariables>(ModeratorDialogSuggestedUsersDocument, options);
        }
export type ModeratorDialogSuggestedUsersQueryHookResult = ReturnType<typeof useModeratorDialogSuggestedUsersQuery>;
export type ModeratorDialogSuggestedUsersLazyQueryHookResult = ReturnType<typeof useModeratorDialogSuggestedUsersLazyQuery>;
export type ModeratorDialogSuggestedUsersQueryResult = Apollo.QueryResult<ModeratorDialogSuggestedUsersQuery, ModeratorDialogSuggestedUsersQueryVariables>;
export const ModeratorListPrivilegedUsersDocument = gql`
    query ModeratorListPrivilegedUsers($channelId: ID!, $pageSize: Int!, $cursor: String) {
  channelPrivilegedUsers(
    channelId: $channelId
    cursor: {first: $pageSize, after: $cursor}
  ) {
    pageInfo {
      endCursor
      hasNextPage
    }
    users {
      userId
      roles
      user {
        userId
        ...ModeratorProfile
      }
    }
  }
}
    ${ModeratorProfileFragmentDoc}`;

/**
 * __useModeratorListPrivilegedUsersQuery__
 *
 * To run a query within a React component, call `useModeratorListPrivilegedUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useModeratorListPrivilegedUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useModeratorListPrivilegedUsersQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      pageSize: // value for 'pageSize'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useModeratorListPrivilegedUsersQuery(baseOptions: Apollo.QueryHookOptions<ModeratorListPrivilegedUsersQuery, ModeratorListPrivilegedUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ModeratorListPrivilegedUsersQuery, ModeratorListPrivilegedUsersQueryVariables>(ModeratorListPrivilegedUsersDocument, options);
      }
export function useModeratorListPrivilegedUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ModeratorListPrivilegedUsersQuery, ModeratorListPrivilegedUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ModeratorListPrivilegedUsersQuery, ModeratorListPrivilegedUsersQueryVariables>(ModeratorListPrivilegedUsersDocument, options);
        }
export type ModeratorListPrivilegedUsersQueryHookResult = ReturnType<typeof useModeratorListPrivilegedUsersQuery>;
export type ModeratorListPrivilegedUsersLazyQueryHookResult = ReturnType<typeof useModeratorListPrivilegedUsersLazyQuery>;
export type ModeratorListPrivilegedUsersQueryResult = Apollo.QueryResult<ModeratorListPrivilegedUsersQuery, ModeratorListPrivilegedUsersQueryVariables>;
export const SetUserRolesDocument = gql`
    mutation SetUserRoles($channelId: ID!, $userId: ID!, $roles: [ChannelChannelRole!]) {
  setUserChannelRoles(channelId: $channelId, userId: $userId, roles: $roles) {
    emptyTypeWorkaround
  }
}
    `;
export type SetUserRolesMutationFn = Apollo.MutationFunction<SetUserRolesMutation, SetUserRolesMutationVariables>;

/**
 * __useSetUserRolesMutation__
 *
 * To run a mutation, you first call `useSetUserRolesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetUserRolesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setUserRolesMutation, { data, loading, error }] = useSetUserRolesMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *      roles: // value for 'roles'
 *   },
 * });
 */
export function useSetUserRolesMutation(baseOptions?: Apollo.MutationHookOptions<SetUserRolesMutation, SetUserRolesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetUserRolesMutation, SetUserRolesMutationVariables>(SetUserRolesDocument, options);
      }
export type SetUserRolesMutationHookResult = ReturnType<typeof useSetUserRolesMutation>;
export type SetUserRolesMutationResult = Apollo.MutationResult<SetUserRolesMutation>;
export type SetUserRolesMutationOptions = Apollo.BaseMutationOptions<SetUserRolesMutation, SetUserRolesMutationVariables>;
export const ModeratorSettingsDataDocument = gql`
    query ModeratorSettingsData($channelId: ID!) {
  channelModerationSettings(channelId: $channelId) {
    channelId
    banAppealsEnabled
  }
}
    `;

/**
 * __useModeratorSettingsDataQuery__
 *
 * To run a query within a React component, call `useModeratorSettingsDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useModeratorSettingsDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useModeratorSettingsDataQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useModeratorSettingsDataQuery(baseOptions: Apollo.QueryHookOptions<ModeratorSettingsDataQuery, ModeratorSettingsDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ModeratorSettingsDataQuery, ModeratorSettingsDataQueryVariables>(ModeratorSettingsDataDocument, options);
      }
export function useModeratorSettingsDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ModeratorSettingsDataQuery, ModeratorSettingsDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ModeratorSettingsDataQuery, ModeratorSettingsDataQueryVariables>(ModeratorSettingsDataDocument, options);
        }
export type ModeratorSettingsDataQueryHookResult = ReturnType<typeof useModeratorSettingsDataQuery>;
export type ModeratorSettingsDataLazyQueryHookResult = ReturnType<typeof useModeratorSettingsDataLazyQuery>;
export type ModeratorSettingsDataQueryResult = Apollo.QueryResult<ModeratorSettingsDataQuery, ModeratorSettingsDataQueryVariables>;
export const UpdateChannelModerationBanAppealSettingDocument = gql`
    mutation UpdateChannelModerationBanAppealSetting($channelId: ID!, $banAppealsEnabled: Boolean) {
  updateChannelModerationSettings(
    body: {channelId: $channelId, banAppealsEnabled: $banAppealsEnabled}
  ) {
    banAppealsEnabled
  }
}
    `;
export type UpdateChannelModerationBanAppealSettingMutationFn = Apollo.MutationFunction<UpdateChannelModerationBanAppealSettingMutation, UpdateChannelModerationBanAppealSettingMutationVariables>;

/**
 * __useUpdateChannelModerationBanAppealSettingMutation__
 *
 * To run a mutation, you first call `useUpdateChannelModerationBanAppealSettingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChannelModerationBanAppealSettingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChannelModerationBanAppealSettingMutation, { data, loading, error }] = useUpdateChannelModerationBanAppealSettingMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      banAppealsEnabled: // value for 'banAppealsEnabled'
 *   },
 * });
 */
export function useUpdateChannelModerationBanAppealSettingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChannelModerationBanAppealSettingMutation, UpdateChannelModerationBanAppealSettingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChannelModerationBanAppealSettingMutation, UpdateChannelModerationBanAppealSettingMutationVariables>(UpdateChannelModerationBanAppealSettingDocument, options);
      }
export type UpdateChannelModerationBanAppealSettingMutationHookResult = ReturnType<typeof useUpdateChannelModerationBanAppealSettingMutation>;
export type UpdateChannelModerationBanAppealSettingMutationResult = Apollo.MutationResult<UpdateChannelModerationBanAppealSettingMutation>;
export type UpdateChannelModerationBanAppealSettingMutationOptions = Apollo.BaseMutationOptions<UpdateChannelModerationBanAppealSettingMutation, UpdateChannelModerationBanAppealSettingMutationVariables>;
export const ChannelSimulcastingConfigDocument = gql`
    query ChannelSimulcastingConfig($channelId: ID!) {
  restreamingConfig(channelId: $channelId) {
    ...SimulcastingDestinationConfig
  }
}
    ${SimulcastingDestinationConfigFragmentDoc}`;

/**
 * __useChannelSimulcastingConfigQuery__
 *
 * To run a query within a React component, call `useChannelSimulcastingConfigQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelSimulcastingConfigQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelSimulcastingConfigQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelSimulcastingConfigQuery(baseOptions: Apollo.QueryHookOptions<ChannelSimulcastingConfigQuery, ChannelSimulcastingConfigQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelSimulcastingConfigQuery, ChannelSimulcastingConfigQueryVariables>(ChannelSimulcastingConfigDocument, options);
      }
export function useChannelSimulcastingConfigLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelSimulcastingConfigQuery, ChannelSimulcastingConfigQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelSimulcastingConfigQuery, ChannelSimulcastingConfigQueryVariables>(ChannelSimulcastingConfigDocument, options);
        }
export type ChannelSimulcastingConfigQueryHookResult = ReturnType<typeof useChannelSimulcastingConfigQuery>;
export type ChannelSimulcastingConfigLazyQueryHookResult = ReturnType<typeof useChannelSimulcastingConfigLazyQuery>;
export type ChannelSimulcastingConfigQueryResult = Apollo.QueryResult<ChannelSimulcastingConfigQuery, ChannelSimulcastingConfigQueryVariables>;
export const UpdateChannelSimulcastingConfigDocument = gql`
    mutation UpdateChannelSimulcastingConfig($channelId: ID!, $rtmpEndpoint: String, $rtmpKey: String, $bitrate: Int, $enabled: Boolean) {
  updateRestreamingConfig(
    body: {channelId: $channelId, rtmpEndpoint: $rtmpEndpoint, rtmpKey: $rtmpKey, bitrate: $bitrate, enabled: $enabled}
  ) {
    ...SimulcastingDestinationConfig
  }
}
    ${SimulcastingDestinationConfigFragmentDoc}`;
export type UpdateChannelSimulcastingConfigMutationFn = Apollo.MutationFunction<UpdateChannelSimulcastingConfigMutation, UpdateChannelSimulcastingConfigMutationVariables>;

/**
 * __useUpdateChannelSimulcastingConfigMutation__
 *
 * To run a mutation, you first call `useUpdateChannelSimulcastingConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChannelSimulcastingConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChannelSimulcastingConfigMutation, { data, loading, error }] = useUpdateChannelSimulcastingConfigMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      rtmpEndpoint: // value for 'rtmpEndpoint'
 *      rtmpKey: // value for 'rtmpKey'
 *      bitrate: // value for 'bitrate'
 *      enabled: // value for 'enabled'
 *   },
 * });
 */
export function useUpdateChannelSimulcastingConfigMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChannelSimulcastingConfigMutation, UpdateChannelSimulcastingConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChannelSimulcastingConfigMutation, UpdateChannelSimulcastingConfigMutationVariables>(UpdateChannelSimulcastingConfigDocument, options);
      }
export type UpdateChannelSimulcastingConfigMutationHookResult = ReturnType<typeof useUpdateChannelSimulcastingConfigMutation>;
export type UpdateChannelSimulcastingConfigMutationResult = Apollo.MutationResult<UpdateChannelSimulcastingConfigMutation>;
export type UpdateChannelSimulcastingConfigMutationOptions = Apollo.BaseMutationOptions<UpdateChannelSimulcastingConfigMutation, UpdateChannelSimulcastingConfigMutationVariables>;
export const ChannelRestreamingConfigDocument = gql`
    query ChannelRestreamingConfig($channelId: ID!) {
  restreamingConfig(channelId: $channelId) {
    ...RestreamingConfigFragment
  }
}
    ${RestreamingConfigFragmentFragmentDoc}`;

/**
 * __useChannelRestreamingConfigQuery__
 *
 * To run a query within a React component, call `useChannelRestreamingConfigQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelRestreamingConfigQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelRestreamingConfigQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelRestreamingConfigQuery(baseOptions: Apollo.QueryHookOptions<ChannelRestreamingConfigQuery, ChannelRestreamingConfigQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelRestreamingConfigQuery, ChannelRestreamingConfigQueryVariables>(ChannelRestreamingConfigDocument, options);
      }
export function useChannelRestreamingConfigLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelRestreamingConfigQuery, ChannelRestreamingConfigQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelRestreamingConfigQuery, ChannelRestreamingConfigQueryVariables>(ChannelRestreamingConfigDocument, options);
        }
export type ChannelRestreamingConfigQueryHookResult = ReturnType<typeof useChannelRestreamingConfigQuery>;
export type ChannelRestreamingConfigLazyQueryHookResult = ReturnType<typeof useChannelRestreamingConfigLazyQuery>;
export type ChannelRestreamingConfigQueryResult = Apollo.QueryResult<ChannelRestreamingConfigQuery, ChannelRestreamingConfigQueryVariables>;
export const UpdateChannelRestreamingConfigDocument = gql`
    mutation UpdateChannelRestreamingConfig($channelId: ID!, $rtmpEndpoint: String, $rtmpKey: String, $bitrate: Int, $enabled: Boolean) {
  updateRestreamingConfig(
    body: {channelId: $channelId, rtmpEndpoint: $rtmpEndpoint, rtmpKey: $rtmpKey, bitrate: $bitrate, enabled: $enabled}
  ) {
    ...RestreamingConfigFragment
  }
}
    ${RestreamingConfigFragmentFragmentDoc}`;
export type UpdateChannelRestreamingConfigMutationFn = Apollo.MutationFunction<UpdateChannelRestreamingConfigMutation, UpdateChannelRestreamingConfigMutationVariables>;

/**
 * __useUpdateChannelRestreamingConfigMutation__
 *
 * To run a mutation, you first call `useUpdateChannelRestreamingConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChannelRestreamingConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChannelRestreamingConfigMutation, { data, loading, error }] = useUpdateChannelRestreamingConfigMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      rtmpEndpoint: // value for 'rtmpEndpoint'
 *      rtmpKey: // value for 'rtmpKey'
 *      bitrate: // value for 'bitrate'
 *      enabled: // value for 'enabled'
 *   },
 * });
 */
export function useUpdateChannelRestreamingConfigMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChannelRestreamingConfigMutation, UpdateChannelRestreamingConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChannelRestreamingConfigMutation, UpdateChannelRestreamingConfigMutationVariables>(UpdateChannelRestreamingConfigDocument, options);
      }
export type UpdateChannelRestreamingConfigMutationHookResult = ReturnType<typeof useUpdateChannelRestreamingConfigMutation>;
export type UpdateChannelRestreamingConfigMutationResult = Apollo.MutationResult<UpdateChannelRestreamingConfigMutation>;
export type UpdateChannelRestreamingConfigMutationOptions = Apollo.BaseMutationOptions<UpdateChannelRestreamingConfigMutation, UpdateChannelRestreamingConfigMutationVariables>;
export const StudioChannelVisibilityChannelDocument = gql`
    query StudioChannelVisibilityChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    isPublic
  }
}
    `;

/**
 * __useStudioChannelVisibilityChannelQuery__
 *
 * To run a query within a React component, call `useStudioChannelVisibilityChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useStudioChannelVisibilityChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStudioChannelVisibilityChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useStudioChannelVisibilityChannelQuery(baseOptions: Apollo.QueryHookOptions<StudioChannelVisibilityChannelQuery, StudioChannelVisibilityChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StudioChannelVisibilityChannelQuery, StudioChannelVisibilityChannelQueryVariables>(StudioChannelVisibilityChannelDocument, options);
      }
export function useStudioChannelVisibilityChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StudioChannelVisibilityChannelQuery, StudioChannelVisibilityChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StudioChannelVisibilityChannelQuery, StudioChannelVisibilityChannelQueryVariables>(StudioChannelVisibilityChannelDocument, options);
        }
export type StudioChannelVisibilityChannelQueryHookResult = ReturnType<typeof useStudioChannelVisibilityChannelQuery>;
export type StudioChannelVisibilityChannelLazyQueryHookResult = ReturnType<typeof useStudioChannelVisibilityChannelLazyQuery>;
export type StudioChannelVisibilityChannelQueryResult = Apollo.QueryResult<StudioChannelVisibilityChannelQuery, StudioChannelVisibilityChannelQueryVariables>;
export const StudioUpdateChannelVisibilityDocument = gql`
    mutation StudioUpdateChannelVisibility($channelId: ID!, $isPublic: Boolean) {
  updateChannelDetails(body: {id: $channelId, isPublic: $isPublic}) {
    id
    isPublic
  }
}
    `;
export type StudioUpdateChannelVisibilityMutationFn = Apollo.MutationFunction<StudioUpdateChannelVisibilityMutation, StudioUpdateChannelVisibilityMutationVariables>;

/**
 * __useStudioUpdateChannelVisibilityMutation__
 *
 * To run a mutation, you first call `useStudioUpdateChannelVisibilityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStudioUpdateChannelVisibilityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [studioUpdateChannelVisibilityMutation, { data, loading, error }] = useStudioUpdateChannelVisibilityMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      isPublic: // value for 'isPublic'
 *   },
 * });
 */
export function useStudioUpdateChannelVisibilityMutation(baseOptions?: Apollo.MutationHookOptions<StudioUpdateChannelVisibilityMutation, StudioUpdateChannelVisibilityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<StudioUpdateChannelVisibilityMutation, StudioUpdateChannelVisibilityMutationVariables>(StudioUpdateChannelVisibilityDocument, options);
      }
export type StudioUpdateChannelVisibilityMutationHookResult = ReturnType<typeof useStudioUpdateChannelVisibilityMutation>;
export type StudioUpdateChannelVisibilityMutationResult = Apollo.MutationResult<StudioUpdateChannelVisibilityMutation>;
export type StudioUpdateChannelVisibilityMutationOptions = Apollo.BaseMutationOptions<StudioUpdateChannelVisibilityMutation, StudioUpdateChannelVisibilityMutationVariables>;
export const WidgetWrapperUserDocument = gql`
    query WidgetWrapperUser($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ExternalPopoutProfile
  }
}
    ${ExternalPopoutProfileFragmentDoc}`;

/**
 * __useWidgetWrapperUserQuery__
 *
 * To run a query within a React component, call `useWidgetWrapperUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useWidgetWrapperUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useWidgetWrapperUserQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useWidgetWrapperUserQuery(baseOptions: Apollo.QueryHookOptions<WidgetWrapperUserQuery, WidgetWrapperUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<WidgetWrapperUserQuery, WidgetWrapperUserQueryVariables>(WidgetWrapperUserDocument, options);
      }
export function useWidgetWrapperUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<WidgetWrapperUserQuery, WidgetWrapperUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<WidgetWrapperUserQuery, WidgetWrapperUserQueryVariables>(WidgetWrapperUserDocument, options);
        }
export type WidgetWrapperUserQueryHookResult = ReturnType<typeof useWidgetWrapperUserQuery>;
export type WidgetWrapperUserLazyQueryHookResult = ReturnType<typeof useWidgetWrapperUserLazyQuery>;
export type WidgetWrapperUserQueryResult = Apollo.QueryResult<WidgetWrapperUserQuery, WidgetWrapperUserQueryVariables>;
export const StudioSuspendedDocument = gql`
    query StudioSuspended($userId: ID) {
  platformBan(userId: $userId) {
    banId
    expiresAt
    violation
    description
  }
  profile(userId: $userId) {
    userId
    userTag
    ...ProfileImageProfile
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useStudioSuspendedQuery__
 *
 * To run a query within a React component, call `useStudioSuspendedQuery` and pass it any options that fit your needs.
 * When your component renders, `useStudioSuspendedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStudioSuspendedQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useStudioSuspendedQuery(baseOptions?: Apollo.QueryHookOptions<StudioSuspendedQuery, StudioSuspendedQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StudioSuspendedQuery, StudioSuspendedQueryVariables>(StudioSuspendedDocument, options);
      }
export function useStudioSuspendedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StudioSuspendedQuery, StudioSuspendedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StudioSuspendedQuery, StudioSuspendedQueryVariables>(StudioSuspendedDocument, options);
        }
export type StudioSuspendedQueryHookResult = ReturnType<typeof useStudioSuspendedQuery>;
export type StudioSuspendedLazyQueryHookResult = ReturnType<typeof useStudioSuspendedLazyQuery>;
export type StudioSuspendedQueryResult = Apollo.QueryResult<StudioSuspendedQuery, StudioSuspendedQueryVariables>;
export const GetMatchEndDailyBoostDocument = gql`
    query GetMatchEndDailyBoost {
  dailyXPBoostLimit {
    remainingDailyXpBoost
  }
}
    `;

/**
 * __useGetMatchEndDailyBoostQuery__
 *
 * To run a query within a React component, call `useGetMatchEndDailyBoostQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMatchEndDailyBoostQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMatchEndDailyBoostQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetMatchEndDailyBoostQuery(baseOptions?: Apollo.QueryHookOptions<GetMatchEndDailyBoostQuery, GetMatchEndDailyBoostQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMatchEndDailyBoostQuery, GetMatchEndDailyBoostQueryVariables>(GetMatchEndDailyBoostDocument, options);
      }
export function useGetMatchEndDailyBoostLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMatchEndDailyBoostQuery, GetMatchEndDailyBoostQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMatchEndDailyBoostQuery, GetMatchEndDailyBoostQueryVariables>(GetMatchEndDailyBoostDocument, options);
        }
export type GetMatchEndDailyBoostQueryHookResult = ReturnType<typeof useGetMatchEndDailyBoostQuery>;
export type GetMatchEndDailyBoostLazyQueryHookResult = ReturnType<typeof useGetMatchEndDailyBoostLazyQuery>;
export type GetMatchEndDailyBoostQueryResult = Apollo.QueryResult<GetMatchEndDailyBoostQuery, GetMatchEndDailyBoostQueryVariables>;
export const GetMatchEndLevelThresholdsDocument = gql`
    query GetMatchEndLevelThresholds($seasonId: ID!, $startLevel: Int!, $endLevel: Int!) {
  listLevelConfigs(
    seasonId: $seasonId
    minLevel: $startLevel
    maxLevel: $endLevel
  ) {
    levelConfigs {
      ...MatchEndLevelThresholds
    }
  }
}
    ${MatchEndLevelThresholdsFragmentDoc}`;

/**
 * __useGetMatchEndLevelThresholdsQuery__
 *
 * To run a query within a React component, call `useGetMatchEndLevelThresholdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMatchEndLevelThresholdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMatchEndLevelThresholdsQuery({
 *   variables: {
 *      seasonId: // value for 'seasonId'
 *      startLevel: // value for 'startLevel'
 *      endLevel: // value for 'endLevel'
 *   },
 * });
 */
export function useGetMatchEndLevelThresholdsQuery(baseOptions: Apollo.QueryHookOptions<GetMatchEndLevelThresholdsQuery, GetMatchEndLevelThresholdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMatchEndLevelThresholdsQuery, GetMatchEndLevelThresholdsQueryVariables>(GetMatchEndLevelThresholdsDocument, options);
      }
export function useGetMatchEndLevelThresholdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMatchEndLevelThresholdsQuery, GetMatchEndLevelThresholdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMatchEndLevelThresholdsQuery, GetMatchEndLevelThresholdsQueryVariables>(GetMatchEndLevelThresholdsDocument, options);
        }
export type GetMatchEndLevelThresholdsQueryHookResult = ReturnType<typeof useGetMatchEndLevelThresholdsQuery>;
export type GetMatchEndLevelThresholdsLazyQueryHookResult = ReturnType<typeof useGetMatchEndLevelThresholdsLazyQuery>;
export type GetMatchEndLevelThresholdsQueryResult = Apollo.QueryResult<GetMatchEndLevelThresholdsQuery, GetMatchEndLevelThresholdsQueryVariables>;
export const GetMatchEndPlayerLevelDocument = gql`
    query GetMatchEndPlayerLevel($userId: ID!, $seasonId: ID!) {
  seasonProgression(userId: $userId, seasonId: $seasonId) {
    ...MatchEndPlayerLevel
  }
}
    ${MatchEndPlayerLevelFragmentDoc}`;

/**
 * __useGetMatchEndPlayerLevelQuery__
 *
 * To run a query within a React component, call `useGetMatchEndPlayerLevelQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMatchEndPlayerLevelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMatchEndPlayerLevelQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useGetMatchEndPlayerLevelQuery(baseOptions: Apollo.QueryHookOptions<GetMatchEndPlayerLevelQuery, GetMatchEndPlayerLevelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMatchEndPlayerLevelQuery, GetMatchEndPlayerLevelQueryVariables>(GetMatchEndPlayerLevelDocument, options);
      }
export function useGetMatchEndPlayerLevelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMatchEndPlayerLevelQuery, GetMatchEndPlayerLevelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMatchEndPlayerLevelQuery, GetMatchEndPlayerLevelQueryVariables>(GetMatchEndPlayerLevelDocument, options);
        }
export type GetMatchEndPlayerLevelQueryHookResult = ReturnType<typeof useGetMatchEndPlayerLevelQuery>;
export type GetMatchEndPlayerLevelLazyQueryHookResult = ReturnType<typeof useGetMatchEndPlayerLevelLazyQuery>;
export type GetMatchEndPlayerLevelQueryResult = Apollo.QueryResult<GetMatchEndPlayerLevelQuery, GetMatchEndPlayerLevelQueryVariables>;
export const MatchResultsDialogBestPlayGameCardsDocument = gql`
    query MatchResultsDialogBestPlayGameCards($cardIds: [String!]) {
  gameCards(cardIds: $cardIds) {
    cards {
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useMatchResultsDialogBestPlayGameCardsQuery__
 *
 * To run a query within a React component, call `useMatchResultsDialogBestPlayGameCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchResultsDialogBestPlayGameCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchResultsDialogBestPlayGameCardsQuery({
 *   variables: {
 *      cardIds: // value for 'cardIds'
 *   },
 * });
 */
export function useMatchResultsDialogBestPlayGameCardsQuery(baseOptions?: Apollo.QueryHookOptions<MatchResultsDialogBestPlayGameCardsQuery, MatchResultsDialogBestPlayGameCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchResultsDialogBestPlayGameCardsQuery, MatchResultsDialogBestPlayGameCardsQueryVariables>(MatchResultsDialogBestPlayGameCardsDocument, options);
      }
export function useMatchResultsDialogBestPlayGameCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchResultsDialogBestPlayGameCardsQuery, MatchResultsDialogBestPlayGameCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchResultsDialogBestPlayGameCardsQuery, MatchResultsDialogBestPlayGameCardsQueryVariables>(MatchResultsDialogBestPlayGameCardsDocument, options);
        }
export type MatchResultsDialogBestPlayGameCardsQueryHookResult = ReturnType<typeof useMatchResultsDialogBestPlayGameCardsQuery>;
export type MatchResultsDialogBestPlayGameCardsLazyQueryHookResult = ReturnType<typeof useMatchResultsDialogBestPlayGameCardsLazyQuery>;
export type MatchResultsDialogBestPlayGameCardsQueryResult = Apollo.QueryResult<MatchResultsDialogBestPlayGameCardsQuery, MatchResultsDialogBestPlayGameCardsQueryVariables>;
export const MatchResultsDialogBestPlayProfilesDocument = gql`
    query MatchResultsDialogBestPlayProfiles($userIds: [String!]) {
  profileBatch(userIds: $userIds) {
    profiles {
      userId
      ...ProfileImageProfile
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useMatchResultsDialogBestPlayProfilesQuery__
 *
 * To run a query within a React component, call `useMatchResultsDialogBestPlayProfilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchResultsDialogBestPlayProfilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchResultsDialogBestPlayProfilesQuery({
 *   variables: {
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useMatchResultsDialogBestPlayProfilesQuery(baseOptions?: Apollo.QueryHookOptions<MatchResultsDialogBestPlayProfilesQuery, MatchResultsDialogBestPlayProfilesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchResultsDialogBestPlayProfilesQuery, MatchResultsDialogBestPlayProfilesQueryVariables>(MatchResultsDialogBestPlayProfilesDocument, options);
      }
export function useMatchResultsDialogBestPlayProfilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchResultsDialogBestPlayProfilesQuery, MatchResultsDialogBestPlayProfilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchResultsDialogBestPlayProfilesQuery, MatchResultsDialogBestPlayProfilesQueryVariables>(MatchResultsDialogBestPlayProfilesDocument, options);
        }
export type MatchResultsDialogBestPlayProfilesQueryHookResult = ReturnType<typeof useMatchResultsDialogBestPlayProfilesQuery>;
export type MatchResultsDialogBestPlayProfilesLazyQueryHookResult = ReturnType<typeof useMatchResultsDialogBestPlayProfilesLazyQuery>;
export type MatchResultsDialogBestPlayProfilesQueryResult = Apollo.QueryResult<MatchResultsDialogBestPlayProfilesQuery, MatchResultsDialogBestPlayProfilesQueryVariables>;
export const MatchResultsDialogPlayerScoresProfileDocument = gql`
    query MatchResultsDialogPlayerScoresProfile($userIds: [String!]) {
  profileBatch(userIds: $userIds) {
    profiles {
      userId
      ...ProfileImageProfile
      avatars {
        avatarFullbody
      }
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useMatchResultsDialogPlayerScoresProfileQuery__
 *
 * To run a query within a React component, call `useMatchResultsDialogPlayerScoresProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchResultsDialogPlayerScoresProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchResultsDialogPlayerScoresProfileQuery({
 *   variables: {
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useMatchResultsDialogPlayerScoresProfileQuery(baseOptions?: Apollo.QueryHookOptions<MatchResultsDialogPlayerScoresProfileQuery, MatchResultsDialogPlayerScoresProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchResultsDialogPlayerScoresProfileQuery, MatchResultsDialogPlayerScoresProfileQueryVariables>(MatchResultsDialogPlayerScoresProfileDocument, options);
      }
export function useMatchResultsDialogPlayerScoresProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchResultsDialogPlayerScoresProfileQuery, MatchResultsDialogPlayerScoresProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchResultsDialogPlayerScoresProfileQuery, MatchResultsDialogPlayerScoresProfileQueryVariables>(MatchResultsDialogPlayerScoresProfileDocument, options);
        }
export type MatchResultsDialogPlayerScoresProfileQueryHookResult = ReturnType<typeof useMatchResultsDialogPlayerScoresProfileQuery>;
export type MatchResultsDialogPlayerScoresProfileLazyQueryHookResult = ReturnType<typeof useMatchResultsDialogPlayerScoresProfileLazyQuery>;
export type MatchResultsDialogPlayerScoresProfileQueryResult = Apollo.QueryResult<MatchResultsDialogPlayerScoresProfileQuery, MatchResultsDialogPlayerScoresProfileQueryVariables>;
export const MatchResultsDialogRewardsGameDocument = gql`
    query MatchResultsDialogRewardsGame($gameId: ID, $userId: ID) {
  game(id: $gameId) {
    id
    name
    activeSeason {
      id
      name
      progression(user_id: $userId) {
        level
      }
    }
  }
}
    `;

/**
 * __useMatchResultsDialogRewardsGameQuery__
 *
 * To run a query within a React component, call `useMatchResultsDialogRewardsGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchResultsDialogRewardsGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchResultsDialogRewardsGameQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useMatchResultsDialogRewardsGameQuery(baseOptions?: Apollo.QueryHookOptions<MatchResultsDialogRewardsGameQuery, MatchResultsDialogRewardsGameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchResultsDialogRewardsGameQuery, MatchResultsDialogRewardsGameQueryVariables>(MatchResultsDialogRewardsGameDocument, options);
      }
export function useMatchResultsDialogRewardsGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchResultsDialogRewardsGameQuery, MatchResultsDialogRewardsGameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchResultsDialogRewardsGameQuery, MatchResultsDialogRewardsGameQueryVariables>(MatchResultsDialogRewardsGameDocument, options);
        }
export type MatchResultsDialogRewardsGameQueryHookResult = ReturnType<typeof useMatchResultsDialogRewardsGameQuery>;
export type MatchResultsDialogRewardsGameLazyQueryHookResult = ReturnType<typeof useMatchResultsDialogRewardsGameLazyQuery>;
export type MatchResultsDialogRewardsGameQueryResult = Apollo.QueryResult<MatchResultsDialogRewardsGameQuery, MatchResultsDialogRewardsGameQueryVariables>;
export const MatchResultsSummaryPlayerScoresProfileDocument = gql`
    query MatchResultsSummaryPlayerScoresProfile($userIds: [String!]) {
  profileBatch(userIds: $userIds) {
    profiles {
      userId
      ...MatchResultsSummaryPlayerScoreProfile
    }
  }
}
    ${MatchResultsSummaryPlayerScoreProfileFragmentDoc}`;

/**
 * __useMatchResultsSummaryPlayerScoresProfileQuery__
 *
 * To run a query within a React component, call `useMatchResultsSummaryPlayerScoresProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchResultsSummaryPlayerScoresProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchResultsSummaryPlayerScoresProfileQuery({
 *   variables: {
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useMatchResultsSummaryPlayerScoresProfileQuery(baseOptions?: Apollo.QueryHookOptions<MatchResultsSummaryPlayerScoresProfileQuery, MatchResultsSummaryPlayerScoresProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchResultsSummaryPlayerScoresProfileQuery, MatchResultsSummaryPlayerScoresProfileQueryVariables>(MatchResultsSummaryPlayerScoresProfileDocument, options);
      }
export function useMatchResultsSummaryPlayerScoresProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchResultsSummaryPlayerScoresProfileQuery, MatchResultsSummaryPlayerScoresProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchResultsSummaryPlayerScoresProfileQuery, MatchResultsSummaryPlayerScoresProfileQueryVariables>(MatchResultsSummaryPlayerScoresProfileDocument, options);
        }
export type MatchResultsSummaryPlayerScoresProfileQueryHookResult = ReturnType<typeof useMatchResultsSummaryPlayerScoresProfileQuery>;
export type MatchResultsSummaryPlayerScoresProfileLazyQueryHookResult = ReturnType<typeof useMatchResultsSummaryPlayerScoresProfileLazyQuery>;
export type MatchResultsSummaryPlayerScoresProfileQueryResult = Apollo.QueryResult<MatchResultsSummaryPlayerScoresProfileQuery, MatchResultsSummaryPlayerScoresProfileQueryVariables>;
export const MatchGroupWaitingLgPlayersDocument = gql`
    query MatchGroupWaitingLgPlayers($playerIds: [String!]!) {
  profileBatch(userIds: $playerIds) {
    profiles {
      userId
      ...CardRowAvatarProfile
    }
  }
}
    ${CardRowAvatarProfileFragmentDoc}`;

/**
 * __useMatchGroupWaitingLgPlayersQuery__
 *
 * To run a query within a React component, call `useMatchGroupWaitingLgPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchGroupWaitingLgPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchGroupWaitingLgPlayersQuery({
 *   variables: {
 *      playerIds: // value for 'playerIds'
 *   },
 * });
 */
export function useMatchGroupWaitingLgPlayersQuery(baseOptions: Apollo.QueryHookOptions<MatchGroupWaitingLgPlayersQuery, MatchGroupWaitingLgPlayersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchGroupWaitingLgPlayersQuery, MatchGroupWaitingLgPlayersQueryVariables>(MatchGroupWaitingLgPlayersDocument, options);
      }
export function useMatchGroupWaitingLgPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchGroupWaitingLgPlayersQuery, MatchGroupWaitingLgPlayersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchGroupWaitingLgPlayersQuery, MatchGroupWaitingLgPlayersQueryVariables>(MatchGroupWaitingLgPlayersDocument, options);
        }
export type MatchGroupWaitingLgPlayersQueryHookResult = ReturnType<typeof useMatchGroupWaitingLgPlayersQuery>;
export type MatchGroupWaitingLgPlayersLazyQueryHookResult = ReturnType<typeof useMatchGroupWaitingLgPlayersLazyQuery>;
export type MatchGroupWaitingLgPlayersQueryResult = Apollo.QueryResult<MatchGroupWaitingLgPlayersQuery, MatchGroupWaitingLgPlayersQueryVariables>;
export const BestPlaysDataDocument = gql`
    query BestPlaysData($cardIds: [String!]!, $userIds: [String!]!) {
  gameCards(cardIds: $cardIds) {
    cards {
      ...GameCard
    }
  }
  profileBatch(userIds: $userIds) {
    profiles {
      ...BestPlayProfile
    }
  }
}
    ${GameCardFragmentDoc}
${BestPlayProfileFragmentDoc}`;

/**
 * __useBestPlaysDataQuery__
 *
 * To run a query within a React component, call `useBestPlaysDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useBestPlaysDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBestPlaysDataQuery({
 *   variables: {
 *      cardIds: // value for 'cardIds'
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useBestPlaysDataQuery(baseOptions: Apollo.QueryHookOptions<BestPlaysDataQuery, BestPlaysDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BestPlaysDataQuery, BestPlaysDataQueryVariables>(BestPlaysDataDocument, options);
      }
export function useBestPlaysDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BestPlaysDataQuery, BestPlaysDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BestPlaysDataQuery, BestPlaysDataQueryVariables>(BestPlaysDataDocument, options);
        }
export type BestPlaysDataQueryHookResult = ReturnType<typeof useBestPlaysDataQuery>;
export type BestPlaysDataLazyQueryHookResult = ReturnType<typeof useBestPlaysDataLazyQuery>;
export type BestPlaysDataQueryResult = Apollo.QueryResult<BestPlaysDataQuery, BestPlaysDataQueryVariables>;
export const DisplayBottomLgPlayerDocument = gql`
    query DisplayBottomLgPlayer($playerId: ID!) {
  profile(userId: $playerId) {
    userId
    ...CardRowAvatarProfile
    ...PlayerScoreProfile
  }
}
    ${CardRowAvatarProfileFragmentDoc}
${PlayerScoreProfileFragmentDoc}`;

/**
 * __useDisplayBottomLgPlayerQuery__
 *
 * To run a query within a React component, call `useDisplayBottomLgPlayerQuery` and pass it any options that fit your needs.
 * When your component renders, `useDisplayBottomLgPlayerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDisplayBottomLgPlayerQuery({
 *   variables: {
 *      playerId: // value for 'playerId'
 *   },
 * });
 */
export function useDisplayBottomLgPlayerQuery(baseOptions: Apollo.QueryHookOptions<DisplayBottomLgPlayerQuery, DisplayBottomLgPlayerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DisplayBottomLgPlayerQuery, DisplayBottomLgPlayerQueryVariables>(DisplayBottomLgPlayerDocument, options);
      }
export function useDisplayBottomLgPlayerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DisplayBottomLgPlayerQuery, DisplayBottomLgPlayerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DisplayBottomLgPlayerQuery, DisplayBottomLgPlayerQueryVariables>(DisplayBottomLgPlayerDocument, options);
        }
export type DisplayBottomLgPlayerQueryHookResult = ReturnType<typeof useDisplayBottomLgPlayerQuery>;
export type DisplayBottomLgPlayerLazyQueryHookResult = ReturnType<typeof useDisplayBottomLgPlayerLazyQuery>;
export type DisplayBottomLgPlayerQueryResult = Apollo.QueryResult<DisplayBottomLgPlayerQuery, DisplayBottomLgPlayerQueryVariables>;
export const AllOrNothingDialogCardDocument = gql`
    query AllOrNothingDialogCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useAllOrNothingDialogCardQuery__
 *
 * To run a query within a React component, call `useAllOrNothingDialogCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllOrNothingDialogCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllOrNothingDialogCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useAllOrNothingDialogCardQuery(baseOptions: Apollo.QueryHookOptions<AllOrNothingDialogCardQuery, AllOrNothingDialogCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllOrNothingDialogCardQuery, AllOrNothingDialogCardQueryVariables>(AllOrNothingDialogCardDocument, options);
      }
export function useAllOrNothingDialogCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllOrNothingDialogCardQuery, AllOrNothingDialogCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllOrNothingDialogCardQuery, AllOrNothingDialogCardQueryVariables>(AllOrNothingDialogCardDocument, options);
        }
export type AllOrNothingDialogCardQueryHookResult = ReturnType<typeof useAllOrNothingDialogCardQuery>;
export type AllOrNothingDialogCardLazyQueryHookResult = ReturnType<typeof useAllOrNothingDialogCardLazyQuery>;
export type AllOrNothingDialogCardQueryResult = Apollo.QueryResult<AllOrNothingDialogCardQuery, AllOrNothingDialogCardQueryVariables>;
export const CardSelectCardsDocument = gql`
    query CardSelectCards($cardIds: [String!]!) {
  gameCards(cardIds: $cardIds) {
    cards {
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useCardSelectCardsQuery__
 *
 * To run a query within a React component, call `useCardSelectCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardSelectCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardSelectCardsQuery({
 *   variables: {
 *      cardIds: // value for 'cardIds'
 *   },
 * });
 */
export function useCardSelectCardsQuery(baseOptions: Apollo.QueryHookOptions<CardSelectCardsQuery, CardSelectCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardSelectCardsQuery, CardSelectCardsQueryVariables>(CardSelectCardsDocument, options);
      }
export function useCardSelectCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardSelectCardsQuery, CardSelectCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardSelectCardsQuery, CardSelectCardsQueryVariables>(CardSelectCardsDocument, options);
        }
export type CardSelectCardsQueryHookResult = ReturnType<typeof useCardSelectCardsQuery>;
export type CardSelectCardsLazyQueryHookResult = ReturnType<typeof useCardSelectCardsLazyQuery>;
export type CardSelectCardsQueryResult = Apollo.QueryResult<CardSelectCardsQuery, CardSelectCardsQueryVariables>;
export const CardSelectMatchCardsDocument = gql`
    query CardSelectMatchCards($cardIds: [String!]!) {
  gameCards(cardIds: $cardIds) {
    cards {
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useCardSelectMatchCardsQuery__
 *
 * To run a query within a React component, call `useCardSelectMatchCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardSelectMatchCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardSelectMatchCardsQuery({
 *   variables: {
 *      cardIds: // value for 'cardIds'
 *   },
 * });
 */
export function useCardSelectMatchCardsQuery(baseOptions: Apollo.QueryHookOptions<CardSelectMatchCardsQuery, CardSelectMatchCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardSelectMatchCardsQuery, CardSelectMatchCardsQueryVariables>(CardSelectMatchCardsDocument, options);
      }
export function useCardSelectMatchCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardSelectMatchCardsQuery, CardSelectMatchCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardSelectMatchCardsQuery, CardSelectMatchCardsQueryVariables>(CardSelectMatchCardsDocument, options);
        }
export type CardSelectMatchCardsQueryHookResult = ReturnType<typeof useCardSelectMatchCardsQuery>;
export type CardSelectMatchCardsLazyQueryHookResult = ReturnType<typeof useCardSelectMatchCardsLazyQuery>;
export type CardSelectMatchCardsQueryResult = Apollo.QueryResult<CardSelectMatchCardsQuery, CardSelectMatchCardsQueryVariables>;
export const HighScoringCardDataDocument = gql`
    query HighScoringCardData($cardId: String!, $playerId: ID!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      ...GameCard
    }
  }
  profile(userId: $playerId) {
    ...HighScoringCardPlayer
  }
}
    ${GameCardFragmentDoc}
${HighScoringCardPlayerFragmentDoc}`;

/**
 * __useHighScoringCardDataQuery__
 *
 * To run a query within a React component, call `useHighScoringCardDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useHighScoringCardDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHighScoringCardDataQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *      playerId: // value for 'playerId'
 *   },
 * });
 */
export function useHighScoringCardDataQuery(baseOptions: Apollo.QueryHookOptions<HighScoringCardDataQuery, HighScoringCardDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HighScoringCardDataQuery, HighScoringCardDataQueryVariables>(HighScoringCardDataDocument, options);
      }
export function useHighScoringCardDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HighScoringCardDataQuery, HighScoringCardDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HighScoringCardDataQuery, HighScoringCardDataQueryVariables>(HighScoringCardDataDocument, options);
        }
export type HighScoringCardDataQueryHookResult = ReturnType<typeof useHighScoringCardDataQuery>;
export type HighScoringCardDataLazyQueryHookResult = ReturnType<typeof useHighScoringCardDataLazyQuery>;
export type HighScoringCardDataQueryResult = Apollo.QueryResult<HighScoringCardDataQuery, HighScoringCardDataQueryVariables>;
export const SpectatorPlayerDisplayProfileDocument = gql`
    query SpectatorPlayerDisplayProfile($id: ID!) {
  profile(userId: $id) {
    ...SpectatorDisplayBottomProfile
  }
}
    ${SpectatorDisplayBottomProfileFragmentDoc}`;

/**
 * __useSpectatorPlayerDisplayProfileQuery__
 *
 * To run a query within a React component, call `useSpectatorPlayerDisplayProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useSpectatorPlayerDisplayProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSpectatorPlayerDisplayProfileQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSpectatorPlayerDisplayProfileQuery(baseOptions: Apollo.QueryHookOptions<SpectatorPlayerDisplayProfileQuery, SpectatorPlayerDisplayProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SpectatorPlayerDisplayProfileQuery, SpectatorPlayerDisplayProfileQueryVariables>(SpectatorPlayerDisplayProfileDocument, options);
      }
export function useSpectatorPlayerDisplayProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SpectatorPlayerDisplayProfileQuery, SpectatorPlayerDisplayProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SpectatorPlayerDisplayProfileQuery, SpectatorPlayerDisplayProfileQueryVariables>(SpectatorPlayerDisplayProfileDocument, options);
        }
export type SpectatorPlayerDisplayProfileQueryHookResult = ReturnType<typeof useSpectatorPlayerDisplayProfileQuery>;
export type SpectatorPlayerDisplayProfileLazyQueryHookResult = ReturnType<typeof useSpectatorPlayerDisplayProfileLazyQuery>;
export type SpectatorPlayerDisplayProfileQueryResult = Apollo.QueryResult<SpectatorPlayerDisplayProfileQuery, SpectatorPlayerDisplayProfileQueryVariables>;
export const DisplayBottomSmPlayerDocument = gql`
    query DisplayBottomSmPlayer($playerId: ID!) {
  profile(userId: $playerId) {
    userId
    ...CardRowAvatarProfile
  }
}
    ${CardRowAvatarProfileFragmentDoc}`;

/**
 * __useDisplayBottomSmPlayerQuery__
 *
 * To run a query within a React component, call `useDisplayBottomSmPlayerQuery` and pass it any options that fit your needs.
 * When your component renders, `useDisplayBottomSmPlayerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDisplayBottomSmPlayerQuery({
 *   variables: {
 *      playerId: // value for 'playerId'
 *   },
 * });
 */
export function useDisplayBottomSmPlayerQuery(baseOptions: Apollo.QueryHookOptions<DisplayBottomSmPlayerQuery, DisplayBottomSmPlayerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DisplayBottomSmPlayerQuery, DisplayBottomSmPlayerQueryVariables>(DisplayBottomSmPlayerDocument, options);
      }
export function useDisplayBottomSmPlayerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DisplayBottomSmPlayerQuery, DisplayBottomSmPlayerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DisplayBottomSmPlayerQuery, DisplayBottomSmPlayerQueryVariables>(DisplayBottomSmPlayerDocument, options);
        }
export type DisplayBottomSmPlayerQueryHookResult = ReturnType<typeof useDisplayBottomSmPlayerQuery>;
export type DisplayBottomSmPlayerLazyQueryHookResult = ReturnType<typeof useDisplayBottomSmPlayerLazyQuery>;
export type DisplayBottomSmPlayerQueryResult = Apollo.QueryResult<DisplayBottomSmPlayerQuery, DisplayBottomSmPlayerQueryVariables>;
export const PlayerScoreProfileDocument = gql`
    query PlayerScoreProfile($playerId: ID!) {
  profile(userId: $playerId) {
    userId
    userTag
  }
}
    `;

/**
 * __usePlayerScoreProfileQuery__
 *
 * To run a query within a React component, call `usePlayerScoreProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlayerScoreProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlayerScoreProfileQuery({
 *   variables: {
 *      playerId: // value for 'playerId'
 *   },
 * });
 */
export function usePlayerScoreProfileQuery(baseOptions: Apollo.QueryHookOptions<PlayerScoreProfileQuery, PlayerScoreProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlayerScoreProfileQuery, PlayerScoreProfileQueryVariables>(PlayerScoreProfileDocument, options);
      }
export function usePlayerScoreProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlayerScoreProfileQuery, PlayerScoreProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlayerScoreProfileQuery, PlayerScoreProfileQueryVariables>(PlayerScoreProfileDocument, options);
        }
export type PlayerScoreProfileQueryHookResult = ReturnType<typeof usePlayerScoreProfileQuery>;
export type PlayerScoreProfileLazyQueryHookResult = ReturnType<typeof usePlayerScoreProfileLazyQuery>;
export type PlayerScoreProfileQueryResult = Apollo.QueryResult<PlayerScoreProfileQuery, PlayerScoreProfileQueryVariables>;
export const CardSelectSmCardsDocument = gql`
    query CardSelectSmCards($cardIds: [String!]!) {
  gameCards(cardIds: $cardIds) {
    cards {
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useCardSelectSmCardsQuery__
 *
 * To run a query within a React component, call `useCardSelectSmCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardSelectSmCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardSelectSmCardsQuery({
 *   variables: {
 *      cardIds: // value for 'cardIds'
 *   },
 * });
 */
export function useCardSelectSmCardsQuery(baseOptions: Apollo.QueryHookOptions<CardSelectSmCardsQuery, CardSelectSmCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardSelectSmCardsQuery, CardSelectSmCardsQueryVariables>(CardSelectSmCardsDocument, options);
      }
export function useCardSelectSmCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardSelectSmCardsQuery, CardSelectSmCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardSelectSmCardsQuery, CardSelectSmCardsQueryVariables>(CardSelectSmCardsDocument, options);
        }
export type CardSelectSmCardsQueryHookResult = ReturnType<typeof useCardSelectSmCardsQuery>;
export type CardSelectSmCardsLazyQueryHookResult = ReturnType<typeof useCardSelectSmCardsLazyQuery>;
export type CardSelectSmCardsQueryResult = Apollo.QueryResult<CardSelectSmCardsQuery, CardSelectSmCardsQueryVariables>;
export const ProgressionPausedSeasonDocument = gql`
    query ProgressionPausedSeason($channelId: ID!) {
  channel(id: $channelId) {
    id
    game {
      id
      activeSeason {
        id
        progressionPaused
        progressionPauseReason
      }
    }
  }
}
    `;

/**
 * __useProgressionPausedSeasonQuery__
 *
 * To run a query within a React component, call `useProgressionPausedSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useProgressionPausedSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProgressionPausedSeasonQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useProgressionPausedSeasonQuery(baseOptions: Apollo.QueryHookOptions<ProgressionPausedSeasonQuery, ProgressionPausedSeasonQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProgressionPausedSeasonQuery, ProgressionPausedSeasonQueryVariables>(ProgressionPausedSeasonDocument, options);
      }
export function useProgressionPausedSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProgressionPausedSeasonQuery, ProgressionPausedSeasonQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProgressionPausedSeasonQuery, ProgressionPausedSeasonQueryVariables>(ProgressionPausedSeasonDocument, options);
        }
export type ProgressionPausedSeasonQueryHookResult = ReturnType<typeof useProgressionPausedSeasonQuery>;
export type ProgressionPausedSeasonLazyQueryHookResult = ReturnType<typeof useProgressionPausedSeasonLazyQuery>;
export type ProgressionPausedSeasonQueryResult = Apollo.QueryResult<ProgressionPausedSeasonQuery, ProgressionPausedSeasonQueryVariables>;
export const ActiveCardSoundsDocument = gql`
    query ActiveCardSounds($id: String!) {
  gameCards(cardIds: [$id]) {
    cards {
      ...GameCardSoundData
    }
  }
}
    ${GameCardSoundDataFragmentDoc}`;

/**
 * __useActiveCardSoundsQuery__
 *
 * To run a query within a React component, call `useActiveCardSoundsQuery` and pass it any options that fit your needs.
 * When your component renders, `useActiveCardSoundsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActiveCardSoundsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useActiveCardSoundsQuery(baseOptions: Apollo.QueryHookOptions<ActiveCardSoundsQuery, ActiveCardSoundsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActiveCardSoundsQuery, ActiveCardSoundsQueryVariables>(ActiveCardSoundsDocument, options);
      }
export function useActiveCardSoundsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActiveCardSoundsQuery, ActiveCardSoundsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActiveCardSoundsQuery, ActiveCardSoundsQueryVariables>(ActiveCardSoundsDocument, options);
        }
export type ActiveCardSoundsQueryHookResult = ReturnType<typeof useActiveCardSoundsQuery>;
export type ActiveCardSoundsLazyQueryHookResult = ReturnType<typeof useActiveCardSoundsLazyQuery>;
export type ActiveCardSoundsQueryResult = Apollo.QueryResult<ActiveCardSoundsQuery, ActiveCardSoundsQueryVariables>;
export const UseSpeedUpBoosterDurationDocument = gql`
    query useSpeedUpBoosterDuration($id: Int!) {
  booster(id: $id) {
    id
    timeActive
  }
}
    `;

/**
 * __useUseSpeedUpBoosterDurationQuery__
 *
 * To run a query within a React component, call `useUseSpeedUpBoosterDurationQuery` and pass it any options that fit your needs.
 * When your component renders, `useUseSpeedUpBoosterDurationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUseSpeedUpBoosterDurationQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUseSpeedUpBoosterDurationQuery(baseOptions: Apollo.QueryHookOptions<UseSpeedUpBoosterDurationQuery, UseSpeedUpBoosterDurationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UseSpeedUpBoosterDurationQuery, UseSpeedUpBoosterDurationQueryVariables>(UseSpeedUpBoosterDurationDocument, options);
      }
export function useUseSpeedUpBoosterDurationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UseSpeedUpBoosterDurationQuery, UseSpeedUpBoosterDurationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UseSpeedUpBoosterDurationQuery, UseSpeedUpBoosterDurationQueryVariables>(UseSpeedUpBoosterDurationDocument, options);
        }
export type UseSpeedUpBoosterDurationQueryHookResult = ReturnType<typeof useUseSpeedUpBoosterDurationQuery>;
export type UseSpeedUpBoosterDurationLazyQueryHookResult = ReturnType<typeof useUseSpeedUpBoosterDurationLazyQuery>;
export type UseSpeedUpBoosterDurationQueryResult = Apollo.QueryResult<UseSpeedUpBoosterDurationQuery, UseSpeedUpBoosterDurationQueryVariables>;
export const GameCardBackgroundArtSeasonDocument = gql`
    query GameCardBackgroundArtSeason($seasonId: ID!) {
  season(id: $seasonId) {
    id
    cardBackgroundUrls {
      rarity
      url
    }
  }
}
    `;

/**
 * __useGameCardBackgroundArtSeasonQuery__
 *
 * To run a query within a React component, call `useGameCardBackgroundArtSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameCardBackgroundArtSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameCardBackgroundArtSeasonQuery({
 *   variables: {
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useGameCardBackgroundArtSeasonQuery(baseOptions: Apollo.QueryHookOptions<GameCardBackgroundArtSeasonQuery, GameCardBackgroundArtSeasonQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameCardBackgroundArtSeasonQuery, GameCardBackgroundArtSeasonQueryVariables>(GameCardBackgroundArtSeasonDocument, options);
      }
export function useGameCardBackgroundArtSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameCardBackgroundArtSeasonQuery, GameCardBackgroundArtSeasonQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameCardBackgroundArtSeasonQuery, GameCardBackgroundArtSeasonQueryVariables>(GameCardBackgroundArtSeasonDocument, options);
        }
export type GameCardBackgroundArtSeasonQueryHookResult = ReturnType<typeof useGameCardBackgroundArtSeasonQuery>;
export type GameCardBackgroundArtSeasonLazyQueryHookResult = ReturnType<typeof useGameCardBackgroundArtSeasonLazyQuery>;
export type GameCardBackgroundArtSeasonQueryResult = Apollo.QueryResult<GameCardBackgroundArtSeasonQuery, GameCardBackgroundArtSeasonQueryVariables>;
export const GameCardLevelSeasonDocument = gql`
    query GameCardLevelSeason($seasonId: ID!) {
  season(id: $seasonId) {
    id
    badgeUrl
  }
}
    `;

/**
 * __useGameCardLevelSeasonQuery__
 *
 * To run a query within a React component, call `useGameCardLevelSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameCardLevelSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameCardLevelSeasonQuery({
 *   variables: {
 *      seasonId: // value for 'seasonId'
 *   },
 * });
 */
export function useGameCardLevelSeasonQuery(baseOptions: Apollo.QueryHookOptions<GameCardLevelSeasonQuery, GameCardLevelSeasonQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameCardLevelSeasonQuery, GameCardLevelSeasonQueryVariables>(GameCardLevelSeasonDocument, options);
      }
export function useGameCardLevelSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameCardLevelSeasonQuery, GameCardLevelSeasonQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameCardLevelSeasonQuery, GameCardLevelSeasonQueryVariables>(GameCardLevelSeasonDocument, options);
        }
export type GameCardLevelSeasonQueryHookResult = ReturnType<typeof useGameCardLevelSeasonQuery>;
export type GameCardLevelSeasonLazyQueryHookResult = ReturnType<typeof useGameCardLevelSeasonLazyQuery>;
export type GameCardLevelSeasonQueryResult = Apollo.QueryResult<GameCardLevelSeasonQuery, GameCardLevelSeasonQueryVariables>;
export const LeaderboardItemPlayersDocument = gql`
    query LeaderboardItemPlayers($playerIds: [String!]!) {
  profileBatch(userIds: $playerIds) {
    profiles {
      userId
      userTag
      avatars {
        avatar2D
      }
    }
  }
}
    `;

/**
 * __useLeaderboardItemPlayersQuery__
 *
 * To run a query within a React component, call `useLeaderboardItemPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useLeaderboardItemPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLeaderboardItemPlayersQuery({
 *   variables: {
 *      playerIds: // value for 'playerIds'
 *   },
 * });
 */
export function useLeaderboardItemPlayersQuery(baseOptions: Apollo.QueryHookOptions<LeaderboardItemPlayersQuery, LeaderboardItemPlayersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LeaderboardItemPlayersQuery, LeaderboardItemPlayersQueryVariables>(LeaderboardItemPlayersDocument, options);
      }
export function useLeaderboardItemPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LeaderboardItemPlayersQuery, LeaderboardItemPlayersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LeaderboardItemPlayersQuery, LeaderboardItemPlayersQueryVariables>(LeaderboardItemPlayersDocument, options);
        }
export type LeaderboardItemPlayersQueryHookResult = ReturnType<typeof useLeaderboardItemPlayersQuery>;
export type LeaderboardItemPlayersLazyQueryHookResult = ReturnType<typeof useLeaderboardItemPlayersLazyQuery>;
export type LeaderboardItemPlayersQueryResult = Apollo.QueryResult<LeaderboardItemPlayersQuery, LeaderboardItemPlayersQueryVariables>;
export const AllOrNothingPendingCardDocument = gql`
    query AllOrNothingPendingCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useAllOrNothingPendingCardQuery__
 *
 * To run a query within a React component, call `useAllOrNothingPendingCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllOrNothingPendingCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllOrNothingPendingCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useAllOrNothingPendingCardQuery(baseOptions: Apollo.QueryHookOptions<AllOrNothingPendingCardQuery, AllOrNothingPendingCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllOrNothingPendingCardQuery, AllOrNothingPendingCardQueryVariables>(AllOrNothingPendingCardDocument, options);
      }
export function useAllOrNothingPendingCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllOrNothingPendingCardQuery, AllOrNothingPendingCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllOrNothingPendingCardQuery, AllOrNothingPendingCardQueryVariables>(AllOrNothingPendingCardDocument, options);
        }
export type AllOrNothingPendingCardQueryHookResult = ReturnType<typeof useAllOrNothingPendingCardQuery>;
export type AllOrNothingPendingCardLazyQueryHookResult = ReturnType<typeof useAllOrNothingPendingCardLazyQuery>;
export type AllOrNothingPendingCardQueryResult = Apollo.QueryResult<AllOrNothingPendingCardQuery, AllOrNothingPendingCardQueryVariables>;
export const CardWithHighlightStateCardDocument = gql`
    query CardWithHighlightStateCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __useCardWithHighlightStateCardQuery__
 *
 * To run a query within a React component, call `useCardWithHighlightStateCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardWithHighlightStateCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardWithHighlightStateCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function useCardWithHighlightStateCardQuery(baseOptions: Apollo.QueryHookOptions<CardWithHighlightStateCardQuery, CardWithHighlightStateCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardWithHighlightStateCardQuery, CardWithHighlightStateCardQueryVariables>(CardWithHighlightStateCardDocument, options);
      }
export function useCardWithHighlightStateCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardWithHighlightStateCardQuery, CardWithHighlightStateCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardWithHighlightStateCardQuery, CardWithHighlightStateCardQueryVariables>(CardWithHighlightStateCardDocument, options);
        }
export type CardWithHighlightStateCardQueryHookResult = ReturnType<typeof useCardWithHighlightStateCardQuery>;
export type CardWithHighlightStateCardLazyQueryHookResult = ReturnType<typeof useCardWithHighlightStateCardLazyQuery>;
export type CardWithHighlightStateCardQueryResult = Apollo.QueryResult<CardWithHighlightStateCardQuery, CardWithHighlightStateCardQueryVariables>;
export const SwitchOutCardDetailsDocument = gql`
    query SwitchOutCardDetails($activeCardId: String!) {
  gameCards(cardIds: [$activeCardId]) {
    cards {
      id
      isAllOrNothing
    }
  }
}
    `;

/**
 * __useSwitchOutCardDetailsQuery__
 *
 * To run a query within a React component, call `useSwitchOutCardDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSwitchOutCardDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSwitchOutCardDetailsQuery({
 *   variables: {
 *      activeCardId: // value for 'activeCardId'
 *   },
 * });
 */
export function useSwitchOutCardDetailsQuery(baseOptions: Apollo.QueryHookOptions<SwitchOutCardDetailsQuery, SwitchOutCardDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SwitchOutCardDetailsQuery, SwitchOutCardDetailsQueryVariables>(SwitchOutCardDetailsDocument, options);
      }
export function useSwitchOutCardDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SwitchOutCardDetailsQuery, SwitchOutCardDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SwitchOutCardDetailsQuery, SwitchOutCardDetailsQueryVariables>(SwitchOutCardDetailsDocument, options);
        }
export type SwitchOutCardDetailsQueryHookResult = ReturnType<typeof useSwitchOutCardDetailsQuery>;
export type SwitchOutCardDetailsLazyQueryHookResult = ReturnType<typeof useSwitchOutCardDetailsLazyQuery>;
export type SwitchOutCardDetailsQueryResult = Apollo.QueryResult<SwitchOutCardDetailsQuery, SwitchOutCardDetailsQueryVariables>;
export const ChallengesContentChallengesDocument = gql`
    query ChallengesContentChallenges($challengeIds: [String!]!) {
  challengesBatch(challengeIds: $challengeIds) {
    challenges {
      ...ChallengesContentChallenge
    }
  }
}
    ${ChallengesContentChallengeFragmentDoc}`;

/**
 * __useChallengesContentChallengesQuery__
 *
 * To run a query within a React component, call `useChallengesContentChallengesQuery` and pass it any options that fit your needs.
 * When your component renders, `useChallengesContentChallengesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChallengesContentChallengesQuery({
 *   variables: {
 *      challengeIds: // value for 'challengeIds'
 *   },
 * });
 */
export function useChallengesContentChallengesQuery(baseOptions: Apollo.QueryHookOptions<ChallengesContentChallengesQuery, ChallengesContentChallengesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChallengesContentChallengesQuery, ChallengesContentChallengesQueryVariables>(ChallengesContentChallengesDocument, options);
      }
export function useChallengesContentChallengesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChallengesContentChallengesQuery, ChallengesContentChallengesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChallengesContentChallengesQuery, ChallengesContentChallengesQueryVariables>(ChallengesContentChallengesDocument, options);
        }
export type ChallengesContentChallengesQueryHookResult = ReturnType<typeof useChallengesContentChallengesQuery>;
export type ChallengesContentChallengesLazyQueryHookResult = ReturnType<typeof useChallengesContentChallengesLazyQuery>;
export type ChallengesContentChallengesQueryResult = Apollo.QueryResult<ChallengesContentChallengesQuery, ChallengesContentChallengesQueryVariables>;
export const PickRateRewardsDocument = gql`
    query PickRateRewards($gameId: ID!) {
  challengeRewards(gameId: $gameId) {
    rewards {
      minPickRate
      maxPickRate
      reward {
        reward {
          ... on RewardRewardTypeCurrency {
            currencyId
            currencyAmount
          }
        }
      }
      gameId
    }
  }
}
    `;

/**
 * __usePickRateRewardsQuery__
 *
 * To run a query within a React component, call `usePickRateRewardsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePickRateRewardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePickRateRewardsQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function usePickRateRewardsQuery(baseOptions: Apollo.QueryHookOptions<PickRateRewardsQuery, PickRateRewardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PickRateRewardsQuery, PickRateRewardsQueryVariables>(PickRateRewardsDocument, options);
      }
export function usePickRateRewardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PickRateRewardsQuery, PickRateRewardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PickRateRewardsQuery, PickRateRewardsQueryVariables>(PickRateRewardsDocument, options);
        }
export type PickRateRewardsQueryHookResult = ReturnType<typeof usePickRateRewardsQuery>;
export type PickRateRewardsLazyQueryHookResult = ReturnType<typeof usePickRateRewardsLazyQuery>;
export type PickRateRewardsQueryResult = Apollo.QueryResult<PickRateRewardsQuery, PickRateRewardsQueryVariables>;
export const ActiveBoostersDataDocument = gql`
    query ActiveBoostersData($boosterId: Int!) {
  booster(id: $boosterId) {
    id
    ...ActiveBooster
  }
}
    ${ActiveBoosterFragmentDoc}`;

/**
 * __useActiveBoostersDataQuery__
 *
 * To run a query within a React component, call `useActiveBoostersDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useActiveBoostersDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActiveBoostersDataQuery({
 *   variables: {
 *      boosterId: // value for 'boosterId'
 *   },
 * });
 */
export function useActiveBoostersDataQuery(baseOptions: Apollo.QueryHookOptions<ActiveBoostersDataQuery, ActiveBoostersDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActiveBoostersDataQuery, ActiveBoostersDataQueryVariables>(ActiveBoostersDataDocument, options);
      }
export function useActiveBoostersDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActiveBoostersDataQuery, ActiveBoostersDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActiveBoostersDataQuery, ActiveBoostersDataQueryVariables>(ActiveBoostersDataDocument, options);
        }
export type ActiveBoostersDataQueryHookResult = ReturnType<typeof useActiveBoostersDataQuery>;
export type ActiveBoostersDataLazyQueryHookResult = ReturnType<typeof useActiveBoostersDataLazyQuery>;
export type ActiveBoostersDataQueryResult = Apollo.QueryResult<ActiveBoostersDataQuery, ActiveBoostersDataQueryVariables>;
export const ActiveBoostersProfileDataDocument = gql`
    query ActiveBoostersProfileData($userId: ID!) {
  profile(userId: $userId) {
    ...ActiveBoosterProfile
  }
}
    ${ActiveBoosterProfileFragmentDoc}`;

/**
 * __useActiveBoostersProfileDataQuery__
 *
 * To run a query within a React component, call `useActiveBoostersProfileDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useActiveBoostersProfileDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActiveBoostersProfileDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useActiveBoostersProfileDataQuery(baseOptions: Apollo.QueryHookOptions<ActiveBoostersProfileDataQuery, ActiveBoostersProfileDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActiveBoostersProfileDataQuery, ActiveBoostersProfileDataQueryVariables>(ActiveBoostersProfileDataDocument, options);
      }
export function useActiveBoostersProfileDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActiveBoostersProfileDataQuery, ActiveBoostersProfileDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActiveBoostersProfileDataQuery, ActiveBoostersProfileDataQueryVariables>(ActiveBoostersProfileDataDocument, options);
        }
export type ActiveBoostersProfileDataQueryHookResult = ReturnType<typeof useActiveBoostersProfileDataQuery>;
export type ActiveBoostersProfileDataLazyQueryHookResult = ReturnType<typeof useActiveBoostersProfileDataLazyQuery>;
export type ActiveBoostersProfileDataQueryResult = Apollo.QueryResult<ActiveBoostersProfileDataQuery, ActiveBoostersProfileDataQueryVariables>;
export const ReplacementBoosterDataDocument = gql`
    query ReplacementBoosterData($id: Int!) {
  booster(id: $id) {
    id
    ...ActiveBooster
  }
}
    ${ActiveBoosterFragmentDoc}`;

/**
 * __useReplacementBoosterDataQuery__
 *
 * To run a query within a React component, call `useReplacementBoosterDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useReplacementBoosterDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReplacementBoosterDataQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useReplacementBoosterDataQuery(baseOptions: Apollo.QueryHookOptions<ReplacementBoosterDataQuery, ReplacementBoosterDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReplacementBoosterDataQuery, ReplacementBoosterDataQueryVariables>(ReplacementBoosterDataDocument, options);
      }
export function useReplacementBoosterDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReplacementBoosterDataQuery, ReplacementBoosterDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReplacementBoosterDataQuery, ReplacementBoosterDataQueryVariables>(ReplacementBoosterDataDocument, options);
        }
export type ReplacementBoosterDataQueryHookResult = ReturnType<typeof useReplacementBoosterDataQuery>;
export type ReplacementBoosterDataLazyQueryHookResult = ReturnType<typeof useReplacementBoosterDataLazyQuery>;
export type ReplacementBoosterDataQueryResult = Apollo.QueryResult<ReplacementBoosterDataQuery, ReplacementBoosterDataQueryVariables>;
export const LocalPlayerBoosterDialogContentDocument = gql`
    query LocalPlayerBoosterDialogContent($boosterId: Int!) {
  booster(id: $boosterId) {
    id
    name
    descriptionCondition
    descriptionDefaultBenefit
    descriptionTargetNoneBenefit
  }
}
    `;

/**
 * __useLocalPlayerBoosterDialogContentQuery__
 *
 * To run a query within a React component, call `useLocalPlayerBoosterDialogContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useLocalPlayerBoosterDialogContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLocalPlayerBoosterDialogContentQuery({
 *   variables: {
 *      boosterId: // value for 'boosterId'
 *   },
 * });
 */
export function useLocalPlayerBoosterDialogContentQuery(baseOptions: Apollo.QueryHookOptions<LocalPlayerBoosterDialogContentQuery, LocalPlayerBoosterDialogContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LocalPlayerBoosterDialogContentQuery, LocalPlayerBoosterDialogContentQueryVariables>(LocalPlayerBoosterDialogContentDocument, options);
      }
export function useLocalPlayerBoosterDialogContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LocalPlayerBoosterDialogContentQuery, LocalPlayerBoosterDialogContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LocalPlayerBoosterDialogContentQuery, LocalPlayerBoosterDialogContentQueryVariables>(LocalPlayerBoosterDialogContentDocument, options);
        }
export type LocalPlayerBoosterDialogContentQueryHookResult = ReturnType<typeof useLocalPlayerBoosterDialogContentQuery>;
export type LocalPlayerBoosterDialogContentLazyQueryHookResult = ReturnType<typeof useLocalPlayerBoosterDialogContentLazyQuery>;
export type LocalPlayerBoosterDialogContentQueryResult = Apollo.QueryResult<LocalPlayerBoosterDialogContentQuery, LocalPlayerBoosterDialogContentQueryVariables>;
export const LocalPlayerBoosterTooltipContentDocument = gql`
    query LocalPlayerBoosterTooltipContent($boosterId: Int!) {
  booster(id: $boosterId) {
    id
    name
    descriptionCondition
    descriptionDefaultBenefit
    descriptionTargetNoneBenefit
  }
}
    `;

/**
 * __useLocalPlayerBoosterTooltipContentQuery__
 *
 * To run a query within a React component, call `useLocalPlayerBoosterTooltipContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useLocalPlayerBoosterTooltipContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLocalPlayerBoosterTooltipContentQuery({
 *   variables: {
 *      boosterId: // value for 'boosterId'
 *   },
 * });
 */
export function useLocalPlayerBoosterTooltipContentQuery(baseOptions: Apollo.QueryHookOptions<LocalPlayerBoosterTooltipContentQuery, LocalPlayerBoosterTooltipContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LocalPlayerBoosterTooltipContentQuery, LocalPlayerBoosterTooltipContentQueryVariables>(LocalPlayerBoosterTooltipContentDocument, options);
      }
export function useLocalPlayerBoosterTooltipContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LocalPlayerBoosterTooltipContentQuery, LocalPlayerBoosterTooltipContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LocalPlayerBoosterTooltipContentQuery, LocalPlayerBoosterTooltipContentQueryVariables>(LocalPlayerBoosterTooltipContentDocument, options);
        }
export type LocalPlayerBoosterTooltipContentQueryHookResult = ReturnType<typeof useLocalPlayerBoosterTooltipContentQuery>;
export type LocalPlayerBoosterTooltipContentLazyQueryHookResult = ReturnType<typeof useLocalPlayerBoosterTooltipContentLazyQuery>;
export type LocalPlayerBoosterTooltipContentQueryResult = Apollo.QueryResult<LocalPlayerBoosterTooltipContentQuery, LocalPlayerBoosterTooltipContentQueryVariables>;
export const BoosterRequestPreviewProfileDocument = gql`
    query BoosterRequestPreviewProfile($id: ID!) {
  profile(userId: $id) {
    userId
    avatars {
      avatar2D
    }
  }
}
    `;

/**
 * __useBoosterRequestPreviewProfileQuery__
 *
 * To run a query within a React component, call `useBoosterRequestPreviewProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useBoosterRequestPreviewProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBoosterRequestPreviewProfileQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBoosterRequestPreviewProfileQuery(baseOptions: Apollo.QueryHookOptions<BoosterRequestPreviewProfileQuery, BoosterRequestPreviewProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BoosterRequestPreviewProfileQuery, BoosterRequestPreviewProfileQueryVariables>(BoosterRequestPreviewProfileDocument, options);
      }
export function useBoosterRequestPreviewProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BoosterRequestPreviewProfileQuery, BoosterRequestPreviewProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BoosterRequestPreviewProfileQuery, BoosterRequestPreviewProfileQueryVariables>(BoosterRequestPreviewProfileDocument, options);
        }
export type BoosterRequestPreviewProfileQueryHookResult = ReturnType<typeof useBoosterRequestPreviewProfileQuery>;
export type BoosterRequestPreviewProfileLazyQueryHookResult = ReturnType<typeof useBoosterRequestPreviewProfileLazyQuery>;
export type BoosterRequestPreviewProfileQueryResult = Apollo.QueryResult<BoosterRequestPreviewProfileQuery, BoosterRequestPreviewProfileQueryVariables>;
export const PlayerActiveCardDocument = gql`
    query PlayerActiveCard($cardId: String!) {
  gameCards(cardIds: [$cardId]) {
    cards {
      id
      name
      ...GameCard
    }
  }
}
    ${GameCardFragmentDoc}`;

/**
 * __usePlayerActiveCardQuery__
 *
 * To run a query within a React component, call `usePlayerActiveCardQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlayerActiveCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlayerActiveCardQuery({
 *   variables: {
 *      cardId: // value for 'cardId'
 *   },
 * });
 */
export function usePlayerActiveCardQuery(baseOptions: Apollo.QueryHookOptions<PlayerActiveCardQuery, PlayerActiveCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlayerActiveCardQuery, PlayerActiveCardQueryVariables>(PlayerActiveCardDocument, options);
      }
export function usePlayerActiveCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlayerActiveCardQuery, PlayerActiveCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlayerActiveCardQuery, PlayerActiveCardQueryVariables>(PlayerActiveCardDocument, options);
        }
export type PlayerActiveCardQueryHookResult = ReturnType<typeof usePlayerActiveCardQuery>;
export type PlayerActiveCardLazyQueryHookResult = ReturnType<typeof usePlayerActiveCardLazyQuery>;
export type PlayerActiveCardQueryResult = Apollo.QueryResult<PlayerActiveCardQuery, PlayerActiveCardQueryVariables>;
export const TeamMateBoosterDialogContentDocument = gql`
    query TeamMateBoosterDialogContent($boosterId: Int!) {
  booster(id: $boosterId) {
    id
    ...TeamMateBoosterDialogContentBooster
  }
}
    ${TeamMateBoosterDialogContentBoosterFragmentDoc}`;

/**
 * __useTeamMateBoosterDialogContentQuery__
 *
 * To run a query within a React component, call `useTeamMateBoosterDialogContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useTeamMateBoosterDialogContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTeamMateBoosterDialogContentQuery({
 *   variables: {
 *      boosterId: // value for 'boosterId'
 *   },
 * });
 */
export function useTeamMateBoosterDialogContentQuery(baseOptions: Apollo.QueryHookOptions<TeamMateBoosterDialogContentQuery, TeamMateBoosterDialogContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TeamMateBoosterDialogContentQuery, TeamMateBoosterDialogContentQueryVariables>(TeamMateBoosterDialogContentDocument, options);
      }
export function useTeamMateBoosterDialogContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TeamMateBoosterDialogContentQuery, TeamMateBoosterDialogContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TeamMateBoosterDialogContentQuery, TeamMateBoosterDialogContentQueryVariables>(TeamMateBoosterDialogContentDocument, options);
        }
export type TeamMateBoosterDialogContentQueryHookResult = ReturnType<typeof useTeamMateBoosterDialogContentQuery>;
export type TeamMateBoosterDialogContentLazyQueryHookResult = ReturnType<typeof useTeamMateBoosterDialogContentLazyQuery>;
export type TeamMateBoosterDialogContentQueryResult = Apollo.QueryResult<TeamMateBoosterDialogContentQuery, TeamMateBoosterDialogContentQueryVariables>;
export const TeamMateBoosterTooltipContentDocument = gql`
    query TeamMateBoosterTooltipContent($boosterId: Int!, $userId: ID!) {
  booster(id: $boosterId) {
    id
    ...TeamMateBoosterTooltipContentBooster
  }
  profile(userId: $userId) {
    userId
    userTag
  }
}
    ${TeamMateBoosterTooltipContentBoosterFragmentDoc}`;

/**
 * __useTeamMateBoosterTooltipContentQuery__
 *
 * To run a query within a React component, call `useTeamMateBoosterTooltipContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useTeamMateBoosterTooltipContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTeamMateBoosterTooltipContentQuery({
 *   variables: {
 *      boosterId: // value for 'boosterId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useTeamMateBoosterTooltipContentQuery(baseOptions: Apollo.QueryHookOptions<TeamMateBoosterTooltipContentQuery, TeamMateBoosterTooltipContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TeamMateBoosterTooltipContentQuery, TeamMateBoosterTooltipContentQueryVariables>(TeamMateBoosterTooltipContentDocument, options);
      }
export function useTeamMateBoosterTooltipContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TeamMateBoosterTooltipContentQuery, TeamMateBoosterTooltipContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TeamMateBoosterTooltipContentQuery, TeamMateBoosterTooltipContentQueryVariables>(TeamMateBoosterTooltipContentDocument, options);
        }
export type TeamMateBoosterTooltipContentQueryHookResult = ReturnType<typeof useTeamMateBoosterTooltipContentQuery>;
export type TeamMateBoosterTooltipContentLazyQueryHookResult = ReturnType<typeof useTeamMateBoosterTooltipContentLazyQuery>;
export type TeamMateBoosterTooltipContentQueryResult = Apollo.QueryResult<TeamMateBoosterTooltipContentQuery, TeamMateBoosterTooltipContentQueryVariables>;
export const CgChallengesSystemChallengesDocument = gql`
    query CGChallengesSystemChallenges($challengeIds: [String!]!) {
  challengesBatch(challengeIds: $challengeIds) {
    challenges {
      ...CGChallengesSystemChallenge
    }
  }
}
    ${CgChallengesSystemChallengeFragmentDoc}`;

/**
 * __useCgChallengesSystemChallengesQuery__
 *
 * To run a query within a React component, call `useCgChallengesSystemChallengesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCgChallengesSystemChallengesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCgChallengesSystemChallengesQuery({
 *   variables: {
 *      challengeIds: // value for 'challengeIds'
 *   },
 * });
 */
export function useCgChallengesSystemChallengesQuery(baseOptions: Apollo.QueryHookOptions<CgChallengesSystemChallengesQuery, CgChallengesSystemChallengesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CgChallengesSystemChallengesQuery, CgChallengesSystemChallengesQueryVariables>(CgChallengesSystemChallengesDocument, options);
      }
export function useCgChallengesSystemChallengesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CgChallengesSystemChallengesQuery, CgChallengesSystemChallengesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CgChallengesSystemChallengesQuery, CgChallengesSystemChallengesQueryVariables>(CgChallengesSystemChallengesDocument, options);
        }
export type CgChallengesSystemChallengesQueryHookResult = ReturnType<typeof useCgChallengesSystemChallengesQuery>;
export type CgChallengesSystemChallengesLazyQueryHookResult = ReturnType<typeof useCgChallengesSystemChallengesLazyQuery>;
export type CgChallengesSystemChallengesQueryResult = Apollo.QueryResult<CgChallengesSystemChallengesQuery, CgChallengesSystemChallengesQueryVariables>;
export const GameStateGameCardDocument = gql`
    query GameStateGameCard($ids: [String!]!) {
  gameCards(cardIds: $ids) {
    cards {
      ...GameStateCard
    }
  }
}
    ${GameStateCardFragmentDoc}`;

/**
 * __useGameStateGameCardQuery__
 *
 * To run a query within a React component, call `useGameStateGameCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameStateGameCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameStateGameCardQuery({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useGameStateGameCardQuery(baseOptions: Apollo.QueryHookOptions<GameStateGameCardQuery, GameStateGameCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameStateGameCardQuery, GameStateGameCardQueryVariables>(GameStateGameCardDocument, options);
      }
export function useGameStateGameCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameStateGameCardQuery, GameStateGameCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameStateGameCardQuery, GameStateGameCardQueryVariables>(GameStateGameCardDocument, options);
        }
export type GameStateGameCardQueryHookResult = ReturnType<typeof useGameStateGameCardQuery>;
export type GameStateGameCardLazyQueryHookResult = ReturnType<typeof useGameStateGameCardLazyQuery>;
export type GameStateGameCardQueryResult = Apollo.QueryResult<GameStateGameCardQuery, GameStateGameCardQueryVariables>;
export const GameStateBoostersDocument = gql`
    query GameStateBoosters($id: Int!) {
  booster(id: $id) {
    id
    ...CgAvailableBooster
    ...CgActiveBooster
  }
}
    ${CgAvailableBoosterFragmentDoc}
${CgActiveBoosterFragmentDoc}`;

/**
 * __useGameStateBoostersQuery__
 *
 * To run a query within a React component, call `useGameStateBoostersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameStateBoostersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameStateBoostersQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGameStateBoostersQuery(baseOptions: Apollo.QueryHookOptions<GameStateBoostersQuery, GameStateBoostersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameStateBoostersQuery, GameStateBoostersQueryVariables>(GameStateBoostersDocument, options);
      }
export function useGameStateBoostersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameStateBoostersQuery, GameStateBoostersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameStateBoostersQuery, GameStateBoostersQueryVariables>(GameStateBoostersDocument, options);
        }
export type GameStateBoostersQueryHookResult = ReturnType<typeof useGameStateBoostersQuery>;
export type GameStateBoostersLazyQueryHookResult = ReturnType<typeof useGameStateBoostersLazyQuery>;
export type GameStateBoostersQueryResult = Apollo.QueryResult<GameStateBoostersQuery, GameStateBoostersQueryVariables>;
export const StreamGameChannelDocument = gql`
    query StreamGameChannel($id: ID!) {
  stream(id: $id) {
    streamId
    channelId
  }
}
    `;

/**
 * __useStreamGameChannelQuery__
 *
 * To run a query within a React component, call `useStreamGameChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useStreamGameChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamGameChannelQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStreamGameChannelQuery(baseOptions: Apollo.QueryHookOptions<StreamGameChannelQuery, StreamGameChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StreamGameChannelQuery, StreamGameChannelQueryVariables>(StreamGameChannelDocument, options);
      }
export function useStreamGameChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StreamGameChannelQuery, StreamGameChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StreamGameChannelQuery, StreamGameChannelQueryVariables>(StreamGameChannelDocument, options);
        }
export type StreamGameChannelQueryHookResult = ReturnType<typeof useStreamGameChannelQuery>;
export type StreamGameChannelLazyQueryHookResult = ReturnType<typeof useStreamGameChannelLazyQuery>;
export type StreamGameChannelQueryResult = Apollo.QueryResult<StreamGameChannelQuery, StreamGameChannelQueryVariables>;
export const ChatChannelEventsSubscriptionDocument = gql`
    subscription ChatChannelEventsSubscription($channelId: ID!) {
  channelEventsSubscribe(channelId: $channelId) {
    channelId
    createdAt
    id
    content {
      content {
        ... on ChannelAvatarItemPurchase {
          itemId
          item {
            ...ChannelEventAvatarItemPurchaseItem
          }
          user {
            userId
            ...ChannelEventContentProfile
          }
        }
        ... on ChannelSubscriptionPurchase {
          userId
          tier
          user {
            userId
            ...ChannelEventContentProfile
            ...ChannelEventSubscriptionContentProfile
          }
        }
        ... on ChannelBundlePurchase {
          bundleName
          userId
          streamerCards {
            id
            channelId
            baseCard {
              id
              name
            }
          }
          user {
            userId
            ...ChannelEventContentProfile
          }
        }
        ... on ChannelStreamerCardPurchase {
          streamerCard {
            id
            channelId
            baseCard {
              id
              name
            }
          }
          userId
          user {
            userId
            ...ChannelEventContentProfile
          }
        }
        ... on ChannelGiftSubscriptionPurchase {
          userId
          user {
            userId
            ...ChannelEventContentProfile
            ...ChannelEventSubscriptionContentProfile
          }
          recipients {
            userId
            ...ChannelEventContentProfile
            ...ChannelEventSubscriptionContentProfile
          }
        }
      }
    }
  }
}
    ${ChannelEventAvatarItemPurchaseItemFragmentDoc}
${ChannelEventContentProfileFragmentDoc}
${ChannelEventSubscriptionContentProfileFragmentDoc}`;

/**
 * __useChatChannelEventsSubscriptionSubscription__
 *
 * To run a query within a React component, call `useChatChannelEventsSubscriptionSubscription` and pass it any options that fit your needs.
 * When your component renders, `useChatChannelEventsSubscriptionSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatChannelEventsSubscriptionSubscription({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChatChannelEventsSubscriptionSubscription(baseOptions: Apollo.SubscriptionHookOptions<ChatChannelEventsSubscriptionSubscription, ChatChannelEventsSubscriptionSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ChatChannelEventsSubscriptionSubscription, ChatChannelEventsSubscriptionSubscriptionVariables>(ChatChannelEventsSubscriptionDocument, options);
      }
export type ChatChannelEventsSubscriptionSubscriptionHookResult = ReturnType<typeof useChatChannelEventsSubscriptionSubscription>;
export type ChatChannelEventsSubscriptionSubscriptionResult = Apollo.SubscriptionResult<ChatChannelEventsSubscriptionSubscription>;
export const InventoryEmojisDocument = gql`
    query InventoryEmojis($userId: ID) {
  inventory(userId: $userId, filters: {itemType: TYPE_EMOJI}) {
    items {
      itemId
      item {
        id
        details {
          ...InventoryEmoji
        }
      }
    }
  }
}
    ${InventoryEmojiFragmentDoc}`;

/**
 * __useInventoryEmojisQuery__
 *
 * To run a query within a React component, call `useInventoryEmojisQuery` and pass it any options that fit your needs.
 * When your component renders, `useInventoryEmojisQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInventoryEmojisQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useInventoryEmojisQuery(baseOptions?: Apollo.QueryHookOptions<InventoryEmojisQuery, InventoryEmojisQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InventoryEmojisQuery, InventoryEmojisQueryVariables>(InventoryEmojisDocument, options);
      }
export function useInventoryEmojisLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InventoryEmojisQuery, InventoryEmojisQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InventoryEmojisQuery, InventoryEmojisQueryVariables>(InventoryEmojisDocument, options);
        }
export type InventoryEmojisQueryHookResult = ReturnType<typeof useInventoryEmojisQuery>;
export type InventoryEmojisLazyQueryHookResult = ReturnType<typeof useInventoryEmojisLazyQuery>;
export type InventoryEmojisQueryResult = Apollo.QueryResult<InventoryEmojisQuery, InventoryEmojisQueryVariables>;
export const UpdateChatSettingsProfileDocument = gql`
    mutation UpdateChatSettingsProfile($userId: ID, $preferredColor: ProfileColor!) {
  updateProfile(body: {preferredColor: $preferredColor, userId: $userId}) {
    userId
    preferredColor
  }
}
    `;
export type UpdateChatSettingsProfileMutationFn = Apollo.MutationFunction<UpdateChatSettingsProfileMutation, UpdateChatSettingsProfileMutationVariables>;

/**
 * __useUpdateChatSettingsProfileMutation__
 *
 * To run a mutation, you first call `useUpdateChatSettingsProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChatSettingsProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChatSettingsProfileMutation, { data, loading, error }] = useUpdateChatSettingsProfileMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      preferredColor: // value for 'preferredColor'
 *   },
 * });
 */
export function useUpdateChatSettingsProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChatSettingsProfileMutation, UpdateChatSettingsProfileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChatSettingsProfileMutation, UpdateChatSettingsProfileMutationVariables>(UpdateChatSettingsProfileDocument, options);
      }
export type UpdateChatSettingsProfileMutationHookResult = ReturnType<typeof useUpdateChatSettingsProfileMutation>;
export type UpdateChatSettingsProfileMutationResult = Apollo.MutationResult<UpdateChatSettingsProfileMutation>;
export type UpdateChatSettingsProfileMutationOptions = Apollo.BaseMutationOptions<UpdateChatSettingsProfileMutation, UpdateChatSettingsProfileMutationVariables>;
export const ChatSettingsProfileDocument = gql`
    query ChatSettingsProfile($channelId: ID!, $userId: ID!) {
  profile(userId: $userId) {
    avatars {
      avatar2D
    }
    badges(channel_id: $channelId) {
      level
      type
    }
    userId
    preferredColor
    userTag
  }
}
    `;

/**
 * __useChatSettingsProfileQuery__
 *
 * To run a query within a React component, call `useChatSettingsProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatSettingsProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatSettingsProfileQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChatSettingsProfileQuery(baseOptions: Apollo.QueryHookOptions<ChatSettingsProfileQuery, ChatSettingsProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatSettingsProfileQuery, ChatSettingsProfileQueryVariables>(ChatSettingsProfileDocument, options);
      }
export function useChatSettingsProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatSettingsProfileQuery, ChatSettingsProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatSettingsProfileQuery, ChatSettingsProfileQueryVariables>(ChatSettingsProfileDocument, options);
        }
export type ChatSettingsProfileQueryHookResult = ReturnType<typeof useChatSettingsProfileQuery>;
export type ChatSettingsProfileLazyQueryHookResult = ReturnType<typeof useChatSettingsProfileLazyQuery>;
export type ChatSettingsProfileQueryResult = Apollo.QueryResult<ChatSettingsProfileQuery, ChatSettingsProfileQueryVariables>;
export const AvatarMovementsDocument = gql`
    query AvatarMovements($userId: ID) {
  inventory(userId: $userId, filters: {itemType: TYPE_EMOTE}) {
    items {
      itemId
      item {
        id
        details {
          ... on AvatarAnimation {
            ...EmoteAvatarAnimation
          }
        }
      }
    }
  }
}
    ${EmoteAvatarAnimationFragmentDoc}`;

/**
 * __useAvatarMovementsQuery__
 *
 * To run a query within a React component, call `useAvatarMovementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAvatarMovementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAvatarMovementsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useAvatarMovementsQuery(baseOptions?: Apollo.QueryHookOptions<AvatarMovementsQuery, AvatarMovementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AvatarMovementsQuery, AvatarMovementsQueryVariables>(AvatarMovementsDocument, options);
      }
export function useAvatarMovementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AvatarMovementsQuery, AvatarMovementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AvatarMovementsQuery, AvatarMovementsQueryVariables>(AvatarMovementsDocument, options);
        }
export type AvatarMovementsQueryHookResult = ReturnType<typeof useAvatarMovementsQuery>;
export type AvatarMovementsLazyQueryHookResult = ReturnType<typeof useAvatarMovementsLazyQuery>;
export type AvatarMovementsQueryResult = Apollo.QueryResult<AvatarMovementsQuery, AvatarMovementsQueryVariables>;
export const HideChatMessageDocument = gql`
    mutation HideChatMessage($chatId: ID!, $messageId: ID!) {
  hideChatMessage(chatId: $chatId, messageId: $messageId) {
    emptyTypeWorkaround
  }
}
    `;
export type HideChatMessageMutationFn = Apollo.MutationFunction<HideChatMessageMutation, HideChatMessageMutationVariables>;

/**
 * __useHideChatMessageMutation__
 *
 * To run a mutation, you first call `useHideChatMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useHideChatMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [hideChatMessageMutation, { data, loading, error }] = useHideChatMessageMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      messageId: // value for 'messageId'
 *   },
 * });
 */
export function useHideChatMessageMutation(baseOptions?: Apollo.MutationHookOptions<HideChatMessageMutation, HideChatMessageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<HideChatMessageMutation, HideChatMessageMutationVariables>(HideChatMessageDocument, options);
      }
export type HideChatMessageMutationHookResult = ReturnType<typeof useHideChatMessageMutation>;
export type HideChatMessageMutationResult = Apollo.MutationResult<HideChatMessageMutation>;
export type HideChatMessageMutationOptions = Apollo.BaseMutationOptions<HideChatMessageMutation, HideChatMessageMutationVariables>;
export const ChatMeProfileDocument = gql`
    query ChatMeProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ChatMessagesProfile
  }
}
    ${ChatMessagesProfileFragmentDoc}`;

/**
 * __useChatMeProfileQuery__
 *
 * To run a query within a React component, call `useChatMeProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatMeProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatMeProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChatMeProfileQuery(baseOptions: Apollo.QueryHookOptions<ChatMeProfileQuery, ChatMeProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatMeProfileQuery, ChatMeProfileQueryVariables>(ChatMeProfileDocument, options);
      }
export function useChatMeProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatMeProfileQuery, ChatMeProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatMeProfileQuery, ChatMeProfileQueryVariables>(ChatMeProfileDocument, options);
        }
export type ChatMeProfileQueryHookResult = ReturnType<typeof useChatMeProfileQuery>;
export type ChatMeProfileLazyQueryHookResult = ReturnType<typeof useChatMeProfileLazyQuery>;
export type ChatMeProfileQueryResult = Apollo.QueryResult<ChatMeProfileQuery, ChatMeProfileQueryVariables>;
export const UserInventoryEmojisDocument = gql`
    query UserInventoryEmojis($userId: ID) {
  inventory(userId: $userId, filters: {itemType: TYPE_EMOJI}) {
    items {
      itemId
      item {
        id
        details {
          ...InventoryEmoji
        }
      }
    }
  }
}
    ${InventoryEmojiFragmentDoc}`;

/**
 * __useUserInventoryEmojisQuery__
 *
 * To run a query within a React component, call `useUserInventoryEmojisQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserInventoryEmojisQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserInventoryEmojisQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserInventoryEmojisQuery(baseOptions?: Apollo.QueryHookOptions<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>(UserInventoryEmojisDocument, options);
      }
export function useUserInventoryEmojisLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>(UserInventoryEmojisDocument, options);
        }
export type UserInventoryEmojisQueryHookResult = ReturnType<typeof useUserInventoryEmojisQuery>;
export type UserInventoryEmojisLazyQueryHookResult = ReturnType<typeof useUserInventoryEmojisLazyQuery>;
export type UserInventoryEmojisQueryResult = Apollo.QueryResult<UserInventoryEmojisQuery, UserInventoryEmojisQueryVariables>;
export const UserInventoryEmojisChannelsDocument = gql`
    query UserInventoryEmojisChannels($channelIds: [String!]) {
  getChannels(channelIds: $channelIds) {
    channels {
      id
      ...EmojiDrawerChannel
    }
  }
}
    ${EmojiDrawerChannelFragmentDoc}`;

/**
 * __useUserInventoryEmojisChannelsQuery__
 *
 * To run a query within a React component, call `useUserInventoryEmojisChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserInventoryEmojisChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserInventoryEmojisChannelsQuery({
 *   variables: {
 *      channelIds: // value for 'channelIds'
 *   },
 * });
 */
export function useUserInventoryEmojisChannelsQuery(baseOptions?: Apollo.QueryHookOptions<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>(UserInventoryEmojisChannelsDocument, options);
      }
export function useUserInventoryEmojisChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>(UserInventoryEmojisChannelsDocument, options);
        }
export type UserInventoryEmojisChannelsQueryHookResult = ReturnType<typeof useUserInventoryEmojisChannelsQuery>;
export type UserInventoryEmojisChannelsLazyQueryHookResult = ReturnType<typeof useUserInventoryEmojisChannelsLazyQuery>;
export type UserInventoryEmojisChannelsQueryResult = Apollo.QueryResult<UserInventoryEmojisChannelsQuery, UserInventoryEmojisChannelsQueryVariables>;
export const ReceivedBoosterRequestMessageProfileDocument = gql`
    query ReceivedBoosterRequestMessageProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    ...ProfileImageProfile
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useReceivedBoosterRequestMessageProfileQuery__
 *
 * To run a query within a React component, call `useReceivedBoosterRequestMessageProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useReceivedBoosterRequestMessageProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReceivedBoosterRequestMessageProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useReceivedBoosterRequestMessageProfileQuery(baseOptions: Apollo.QueryHookOptions<ReceivedBoosterRequestMessageProfileQuery, ReceivedBoosterRequestMessageProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReceivedBoosterRequestMessageProfileQuery, ReceivedBoosterRequestMessageProfileQueryVariables>(ReceivedBoosterRequestMessageProfileDocument, options);
      }
export function useReceivedBoosterRequestMessageProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReceivedBoosterRequestMessageProfileQuery, ReceivedBoosterRequestMessageProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReceivedBoosterRequestMessageProfileQuery, ReceivedBoosterRequestMessageProfileQueryVariables>(ReceivedBoosterRequestMessageProfileDocument, options);
        }
export type ReceivedBoosterRequestMessageProfileQueryHookResult = ReturnType<typeof useReceivedBoosterRequestMessageProfileQuery>;
export type ReceivedBoosterRequestMessageProfileLazyQueryHookResult = ReturnType<typeof useReceivedBoosterRequestMessageProfileLazyQuery>;
export type ReceivedBoosterRequestMessageProfileQueryResult = Apollo.QueryResult<ReceivedBoosterRequestMessageProfileQuery, ReceivedBoosterRequestMessageProfileQueryVariables>;
export const SentBoosterRequestMessageProfileDocument = gql`
    query SentBoosterRequestMessageProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
  }
}
    `;

/**
 * __useSentBoosterRequestMessageProfileQuery__
 *
 * To run a query within a React component, call `useSentBoosterRequestMessageProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useSentBoosterRequestMessageProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSentBoosterRequestMessageProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSentBoosterRequestMessageProfileQuery(baseOptions: Apollo.QueryHookOptions<SentBoosterRequestMessageProfileQuery, SentBoosterRequestMessageProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SentBoosterRequestMessageProfileQuery, SentBoosterRequestMessageProfileQueryVariables>(SentBoosterRequestMessageProfileDocument, options);
      }
export function useSentBoosterRequestMessageProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SentBoosterRequestMessageProfileQuery, SentBoosterRequestMessageProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SentBoosterRequestMessageProfileQuery, SentBoosterRequestMessageProfileQueryVariables>(SentBoosterRequestMessageProfileDocument, options);
        }
export type SentBoosterRequestMessageProfileQueryHookResult = ReturnType<typeof useSentBoosterRequestMessageProfileQuery>;
export type SentBoosterRequestMessageProfileLazyQueryHookResult = ReturnType<typeof useSentBoosterRequestMessageProfileLazyQuery>;
export type SentBoosterRequestMessageProfileQueryResult = Apollo.QueryResult<SentBoosterRequestMessageProfileQuery, SentBoosterRequestMessageProfileQueryVariables>;
export const ChatProviderDataDocument = gql`
    query ChatProviderData($userId: ID!, $chatId: ID!, $channelId: ID!) {
  chatUserStatus(chatId: $chatId, userId: $userId) {
    muted
    muteDuration
  }
  userChannelRoles(userId: $userId, channelId: $channelId) {
    roles
  }
  profile(userId: $userId) {
    userId
    ...ChatMessagesHookProfile
  }
}
    ${ChatMessagesHookProfileFragmentDoc}`;

/**
 * __useChatProviderDataQuery__
 *
 * To run a query within a React component, call `useChatProviderDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatProviderDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatProviderDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      chatId: // value for 'chatId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChatProviderDataQuery(baseOptions: Apollo.QueryHookOptions<ChatProviderDataQuery, ChatProviderDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatProviderDataQuery, ChatProviderDataQueryVariables>(ChatProviderDataDocument, options);
      }
export function useChatProviderDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatProviderDataQuery, ChatProviderDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatProviderDataQuery, ChatProviderDataQueryVariables>(ChatProviderDataDocument, options);
        }
export type ChatProviderDataQueryHookResult = ReturnType<typeof useChatProviderDataQuery>;
export type ChatProviderDataLazyQueryHookResult = ReturnType<typeof useChatProviderDataLazyQuery>;
export type ChatProviderDataQueryResult = Apollo.QueryResult<ChatProviderDataQuery, ChatProviderDataQueryVariables>;
export const OwnChatSenderInfoProfileDocument = gql`
    query OwnChatSenderInfoProfile($userId: ID!, $channelId: ID) {
  profile(userId: $userId) {
    userId
    userTag
    avatars {
      avatar2D
    }
    preferredColor
    badges(channel_id: $channelId) {
      ...UserBadge
    }
  }
}
    ${UserBadgeFragmentDoc}`;

/**
 * __useOwnChatSenderInfoProfileQuery__
 *
 * To run a query within a React component, call `useOwnChatSenderInfoProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useOwnChatSenderInfoProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOwnChatSenderInfoProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useOwnChatSenderInfoProfileQuery(baseOptions: Apollo.QueryHookOptions<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>(OwnChatSenderInfoProfileDocument, options);
      }
export function useOwnChatSenderInfoProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>(OwnChatSenderInfoProfileDocument, options);
        }
export type OwnChatSenderInfoProfileQueryHookResult = ReturnType<typeof useOwnChatSenderInfoProfileQuery>;
export type OwnChatSenderInfoProfileLazyQueryHookResult = ReturnType<typeof useOwnChatSenderInfoProfileLazyQuery>;
export type OwnChatSenderInfoProfileQueryResult = Apollo.QueryResult<OwnChatSenderInfoProfileQuery, OwnChatSenderInfoProfileQueryVariables>;
export const ReportUserDocument = gql`
    mutation ReportUser($reason: SupportReportReason!, $description: String, $context: SupportReportContextInput!) {
  createReport(reason: $reason, description: $description, context: $context) {
    createdAt
  }
}
    `;
export type ReportUserMutationFn = Apollo.MutationFunction<ReportUserMutation, ReportUserMutationVariables>;

/**
 * __useReportUserMutation__
 *
 * To run a mutation, you first call `useReportUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReportUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [reportUserMutation, { data, loading, error }] = useReportUserMutation({
 *   variables: {
 *      reason: // value for 'reason'
 *      description: // value for 'description'
 *      context: // value for 'context'
 *   },
 * });
 */
export function useReportUserMutation(baseOptions?: Apollo.MutationHookOptions<ReportUserMutation, ReportUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReportUserMutation, ReportUserMutationVariables>(ReportUserDocument, options);
      }
export type ReportUserMutationHookResult = ReturnType<typeof useReportUserMutation>;
export type ReportUserMutationResult = Apollo.MutationResult<ReportUserMutation>;
export type ReportUserMutationOptions = Apollo.BaseMutationOptions<ReportUserMutation, ReportUserMutationVariables>;
export const ReportedUserProfileDocument = gql`
    query ReportedUserProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ReportedUserProfile
    ...ReasonSelectProfile
  }
}
    ${ReportedUserProfileFragmentDoc}
${ReasonSelectProfileFragmentDoc}`;

/**
 * __useReportedUserProfileQuery__
 *
 * To run a query within a React component, call `useReportedUserProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportedUserProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportedUserProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useReportedUserProfileQuery(baseOptions: Apollo.QueryHookOptions<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>(ReportedUserProfileDocument, options);
      }
export function useReportedUserProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>(ReportedUserProfileDocument, options);
        }
export type ReportedUserProfileQueryHookResult = ReturnType<typeof useReportedUserProfileQuery>;
export type ReportedUserProfileLazyQueryHookResult = ReturnType<typeof useReportedUserProfileLazyQuery>;
export type ReportedUserProfileQueryResult = Apollo.QueryResult<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>;
export const ReportedChannelDocument = gql`
    query ReportedChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    ...ReasonSelectChannel
    ...ReportedChannel
  }
}
    ${ReasonSelectChannelFragmentDoc}
${ReportedChannelFragmentDoc}`;

/**
 * __useReportedChannelQuery__
 *
 * To run a query within a React component, call `useReportedChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportedChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportedChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useReportedChannelQuery(baseOptions: Apollo.QueryHookOptions<ReportedChannelQuery, ReportedChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportedChannelQuery, ReportedChannelQueryVariables>(ReportedChannelDocument, options);
      }
export function useReportedChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportedChannelQuery, ReportedChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportedChannelQuery, ReportedChannelQueryVariables>(ReportedChannelDocument, options);
        }
export type ReportedChannelQueryHookResult = ReturnType<typeof useReportedChannelQuery>;
export type ReportedChannelLazyQueryHookResult = ReturnType<typeof useReportedChannelLazyQuery>;
export type ReportedChannelQueryResult = Apollo.QueryResult<ReportedChannelQuery, ReportedChannelQueryVariables>;
export const ReportStreamTimestampDocument = gql`
    query ReportStreamTimestamp($streamId: ID!) {
  stream(id: $streamId) {
    streamId
    segments {
      startTime
    }
  }
}
    `;

/**
 * __useReportStreamTimestampQuery__
 *
 * To run a query within a React component, call `useReportStreamTimestampQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportStreamTimestampQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportStreamTimestampQuery({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useReportStreamTimestampQuery(baseOptions: Apollo.QueryHookOptions<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>(ReportStreamTimestampDocument, options);
      }
export function useReportStreamTimestampLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>(ReportStreamTimestampDocument, options);
        }
export type ReportStreamTimestampQueryHookResult = ReturnType<typeof useReportStreamTimestampQuery>;
export type ReportStreamTimestampLazyQueryHookResult = ReturnType<typeof useReportStreamTimestampLazyQuery>;
export type ReportStreamTimestampQueryResult = Apollo.QueryResult<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>;
export const SignupFlowChannelDocument = gql`
    query SignupFlowChannel($channelName: String!) {
  channelByName(name: $channelName) {
    id
    ...SignupFlowChannel
  }
}
    ${SignupFlowChannelFragmentDoc}`;

/**
 * __useSignupFlowChannelQuery__
 *
 * To run a query within a React component, call `useSignupFlowChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useSignupFlowChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSignupFlowChannelQuery({
 *   variables: {
 *      channelName: // value for 'channelName'
 *   },
 * });
 */
export function useSignupFlowChannelQuery(baseOptions: Apollo.QueryHookOptions<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>(SignupFlowChannelDocument, options);
      }
export function useSignupFlowChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>(SignupFlowChannelDocument, options);
        }
export type SignupFlowChannelQueryHookResult = ReturnType<typeof useSignupFlowChannelQuery>;
export type SignupFlowChannelLazyQueryHookResult = ReturnType<typeof useSignupFlowChannelLazyQuery>;
export type SignupFlowChannelQueryResult = Apollo.QueryResult<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>;
export const ChannelAssetCreateTokenDocument = gql`
    mutation ChannelAssetCreateToken($channelId: ID, $assetType: ChannelAssetType) {
  createChannelAssetUploadToken(channelId: $channelId, assetType: $assetType) {
    token
  }
}
    `;
export type ChannelAssetCreateTokenMutationFn = Apollo.MutationFunction<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>;

/**
 * __useChannelAssetCreateTokenMutation__
 *
 * To run a mutation, you first call `useChannelAssetCreateTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelAssetCreateTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelAssetCreateTokenMutation, { data, loading, error }] = useChannelAssetCreateTokenMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      assetType: // value for 'assetType'
 *   },
 * });
 */
export function useChannelAssetCreateTokenMutation(baseOptions?: Apollo.MutationHookOptions<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>(ChannelAssetCreateTokenDocument, options);
      }
export type ChannelAssetCreateTokenMutationHookResult = ReturnType<typeof useChannelAssetCreateTokenMutation>;
export type ChannelAssetCreateTokenMutationResult = Apollo.MutationResult<ChannelAssetCreateTokenMutation>;
export type ChannelAssetCreateTokenMutationOptions = Apollo.BaseMutationOptions<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>;
export const EmojiAssetCreateTokenDocument = gql`
    mutation EmojiAssetCreateToken($itemId: ID!) {
  createEmojiUploadToken(itemId: $itemId) {
    token
  }
}
    `;
export type EmojiAssetCreateTokenMutationFn = Apollo.MutationFunction<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>;

/**
 * __useEmojiAssetCreateTokenMutation__
 *
 * To run a mutation, you first call `useEmojiAssetCreateTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEmojiAssetCreateTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [emojiAssetCreateTokenMutation, { data, loading, error }] = useEmojiAssetCreateTokenMutation({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useEmojiAssetCreateTokenMutation(baseOptions?: Apollo.MutationHookOptions<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>(EmojiAssetCreateTokenDocument, options);
      }
export type EmojiAssetCreateTokenMutationHookResult = ReturnType<typeof useEmojiAssetCreateTokenMutation>;
export type EmojiAssetCreateTokenMutationResult = Apollo.MutationResult<EmojiAssetCreateTokenMutation>;
export type EmojiAssetCreateTokenMutationOptions = Apollo.BaseMutationOptions<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>;
export const WalletDocument = gql`
    query Wallet($userId: ID!) {
  wallet(userId: $userId) {
    wallet {
      currencies {
        ...WalletCurrency
      }
    }
  }
}
    ${WalletCurrencyFragmentDoc}`;

/**
 * __useWalletQuery__
 *
 * To run a query within a React component, call `useWalletQuery` and pass it any options that fit your needs.
 * When your component renders, `useWalletQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useWalletQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useWalletQuery(baseOptions: Apollo.QueryHookOptions<WalletQuery, WalletQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<WalletQuery, WalletQueryVariables>(WalletDocument, options);
      }
export function useWalletLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<WalletQuery, WalletQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<WalletQuery, WalletQueryVariables>(WalletDocument, options);
        }
export type WalletQueryHookResult = ReturnType<typeof useWalletQuery>;
export type WalletLazyQueryHookResult = ReturnType<typeof useWalletLazyQuery>;
export type WalletQueryResult = Apollo.QueryResult<WalletQuery, WalletQueryVariables>;
export const StreamSpectatorCoordinationSubscribeDocument = gql`
    subscription StreamSpectatorCoordinationSubscribe($streamId: ID!) {
  streamSpectatorCoordinationEventsSubscribe(streamId: $streamId) {
    event {
      ... on MatchStreamSpectatorChangeGroupEvent {
        groupId
      }
    }
  }
}
    `;

/**
 * __useStreamSpectatorCoordinationSubscribeSubscription__
 *
 * To run a query within a React component, call `useStreamSpectatorCoordinationSubscribeSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStreamSpectatorCoordinationSubscribeSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamSpectatorCoordinationSubscribeSubscription({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useStreamSpectatorCoordinationSubscribeSubscription(baseOptions: Apollo.SubscriptionHookOptions<StreamSpectatorCoordinationSubscribeSubscription, StreamSpectatorCoordinationSubscribeSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StreamSpectatorCoordinationSubscribeSubscription, StreamSpectatorCoordinationSubscribeSubscriptionVariables>(StreamSpectatorCoordinationSubscribeDocument, options);
      }
export type StreamSpectatorCoordinationSubscribeSubscriptionHookResult = ReturnType<typeof useStreamSpectatorCoordinationSubscribeSubscription>;
export type StreamSpectatorCoordinationSubscribeSubscriptionResult = Apollo.SubscriptionResult<StreamSpectatorCoordinationSubscribeSubscription>;
export const UpdateAvatarDocument = gql`
    mutation UpdateAvatar($avatarId: ID!) {
  updateProfileAvatar(modelId: $avatarId) {
    emptyTypeWorkaround
  }
}
    `;
export type UpdateAvatarMutationFn = Apollo.MutationFunction<UpdateAvatarMutation, UpdateAvatarMutationVariables>;

/**
 * __useUpdateAvatarMutation__
 *
 * To run a mutation, you first call `useUpdateAvatarMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAvatarMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAvatarMutation, { data, loading, error }] = useUpdateAvatarMutation({
 *   variables: {
 *      avatarId: // value for 'avatarId'
 *   },
 * });
 */
export function useUpdateAvatarMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAvatarMutation, UpdateAvatarMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAvatarMutation, UpdateAvatarMutationVariables>(UpdateAvatarDocument, options);
      }
export type UpdateAvatarMutationHookResult = ReturnType<typeof useUpdateAvatarMutation>;
export type UpdateAvatarMutationResult = Apollo.MutationResult<UpdateAvatarMutation>;
export type UpdateAvatarMutationOptions = Apollo.BaseMutationOptions<UpdateAvatarMutation, UpdateAvatarMutationVariables>;
export const SocialChannelBanDocument = gql`
    mutation SocialChannelBan($userId: ID!, $channelId: ID!, $violation: ChannelViolation, $description: String, $keepRecentMessages: Boolean) {
  banChannelUser(
    userId: $userId
    channelId: $channelId
    violation: $violation
    description: $description
    keepRecentMessages: $keepRecentMessages
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialChannelBanMutationFn = Apollo.MutationFunction<SocialChannelBanMutation, SocialChannelBanMutationVariables>;

/**
 * __useSocialChannelBanMutation__
 *
 * To run a mutation, you first call `useSocialChannelBanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialChannelBanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialChannelBanMutation, { data, loading, error }] = useSocialChannelBanMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *      violation: // value for 'violation'
 *      description: // value for 'description'
 *      keepRecentMessages: // value for 'keepRecentMessages'
 *   },
 * });
 */
export function useSocialChannelBanMutation(baseOptions?: Apollo.MutationHookOptions<SocialChannelBanMutation, SocialChannelBanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialChannelBanMutation, SocialChannelBanMutationVariables>(SocialChannelBanDocument, options);
      }
export type SocialChannelBanMutationHookResult = ReturnType<typeof useSocialChannelBanMutation>;
export type SocialChannelBanMutationResult = Apollo.MutationResult<SocialChannelBanMutation>;
export type SocialChannelBanMutationOptions = Apollo.BaseMutationOptions<SocialChannelBanMutation, SocialChannelBanMutationVariables>;
export const SocialChannelUnbanDocument = gql`
    mutation SocialChannelUnban($userId: ID!, $channelId: ID!) {
  unbanChannelUser(userId: $userId, channelId: $channelId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialChannelUnbanMutationFn = Apollo.MutationFunction<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>;

/**
 * __useSocialChannelUnbanMutation__
 *
 * To run a mutation, you first call `useSocialChannelUnbanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialChannelUnbanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialChannelUnbanMutation, { data, loading, error }] = useSocialChannelUnbanMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSocialChannelUnbanMutation(baseOptions?: Apollo.MutationHookOptions<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>(SocialChannelUnbanDocument, options);
      }
export type SocialChannelUnbanMutationHookResult = ReturnType<typeof useSocialChannelUnbanMutation>;
export type SocialChannelUnbanMutationResult = Apollo.MutationResult<SocialChannelUnbanMutation>;
export type SocialChannelUnbanMutationOptions = Apollo.BaseMutationOptions<SocialChannelUnbanMutation, SocialChannelUnbanMutationVariables>;
export const BlockedUserProfileDocument = gql`
    query BlockedUserProfile($userId: ID!) {
  profile(userId: $userId) {
    ...BlockUserProfile
    userId
  }
}
    ${BlockUserProfileFragmentDoc}`;

/**
 * __useBlockedUserProfileQuery__
 *
 * To run a query within a React component, call `useBlockedUserProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlockedUserProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlockedUserProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useBlockedUserProfileQuery(baseOptions: Apollo.QueryHookOptions<BlockedUserProfileQuery, BlockedUserProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BlockedUserProfileQuery, BlockedUserProfileQueryVariables>(BlockedUserProfileDocument, options);
      }
export function useBlockedUserProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BlockedUserProfileQuery, BlockedUserProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BlockedUserProfileQuery, BlockedUserProfileQueryVariables>(BlockedUserProfileDocument, options);
        }
export type BlockedUserProfileQueryHookResult = ReturnType<typeof useBlockedUserProfileQuery>;
export type BlockedUserProfileLazyQueryHookResult = ReturnType<typeof useBlockedUserProfileLazyQuery>;
export type BlockedUserProfileQueryResult = Apollo.QueryResult<BlockedUserProfileQuery, BlockedUserProfileQueryVariables>;
export const MuteUserDocument = gql`
    mutation MuteUser($chatId: ID!, $userId: ID!, $duration: Duration!, $reason: ChatReason!, $description: String!) {
  muteChatUser(
    chatId: $chatId
    userId: $userId
    duration: $duration
    reason: $reason
    description: $description
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type MuteUserMutationFn = Apollo.MutationFunction<MuteUserMutation, MuteUserMutationVariables>;

/**
 * __useMuteUserMutation__
 *
 * To run a mutation, you first call `useMuteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMuteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [muteUserMutation, { data, loading, error }] = useMuteUserMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      userId: // value for 'userId'
 *      duration: // value for 'duration'
 *      reason: // value for 'reason'
 *      description: // value for 'description'
 *   },
 * });
 */
export function useMuteUserMutation(baseOptions?: Apollo.MutationHookOptions<MuteUserMutation, MuteUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<MuteUserMutation, MuteUserMutationVariables>(MuteUserDocument, options);
      }
export type MuteUserMutationHookResult = ReturnType<typeof useMuteUserMutation>;
export type MuteUserMutationResult = Apollo.MutationResult<MuteUserMutation>;
export type MuteUserMutationOptions = Apollo.BaseMutationOptions<MuteUserMutation, MuteUserMutationVariables>;
export const UnmuteUserDocument = gql`
    mutation UnmuteUser($chatId: ID!, $userId: ID!) {
  unmuteChatUser(chatId: $chatId, userId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type UnmuteUserMutationFn = Apollo.MutationFunction<UnmuteUserMutation, UnmuteUserMutationVariables>;

/**
 * __useUnmuteUserMutation__
 *
 * To run a mutation, you first call `useUnmuteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnmuteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unmuteUserMutation, { data, loading, error }] = useUnmuteUserMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUnmuteUserMutation(baseOptions?: Apollo.MutationHookOptions<UnmuteUserMutation, UnmuteUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnmuteUserMutation, UnmuteUserMutationVariables>(UnmuteUserDocument, options);
      }
export type UnmuteUserMutationHookResult = ReturnType<typeof useUnmuteUserMutation>;
export type UnmuteUserMutationResult = Apollo.MutationResult<UnmuteUserMutation>;
export type UnmuteUserMutationOptions = Apollo.BaseMutationOptions<UnmuteUserMutation, UnmuteUserMutationVariables>;
export const ResolvedAddFriendUserTagDocument = gql`
    query ResolvedAddFriendUserTag($userTag: String!) {
  resolveUserTags(userTags: [$userTag]) {
    userIds {
      key
      value
    }
  }
}
    `;

/**
 * __useResolvedAddFriendUserTagQuery__
 *
 * To run a query within a React component, call `useResolvedAddFriendUserTagQuery` and pass it any options that fit your needs.
 * When your component renders, `useResolvedAddFriendUserTagQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useResolvedAddFriendUserTagQuery({
 *   variables: {
 *      userTag: // value for 'userTag'
 *   },
 * });
 */
export function useResolvedAddFriendUserTagQuery(baseOptions: Apollo.QueryHookOptions<ResolvedAddFriendUserTagQuery, ResolvedAddFriendUserTagQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ResolvedAddFriendUserTagQuery, ResolvedAddFriendUserTagQueryVariables>(ResolvedAddFriendUserTagDocument, options);
      }
export function useResolvedAddFriendUserTagLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ResolvedAddFriendUserTagQuery, ResolvedAddFriendUserTagQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ResolvedAddFriendUserTagQuery, ResolvedAddFriendUserTagQueryVariables>(ResolvedAddFriendUserTagDocument, options);
        }
export type ResolvedAddFriendUserTagQueryHookResult = ReturnType<typeof useResolvedAddFriendUserTagQuery>;
export type ResolvedAddFriendUserTagLazyQueryHookResult = ReturnType<typeof useResolvedAddFriendUserTagLazyQuery>;
export type ResolvedAddFriendUserTagQueryResult = Apollo.QueryResult<ResolvedAddFriendUserTagQuery, ResolvedAddFriendUserTagQueryVariables>;
export const FriendSidebarFriendsDocument = gql`
    query FriendSidebarFriends($userId: ID!, $cursor: String, $pageSize: Int! = 25) {
  friends(
    userId: $userId
    cursor: {first: $pageSize, after: $cursor}
    priorityOrder: true
  ) {
    pageInfo {
      endCursor
      hasNextPage
    }
    users {
      userId
      ...FriendsSidebarFriendListFriend
      ...FriendsSidebarPartyFriend
    }
  }
}
    ${FriendsSidebarFriendListFriendFragmentDoc}
${FriendsSidebarPartyFriendFragmentDoc}`;

/**
 * __useFriendSidebarFriendsQuery__
 *
 * To run a query within a React component, call `useFriendSidebarFriendsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendSidebarFriendsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendSidebarFriendsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useFriendSidebarFriendsQuery(baseOptions: Apollo.QueryHookOptions<FriendSidebarFriendsQuery, FriendSidebarFriendsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendSidebarFriendsQuery, FriendSidebarFriendsQueryVariables>(FriendSidebarFriendsDocument, options);
      }
export function useFriendSidebarFriendsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendSidebarFriendsQuery, FriendSidebarFriendsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendSidebarFriendsQuery, FriendSidebarFriendsQueryVariables>(FriendSidebarFriendsDocument, options);
        }
export type FriendSidebarFriendsQueryHookResult = ReturnType<typeof useFriendSidebarFriendsQuery>;
export type FriendSidebarFriendsLazyQueryHookResult = ReturnType<typeof useFriendSidebarFriendsLazyQuery>;
export type FriendSidebarFriendsQueryResult = Apollo.QueryResult<FriendSidebarFriendsQuery, FriendSidebarFriendsQueryVariables>;
export const FriendsSidebarFriendsViewDataDocument = gql`
    query FriendsSidebarFriendsViewData($userId: ID!) {
  receivedFriendRequests(userId: $userId) {
    users {
      userId
      profile {
        userId
      }
    }
  }
}
    `;

/**
 * __useFriendsSidebarFriendsViewDataQuery__
 *
 * To run a query within a React component, call `useFriendsSidebarFriendsViewDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendsSidebarFriendsViewDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendsSidebarFriendsViewDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFriendsSidebarFriendsViewDataQuery(baseOptions: Apollo.QueryHookOptions<FriendsSidebarFriendsViewDataQuery, FriendsSidebarFriendsViewDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendsSidebarFriendsViewDataQuery, FriendsSidebarFriendsViewDataQueryVariables>(FriendsSidebarFriendsViewDataDocument, options);
      }
export function useFriendsSidebarFriendsViewDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendsSidebarFriendsViewDataQuery, FriendsSidebarFriendsViewDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendsSidebarFriendsViewDataQuery, FriendsSidebarFriendsViewDataQueryVariables>(FriendsSidebarFriendsViewDataDocument, options);
        }
export type FriendsSidebarFriendsViewDataQueryHookResult = ReturnType<typeof useFriendsSidebarFriendsViewDataQuery>;
export type FriendsSidebarFriendsViewDataLazyQueryHookResult = ReturnType<typeof useFriendsSidebarFriendsViewDataLazyQuery>;
export type FriendsSidebarFriendsViewDataQueryResult = Apollo.QueryResult<FriendsSidebarFriendsViewDataQuery, FriendsSidebarFriendsViewDataQueryVariables>;
export const FriendsSidebarPartyDocument = gql`
    query FriendsSidebarParty($partyId: ID!) {
  party(partyId: $partyId) {
    id
    leaderId
    members {
      userId
      profile {
        ...FriendsSidebarFriendListProfile
        ...FriendsSidebarPartyProfile
      }
    }
    channel {
      id
      currentStreamId
      name
      game {
        id
        name
      }
    }
  }
}
    ${FriendsSidebarFriendListProfileFragmentDoc}
${FriendsSidebarPartyProfileFragmentDoc}`;

/**
 * __useFriendsSidebarPartyQuery__
 *
 * To run a query within a React component, call `useFriendsSidebarPartyQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendsSidebarPartyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendsSidebarPartyQuery({
 *   variables: {
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function useFriendsSidebarPartyQuery(baseOptions: Apollo.QueryHookOptions<FriendsSidebarPartyQuery, FriendsSidebarPartyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendsSidebarPartyQuery, FriendsSidebarPartyQueryVariables>(FriendsSidebarPartyDocument, options);
      }
export function useFriendsSidebarPartyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendsSidebarPartyQuery, FriendsSidebarPartyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendsSidebarPartyQuery, FriendsSidebarPartyQueryVariables>(FriendsSidebarPartyDocument, options);
        }
export type FriendsSidebarPartyQueryHookResult = ReturnType<typeof useFriendsSidebarPartyQuery>;
export type FriendsSidebarPartyLazyQueryHookResult = ReturnType<typeof useFriendsSidebarPartyLazyQuery>;
export type FriendsSidebarPartyQueryResult = Apollo.QueryResult<FriendsSidebarPartyQuery, FriendsSidebarPartyQueryVariables>;
export const FriendsSidebarMenuPendingRequestsDocument = gql`
    query FriendsSidebarMenuPendingRequests($userId: ID!) {
  receivedFriendRequests(userId: $userId) {
    users {
      userId
    }
  }
}
    `;

/**
 * __useFriendsSidebarMenuPendingRequestsQuery__
 *
 * To run a query within a React component, call `useFriendsSidebarMenuPendingRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendsSidebarMenuPendingRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendsSidebarMenuPendingRequestsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFriendsSidebarMenuPendingRequestsQuery(baseOptions: Apollo.QueryHookOptions<FriendsSidebarMenuPendingRequestsQuery, FriendsSidebarMenuPendingRequestsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendsSidebarMenuPendingRequestsQuery, FriendsSidebarMenuPendingRequestsQueryVariables>(FriendsSidebarMenuPendingRequestsDocument, options);
      }
export function useFriendsSidebarMenuPendingRequestsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendsSidebarMenuPendingRequestsQuery, FriendsSidebarMenuPendingRequestsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendsSidebarMenuPendingRequestsQuery, FriendsSidebarMenuPendingRequestsQueryVariables>(FriendsSidebarMenuPendingRequestsDocument, options);
        }
export type FriendsSidebarMenuPendingRequestsQueryHookResult = ReturnType<typeof useFriendsSidebarMenuPendingRequestsQuery>;
export type FriendsSidebarMenuPendingRequestsLazyQueryHookResult = ReturnType<typeof useFriendsSidebarMenuPendingRequestsLazyQuery>;
export type FriendsSidebarMenuPendingRequestsQueryResult = Apollo.QueryResult<FriendsSidebarMenuPendingRequestsQuery, FriendsSidebarMenuPendingRequestsQueryVariables>;
export const FriendsSidebarPendingViewDataDocument = gql`
    query FriendsSidebarPendingViewData($userId: ID!) {
  receivedFriendRequests(userId: $userId) {
    users {
      userId
      ...FriendsSidebarFriendListFriend
    }
  }
  sentFriendRequests(userId: $userId) {
    users {
      userId
      ...FriendsSidebarFriendListFriend
    }
  }
}
    ${FriendsSidebarFriendListFriendFragmentDoc}`;

/**
 * __useFriendsSidebarPendingViewDataQuery__
 *
 * To run a query within a React component, call `useFriendsSidebarPendingViewDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useFriendsSidebarPendingViewDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFriendsSidebarPendingViewDataQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFriendsSidebarPendingViewDataQuery(baseOptions: Apollo.QueryHookOptions<FriendsSidebarPendingViewDataQuery, FriendsSidebarPendingViewDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FriendsSidebarPendingViewDataQuery, FriendsSidebarPendingViewDataQueryVariables>(FriendsSidebarPendingViewDataDocument, options);
      }
export function useFriendsSidebarPendingViewDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FriendsSidebarPendingViewDataQuery, FriendsSidebarPendingViewDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FriendsSidebarPendingViewDataQuery, FriendsSidebarPendingViewDataQueryVariables>(FriendsSidebarPendingViewDataDocument, options);
        }
export type FriendsSidebarPendingViewDataQueryHookResult = ReturnType<typeof useFriendsSidebarPendingViewDataQuery>;
export type FriendsSidebarPendingViewDataLazyQueryHookResult = ReturnType<typeof useFriendsSidebarPendingViewDataLazyQuery>;
export type FriendsSidebarPendingViewDataQueryResult = Apollo.QueryResult<FriendsSidebarPendingViewDataQuery, FriendsSidebarPendingViewDataQueryVariables>;
export const GiftSubscriptionToCommunityButtonRolesDocument = gql`
    query GiftSubscriptionToCommunityButtonRoles($userId: ID!, $channelId: ID!) {
  userChannelRoles(userId: $userId, channelId: $channelId) {
    roles
  }
}
    `;

/**
 * __useGiftSubscriptionToCommunityButtonRolesQuery__
 *
 * To run a query within a React component, call `useGiftSubscriptionToCommunityButtonRolesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGiftSubscriptionToCommunityButtonRolesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGiftSubscriptionToCommunityButtonRolesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useGiftSubscriptionToCommunityButtonRolesQuery(baseOptions: Apollo.QueryHookOptions<GiftSubscriptionToCommunityButtonRolesQuery, GiftSubscriptionToCommunityButtonRolesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GiftSubscriptionToCommunityButtonRolesQuery, GiftSubscriptionToCommunityButtonRolesQueryVariables>(GiftSubscriptionToCommunityButtonRolesDocument, options);
      }
export function useGiftSubscriptionToCommunityButtonRolesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GiftSubscriptionToCommunityButtonRolesQuery, GiftSubscriptionToCommunityButtonRolesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GiftSubscriptionToCommunityButtonRolesQuery, GiftSubscriptionToCommunityButtonRolesQueryVariables>(GiftSubscriptionToCommunityButtonRolesDocument, options);
        }
export type GiftSubscriptionToCommunityButtonRolesQueryHookResult = ReturnType<typeof useGiftSubscriptionToCommunityButtonRolesQuery>;
export type GiftSubscriptionToCommunityButtonRolesLazyQueryHookResult = ReturnType<typeof useGiftSubscriptionToCommunityButtonRolesLazyQuery>;
export type GiftSubscriptionToCommunityButtonRolesQueryResult = Apollo.QueryResult<GiftSubscriptionToCommunityButtonRolesQuery, GiftSubscriptionToCommunityButtonRolesQueryVariables>;
export const MiniProfileFollowingStateDocument = gql`
    query MiniProfileFollowingState($userId: ID!, $channelId: ID!) {
  channelFollowerStatus(userId: $userId, channelId: $channelId) {
    following
    followedAt
  }
}
    `;

/**
 * __useMiniProfileFollowingStateQuery__
 *
 * To run a query within a React component, call `useMiniProfileFollowingStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useMiniProfileFollowingStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMiniProfileFollowingStateQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useMiniProfileFollowingStateQuery(baseOptions: Apollo.QueryHookOptions<MiniProfileFollowingStateQuery, MiniProfileFollowingStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MiniProfileFollowingStateQuery, MiniProfileFollowingStateQueryVariables>(MiniProfileFollowingStateDocument, options);
      }
export function useMiniProfileFollowingStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MiniProfileFollowingStateQuery, MiniProfileFollowingStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MiniProfileFollowingStateQuery, MiniProfileFollowingStateQueryVariables>(MiniProfileFollowingStateDocument, options);
        }
export type MiniProfileFollowingStateQueryHookResult = ReturnType<typeof useMiniProfileFollowingStateQuery>;
export type MiniProfileFollowingStateLazyQueryHookResult = ReturnType<typeof useMiniProfileFollowingStateLazyQuery>;
export type MiniProfileFollowingStateQueryResult = Apollo.QueryResult<MiniProfileFollowingStateQuery, MiniProfileFollowingStateQueryVariables>;
export const MiniProfileGameRankChannelDocument = gql`
    query MiniProfileGameRankChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    gameId
    game {
      id
      activeSeasonId
    }
  }
}
    `;

/**
 * __useMiniProfileGameRankChannelQuery__
 *
 * To run a query within a React component, call `useMiniProfileGameRankChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useMiniProfileGameRankChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMiniProfileGameRankChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useMiniProfileGameRankChannelQuery(baseOptions: Apollo.QueryHookOptions<MiniProfileGameRankChannelQuery, MiniProfileGameRankChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MiniProfileGameRankChannelQuery, MiniProfileGameRankChannelQueryVariables>(MiniProfileGameRankChannelDocument, options);
      }
export function useMiniProfileGameRankChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MiniProfileGameRankChannelQuery, MiniProfileGameRankChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MiniProfileGameRankChannelQuery, MiniProfileGameRankChannelQueryVariables>(MiniProfileGameRankChannelDocument, options);
        }
export type MiniProfileGameRankChannelQueryHookResult = ReturnType<typeof useMiniProfileGameRankChannelQuery>;
export type MiniProfileGameRankChannelLazyQueryHookResult = ReturnType<typeof useMiniProfileGameRankChannelLazyQuery>;
export type MiniProfileGameRankChannelQueryResult = Apollo.QueryResult<MiniProfileGameRankChannelQuery, MiniProfileGameRankChannelQueryVariables>;
export const MiniProfileDocument = gql`
    query MiniProfile($userId: ID!, $channelId: ID) {
  profile(userId: $userId) {
    userId
    friendshipStatus {
      status
    }
    badges(channel_id: $channelId) {
      ...UserBadge
    }
    ...MiniProfile
    ...ChannelBanModalProfile
    ...ChannelUnbanModalProfile
    ...ChannelMuteModalProfile
    ...ChannelUnmuteModalProfile
  }
}
    ${UserBadgeFragmentDoc}
${MiniProfileFragmentDoc}
${ChannelBanModalProfileFragmentDoc}
${ChannelUnbanModalProfileFragmentDoc}
${ChannelMuteModalProfileFragmentDoc}
${ChannelUnmuteModalProfileFragmentDoc}`;

/**
 * __useMiniProfileQuery__
 *
 * To run a query within a React component, call `useMiniProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useMiniProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMiniProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useMiniProfileQuery(baseOptions: Apollo.QueryHookOptions<MiniProfileQuery, MiniProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MiniProfileQuery, MiniProfileQueryVariables>(MiniProfileDocument, options);
      }
export function useMiniProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MiniProfileQuery, MiniProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MiniProfileQuery, MiniProfileQueryVariables>(MiniProfileDocument, options);
        }
export type MiniProfileQueryHookResult = ReturnType<typeof useMiniProfileQuery>;
export type MiniProfileLazyQueryHookResult = ReturnType<typeof useMiniProfileLazyQuery>;
export type MiniProfileQueryResult = Apollo.QueryResult<MiniProfileQuery, MiniProfileQueryVariables>;
export const MiniProfileModeratorStatusDocument = gql`
    query MiniProfileModeratorStatus($userId: ID!, $channelId: ID!, $chatId: ID, $skipChatModerationData: Boolean!) {
  channelBanUserStatus(userId: $userId, channelId: $channelId) {
    userId
    channelId
    banned
    ...MiniProfilePortalChannelBan
  }
  chatUserStatus(userId: $userId, chatId: $chatId) @skip(if: $skipChatModerationData) {
    ...MiniProfilePortalChatStaus
  }
}
    ${MiniProfilePortalChannelBanFragmentDoc}
${MiniProfilePortalChatStausFragmentDoc}`;

/**
 * __useMiniProfileModeratorStatusQuery__
 *
 * To run a query within a React component, call `useMiniProfileModeratorStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `useMiniProfileModeratorStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMiniProfileModeratorStatusQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *      chatId: // value for 'chatId'
 *      skipChatModerationData: // value for 'skipChatModerationData'
 *   },
 * });
 */
export function useMiniProfileModeratorStatusQuery(baseOptions: Apollo.QueryHookOptions<MiniProfileModeratorStatusQuery, MiniProfileModeratorStatusQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MiniProfileModeratorStatusQuery, MiniProfileModeratorStatusQueryVariables>(MiniProfileModeratorStatusDocument, options);
      }
export function useMiniProfileModeratorStatusLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MiniProfileModeratorStatusQuery, MiniProfileModeratorStatusQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MiniProfileModeratorStatusQuery, MiniProfileModeratorStatusQueryVariables>(MiniProfileModeratorStatusDocument, options);
        }
export type MiniProfileModeratorStatusQueryHookResult = ReturnType<typeof useMiniProfileModeratorStatusQuery>;
export type MiniProfileModeratorStatusLazyQueryHookResult = ReturnType<typeof useMiniProfileModeratorStatusLazyQuery>;
export type MiniProfileModeratorStatusQueryResult = Apollo.QueryResult<MiniProfileModeratorStatusQuery, MiniProfileModeratorStatusQueryVariables>;
export const UserChannelRolesDocument = gql`
    query UserChannelRoles($userId: ID, $channelId: ID!, $skipRoles: Boolean!) {
  userChannelRoles(userId: $userId, channelId: $channelId) @skip(if: $skipRoles) {
    roles
  }
  channel(id: $channelId) {
    id
    currentChatId
  }
}
    `;

/**
 * __useUserChannelRolesQuery__
 *
 * To run a query within a React component, call `useUserChannelRolesQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserChannelRolesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserChannelRolesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *      skipRoles: // value for 'skipRoles'
 *   },
 * });
 */
export function useUserChannelRolesQuery(baseOptions: Apollo.QueryHookOptions<UserChannelRolesQuery, UserChannelRolesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserChannelRolesQuery, UserChannelRolesQueryVariables>(UserChannelRolesDocument, options);
      }
export function useUserChannelRolesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserChannelRolesQuery, UserChannelRolesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserChannelRolesQuery, UserChannelRolesQueryVariables>(UserChannelRolesDocument, options);
        }
export type UserChannelRolesQueryHookResult = ReturnType<typeof useUserChannelRolesQuery>;
export type UserChannelRolesLazyQueryHookResult = ReturnType<typeof useUserChannelRolesLazyQuery>;
export type UserChannelRolesQueryResult = Apollo.QueryResult<UserChannelRolesQuery, UserChannelRolesQueryVariables>;
export const LeavePartyDocument = gql`
    mutation LeaveParty($userId: ID!, $partyId: ID!) {
  deletePartyMember(userId: $userId, partyId: $partyId) {
    emptyTypeWorkaround
  }
}
    `;
export type LeavePartyMutationFn = Apollo.MutationFunction<LeavePartyMutation, LeavePartyMutationVariables>;

/**
 * __useLeavePartyMutation__
 *
 * To run a mutation, you first call `useLeavePartyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLeavePartyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [leavePartyMutation, { data, loading, error }] = useLeavePartyMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function useLeavePartyMutation(baseOptions?: Apollo.MutationHookOptions<LeavePartyMutation, LeavePartyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LeavePartyMutation, LeavePartyMutationVariables>(LeavePartyDocument, options);
      }
export type LeavePartyMutationHookResult = ReturnType<typeof useLeavePartyMutation>;
export type LeavePartyMutationResult = Apollo.MutationResult<LeavePartyMutation>;
export type LeavePartyMutationOptions = Apollo.BaseMutationOptions<LeavePartyMutation, LeavePartyMutationVariables>;
export const CreatePartyDocument = gql`
    mutation CreateParty {
  createParty {
    id
  }
}
    `;
export type CreatePartyMutationFn = Apollo.MutationFunction<CreatePartyMutation, CreatePartyMutationVariables>;

/**
 * __useCreatePartyMutation__
 *
 * To run a mutation, you first call `useCreatePartyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePartyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPartyMutation, { data, loading, error }] = useCreatePartyMutation({
 *   variables: {
 *   },
 * });
 */
export function useCreatePartyMutation(baseOptions?: Apollo.MutationHookOptions<CreatePartyMutation, CreatePartyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePartyMutation, CreatePartyMutationVariables>(CreatePartyDocument, options);
      }
export type CreatePartyMutationHookResult = ReturnType<typeof useCreatePartyMutation>;
export type CreatePartyMutationResult = Apollo.MutationResult<CreatePartyMutation>;
export type CreatePartyMutationOptions = Apollo.BaseMutationOptions<CreatePartyMutation, CreatePartyMutationVariables>;
export const CreatePartyInvitationDocument = gql`
    mutation CreatePartyInvitation($inviterId: ID!, $inviteeId: ID!, $partyId: ID!) {
  createPartyInvitation(
    inviterId: $inviterId
    inviteeId: $inviteeId
    partyId: $partyId
  ) {
    partyId
  }
}
    `;
export type CreatePartyInvitationMutationFn = Apollo.MutationFunction<CreatePartyInvitationMutation, CreatePartyInvitationMutationVariables>;

/**
 * __useCreatePartyInvitationMutation__
 *
 * To run a mutation, you first call `useCreatePartyInvitationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePartyInvitationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPartyInvitationMutation, { data, loading, error }] = useCreatePartyInvitationMutation({
 *   variables: {
 *      inviterId: // value for 'inviterId'
 *      inviteeId: // value for 'inviteeId'
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function useCreatePartyInvitationMutation(baseOptions?: Apollo.MutationHookOptions<CreatePartyInvitationMutation, CreatePartyInvitationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePartyInvitationMutation, CreatePartyInvitationMutationVariables>(CreatePartyInvitationDocument, options);
      }
export type CreatePartyInvitationMutationHookResult = ReturnType<typeof useCreatePartyInvitationMutation>;
export type CreatePartyInvitationMutationResult = Apollo.MutationResult<CreatePartyInvitationMutation>;
export type CreatePartyInvitationMutationOptions = Apollo.BaseMutationOptions<CreatePartyInvitationMutation, CreatePartyInvitationMutationVariables>;
export const PartyInvitesCreatePartyMemberDocument = gql`
    mutation PartyInvitesCreatePartyMember($userId: ID!, $partyId: ID!) {
  createPartyMember(userId: $userId, partyId: $partyId) {
    emptyTypeWorkaround
  }
}
    `;
export type PartyInvitesCreatePartyMemberMutationFn = Apollo.MutationFunction<PartyInvitesCreatePartyMemberMutation, PartyInvitesCreatePartyMemberMutationVariables>;

/**
 * __usePartyInvitesCreatePartyMemberMutation__
 *
 * To run a mutation, you first call `usePartyInvitesCreatePartyMemberMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePartyInvitesCreatePartyMemberMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [partyInvitesCreatePartyMemberMutation, { data, loading, error }] = usePartyInvitesCreatePartyMemberMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function usePartyInvitesCreatePartyMemberMutation(baseOptions?: Apollo.MutationHookOptions<PartyInvitesCreatePartyMemberMutation, PartyInvitesCreatePartyMemberMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PartyInvitesCreatePartyMemberMutation, PartyInvitesCreatePartyMemberMutationVariables>(PartyInvitesCreatePartyMemberDocument, options);
      }
export type PartyInvitesCreatePartyMemberMutationHookResult = ReturnType<typeof usePartyInvitesCreatePartyMemberMutation>;
export type PartyInvitesCreatePartyMemberMutationResult = Apollo.MutationResult<PartyInvitesCreatePartyMemberMutation>;
export type PartyInvitesCreatePartyMemberMutationOptions = Apollo.BaseMutationOptions<PartyInvitesCreatePartyMemberMutation, PartyInvitesCreatePartyMemberMutationVariables>;
export const PartyInvitesDeletePartyInviteDocument = gql`
    mutation PartyInvitesDeletePartyInvite($userId: ID!, $partyId: ID!) {
  deletePartyInvitation(userId: $userId, partyId: $partyId) {
    emptyTypeWorkaround
  }
}
    `;
export type PartyInvitesDeletePartyInviteMutationFn = Apollo.MutationFunction<PartyInvitesDeletePartyInviteMutation, PartyInvitesDeletePartyInviteMutationVariables>;

/**
 * __usePartyInvitesDeletePartyInviteMutation__
 *
 * To run a mutation, you first call `usePartyInvitesDeletePartyInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePartyInvitesDeletePartyInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [partyInvitesDeletePartyInviteMutation, { data, loading, error }] = usePartyInvitesDeletePartyInviteMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function usePartyInvitesDeletePartyInviteMutation(baseOptions?: Apollo.MutationHookOptions<PartyInvitesDeletePartyInviteMutation, PartyInvitesDeletePartyInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PartyInvitesDeletePartyInviteMutation, PartyInvitesDeletePartyInviteMutationVariables>(PartyInvitesDeletePartyInviteDocument, options);
      }
export type PartyInvitesDeletePartyInviteMutationHookResult = ReturnType<typeof usePartyInvitesDeletePartyInviteMutation>;
export type PartyInvitesDeletePartyInviteMutationResult = Apollo.MutationResult<PartyInvitesDeletePartyInviteMutation>;
export type PartyInvitesDeletePartyInviteMutationOptions = Apollo.BaseMutationOptions<PartyInvitesDeletePartyInviteMutation, PartyInvitesDeletePartyInviteMutationVariables>;
export const PartyInvitesCurrentPartyDocument = gql`
    query PartyInvitesCurrentParty($userId: ID!) {
  userParty(userId: $userId) {
    id
    leaderId
    streamId
    members {
      userId
    }
  }
}
    `;

/**
 * __usePartyInvitesCurrentPartyQuery__
 *
 * To run a query within a React component, call `usePartyInvitesCurrentPartyQuery` and pass it any options that fit your needs.
 * When your component renders, `usePartyInvitesCurrentPartyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePartyInvitesCurrentPartyQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function usePartyInvitesCurrentPartyQuery(baseOptions: Apollo.QueryHookOptions<PartyInvitesCurrentPartyQuery, PartyInvitesCurrentPartyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PartyInvitesCurrentPartyQuery, PartyInvitesCurrentPartyQueryVariables>(PartyInvitesCurrentPartyDocument, options);
      }
export function usePartyInvitesCurrentPartyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PartyInvitesCurrentPartyQuery, PartyInvitesCurrentPartyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PartyInvitesCurrentPartyQuery, PartyInvitesCurrentPartyQueryVariables>(PartyInvitesCurrentPartyDocument, options);
        }
export type PartyInvitesCurrentPartyQueryHookResult = ReturnType<typeof usePartyInvitesCurrentPartyQuery>;
export type PartyInvitesCurrentPartyLazyQueryHookResult = ReturnType<typeof usePartyInvitesCurrentPartyLazyQuery>;
export type PartyInvitesCurrentPartyQueryResult = Apollo.QueryResult<PartyInvitesCurrentPartyQuery, PartyInvitesCurrentPartyQueryVariables>;
export const PartyInvitesPartyUpdatesDocument = gql`
    subscription PartyInvitesPartyUpdates($partyId: ID!) {
  partyUpdateSubscribe(partyId: $partyId) {
    party {
      id
      streamId
      leaderId
      members {
        userId
        profile {
          userId
        }
      }
      channel {
        id
      }
    }
  }
}
    `;

/**
 * __usePartyInvitesPartyUpdatesSubscription__
 *
 * To run a query within a React component, call `usePartyInvitesPartyUpdatesSubscription` and pass it any options that fit your needs.
 * When your component renders, `usePartyInvitesPartyUpdatesSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePartyInvitesPartyUpdatesSubscription({
 *   variables: {
 *      partyId: // value for 'partyId'
 *   },
 * });
 */
export function usePartyInvitesPartyUpdatesSubscription(baseOptions: Apollo.SubscriptionHookOptions<PartyInvitesPartyUpdatesSubscription, PartyInvitesPartyUpdatesSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<PartyInvitesPartyUpdatesSubscription, PartyInvitesPartyUpdatesSubscriptionVariables>(PartyInvitesPartyUpdatesDocument, options);
      }
export type PartyInvitesPartyUpdatesSubscriptionHookResult = ReturnType<typeof usePartyInvitesPartyUpdatesSubscription>;
export type PartyInvitesPartyUpdatesSubscriptionResult = Apollo.SubscriptionResult<PartyInvitesPartyUpdatesSubscription>;
export const SocialAcceptFriendRequestDocument = gql`
    mutation SocialAcceptFriendRequest($userId: ID!, $friendId: ID!) {
  acceptFriendRequest(userId: $userId, friendId: $friendId) {
    friendId
    friend {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialAcceptFriendRequestMutationFn = Apollo.MutationFunction<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>;

/**
 * __useSocialAcceptFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialAcceptFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialAcceptFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialAcceptFriendRequestMutation, { data, loading, error }] = useSocialAcceptFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialAcceptFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>(SocialAcceptFriendRequestDocument, options);
      }
export type SocialAcceptFriendRequestMutationHookResult = ReturnType<typeof useSocialAcceptFriendRequestMutation>;
export type SocialAcceptFriendRequestMutationResult = Apollo.MutationResult<SocialAcceptFriendRequestMutation>;
export type SocialAcceptFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialAcceptFriendRequestMutation, SocialAcceptFriendRequestMutationVariables>;
export const SocialBlockUserDocument = gql`
    mutation SocialBlockUser($userId: ID!, $blockedUserId: ID!) {
  blockUser(userId: $userId, blockedUserId: $blockedUserId) {
    blockedUserId
    blockedUser {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialBlockUserMutationFn = Apollo.MutationFunction<SocialBlockUserMutation, SocialBlockUserMutationVariables>;

/**
 * __useSocialBlockUserMutation__
 *
 * To run a mutation, you first call `useSocialBlockUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialBlockUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialBlockUserMutation, { data, loading, error }] = useSocialBlockUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      blockedUserId: // value for 'blockedUserId'
 *   },
 * });
 */
export function useSocialBlockUserMutation(baseOptions?: Apollo.MutationHookOptions<SocialBlockUserMutation, SocialBlockUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialBlockUserMutation, SocialBlockUserMutationVariables>(SocialBlockUserDocument, options);
      }
export type SocialBlockUserMutationHookResult = ReturnType<typeof useSocialBlockUserMutation>;
export type SocialBlockUserMutationResult = Apollo.MutationResult<SocialBlockUserMutation>;
export type SocialBlockUserMutationOptions = Apollo.BaseMutationOptions<SocialBlockUserMutation, SocialBlockUserMutationVariables>;
export const SocialRemoveFriendDocument = gql`
    mutation SocialRemoveFriend($userId: ID!, $friendId: ID!) {
  removeFriend(userId: $userId, friendId: $friendId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialRemoveFriendMutationFn = Apollo.MutationFunction<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>;

/**
 * __useSocialRemoveFriendMutation__
 *
 * To run a mutation, you first call `useSocialRemoveFriendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialRemoveFriendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialRemoveFriendMutation, { data, loading, error }] = useSocialRemoveFriendMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialRemoveFriendMutation(baseOptions?: Apollo.MutationHookOptions<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>(SocialRemoveFriendDocument, options);
      }
export type SocialRemoveFriendMutationHookResult = ReturnType<typeof useSocialRemoveFriendMutation>;
export type SocialRemoveFriendMutationResult = Apollo.MutationResult<SocialRemoveFriendMutation>;
export type SocialRemoveFriendMutationOptions = Apollo.BaseMutationOptions<SocialRemoveFriendMutation, SocialRemoveFriendMutationVariables>;
export const SocialRemoveReceivedFriendRequestDocument = gql`
    mutation SocialRemoveReceivedFriendRequest($userId: ID!, $friendId: ID!) {
  removeFriendRequest(userId: $userId, friendId: $friendId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialRemoveReceivedFriendRequestMutationFn = Apollo.MutationFunction<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>;

/**
 * __useSocialRemoveReceivedFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialRemoveReceivedFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialRemoveReceivedFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialRemoveReceivedFriendRequestMutation, { data, loading, error }] = useSocialRemoveReceivedFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialRemoveReceivedFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>(SocialRemoveReceivedFriendRequestDocument, options);
      }
export type SocialRemoveReceivedFriendRequestMutationHookResult = ReturnType<typeof useSocialRemoveReceivedFriendRequestMutation>;
export type SocialRemoveReceivedFriendRequestMutationResult = Apollo.MutationResult<SocialRemoveReceivedFriendRequestMutation>;
export type SocialRemoveReceivedFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialRemoveReceivedFriendRequestMutation, SocialRemoveReceivedFriendRequestMutationVariables>;
export const SocialRemoveSentFriendRequestDocument = gql`
    mutation SocialRemoveSentFriendRequest($userId: ID!, $friendId: ID!) {
  removeFriendRequest(userId: $friendId, friendId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type SocialRemoveSentFriendRequestMutationFn = Apollo.MutationFunction<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>;

/**
 * __useSocialRemoveSentFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialRemoveSentFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialRemoveSentFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialRemoveSentFriendRequestMutation, { data, loading, error }] = useSocialRemoveSentFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialRemoveSentFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>(SocialRemoveSentFriendRequestDocument, options);
      }
export type SocialRemoveSentFriendRequestMutationHookResult = ReturnType<typeof useSocialRemoveSentFriendRequestMutation>;
export type SocialRemoveSentFriendRequestMutationResult = Apollo.MutationResult<SocialRemoveSentFriendRequestMutation>;
export type SocialRemoveSentFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialRemoveSentFriendRequestMutation, SocialRemoveSentFriendRequestMutationVariables>;
export const SocialSendFriendRequestDocument = gql`
    mutation SocialSendFriendRequest($userId: ID!, $friendId: ID!) {
  sendFriendRequest(userId: $userId, friendId: $friendId) {
    friendId
    friend {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialSendFriendRequestMutationFn = Apollo.MutationFunction<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>;

/**
 * __useSocialSendFriendRequestMutation__
 *
 * To run a mutation, you first call `useSocialSendFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialSendFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialSendFriendRequestMutation, { data, loading, error }] = useSocialSendFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      friendId: // value for 'friendId'
 *   },
 * });
 */
export function useSocialSendFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>(SocialSendFriendRequestDocument, options);
      }
export type SocialSendFriendRequestMutationHookResult = ReturnType<typeof useSocialSendFriendRequestMutation>;
export type SocialSendFriendRequestMutationResult = Apollo.MutationResult<SocialSendFriendRequestMutation>;
export type SocialSendFriendRequestMutationOptions = Apollo.BaseMutationOptions<SocialSendFriendRequestMutation, SocialSendFriendRequestMutationVariables>;
export const SocialUnblockUserDocument = gql`
    mutation SocialUnblockUser($userId: ID!, $blockedUserId: ID!) {
  unblockUser(userId: $userId, blockedUserId: $blockedUserId) {
    unblockedUserId
    unblockedUser {
      ...FriendStatusUpdateProfile
    }
  }
}
    ${FriendStatusUpdateProfileFragmentDoc}`;
export type SocialUnblockUserMutationFn = Apollo.MutationFunction<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>;

/**
 * __useSocialUnblockUserMutation__
 *
 * To run a mutation, you first call `useSocialUnblockUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSocialUnblockUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [socialUnblockUserMutation, { data, loading, error }] = useSocialUnblockUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      blockedUserId: // value for 'blockedUserId'
 *   },
 * });
 */
export function useSocialUnblockUserMutation(baseOptions?: Apollo.MutationHookOptions<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>(SocialUnblockUserDocument, options);
      }
export type SocialUnblockUserMutationHookResult = ReturnType<typeof useSocialUnblockUserMutation>;
export type SocialUnblockUserMutationResult = Apollo.MutationResult<SocialUnblockUserMutation>;
export type SocialUnblockUserMutationOptions = Apollo.BaseMutationOptions<SocialUnblockUserMutation, SocialUnblockUserMutationVariables>;