// THIS FILE IS GENERATED BY graphql-codegen, DO NOT EDIT!
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Duration: { input: string; output: string; }
  InputTimestamp: { input: string; output: string; }
  Timestamp: { input: string; output: string; }
};

export type ApiAddressInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  zip?: InputMaybe<Scalars['String']['input']>;
};

export type ApiCursorInput = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ApiDateInput = {
  day?: InputMaybe<Scalars['Int']['input']>;
  month?: InputMaybe<Scalars['Int']['input']>;
  year?: InputMaybe<Scalars['Int']['input']>;
};

export type ApiPageInfo = {
  __typename?: 'APIPageInfo';
  endCursor: Scalars['String']['output'];
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  startCursor: Scalars['String']['output'];
};

export type AdsGetPlacementResponse = {
  __typename?: 'AdsGetPlacementResponse';
  placementId: Scalars['ID']['output'];
  referenceId: Scalars['ID']['output'];
  /** TODO: Kept while migrating and set to the first item in rewards */
  reward: AdsRewardDescription;
  rewards: Array<AdsRewardDescription>;
  state: AdsPlacementState;
  updatesAt: Scalars['Timestamp']['output'];
};

export enum AdsPlacementState {
  PlacementStateNotReady = 'PLACEMENT_STATE_NOT_READY',
  PlacementStateReady = 'PLACEMENT_STATE_READY',
  PlacementStateUnspecified = 'PLACEMENT_STATE_UNSPECIFIED'
}

export type AdsPlacementStateEvent = {
  __typename?: 'AdsPlacementStateEvent';
  placementId: Scalars['ID']['output'];
  referenceId: Scalars['ID']['output'];
  state: AdsPlacementState;
  userId: Scalars['ID']['output'];
};

export type AdsRewardDescription = {
  __typename?: 'AdsRewardDescription';
  prizes: Array<AdsRewardDescriptionPrizeDescription>;
  rarity: RarityRarity;
  readyAt: Scalars['Timestamp']['output'];
};

export type AdsRewardDescriptionPrizeDescription = {
  __typename?: 'AdsRewardDescriptionPrizeDescription';
  amount: Scalars['Int']['output'];
  kind: AdsRewardDescriptionPrizeDescriptionKind;
  max: Scalars['Int']['output'];
  min: Scalars['Int']['output'];
  value: Scalars['String']['output'];
};

export enum AdsRewardDescriptionPrizeDescriptionKind {
  KindCurrency = 'KIND_CURRENCY',
  KindExperiencePoints = 'KIND_EXPERIENCE_POINTS',
  KindUnspecified = 'KIND_UNSPECIFIED'
}

export type AdyenAmount = {
  __typename?: 'AdyenAmount';
  currency: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type AdyenSession = {
  __typename?: 'AdyenSession';
  amount: AdyenAmount;
  id: Scalars['ID']['output'];
  reference: Scalars['String']['output'];
  returnUrl: Scalars['String']['output'];
  sessionData: Scalars['String']['output'];
};

export type AgreementAgreementRevision = {
  __typename?: 'AgreementAgreementRevision';
  name: Scalars['String']['output'];
  revision: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type AgreementListAgreementResponse = {
  __typename?: 'AgreementListAgreementResponse';
  agreements: Array<AgreementAgreementRevision>;
};

export type AnnouncementAnnouncement = {
  __typename?: 'AnnouncementAnnouncement';
  category: AnnouncementAnnouncementCategory;
  createdAt: Scalars['Timestamp']['output'];
  creator: ProfileProfile;
  creatorId: Scalars['ID']['output'];
  endTime?: Maybe<Scalars['Timestamp']['output']>;
  id: Scalars['ID']['output'];
  image: Scalars['String']['output'];
  imageUrl: Scalars['String']['output'];
  published: Scalars['Boolean']['output'];
  startTime?: Maybe<Scalars['Timestamp']['output']>;
  status: AnnouncementAnnouncementStatus;
  targets: AnnouncementTargets;
  text: Scalars['String']['output'];
  title: Scalars['String']['output'];
};

export enum AnnouncementAnnouncementCategory {
  AnnouncementCategoryGameApexLegends = 'ANNOUNCEMENT_CATEGORY_GAME_APEX_LEGENDS',
  AnnouncementCategoryGameDbd = 'ANNOUNCEMENT_CATEGORY_GAME_DBD',
  AnnouncementCategoryGameDota2 = 'ANNOUNCEMENT_CATEGORY_GAME_DOTA2',
  AnnouncementCategoryGameFortnite = 'ANNOUNCEMENT_CATEGORY_GAME_FORTNITE',
  AnnouncementCategoryGameLeagueOfLegends = 'ANNOUNCEMENT_CATEGORY_GAME_LEAGUE_OF_LEGENDS',
  AnnouncementCategoryPlatform = 'ANNOUNCEMENT_CATEGORY_PLATFORM',
  AnnouncementCategorySystem = 'ANNOUNCEMENT_CATEGORY_SYSTEM',
  AnnouncementCategoryUnspecified = 'ANNOUNCEMENT_CATEGORY_UNSPECIFIED'
}

export type AnnouncementAnnouncementFilterInput = {
  statuses?: InputMaybe<Array<AnnouncementAnnouncementStatus>>;
  targets?: InputMaybe<Array<AnnouncementAnnouncementTarget>>;
};

export type AnnouncementAnnouncementInput = {
  category?: InputMaybe<AnnouncementAnnouncementCategory>;
  createdAt?: InputMaybe<Scalars['InputTimestamp']['input']>;
  creatorId?: InputMaybe<Scalars['ID']['input']>;
  endTime?: InputMaybe<Scalars['InputTimestamp']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  startTime?: InputMaybe<Scalars['InputTimestamp']['input']>;
  status?: InputMaybe<AnnouncementAnnouncementStatus>;
  targets?: InputMaybe<AnnouncementTargetsInput>;
  text?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export enum AnnouncementAnnouncementStatus {
  AnnouncementStatusActive = 'ANNOUNCEMENT_STATUS_ACTIVE',
  AnnouncementStatusDraft = 'ANNOUNCEMENT_STATUS_DRAFT',
  AnnouncementStatusPast = 'ANNOUNCEMENT_STATUS_PAST',
  AnnouncementStatusScheduled = 'ANNOUNCEMENT_STATUS_SCHEDULED',
  AnnouncementStatusUnspecified = 'ANNOUNCEMENT_STATUS_UNSPECIFIED'
}

export enum AnnouncementAnnouncementTarget {
  AnnouncementTargetMobile = 'ANNOUNCEMENT_TARGET_MOBILE',
  AnnouncementTargetStudio = 'ANNOUNCEMENT_TARGET_STUDIO',
  AnnouncementTargetUnspecified = 'ANNOUNCEMENT_TARGET_UNSPECIFIED',
  AnnouncementTargetWeb = 'ANNOUNCEMENT_TARGET_WEB'
}

export type AnnouncementCreateAnnouncementImageUploadTokenResponse = {
  __typename?: 'AnnouncementCreateAnnouncementImageUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type AnnouncementListAnnouncementsResponse = {
  __typename?: 'AnnouncementListAnnouncementsResponse';
  announcements: Array<AnnouncementAnnouncement>;
  pageInfo: ApiPageInfo;
  totalCount: Scalars['Int']['output'];
};

export type AnnouncementListUserAnnouncementsResponse = {
  __typename?: 'AnnouncementListUserAnnouncementsResponse';
  announcements: Array<AnnouncementAnnouncement>;
  pageInfo: ApiPageInfo;
};

export type AnnouncementTargets = {
  __typename?: 'AnnouncementTargets';
  mobile: Scalars['Boolean']['output'];
  studio: Scalars['Boolean']['output'];
  web: Scalars['Boolean']['output'];
};

export type AnnouncementTargetsInput = {
  mobile?: InputMaybe<Scalars['Boolean']['input']>;
  studio?: InputMaybe<Scalars['Boolean']['input']>;
  web?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum ApiEntityState {
  EntityStateBlocked = 'ENTITY_STATE_BLOCKED',
  EntityStateDeleted = 'ENTITY_STATE_DELETED',
  EntityStateUnspecified = 'ENTITY_STATE_UNSPECIFIED'
}

export type ArenaArena = {
  __typename?: 'ArenaArena';
  config?: Maybe<ArenaArenaConfigUnion>;
  enabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  thumbnailUrl: Scalars['String']['output'];
};

export type ArenaArenaConfigUnion = ArenaServerSideArenaConfig;

export type ArenaClientSideArena = {
  __typename?: 'ArenaClientSideArena';
  enabled: Scalars['Boolean']['output'];
  environmentUrl: Scalars['String']['output'];
  glbUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lightmapUrl: Scalars['String']['output'];
  name: Scalars['String']['output'];
  thumbnailUrl: Scalars['String']['output'];
  version: Scalars['String']['output'];
};

export type ArenaListArenasResponse = {
  __typename?: 'ArenaListArenasResponse';
  arenas: Array<ArenaArena>;
  pageInfo: ApiPageInfo;
};

export type ArenaListClientSideArenasResponse = {
  __typename?: 'ArenaListClientSideArenasResponse';
  arenas: Array<ArenaClientSideArena>;
};

export type ArenaServerSideArenaConfig = {
  __typename?: 'ArenaServerSideArenaConfig';
  arenaConfigUrl: Scalars['String']['output'];
  contentCatalogUrl: Scalars['String']['output'];
  gameViewScreenshotUrl: Scalars['String']['output'];
};

export type AttributeAttribute = {
  __typename?: 'AttributeAttribute';
  value?: Maybe<AttributeAttributeValueUnion>;
};

export type AttributeAttributeBoolArray = {
  __typename?: 'AttributeAttributeBoolArray';
  value: Array<Scalars['Boolean']['output']>;
};

export type AttributeAttributeBoolArrayInput = {
  value?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

export type AttributeAttributeFloatArray = {
  __typename?: 'AttributeAttributeFloatArray';
  value: Array<Scalars['Float']['output']>;
};

export type AttributeAttributeFloatArrayInput = {
  value?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type AttributeAttributeInput = {
  boolArrayValue?: InputMaybe<AttributeAttributeBoolArrayInput>;
  boolValue?: InputMaybe<Scalars['Boolean']['input']>;
  floatArrayValue?: InputMaybe<AttributeAttributeFloatArrayInput>;
  floatValue?: InputMaybe<Scalars['Float']['input']>;
  intArrayValue?: InputMaybe<AttributeAttributeIntArrayInput>;
  intValue?: InputMaybe<Scalars['Int']['input']>;
  mapValue?: InputMaybe<AttributeAttributeMapInput>;
  stringArrayValue?: InputMaybe<AttributeAttributeStringArrayInput>;
  stringValue?: InputMaybe<Scalars['String']['input']>;
};

export type AttributeAttributeIntArray = {
  __typename?: 'AttributeAttributeIntArray';
  value: Array<Scalars['Int']['output']>;
};

export type AttributeAttributeIntArrayInput = {
  value?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type AttributeAttributeMap = {
  __typename?: 'AttributeAttributeMap';
  value: Array<AttributeAttributeMapValueEntry>;
};

export type AttributeAttributeMapInput = {
  value?: InputMaybe<Array<AttributeAttributeMapValueEntryInput>>;
};

export type AttributeAttributeMapValueEntry = {
  __typename?: 'AttributeAttributeMapValueEntry';
  key: Scalars['String']['output'];
  value: AttributeAttribute;
};

export type AttributeAttributeMapValueEntryInput = {
  key?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type AttributeAttributeStringArray = {
  __typename?: 'AttributeAttributeStringArray';
  value: Array<Scalars['String']['output']>;
};

export type AttributeAttributeStringArrayInput = {
  value?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type AttributeAttributeValueUnion = AttributeAttributeBoolArray | AttributeAttributeFloatArray | AttributeAttributeIntArray | AttributeAttributeMap | AttributeAttributeStringArray | BooleanType | FloatType | IntType | StringType;

export type AuthAccount = {
  __typename?: 'AuthAccount';
  acceptedTerms: Array<AuthTermsVersion>;
  birthday?: Maybe<AuthDate>;
  channelCreationEligibility: ChannelChannelCreationEligibility;
  createdAt: Scalars['Timestamp']['output'];
  email: Scalars['String']['output'];
  emailVerifiedAt?: Maybe<Scalars['Timestamp']['output']>;
  externalIds: Array<AuthIdentity>;
  flags: Array<AuthAccountStatusFlag>;
  isBot: Scalars['Boolean']['output'];
  labels: Array<Scalars['String']['output']>;
  marketingConsent: AuthConsentStatus;
  matureRatedContentAllowed: Scalars['Boolean']['output'];
  pendingAgreements: Array<AgreementAgreementRevision>;
  roles: Array<AuthPlatformRole>;
  signupLocation: Scalars['String']['output'];
  signupOrigin?: Maybe<AuthSignupOrigin>;
  staff: Scalars['Boolean']['output'];
  state: ApiEntityState;
  temporary: Scalars['Boolean']['output'];
  uid: Scalars['String']['output'];
};

export enum AuthAccountStatusFlag {
  StatusFlagBanned = 'STATUS_FLAG_BANNED',
  StatusFlagDeletionScheduled = 'STATUS_FLAG_DELETION_SCHEDULED',
  StatusFlagUnspecified = 'STATUS_FLAG_UNSPECIFIED',
  StatusFlagWaitlist = 'STATUS_FLAG_WAITLIST'
}

export type AuthAccountUpdateInput = {
  roles?: InputMaybe<Array<AuthPlatformRole>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export enum AuthConsentStatus {
  ConsentStatusAccepted = 'CONSENT_STATUS_ACCEPTED',
  ConsentStatusDeclined = 'CONSENT_STATUS_DECLINED',
  ConsentStatusUnspecified = 'CONSENT_STATUS_UNSPECIFIED'
}

export type AuthDate = {
  __typename?: 'AuthDate';
  day: Scalars['Int']['output'];
  month: Scalars['Int']['output'];
  year: Scalars['Int']['output'];
};

export type AuthDateInput = {
  day?: InputMaybe<Scalars['Int']['input']>;
  month?: InputMaybe<Scalars['Int']['input']>;
  year?: InputMaybe<Scalars['Int']['input']>;
};

export type AuthIdentity = {
  __typename?: 'AuthIdentity';
  id: Scalars['ID']['output'];
  type: AuthIdentityType;
};

export enum AuthIdentityType {
  IdentityTypeApple = 'IDENTITY_TYPE_APPLE',
  IdentityTypeDiscord = 'IDENTITY_TYPE_DISCORD',
  IdentityTypeEmail = 'IDENTITY_TYPE_EMAIL',
  IdentityTypeUnspecified = 'IDENTITY_TYPE_UNSPECIFIED'
}

export enum AuthPlatformRole {
  PlatformRoleAdmin = 'PLATFORM_ROLE_ADMIN',
  PlatformRoleBot = 'PLATFORM_ROLE_BOT',
  PlatformRoleFullUser = 'PLATFORM_ROLE_FULL_USER',
  PlatformRoleGuest = 'PLATFORM_ROLE_GUEST',
  PlatformRoleModerator = 'PLATFORM_ROLE_MODERATOR',
  PlatformRolePxAgent = 'PLATFORM_ROLE_PX_AGENT',
  PlatformRoleRoot = 'PLATFORM_ROLE_ROOT',
  PlatformRoleStreamerTooling = 'PLATFORM_ROLE_STREAMER_TOOLING',
  PlatformRoleUnspecified = 'PLATFORM_ROLE_UNSPECIFIED',
  PlatformRoleUser = 'PLATFORM_ROLE_USER'
}

export type AuthSignupOrigin = {
  __typename?: 'AuthSignupOrigin';
  origin?: Maybe<AuthSignupOriginOriginUnion>;
};

export type AuthSignupOriginCampaign = {
  __typename?: 'AuthSignupOriginCampaign';
  campaign: Scalars['String']['output'];
  content: Scalars['String']['output'];
  creator: Scalars['String']['output'];
  format: Scalars['String']['output'];
  medium: Scalars['String']['output'];
  source: Scalars['String']['output'];
  term: Scalars['String']['output'];
};

export type AuthSignupOriginChannel = {
  __typename?: 'AuthSignupOriginChannel';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
};

export type AuthSignupOriginOriginUnion = AuthSignupOriginCampaign | AuthSignupOriginChannel | AuthSignupOriginPage;

export type AuthSignupOriginPage = {
  __typename?: 'AuthSignupOriginPage';
  url: Scalars['String']['output'];
};

export type AuthTermsVersion = {
  __typename?: 'AuthTermsVersion';
  name: Scalars['String']['output'];
  revision: Scalars['String']['output'];
  signature: Scalars['String']['output'];
};

export type AuthTermsVersionInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
  signature?: InputMaybe<Scalars['String']['input']>;
};

export type AuthV4GetOAuth2ConsentResponse = {
  __typename?: 'AuthV4GetOAuth2ConsentResponse';
  clientId: Scalars['ID']['output'];
  clientName: Scalars['String']['output'];
  scopes: Array<Scalars['String']['output']>;
};

export type AvatarAnimation = {
  __typename?: 'AvatarAnimation';
  category: Array<AvatarAnimationCategory>;
  chatCommand: Scalars['String']['output'];
  config: AvatarAnimationConfig;
  enabled: Scalars['Boolean']['output'];
  glbUrl: Scalars['String']['output'];
  iconUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  mirroredGlbUrl: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export enum AvatarAnimationCategory {
  CategoryAngry = 'CATEGORY_ANGRY',
  CategoryBoosterReceived = 'CATEGORY_BOOSTER_RECEIVED',
  CategoryBoosterRequested = 'CATEGORY_BOOSTER_REQUESTED',
  CategoryBoosterSent = 'CATEGORY_BOOSTER_SENT',
  CategoryCameraDrive = 'CATEGORY_CAMERA_DRIVE',
  CategoryCameraDriveExcited = 'CATEGORY_CAMERA_DRIVE_EXCITED',
  CategoryCardFailure = 'CATEGORY_CARD_FAILURE',
  CategoryCardMaxedOut = 'CATEGORY_CARD_MAXED_OUT',
  CategoryCardSuccess = 'CATEGORY_CARD_SUCCESS',
  CategoryChatMessage = 'CATEGORY_CHAT_MESSAGE',
  CategoryCheer = 'CATEGORY_CHEER',
  CategoryDance = 'CATEGORY_DANCE',
  CategoryDefeat = 'CATEGORY_DEFEAT',
  CategoryEditorIdle = 'CATEGORY_EDITOR_IDLE',
  CategoryEditorPickBody = 'CATEGORY_EDITOR_PICK_BODY',
  CategoryEditorPickFace = 'CATEGORY_EDITOR_PICK_FACE',
  CategoryEditorPickGloves = 'CATEGORY_EDITOR_PICK_GLOVES',
  CategoryEditorPickHat = 'CATEGORY_EDITOR_PICK_HAT',
  CategoryEditorPickJacket = 'CATEGORY_EDITOR_PICK_JACKET',
  CategoryEditorPickPants = 'CATEGORY_EDITOR_PICK_PANTS',
  CategoryEditorPickShoes = 'CATEGORY_EDITOR_PICK_SHOES',
  CategoryEmoji = 'CATEGORY_EMOJI',
  CategoryEmote = 'CATEGORY_EMOTE',
  CategoryExcited = 'CATEGORY_EXCITED',
  CategoryFsInChat = 'CATEGORY_FS_IN_CHAT',
  CategoryIdle = 'CATEGORY_IDLE',
  CategoryMessage = 'CATEGORY_MESSAGE',
  CategoryPhotoPoses = 'CATEGORY_PHOTO_POSES',
  CategoryPlayerExit = 'CATEGORY_PLAYER_EXIT',
  CategoryPlayerJoin = 'CATEGORY_PLAYER_JOIN',
  CategoryPlayerPickCard = 'CATEGORY_PLAYER_PICK_CARD',
  CategoryPlayerSwapCard = 'CATEGORY_PLAYER_SWAP_CARD',
  CategoryPoseConfused = 'CATEGORY_POSE_CONFUSED',
  CategoryPoseCool = 'CATEGORY_POSE_COOL',
  CategoryPoseCrying = 'CATEGORY_POSE_CRYING',
  CategoryPoseDefault = 'CATEGORY_POSE_DEFAULT',
  CategoryPoseJustJoking = 'CATEGORY_POSE_JUST_JOKING',
  CategoryPoseLol = 'CATEGORY_POSE_LOL',
  CategoryPoseLove = 'CATEGORY_POSE_LOVE',
  CategoryPoseNoice = 'CATEGORY_POSE_NOICE',
  CategoryPoseOhno = 'CATEGORY_POSE_OHNO',
  CategoryPoseParty = 'CATEGORY_POSE_PARTY',
  CategoryPoseRage = 'CATEGORY_POSE_RAGE',
  CategoryPoseSad = 'CATEGORY_POSE_SAD',
  CategoryPoseShocked = 'CATEGORY_POSE_SHOCKED',
  CategoryPoseSick = 'CATEGORY_POSE_SICK',
  CategoryPoseSmile = 'CATEGORY_POSE_SMILE',
  CategoryPoseSurprised = 'CATEGORY_POSE_SURPRISED',
  CategoryPoseSweat = 'CATEGORY_POSE_SWEAT',
  CategoryPoseWhoa = 'CATEGORY_POSE_WHOA',
  CategorySad = 'CATEGORY_SAD',
  CategorySpotlightCrowd = 'CATEGORY_SPOTLIGHT_CROWD',
  CategorySpotlightPodium = 'CATEGORY_SPOTLIGHT_PODIUM',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED',
  CategoryVictory = 'CATEGORY_VICTORY',
  CategoryWsInChat = 'CATEGORY_WS_IN_CHAT'
}

export type AvatarAnimationConfig = {
  __typename?: 'AvatarAnimationConfig';
  clamp: Scalars['Boolean']['output'];
  fadeInTimeSec: Scalars['Float']['output'];
  handedness: AvatarAnimationHandedness;
  interruptible: Scalars['Boolean']['output'];
  maxLoops: Scalars['Int']['output'];
  randomizeLoops: Scalars['Boolean']['output'];
};

export enum AvatarAnimationHandedness {
  HandednessBoth = 'HANDEDNESS_BOTH',
  HandednessLeft = 'HANDEDNESS_LEFT',
  HandednessRight = 'HANDEDNESS_RIGHT',
  HandednessUnspecified = 'HANDEDNESS_UNSPECIFIED'
}

export type AvatarAvatar = {
  __typename?: 'AvatarAvatar';
  assets: AvatarAvatarAssets;
  avatar3D: Scalars['String']['output'];
  avatarComposition: AvatarAvatarComposition;
  avatarLods: Array<Scalars['String']['output']>;
  body: Scalars['String']['output'];
  face: Scalars['String']['output'];
  /** todo: remove or use Gender instead */
  gender: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** selectable is used to determine if the avatar is shown in the avatar picker */
  selectable: Scalars['Boolean']['output'];
};

export type AvatarAvatarAssets = {
  __typename?: 'AvatarAvatarAssets';
  images: Array<AvatarAvatarAssetsImage>;
  lods: Array<AvatarAvatarAssetsLod>;
};

export type AvatarAvatarAssetsImage = {
  __typename?: 'AvatarAvatarAssetsImage';
  category: AvatarAvatarAssetsImageCategory;
  url: Scalars['String']['output'];
};

export enum AvatarAvatarAssetsImageCategory {
  CategoryPoseConfused = 'CATEGORY_POSE_CONFUSED',
  CategoryPoseCool = 'CATEGORY_POSE_COOL',
  CategoryPoseCrying = 'CATEGORY_POSE_CRYING',
  CategoryPoseJustJoking = 'CATEGORY_POSE_JUST_JOKING',
  CategoryPoseLol = 'CATEGORY_POSE_LOL',
  CategoryPoseLove = 'CATEGORY_POSE_LOVE',
  CategoryPoseNoice = 'CATEGORY_POSE_NOICE',
  CategoryPoseOhno = 'CATEGORY_POSE_OHNO',
  CategoryPoseParty = 'CATEGORY_POSE_PARTY',
  CategoryPoseRage = 'CATEGORY_POSE_RAGE',
  CategoryPoseSad = 'CATEGORY_POSE_SAD',
  CategoryPoseShocked = 'CATEGORY_POSE_SHOCKED',
  CategoryPoseSick = 'CATEGORY_POSE_SICK',
  CategoryPoseSmile = 'CATEGORY_POSE_SMILE',
  CategoryPoseSurprised = 'CATEGORY_POSE_SURPRISED',
  CategoryPoseSweat = 'CATEGORY_POSE_SWEAT',
  CategoryPoseWhoa = 'CATEGORY_POSE_WHOA',
  CategoryProfileBody = 'CATEGORY_PROFILE_BODY',
  CategoryProfileFace = 'CATEGORY_PROFILE_FACE',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED'
}

export type AvatarAvatarAssetsImageInput = {
  category?: InputMaybe<AvatarAvatarAssetsImageCategory>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type AvatarAvatarAssetsInput = {
  images?: InputMaybe<Array<AvatarAvatarAssetsImageInput>>;
  lods?: InputMaybe<Array<AvatarAvatarAssetsLodInput>>;
};

export type AvatarAvatarAssetsLod = {
  __typename?: 'AvatarAvatarAssetsLod';
  glbUrl: Scalars['String']['output'];
  skeletonType: AvatarAvatarAssetsLodSkeletonType;
};

export type AvatarAvatarAssetsLodInput = {
  glbUrl?: InputMaybe<Scalars['String']['input']>;
  skeletonType?: InputMaybe<AvatarAvatarAssetsLodSkeletonType>;
};

export enum AvatarAvatarAssetsLodSkeletonType {
  SkeletonTypeComplex = 'SKELETON_TYPE_COMPLEX',
  SkeletonTypeSimple = 'SKELETON_TYPE_SIMPLE',
  SkeletonTypeUnspecified = 'SKELETON_TYPE_UNSPECIFIED'
}

export type AvatarAvatarComposition = {
  __typename?: 'AvatarAvatarComposition';
  generatorVersion: Scalars['String']['output'];
  partCustomizations: Array<AvatarAvatarPartCustomization>;
  partIds: Array<Scalars['String']['output']>;
};

export type AvatarAvatarCompositionInput = {
  generatorVersion?: InputMaybe<Scalars['String']['input']>;
  partCustomizations?: InputMaybe<Array<AvatarAvatarPartCustomizationInput>>;
  partIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type AvatarAvatarInput = {
  assets?: InputMaybe<AvatarAvatarAssetsInput>;
  avatar3D?: InputMaybe<Scalars['String']['input']>;
  avatarComposition?: InputMaybe<AvatarAvatarCompositionInput>;
  avatarLods?: InputMaybe<Array<Scalars['String']['input']>>;
  body?: InputMaybe<Scalars['String']['input']>;
  face?: InputMaybe<Scalars['String']['input']>;
  /** todo: remove or use Gender instead */
  gender?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  /** selectable is used to determine if the avatar is shown in the avatar picker */
  selectable?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AvatarAvatarPart = {
  __typename?: 'AvatarAvatarPart';
  category: AvatarAvatarPartCategory;
  categoryOverride: Array<AvatarAvatarPartCategory>;
  channelId: Scalars['ID']['output'];
  clothingSet: Scalars['String']['output'];
  color: Scalars['String']['output'];
  colorPresetOptions: Array<Scalars['String']['output']>;
  colors: Array<Scalars['String']['output']>;
  default: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
  experimental: Scalars['Boolean']['output'];
  gender: AvatarGender;
  glbUrl: Scalars['String']['output'];
  glbUrlOverride?: Maybe<AvatarAvatarPartGlbUrlOverride>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  previewImgUrl: Scalars['String']['output'];
  sellable: Scalars['Boolean']['output'];
  skinData?: Maybe<AvatarAvatarPartSkinData>;
  skinOptions: Array<Scalars['String']['output']>;
  uniqueBootstrap: Scalars['Boolean']['output'];
  url: Scalars['String']['output'];
  userDefault: Scalars['Boolean']['output'];
};

export enum AvatarAvatarPartCategory {
  CategoryBeard = 'CATEGORY_BEARD',
  CategoryBody = 'CATEGORY_BODY',
  CategoryColorPreset = 'CATEGORY_COLOR_PRESET',
  CategoryEyebrows = 'CATEGORY_EYEBROWS',
  CategoryEyebrowsColor = 'CATEGORY_EYEBROWS_COLOR',
  CategoryEyelashes = 'CATEGORY_EYELASHES',
  CategoryEyelashesColor = 'CATEGORY_EYELASHES_COLOR',
  CategoryEyes = 'CATEGORY_EYES',
  CategoryFaceItem = 'CATEGORY_FACE_ITEM',
  CategoryHair = 'CATEGORY_HAIR',
  CategoryHairColor = 'CATEGORY_HAIR_COLOR',
  CategoryHands = 'CATEGORY_HANDS',
  CategoryHead = 'CATEGORY_HEAD',
  CategoryHeadItem = 'CATEGORY_HEAD_ITEM',
  CategoryLegs = 'CATEGORY_LEGS',
  CategoryShoes = 'CATEGORY_SHOES',
  CategorySkin = 'CATEGORY_SKIN',
  CategorySkinColor = 'CATEGORY_SKIN_COLOR',
  CategoryTeeth = 'CATEGORY_TEETH',
  CategoryTorso = 'CATEGORY_TORSO',
  CategoryUnspecified = 'CATEGORY_UNSPECIFIED'
}

export type AvatarAvatarPartCustomization = {
  __typename?: 'AvatarAvatarPartCustomization';
  colorPreset: Scalars['String']['output'];
  partId: Scalars['ID']['output'];
  skin: Scalars['String']['output'];
};

export type AvatarAvatarPartCustomizationInput = {
  colorPreset?: InputMaybe<Scalars['String']['input']>;
  partId?: InputMaybe<Scalars['ID']['input']>;
  skin?: InputMaybe<Scalars['String']['input']>;
};

export type AvatarAvatarPartGlbUrlOverride = {
  __typename?: 'AvatarAvatarPartGlbURLOverride';
  category: AvatarAvatarPartCategory;
  glbUrl: Scalars['String']['output'];
};

export type AvatarAvatarPartSkinData = {
  __typename?: 'AvatarAvatarPartSkinData';
  baseMapUrl: Scalars['String']['output'];
  emissionMapUrl: Scalars['String']['output'];
  normalMapUrl: Scalars['String']['output'];
  ormMapUrl: Scalars['String']['output'];
};

export type AvatarBatchGetAnimationsResponse = {
  __typename?: 'AvatarBatchGetAnimationsResponse';
  animations: Array<AvatarAnimation>;
};

export type AvatarBatchGetAvatarPartsResponse = {
  __typename?: 'AvatarBatchGetAvatarPartsResponse';
  avatarParts: Array<AvatarAvatarPart>;
};

export type AvatarBatchGetAvatarsResponse = {
  __typename?: 'AvatarBatchGetAvatarsResponse';
  avatars: Array<AvatarAvatar>;
};

export enum AvatarGender {
  GenderFemale = 'GENDER_FEMALE',
  GenderMale = 'GENDER_MALE',
  GenderUnspecified = 'GENDER_UNSPECIFIED'
}

export type AvatarListAnimationsResponse = {
  __typename?: 'AvatarListAnimationsResponse';
  animations: Array<AvatarAnimation>;
};

export type AvatarListAvatarPartsResponse = {
  __typename?: 'AvatarListAvatarPartsResponse';
  avatarParts: Array<AvatarAvatarPart>;
};

export type AvatarListAvatarsResponse = {
  __typename?: 'AvatarListAvatarsResponse';
  avatars: Array<AvatarAvatar>;
  pageInfo: ApiPageInfo;
};

export type AvatarValidateAvatarCompositionResponse = {
  __typename?: 'AvatarValidateAvatarCompositionResponse';
  changes: Array<AvatarValidateAvatarCompositionResponseChange>;
  composition: AvatarAvatarComposition;
  /** @deprecated field is deprecated */
  duplicatePartIds: Array<Scalars['String']['output']>;
  isDefault: Scalars['Boolean']['output'];
  /** @deprecated field is deprecated */
  missingPartCategories: Array<AvatarAvatarPartCategory>;
  /** @deprecated field is deprecated */
  missingPartIds: Array<Scalars['String']['output']>;
};

export type AvatarValidateAvatarCompositionResponseChange = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChange';
  action?: Maybe<AvatarValidateAvatarCompositionResponseChangeActionUnion>;
};

export type AvatarValidateAvatarCompositionResponseChangeActionUnion = AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded | AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved | AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced;

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartAdded';
  id: Scalars['ID']['output'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
};

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartRemoved';
  id: Scalars['ID']['output'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
};

export type AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced = {
  __typename?: 'AvatarValidateAvatarCompositionResponseChangeAvatarPartReplaced';
  id: Scalars['ID']['output'];
  reason: AvatarValidateAvatarCompositionResponseChangeReason;
  replacementId: Scalars['ID']['output'];
};

export enum AvatarValidateAvatarCompositionResponseChangeReason {
  ReasonAvatarPartBodyRequired = 'REASON_AVATAR_PART_BODY_REQUIRED',
  ReasonAvatarPartEyesRequired = 'REASON_AVATAR_PART_EYES_REQUIRED',
  ReasonAvatarPartHeadRequired = 'REASON_AVATAR_PART_HEAD_REQUIRED',
  ReasonAvatarPartLegsRequired = 'REASON_AVATAR_PART_LEGS_REQUIRED',
  ReasonAvatarPartTorsoRequired = 'REASON_AVATAR_PART_TORSO_REQUIRED',
  ReasonAvatarPartUnavailable = 'REASON_AVATAR_PART_UNAVAILABLE',
  ReasonAvatarPartUnknown = 'REASON_AVATAR_PART_UNKNOWN',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type BadgeBadge = {
  __typename?: 'BadgeBadge';
  level: Scalars['Int']['output'];
  nextLevelAt: Scalars['Timestamp']['output'];
  type: BadgeBadgeType;
};

export enum BadgeBadgeType {
  TypeChannelModerator = 'TYPE_CHANNEL_MODERATOR',
  TypeChannelSubscriber = 'TYPE_CHANNEL_SUBSCRIBER',
  TypeClosedBetaCreator = 'TYPE_CLOSED_BETA_CREATOR',
  TypeNoiceStaff = 'TYPE_NOICE_STAFF',
  TypeStreamer = 'TYPE_STREAMER',
  TypeSubsGifter = 'TYPE_SUBS_GIFTER',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type BadgeBatchGetUserBadgesResponse = {
  __typename?: 'BadgeBatchGetUserBadgesResponse';
  badges: Array<BadgeUserBadges>;
};

export type BadgeGetUserBadgesResponse = {
  __typename?: 'BadgeGetUserBadgesResponse';
  badges: Array<BadgeBadge>;
};

export type BadgeUserBadges = {
  __typename?: 'BadgeUserBadges';
  badges: Array<BadgeBadge>;
  userId: Scalars['ID']['output'];
};

export type BooleanType = {
  __typename?: 'BooleanType';
  /** The wrapped value of type Boolean */
  value: Scalars['Boolean']['output'];
};

export type ChallengeChallengeReward = {
  __typename?: 'ChallengeChallengeReward';
  gameId: Scalars['ID']['output'];
  maxPickRate: Scalars['Int']['output'];
  minPickRate: Scalars['Int']['output'];
  reward: RewardRewardType;
};

export type ChallengeChallengeUpdateInput = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChallengeGetChallengeRewardsResponse = {
  __typename?: 'ChallengeGetChallengeRewardsResponse';
  rewards: Array<ChallengeChallengeReward>;
};

export type ChallengeListChallengesResponse = {
  __typename?: 'ChallengeListChallengesResponse';
  challenges: Array<GameLogicChallenge>;
};

export type ChallengesessionChallenge = {
  __typename?: 'ChallengesessionChallenge';
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  sessionId: Scalars['ID']['output'];
  state: ChallengesessionChallengeChallengeState;
};

export enum ChallengesessionChallengeChallengeState {
  ChallengeStateFailed = 'CHALLENGE_STATE_FAILED',
  ChallengeStateSucceeded = 'CHALLENGE_STATE_SUCCEEDED',
  ChallengeStateUnresolved = 'CHALLENGE_STATE_UNRESOLVED',
  ChallengeStateUnspecified = 'CHALLENGE_STATE_UNSPECIFIED'
}

export type ChallengesessionChallengeInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  sessionId?: InputMaybe<Scalars['ID']['input']>;
  state?: InputMaybe<ChallengesessionChallengeChallengeState>;
};

export type ChallengesessionChallengePick = {
  __typename?: 'ChallengesessionChallengePick';
  challengeId: Scalars['ID']['output'];
  sessionId: Scalars['ID']['output'];
  stake: ChallengesessionStake;
  userId: Scalars['ID']['output'];
};

export type ChallengesessionChallengeSession = {
  __typename?: 'ChallengesessionChallengeSession';
  challenges: Array<ChallengesessionChallenge>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  phase: ChallengesessionChallengeSessionPhase;
  streamId: Scalars['ID']['output'];
  submissionDeadline: Scalars['Timestamp']['output'];
  submissionWindowLength: Scalars['Int']['output'];
};

export type ChallengesessionChallengeSessionEvent = {
  __typename?: 'ChallengesessionChallengeSessionEvent';
  event?: Maybe<ChallengesessionChallengeSessionEventEventUnion>;
  streamId: Scalars['ID']['output'];
};

export type ChallengesessionChallengeSessionEventChallengeStatusChange = {
  __typename?: 'ChallengesessionChallengeSessionEventChallengeStatusChange';
  challenge: ChallengesessionChallenge;
  sessionId: Scalars['ID']['output'];
};

export type ChallengesessionChallengeSessionEventEventUnion = ChallengesessionChallengeSessionEventChallengeStatusChange | ChallengesessionChallengeSessionEventInitial | ChallengesessionChallengeSessionEventPhaseChange | ChallengesessionChallengeSessionEventStakeChange;

export type ChallengesessionChallengeSessionEventInitial = {
  __typename?: 'ChallengesessionChallengeSessionEventInitial';
  session: ChallengesessionChallengeSession;
  stats: Array<ChallengesessionChallengeStats>;
  userPick: ChallengesessionChallengePick;
};

export type ChallengesessionChallengeSessionEventPhaseChange = {
  __typename?: 'ChallengesessionChallengeSessionEventPhaseChange';
  session: ChallengesessionChallengeSession;
};

export type ChallengesessionChallengeSessionEventStakeChange = {
  __typename?: 'ChallengesessionChallengeSessionEventStakeChange';
  sessionId: Scalars['ID']['output'];
  stats: Array<ChallengesessionChallengeStats>;
};

export enum ChallengesessionChallengeSessionPhase {
  PhaseActive = 'PHASE_ACTIVE',
  PhaseCancelled = 'PHASE_CANCELLED',
  PhaseCompleted = 'PHASE_COMPLETED',
  PhaseDraft = 'PHASE_DRAFT',
  PhaseSubmission = 'PHASE_SUBMISSION',
  PhaseUnspecified = 'PHASE_UNSPECIFIED'
}

export type ChallengesessionChallengeSessionUpdateInput = {
  challenges?: InputMaybe<Array<ChallengesessionChallengeInput>>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
  submissionWindowLength?: InputMaybe<Scalars['Int']['input']>;
};

export type ChallengesessionChallengeStats = {
  __typename?: 'ChallengesessionChallengeStats';
  challengeId: Scalars['ID']['output'];
  highestStakePick: ChallengesessionChallengePick;
  sessionId: Scalars['ID']['output'];
  totalPicks: Scalars['Int']['output'];
  totalStake: ChallengesessionStake;
};

export type ChallengesessionStake = {
  __typename?: 'ChallengesessionStake';
  currencyAmount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
};

export type ChallengesessionStakeInput = {
  currencyAmount?: InputMaybe<Scalars['Int']['input']>;
  currencyId?: InputMaybe<Scalars['ID']['input']>;
};

export enum ChannelAppealStatus {
  AppealStatusAccepted = 'APPEAL_STATUS_ACCEPTED',
  AppealStatusDeclined = 'APPEAL_STATUS_DECLINED',
  AppealStatusPending = 'APPEAL_STATUS_PENDING',
  AppealStatusUnspecified = 'APPEAL_STATUS_UNSPECIFIED'
}

export enum ChannelAssetType {
  AssetTypeBanner = 'ASSET_TYPE_BANNER',
  AssetTypeLogo = 'ASSET_TYPE_LOGO',
  AssetTypeUnspecified = 'ASSET_TYPE_UNSPECIFIED'
}

export type ChannelAutomodItemAccepted = {
  __typename?: 'ChannelAutomodItemAccepted';
  message: ChatMessageContent;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelAutomodItemRejected = {
  __typename?: 'ChannelAutomodItemRejected';
  message: ChatMessageContent;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelAutomodSettings = {
  __typename?: 'ChannelAutomodSettings';
  defaultDecision: ChatAutomodDecision;
  level: ChatAutomodLevel;
};

export type ChannelAutomodSettingsInput = {
  defaultDecision?: InputMaybe<ChatAutomodDecision>;
  level?: InputMaybe<ChatAutomodLevel>;
};

export type ChannelAvatarItemPurchase = {
  __typename?: 'ChannelAvatarItemPurchase';
  item: ItemItem;
  itemId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelBanAppeal = {
  __typename?: 'ChannelBanAppeal';
  appealText: Scalars['String']['output'];
  bannedAt: Scalars['Timestamp']['output'];
  channelId: Scalars['ID']['output'];
  createdAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  moderatorId: Scalars['ID']['output'];
  reviewerComment: Scalars['String']['output'];
  reviewerId: Scalars['ID']['output'];
  status: ChannelAppealStatus;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelBanAppealAccepted = {
  __typename?: 'ChannelBanAppealAccepted';
  comment: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelBanAppealInfo = {
  __typename?: 'ChannelBanAppealInfo';
  appealText: Scalars['String']['output'];
  channelId: Scalars['ID']['output'];
  createdAt: Scalars['Timestamp']['output'];
  reviewer: ProfileProfile;
  reviewerComment: Scalars['String']['output'];
  reviewerId: Scalars['ID']['output'];
  status: ChannelAppealStatus;
  userId: Scalars['ID']['output'];
};

export type ChannelBanAppealRejected = {
  __typename?: 'ChannelBanAppealRejected';
  comment: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelBannedUser = {
  __typename?: 'ChannelBannedUser';
  appeal?: Maybe<ChannelBanAppealInfo>;
  bannedAt: Scalars['Timestamp']['output'];
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  keepRecentMessages: Scalars['Boolean']['output'];
  moderator: ProfileProfile;
  moderatorId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelBatchGetChannelsResponse = {
  __typename?: 'ChannelBatchGetChannelsResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelBatchGetGameStatsResponse = {
  __typename?: 'ChannelBatchGetGameStatsResponse';
  gameStats: Array<ChannelGameStats>;
};

export type ChannelBatchGetStreamSummaryResponse = {
  __typename?: 'ChannelBatchGetStreamSummaryResponse';
  summaries: Array<ChannelStreamSummary>;
};

export type ChannelBatchGetUserBanStatusResponse = {
  __typename?: 'ChannelBatchGetUserBanStatusResponse';
  statuses: Array<ChannelUserBanStatus>;
};

export type ChannelBatchStreamGetChannelResponse = {
  __typename?: 'ChannelBatchStreamGetChannelResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelBundlePurchase = {
  __typename?: 'ChannelBundlePurchase';
  bundleName: Scalars['String']['output'];
  streamerCardIds: Array<Scalars['String']['output']>;
  streamerCards?: Maybe<Array<GameLogicStreamerCard>>;
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelChallengesFeatureStatus = {
  __typename?: 'ChannelChallengesFeatureStatus';
  enabled: Scalars['Boolean']['output'];
};

/** Public channel information */
export type ChannelChannel = {
  __typename?: 'ChannelChannel';
  activeStream?: Maybe<ChannelStreamSummary>;
  channelFriends: FriendsChannelFriends;
  createdAt: Scalars['Timestamp']['output'];
  currentChatId?: Maybe<Scalars['String']['output']>;
  currentStream?: Maybe<ChannelStream>;
  currentStreamId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  features: ChannelChannelFeatures;
  followerCount: Scalars['Int']['output'];
  following: Scalars['Boolean']['output'];
  game: GameGame;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  isPublic: Scalars['Boolean']['output'];
  itemStats: Array<ItemItemStat>;
  links: Array<ChannelChannelLink>;
  liveStatus: ChannelLiveStatus;
  logo: Scalars['String']['output'];
  matchOngoing: Scalars['Boolean']['output'];
  matureRatedContent: Scalars['Boolean']['output'];
  monetizationSettings: ChannelMonetizationSettings;
  name: Scalars['String']['output'];
  offlineBanner: Scalars['String']['output'];
  offlineBannerUrl: Scalars['String']['output'];
  playedGameIds: Array<Scalars['String']['output']>;
  priority: Scalars['Int']['output'];
  reportingId: Scalars['ID']['output'];
  riskTier: ChannelRiskTier;
  state: ApiEntityState;
  streamedGames?: Maybe<Array<GameGame>>;
  streamer: ProfileProfile;
  streamerId: Scalars['ID']['output'];
  subscriberCount: Scalars['Int']['output'];
  subscription?: Maybe<SubscriptionChannelSubscription>;
  subscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  suspension: ChannelSuspension;
  thumbnail: Scalars['String']['output'];
  title: Scalars['String']['output'];
  userBanStatus: ChannelUserBanStatus;
  viewerCount: Scalars['Int']['output'];
};

export type ChannelChannelCreationEligibility = {
  __typename?: 'ChannelChannelCreationEligibility';
  canCreateChannel: Scalars['Boolean']['output'];
};

export type ChannelChannelDetailsUpdateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  featureChallengesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  featureNoicePredictionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  links?: InputMaybe<Array<ChannelChannelLinkInput>>;
  matureRatedContent?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  riskTier?: InputMaybe<ChannelRiskTier>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelChannelEvent = {
  __typename?: 'ChannelChannelEvent';
  channelId: Scalars['ID']['output'];
  content: ChannelChannelEventContent;
  createdAt: Scalars['Timestamp']['output'];
  id: Scalars['ID']['output'];
};

export type ChannelChannelEventContent = {
  __typename?: 'ChannelChannelEventContent';
  content?: Maybe<ChannelChannelEventContentContentUnion>;
};

export type ChannelChannelEventContentContentUnion = ChannelAvatarItemPurchase | ChannelBundlePurchase | ChannelGiftSubscriptionPurchase | ChannelStreamerCardPurchase | ChannelSubscriptionPurchase | ChannelSubscriptionRenewal;

export enum ChannelChannelFeature {
  ChannelFeatureChallenges = 'CHANNEL_FEATURE_CHALLENGES',
  ChannelFeatureNoicePredictions = 'CHANNEL_FEATURE_NOICE_PREDICTIONS',
  ChannelFeatureStreaming = 'CHANNEL_FEATURE_STREAMING',
  ChannelFeatureUnspecified = 'CHANNEL_FEATURE_UNSPECIFIED'
}

export type ChannelChannelFeatures = {
  __typename?: 'ChannelChannelFeatures';
  challenges: ChannelChallengesFeatureStatus;
  noicePredictions: ChannelNoicePredictionsFeatureStatus;
  streaming: ChannelStreamingFeatureStatus;
};

export type ChannelChannelLink = {
  __typename?: 'ChannelChannelLink';
  name: Scalars['String']['output'];
  type: ChannelChannelLinkLinkType;
  url: Scalars['String']['output'];
};

export type ChannelChannelLinkInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ChannelChannelLinkLinkType>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export enum ChannelChannelLinkLinkType {
  LinkTypeCustom = 'LINK_TYPE_CUSTOM',
  LinkTypeDiscord = 'LINK_TYPE_DISCORD',
  LinkTypeFacebook = 'LINK_TYPE_FACEBOOK',
  LinkTypeInstagram = 'LINK_TYPE_INSTAGRAM',
  LinkTypeTiktok = 'LINK_TYPE_TIKTOK',
  LinkTypeTwitter = 'LINK_TYPE_TWITTER',
  LinkTypeUnspecified = 'LINK_TYPE_UNSPECIFIED',
  LinkTypeYoutube = 'LINK_TYPE_YOUTUBE'
}

export enum ChannelChannelRole {
  ChannelRoleModerator = 'CHANNEL_ROLE_MODERATOR',
  ChannelRolePlatformModerator = 'CHANNEL_ROLE_PLATFORM_MODERATOR',
  ChannelRoleStreamer = 'CHANNEL_ROLE_STREAMER',
  ChannelRoleUnspecified = 'CHANNEL_ROLE_UNSPECIFIED'
}

export type ChannelChannelRoles = {
  __typename?: 'ChannelChannelRoles';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  roles: Array<ChannelChannelRole>;
};

export type ChannelChannelStreamDetailEvent = {
  __typename?: 'ChannelChannelStreamDetailEvent';
  challengesEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  liveStatus: ChannelLiveStatus;
  matureRatedContent: Scalars['Boolean']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  serverRenderingEnabled: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
  transcodingEnabled: Scalars['Boolean']['output'];
};

export type ChannelContentRendererConfig = {
  __typename?: 'ChannelContentRendererConfig';
  arenaId: Scalars['ID']['output'];
  containerImage: Scalars['String']['output'];
  controllerContainerImage: Scalars['String']['output'];
};

export type ChannelContentRendererConfigInput = {
  arenaId?: InputMaybe<Scalars['ID']['input']>;
  containerImage?: InputMaybe<Scalars['String']['input']>;
  controllerContainerImage?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelCreateChannelAssetUploadTokenResponse = {
  __typename?: 'ChannelCreateChannelAssetUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type ChannelFollowerCountEvent = {
  __typename?: 'ChannelFollowerCountEvent';
  channelId: Scalars['ID']['output'];
  followerCount: Scalars['Int']['output'];
};

export type ChannelFollowerNotificationSettings = {
  __typename?: 'ChannelFollowerNotificationSettings';
  channelId: Scalars['ID']['output'];
  channelLiveNotificationEnabled: Scalars['Boolean']['output'];
  userId: Scalars['ID']['output'];
};

export type ChannelGameStats = {
  __typename?: 'ChannelGameStats';
  game: GameGame;
  gameId: Scalars['ID']['output'];
  liveStreams: Scalars['Int']['output'];
};

export enum ChannelGender {
  GenderFemale = 'GENDER_FEMALE',
  GenderMale = 'GENDER_MALE',
  GenderUnspecified = 'GENDER_UNSPECIFIED'
}

export type ChannelGetChannelFollowerStatusResponse = {
  __typename?: 'ChannelGetChannelFollowerStatusResponse';
  followedAt?: Maybe<Scalars['Timestamp']['output']>;
  following: Scalars['Boolean']['output'];
};

export type ChannelGetFollowStatusResponse = {
  __typename?: 'ChannelGetFollowStatusResponse';
  following: Array<Scalars['Boolean']['output']>;
};

export type ChannelGetUserFollowedChannelsResponse = {
  __typename?: 'ChannelGetUserFollowedChannelsResponse';
  channels: Array<ChannelChannel>;
  pageInfo: ApiPageInfo;
};

export type ChannelGiftSubscriptionPurchase = {
  __typename?: 'ChannelGiftSubscriptionPurchase';
  recipientUserIds: Array<Scalars['String']['output']>;
  recipients?: Maybe<Array<ProfileProfile>>;
  tier: Scalars['Int']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelIngestStatsEvent = {
  __typename?: 'ChannelIngestStatsEvent';
  audioChannelCnt: Scalars['Int']['output'];
  audioSampleRate: Scalars['Int']['output'];
  bSlices: Scalars['Int']['output'];
  bitrate: Scalars['Int']['output'];
  channelId: Scalars['ID']['output'];
  framerate: Scalars['Int']['output'];
  height: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  width: Scalars['Int']['output'];
};

export type ChannelListBanAppealsResponse = {
  __typename?: 'ChannelListBanAppealsResponse';
  appeals: Array<ChannelBanAppeal>;
  pageInfo: ApiPageInfo;
};

export type ChannelListBannedUsersResponse = {
  __typename?: 'ChannelListBannedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<ChannelBannedUser>;
};

export type ChannelListChannelPrivilegedUsersResponse = {
  __typename?: 'ChannelListChannelPrivilegedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<ChannelPrivilegedUser>;
};

export type ChannelListChannelsResponse = {
  __typename?: 'ChannelListChannelsResponse';
  channels: Array<ChannelChannel>;
  pageInfo: ApiPageInfo;
};

export type ChannelListGameStatsRequestFilterInput = {
  live?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelListGameStatsResponse = {
  __typename?: 'ChannelListGameStatsResponse';
  games: Array<ChannelGameStats>;
  pageInfo: ApiPageInfo;
};

export type ChannelListHighlightedChannelsResponse = {
  __typename?: 'ChannelListHighlightedChannelsResponse';
  channels: Array<ChannelChannel>;
};

export type ChannelListModerationEventsResponse = {
  __typename?: 'ChannelListModerationEventsResponse';
  events: Array<ChannelModerationEvent>;
  pageInfo: ApiPageInfo;
};

export type ChannelListStreamBackendConfigsResponse = {
  __typename?: 'ChannelListStreamBackendConfigsResponse';
  configs: Array<ChannelStreamBackendConfig>;
};

export type ChannelListStreamsResponse = {
  __typename?: 'ChannelListStreamsResponse';
  pageInfo: ApiPageInfo;
  streams: Array<ChannelStream>;
};

export type ChannelListUserChannelBansResponse = {
  __typename?: 'ChannelListUserChannelBansResponse';
  bans: Array<ChannelBannedUser>;
  pageInfo: ApiPageInfo;
};

export type ChannelListUserChannelRolesResponse = {
  __typename?: 'ChannelListUserChannelRolesResponse';
  roles: Array<ChannelChannelRole>;
};

export type ChannelListUserPrivilegedChannelsResponse = {
  __typename?: 'ChannelListUserPrivilegedChannelsResponse';
  channels: Array<ChannelChannelRoles>;
};

export enum ChannelLiveStatus {
  LiveStatusLive = 'LIVE_STATUS_LIVE',
  LiveStatusOffline = 'LIVE_STATUS_OFFLINE',
  LiveStatusUnlisted = 'LIVE_STATUS_UNLISTED',
  LiveStatusUnspecified = 'LIVE_STATUS_UNSPECIFIED'
}

export type ChannelLiveStatusEvent = {
  __typename?: 'ChannelLiveStatusEvent';
  channelId: Scalars['ID']['output'];
  liveStatus: ChannelLiveStatus;
  streamId: Scalars['ID']['output'];
};

export type ChannelMachineLearningConfig = {
  __typename?: 'ChannelMachineLearningConfig';
  containerImage: Scalars['String']['output'];
  disabled: Scalars['Boolean']['output'];
};

export type ChannelMachineLearningConfigInput = {
  containerImage?: InputMaybe<Scalars['String']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelModerationEvent = {
  __typename?: 'ChannelModerationEvent';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  content: ChannelModerationEventContent;
  id: Scalars['ID']['output'];
  moderator?: Maybe<ProfileProfile>;
  moderatorId: Scalars['ID']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

export type ChannelModerationEventContent = {
  __typename?: 'ChannelModerationEventContent';
  content?: Maybe<ChannelModerationEventContentContentUnion>;
};

export type ChannelModerationEventContentContentUnion = ChannelAutomodItemAccepted | ChannelAutomodItemRejected | ChannelBanAppealAccepted | ChannelBanAppealRejected | ChannelUserBanned | ChannelUserMuted | ChannelUserUnbanned;

export enum ChannelModerationEventType {
  ModerationEventTypeAutomodItemAccepted = 'MODERATION_EVENT_TYPE_AUTOMOD_ITEM_ACCEPTED',
  ModerationEventTypeAutomodItemRejected = 'MODERATION_EVENT_TYPE_AUTOMOD_ITEM_REJECTED',
  ModerationEventTypeBanAppealAccepted = 'MODERATION_EVENT_TYPE_BAN_APPEAL_ACCEPTED',
  ModerationEventTypeBanAppealRejected = 'MODERATION_EVENT_TYPE_BAN_APPEAL_REJECTED',
  ModerationEventTypeUnspecified = 'MODERATION_EVENT_TYPE_UNSPECIFIED',
  ModerationEventTypeUserBanned = 'MODERATION_EVENT_TYPE_USER_BANNED',
  ModerationEventTypeUserMuted = 'MODERATION_EVENT_TYPE_USER_MUTED',
  ModerationEventTypeUserUnbanned = 'MODERATION_EVENT_TYPE_USER_UNBANNED'
}

export type ChannelModerationEventsFilterInput = {
  eventTypes?: InputMaybe<Array<ChannelModerationEventType>>;
};

export type ChannelModerationSettings = {
  __typename?: 'ChannelModerationSettings';
  automod: ChannelAutomodSettings;
  banAppealsEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
};

export type ChannelModerationSettingsInput = {
  automod?: InputMaybe<ChannelAutomodSettingsInput>;
  banAppealsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChannelMonetizationSettings = {
  __typename?: 'ChannelMonetizationSettings';
  channelId: Scalars['ID']['output'];
  eligible: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
};

export type ChannelMonetizationSettingsInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  eligible?: InputMaybe<Scalars['Boolean']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelNoicePredictionsFeatureStatus = {
  __typename?: 'ChannelNoicePredictionsFeatureStatus';
  enabled: Scalars['Boolean']['output'];
};

export type ChannelNotificationSettings = {
  __typename?: 'ChannelNotificationSettings';
  channelLiveNotification: ChannelNotificationStatus;
  userId: Scalars['ID']['output'];
};

export type ChannelNotificationStatus = {
  __typename?: 'ChannelNotificationStatus';
  emailEnabled: Scalars['Boolean']['output'];
  pushEnabled: Scalars['Boolean']['output'];
};

export type ChannelNotificationStatusInput = {
  emailEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  pushEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChannelPrivilegedUser = {
  __typename?: 'ChannelPrivilegedUser';
  roles: Array<ChannelChannelRole>;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelRestreamingConfig = {
  __typename?: 'ChannelRestreamingConfig';
  bitrate: Scalars['Int']['output'];
  channelId: Scalars['ID']['output'];
  enabled: Scalars['Boolean']['output'];
  rtmpEndpoint: Scalars['String']['output'];
  rtmpKey: Scalars['String']['output'];
};

export type ChannelRestreamingConfigInput = {
  bitrate?: InputMaybe<Scalars['Int']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  rtmpEndpoint?: InputMaybe<Scalars['String']['input']>;
  rtmpKey?: InputMaybe<Scalars['String']['input']>;
};

export enum ChannelRiskTier {
  RiskTier_0 = 'RISK_TIER_0',
  RiskTier_1 = 'RISK_TIER_1',
  RiskTier_2 = 'RISK_TIER_2',
  RiskTierUnspecified = 'RISK_TIER_UNSPECIFIED'
}

export type ChannelStream = {
  __typename?: 'ChannelStream';
  challengesEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
  matureRatedContent: Scalars['Boolean']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  segments: Array<ChannelStreamSegment>;
  serverRenderingEnabled: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
  transcodingEnabled: Scalars['Boolean']['output'];
};

export type ChannelStreamBackendConfig = {
  __typename?: 'ChannelStreamBackendConfig';
  channelId: Scalars['ID']['output'];
  crConfig?: Maybe<ChannelContentRendererConfig>;
  game: GameGame;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  mlConfig?: Maybe<ChannelMachineLearningConfig>;
  recConfig?: Maybe<ChannelStreamRecorderConfig>;
  transcoderConfig?: Maybe<ChannelStreamTranscoderConfig>;
};

export type ChannelStreamBackendConfigInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  crConfig?: InputMaybe<ChannelContentRendererConfigInput>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  mlConfig?: InputMaybe<ChannelMachineLearningConfigInput>;
  recConfig?: InputMaybe<ChannelStreamRecorderConfigInput>;
  transcoderConfig?: InputMaybe<ChannelStreamTranscoderConfigInput>;
};

export type ChannelStreamRecorderConfig = {
  __typename?: 'ChannelStreamRecorderConfig';
  containerImage: Scalars['String']['output'];
};

export type ChannelStreamRecorderConfigInput = {
  containerImage?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelStreamSegment = {
  __typename?: 'ChannelStreamSegment';
  crConfig: ChannelContentRendererConfig;
  endTime?: Maybe<Scalars['Timestamp']['output']>;
  gameId: Scalars['ID']['output'];
  mlConfig: ChannelMachineLearningConfig;
  segmentId: Scalars['ID']['output'];
  startTime: Scalars['Timestamp']['output'];
  title: Scalars['String']['output'];
};

export type ChannelStreamStatusEvent = {
  __typename?: 'ChannelStreamStatusEvent';
  channelId: Scalars['ID']['output'];
  crStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  egressStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  gameRunnerStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  liveStatus: ChannelLiveStatus;
  mlStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  recStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  restreamingStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
  streamId: Scalars['ID']['output'];
  transcoderStatus: StreamDeploymentStreamDeploymentStatusComponentStatus;
};

export type ChannelStreamSummary = {
  __typename?: 'ChannelStreamSummary';
  challengesEnabled: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
  endTime?: Maybe<Scalars['Timestamp']['output']>;
  gameId: Scalars['ID']['output'];
  matureRatedContent: Scalars['Boolean']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  serverRenderingEnabled: Scalars['Boolean']['output'];
  startTime: Scalars['Timestamp']['output'];
  streamId: Scalars['ID']['output'];
  transcodingEnabled: Scalars['Boolean']['output'];
};

export type ChannelStreamTranscoderConfig = {
  __typename?: 'ChannelStreamTranscoderConfig';
  containerImage: Scalars['String']['output'];
};

export type ChannelStreamTranscoderConfigInput = {
  containerImage?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelStreamerCardPurchase = {
  __typename?: 'ChannelStreamerCardPurchase';
  streamerCard: GameLogicStreamerCard;
  streamerCardId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelStreamingFeatureStatus = {
  __typename?: 'ChannelStreamingFeatureStatus';
  enabled: Scalars['Boolean']['output'];
  suspension?: Maybe<ChannelSuspension>;
};

export type ChannelSubscriptionPurchase = {
  __typename?: 'ChannelSubscriptionPurchase';
  tier: Scalars['Int']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ChannelSubscriptionRenewal = {
  __typename?: 'ChannelSubscriptionRenewal';
  tier: Scalars['Int']['output'];
  userId: Scalars['ID']['output'];
};

export type ChannelSuspension = {
  __typename?: 'ChannelSuspension';
  description: Scalars['String']['output'];
  moderator?: Maybe<ProfileProfile>;
  reason: ChannelSuspensionReason;
  suspendedAt: Scalars['Timestamp']['output'];
  suspendedBy: Scalars['String']['output'];
  until?: Maybe<Scalars['Timestamp']['output']>;
};

export enum ChannelSuspensionReason {
  ReasonChannelDeleted = 'REASON_CHANNEL_DELETED',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type ChannelUpdateFollowerNotificationSettingsParamsInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  channelLiveNotificationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChannelUpdateNotificationSettingsParamsInput = {
  channelLiveNotification?: InputMaybe<ChannelNotificationStatusInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChannelUserBanStatus = {
  __typename?: 'ChannelUserBanStatus';
  appeal?: Maybe<ChannelBanAppealInfo>;
  banned: Scalars['Boolean']['output'];
  bannedAt?: Maybe<Scalars['Timestamp']['output']>;
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  moderator?: Maybe<ProfileProfile>;
  moderatorId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelUserBanned = {
  __typename?: 'ChannelUserBanned';
  description: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelUserBannedNotification = {
  __typename?: 'ChannelUserBannedNotification';
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  moderatorId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
  violation: ChannelViolation;
};

export type ChannelUserMuted = {
  __typename?: 'ChannelUserMuted';
  description: Scalars['String']['output'];
  duration: Scalars['Duration']['output'];
  reason: ChatReason;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelUserUnbanned = {
  __typename?: 'ChannelUserUnbanned';
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChannelViewerCountEvent = {
  __typename?: 'ChannelViewerCountEvent';
  channelId: Scalars['ID']['output'];
  viewerCount: Scalars['Int']['output'];
};

export enum ChannelViolation {
  ViolationOther = 'VIOLATION_OTHER',
  ViolationSpam = 'VIOLATION_SPAM',
  ViolationUnspecified = 'VIOLATION_UNSPECIFIED'
}

export type ChatAutoModQueueEvent = {
  __typename?: 'ChatAutoModQueueEvent';
  event?: Maybe<ChatAutoModQueueEventEventUnion>;
};

export type ChatAutoModQueueEventAdd = {
  __typename?: 'ChatAutoModQueueEventAdd';
  item: ChatModerationItem;
};

export type ChatAutoModQueueEventEventUnion = ChatAutoModQueueEventAdd | ChatAutoModQueueEventRemove | ChatAutoModQueueEventUpdate;

export type ChatAutoModQueueEventRemove = {
  __typename?: 'ChatAutoModQueueEventRemove';
  id: Scalars['ID']['output'];
};

export type ChatAutoModQueueEventUpdate = {
  __typename?: 'ChatAutoModQueueEventUpdate';
  item: ChatModerationItem;
};

export enum ChatAutomodDecision {
  AutomodDecisionAccepted = 'AUTOMOD_DECISION_ACCEPTED',
  AutomodDecisionRejected = 'AUTOMOD_DECISION_REJECTED',
  AutomodDecisionUnspecified = 'AUTOMOD_DECISION_UNSPECIFIED'
}

export enum ChatAutomodLevel {
  AutomodLevelHigh = 'AUTOMOD_LEVEL_HIGH',
  AutomodLevelLow = 'AUTOMOD_LEVEL_LOW',
  AutomodLevelUnspecified = 'AUTOMOD_LEVEL_UNSPECIFIED'
}

export type ChatChatDetails = {
  __typename?: 'ChatChatDetails';
  chatId: Scalars['ID']['output'];
  roles: Array<ChatChatRole>;
};

export type ChatChatEvent = {
  __typename?: 'ChatChatEvent';
  chatId: Scalars['ID']['output'];
  cid: Scalars['Int']['output'];
  event?: Maybe<ChatChatEventEventUnion>;
};

export type ChatChatEventEventUnion = ChatChatDetails | ChatChatMessage | ChatHideMessage | ChatMessageDenied | ChatPing | ChatUserBanned | ChatUserMuted | ChatUserUnmuted;

export type ChatChatMessage = {
  __typename?: 'ChatChatMessage';
  chatId: Scalars['ID']['output'];
  content: ChatMessageContent;
  createdAt: Scalars['Timestamp']['output'];
  messageId: Scalars['ID']['output'];
  moderationStatus: ChatModerationStatus;
  sender: ProfileProfile;
  senderId: Scalars['ID']['output'];
  senderInfo: ChatSenderInfo;
  state: ApiEntityState;
  textClassification: ClassificationTextClassification;
  username: Scalars['String']['output'];
};

export enum ChatChatRole {
  ChatRoleMember = 'CHAT_ROLE_MEMBER',
  ChatRoleModerator = 'CHAT_ROLE_MODERATOR',
  ChatRolePlatformModerator = 'CHAT_ROLE_PLATFORM_MODERATOR',
  ChatRoleStreamer = 'CHAT_ROLE_STREAMER',
  ChatRoleUnspecified = 'CHAT_ROLE_UNSPECIFIED'
}

export type ChatChatUser = {
  __typename?: 'ChatChatUser';
  label: ChatUserLabel;
  senderInfo: ChatSenderInfo;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ChatGetChatUserStatusResponse = {
  __typename?: 'ChatGetChatUserStatusResponse';
  muteDuration?: Maybe<Scalars['Duration']['output']>;
  muted: Scalars['Boolean']['output'];
};

export type ChatHideMessage = {
  __typename?: 'ChatHideMessage';
  chatId: Scalars['ID']['output'];
  messageId: Scalars['ID']['output'];
};

export type ChatListChatUsersResponse = {
  __typename?: 'ChatListChatUsersResponse';
  users: Array<ChatChatUser>;
};

export type ChatListMessagesResponse = {
  __typename?: 'ChatListMessagesResponse';
  messages: Array<ChatChatMessage>;
  pageInfo: ApiPageInfo;
};

export type ChatMessageContent = {
  __typename?: 'ChatMessageContent';
  content?: Maybe<ChatMessageContentContentUnion>;
};

export type ChatMessageContentContentUnion = ChatTextMessage | ChatTombstone;

export type ChatMessageContentInput = {
  textContent?: InputMaybe<ChatTextMessageInput>;
  tombstone?: InputMaybe<ChatTombstoneInput>;
};

export type ChatMessageDenied = {
  __typename?: 'ChatMessageDenied';
  chatId: Scalars['ID']['output'];
  messageId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ChatModerationItem = {
  __typename?: 'ChatModerationItem';
  chatMessage: ChatChatMessage;
  expired: Scalars['Boolean']['output'];
  expiresAt: Scalars['Timestamp']['output'];
  id: Scalars['ID']['output'];
  reviewer?: Maybe<ProfileProfile>;
  reviewerId?: Maybe<Scalars['ID']['output']>;
  status: ChatModerationItemStatus;
};

export enum ChatModerationItemStatus {
  StatusAllowed = 'STATUS_ALLOWED',
  StatusDenied = 'STATUS_DENIED',
  StatusPending = 'STATUS_PENDING',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export enum ChatModerationStatus {
  ModerationStatusApproved = 'MODERATION_STATUS_APPROVED',
  ModerationStatusUnspecified = 'MODERATION_STATUS_UNSPECIFIED'
}

export type ChatPing = {
  __typename?: 'ChatPing';
  seq: Scalars['Int']['output'];
};

export enum ChatReason {
  ReasonOther = 'REASON_OTHER',
  ReasonSpam = 'REASON_SPAM',
  ReasonUnspecified = 'REASON_UNSPECIFIED'
}

export type ChatSendMessageResponse = {
  __typename?: 'ChatSendMessageResponse';
  messageId: Scalars['ID']['output'];
};

export type ChatSenderInfo = {
  __typename?: 'ChatSenderInfo';
  avatar2D: Scalars['String']['output'];
  badges: Array<BadgeBadge>;
  label: ChatUserLabel;
  preferredColor: ProfileColor;
  roles: Array<ChatChatRole>;
  userId: Scalars['ID']['output'];
  username: Scalars['String']['output'];
};

export type ChatTextMessage = {
  __typename?: 'ChatTextMessage';
  attachments: Array<ChatTextMessageAttachment>;
  links: Array<ChatTextMessageLink>;
  text: Scalars['String']['output'];
};

export type ChatTextMessageAttachment = {
  __typename?: 'ChatTextMessageAttachment';
  endIndex: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
  label: Scalars['String']['output'];
  source: Scalars['String']['output'];
  startIndex: Scalars['Int']['output'];
};

export type ChatTextMessageAttachmentInput = {
  endIndex?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  startIndex?: InputMaybe<Scalars['Int']['input']>;
};

export type ChatTextMessageInput = {
  attachments?: InputMaybe<Array<ChatTextMessageAttachmentInput>>;
  links?: InputMaybe<Array<ChatTextMessageLinkInput>>;
  text?: InputMaybe<Scalars['String']['input']>;
};

export type ChatTextMessageLink = {
  __typename?: 'ChatTextMessageLink';
  endIndex: Scalars['Int']['output'];
  startIndex: Scalars['Int']['output'];
  url: Scalars['String']['output'];
};

export type ChatTextMessageLinkInput = {
  endIndex?: InputMaybe<Scalars['Int']['input']>;
  startIndex?: InputMaybe<Scalars['Int']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type ChatTombstone = {
  __typename?: 'ChatTombstone';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type ChatTombstoneInput = {
  emptyTypeWorkaround: Scalars['Boolean']['input'];
};

export type ChatUserBanned = {
  __typename?: 'ChatUserBanned';
  chatId: Scalars['ID']['output'];
  moderatorId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export enum ChatUserLabel {
  UserLabelModerator = 'USER_LABEL_MODERATOR',
  UserLabelStaff = 'USER_LABEL_STAFF',
  UserLabelStreamer = 'USER_LABEL_STREAMER',
  UserLabelUnspecified = 'USER_LABEL_UNSPECIFIED',
  UserLabelViewer = 'USER_LABEL_VIEWER'
}

export type ChatUserMuted = {
  __typename?: 'ChatUserMuted';
  chatId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  duration: Scalars['Duration']['output'];
  moderatorId: Scalars['ID']['output'];
  reason: ChatReason;
  userId: Scalars['ID']['output'];
};

export type ChatUserUnmuted = {
  __typename?: 'ChatUserUnmuted';
  chatId: Scalars['ID']['output'];
  moderatorId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ClassificationEvent = {
  __typename?: 'ClassificationEvent';
  event?: Maybe<ClassificationEventEventUnion>;
};

export type ClassificationEventCustomEvent = {
  __typename?: 'ClassificationEventCustomEvent';
  id: Scalars['ID']['output'];
  message: Scalars['String']['output'];
};

export type ClassificationEventEventFlooding = {
  __typename?: 'ClassificationEventEventFlooding';
  count: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  limit: Scalars['Int']['output'];
};

export type ClassificationEventEventTrustChanged = {
  __typename?: 'ClassificationEventEventTrustChanged';
  id: Scalars['ID']['output'];
  message: Scalars['String']['output'];
  oldTrustLevel: ClassificationTrustLevel;
  trustLevel: ClassificationTrustLevel;
};

export type ClassificationEventEventUnion = ClassificationEventCustomEvent | ClassificationEventEventFlooding | ClassificationEventEventTrustChanged;

export type ClassificationTextClassification = {
  __typename?: 'ClassificationTextClassification';
  escalations: Array<Scalars['String']['output']>;
  events: Array<ClassificationEvent>;
  hashed: Scalars['String']['output'];
  hashes: Array<Scalars['Int']['output']>;
  highRiskLanguage: Scalars['String']['output'];
  notableIndexes: Array<Scalars['Int']['output']>;
  response: Scalars['Boolean']['output'];
  risk: ClassificationTextRisk;
  topics: Array<ClassificationTextClassificationTopicTextRiskLevel>;
  trust: ClassificationTrustLevel;
};

export type ClassificationTextClassificationTopicTextRiskLevel = {
  __typename?: 'ClassificationTextClassificationTopicTextRiskLevel';
  risk: ClassificationTextRisk;
  topic: ClassificationTopic;
};

export enum ClassificationTextRisk {
  TextRiskDangerous = 'TEXT_RISK_DANGEROUS',
  TextRiskExplicit = 'TEXT_RISK_EXPLICIT',
  TextRiskLow = 'TEXT_RISK_LOW',
  TextRiskMature = 'TEXT_RISK_MATURE',
  TextRiskNotable = 'TEXT_RISK_NOTABLE',
  TextRiskQuestionable = 'TEXT_RISK_QUESTIONABLE',
  TextRiskSafe = 'TEXT_RISK_SAFE',
  TextRiskUnknown = 'TEXT_RISK_UNKNOWN',
  TextRiskUnspecified = 'TEXT_RISK_UNSPECIFIED'
}

export enum ClassificationTopic {
  TopicAlarm = 'TOPIC_ALARM',
  TopicBullying = 'TOPIC_BULLYING',
  TopicChildGrooming = 'TOPIC_CHILD_GROOMING',
  TopicDrugsAndAlcohol = 'TOPIC_DRUGS_AND_ALCOHOL',
  TopicExtremism = 'TOPIC_EXTREMISM',
  TopicFraud = 'TOPIC_FRAUD',
  TopicGeneralRisk = 'TOPIC_GENERAL_RISK',
  TopicHateSpeech = 'TOPIC_HATE_SPEECH',
  TopicInApp = 'TOPIC_IN_APP',
  TopicJunk = 'TOPIC_JUNK',
  TopicPersonalIdentifyingInfo = 'TOPIC_PERSONAL_IDENTIFYING_INFO',
  TopicPolitics = 'TOPIC_POLITICS',
  TopicPublicThreat = 'TOPIC_PUBLIC_THREAT',
  TopicRealName = 'TOPIC_REAL_NAME',
  TopicRelationshipAndSexualContent = 'TOPIC_RELATIONSHIP_AND_SEXUAL_CONTENT',
  TopicReligious = 'TOPIC_RELIGIOUS',
  TopicSentiment = 'TOPIC_SENTIMENT',
  TopicSubversive = 'TOPIC_SUBVERSIVE',
  TopicUnspecified = 'TOPIC_UNSPECIFIED',
  TopicViolence = 'TOPIC_VIOLENCE',
  TopicVulgarity = 'TOPIC_VULGARITY',
  TopicWebsite = 'TOPIC_WEBSITE'
}

export enum ClassificationTrustLevel {
  TrustLevelDefault = 'TRUST_LEVEL_DEFAULT',
  TrustLevelMute = 'TRUST_LEVEL_MUTE',
  TrustLevelNotTrusted = 'TRUST_LEVEL_NOT_TRUSTED',
  TrustLevelSuperuser = 'TRUST_LEVEL_SUPERUSER',
  TrustLevelTrusted = 'TRUST_LEVEL_TRUSTED',
  TrustLevelUnspecified = 'TRUST_LEVEL_UNSPECIFIED'
}

export type ConfigMetagameConfigInactivityTimeouts = {
  __typename?: 'ConfigMetagameConfigInactivityTimeouts';
  enabled: Scalars['Boolean']['output'];
  idleTimeoutSec: Scalars['Int']['output'];
  implicitOfflineTimeoutSec: Scalars['Int']['output'];
  offlineTimeoutSec: Scalars['Int']['output'];
};

export type ConfigMetagameConfigUiTimings = {
  __typename?: 'ConfigMetagameConfigUITimings';
  teamActionTimeout: Scalars['Int']['output'];
};

export type EmojiBatchGetEmojisResponse = {
  __typename?: 'EmojiBatchGetEmojisResponse';
  emojis: Array<EmojiEmoji>;
};

export type EmojiCreateEmojiUploadTokenResponse = {
  __typename?: 'EmojiCreateEmojiUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type EmojiEmoji = {
  __typename?: 'EmojiEmoji';
  channelId: Scalars['ID']['output'];
  disabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  image: Scalars['String']['output'];
  imageUrl: Scalars['String']['output'];
  label: Scalars['String']['output'];
  name: Scalars['String']['output'];
  prefabName: Scalars['String']['output'];
};

export type EmojiListChannelEmojisResponse = {
  __typename?: 'EmojiListChannelEmojisResponse';
  count?: Maybe<ItemItemTotalCount>;
  emojis: Array<EmojiEmoji>;
  pageInfo: ApiPageInfo;
};

export type EmojiListPlatformEmojisResponse = {
  __typename?: 'EmojiListPlatformEmojisResponse';
  count?: Maybe<ItemItemTotalCount>;
  emojis: Array<EmojiEmoji>;
  pageInfo: ApiPageInfo;
};

export type EmojiUpdateChannelEmojiParamsInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};

export type EmojiUpdatePlatformEmojiParamsInput = {
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlag = {
  __typename?: 'FlagFeatureFlag';
  description: Scalars['String']['output'];
  enabled: Scalars['Boolean']['output'];
  groups: Array<FlagFeatureFlagGroup>;
  name: Scalars['String']['output'];
};

export type FlagFeatureFlagConfig = {
  __typename?: 'FlagFeatureFlagConfig';
  channelFlags: FlagFeatureFlagList;
  createdAt: Scalars['Timestamp']['output'];
  revision: Scalars['String']['output'];
  userFlags: FlagFeatureFlagList;
};

export type FlagFeatureFlagConfigInput = {
  channelFlags?: InputMaybe<FlagFeatureFlagListInput>;
  createdAt?: InputMaybe<Scalars['InputTimestamp']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
  userFlags?: InputMaybe<FlagFeatureFlagListInput>;
};

export type FlagFeatureFlagGroup = {
  __typename?: 'FlagFeatureFlagGroup';
  conditions: Array<FlagFeatureFlagGroupCondition>;
  default: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  values: Array<FlagFeatureFlagGroupValue>;
};

export type FlagFeatureFlagGroupCondition = {
  __typename?: 'FlagFeatureFlagGroupCondition';
  rule?: Maybe<FlagFeatureFlagGroupConditionRuleUnion>;
};

export type FlagFeatureFlagGroupConditionAny = {
  __typename?: 'FlagFeatureFlagGroupConditionAny';
  field: Scalars['String']['output'];
  values: Array<Scalars['String']['output']>;
};

export type FlagFeatureFlagGroupConditionAnyInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type FlagFeatureFlagGroupConditionEq = {
  __typename?: 'FlagFeatureFlagGroupConditionEq';
  field: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagFeatureFlagGroupConditionEqInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagGroupConditionGte = {
  __typename?: 'FlagFeatureFlagGroupConditionGte';
  field: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagFeatureFlagGroupConditionGteInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagGroupConditionInput = {
  any?: InputMaybe<FlagFeatureFlagGroupConditionAnyInput>;
  eq?: InputMaybe<FlagFeatureFlagGroupConditionEqInput>;
  gte?: InputMaybe<FlagFeatureFlagGroupConditionGteInput>;
  lte?: InputMaybe<FlagFeatureFlagGroupConditionLteInput>;
};

export type FlagFeatureFlagGroupConditionLte = {
  __typename?: 'FlagFeatureFlagGroupConditionLte';
  field: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagFeatureFlagGroupConditionLteInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagGroupConditionRuleUnion = FlagFeatureFlagGroupConditionAny | FlagFeatureFlagGroupConditionEq | FlagFeatureFlagGroupConditionGte | FlagFeatureFlagGroupConditionLte;

export type FlagFeatureFlagGroupInput = {
  conditions?: InputMaybe<Array<FlagFeatureFlagGroupConditionInput>>;
  default?: InputMaybe<Scalars['Boolean']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  values?: InputMaybe<Array<FlagFeatureFlagGroupValueInput>>;
};

export type FlagFeatureFlagGroupValue = {
  __typename?: 'FlagFeatureFlagGroupValue';
  value: Scalars['String']['output'];
  weight: Scalars['Int']['output'];
};

export type FlagFeatureFlagGroupValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

export type FlagFeatureFlagInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  groups?: InputMaybe<Array<FlagFeatureFlagGroupInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type FlagFeatureFlagList = {
  __typename?: 'FlagFeatureFlagList';
  flags: Array<FlagFeatureFlag>;
};

export type FlagFeatureFlagListInput = {
  flags?: InputMaybe<Array<FlagFeatureFlagInput>>;
};

export type FlagFeatureFlagSchema = {
  __typename?: 'FlagFeatureFlagSchema';
  flags: Array<FlagFeatureFlagSchemaFlagsEntry>;
};

export type FlagFeatureFlagSchemaFlagsEntry = {
  __typename?: 'FlagFeatureFlagSchemaFlagsEntry';
  key: Scalars['String']['output'];
  value: FlagJsonSchema;
};

export type FlagFeatureFlagState = {
  __typename?: 'FlagFeatureFlagState';
  name: Scalars['String']['output'];
  revision: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FlagJsonSchema = {
  __typename?: 'FlagJSONSchema';
  description: Scalars['String']['output'];
  enum: Array<Scalars['String']['output']>;
  items: FlagJsonSchema;
  maximum: Scalars['Float']['output'];
  minimum: Scalars['Float']['output'];
  multipleOf: Scalars['Float']['output'];
  pattern: Scalars['String']['output'];
  patternProperties: Array<FlagJsonSchemaPatternPropertiesEntry>;
  properties: Array<FlagJsonSchemaPropertiesEntry>;
  type: Scalars['String']['output'];
};

export type FlagJsonSchemaPatternPropertiesEntry = {
  __typename?: 'FlagJSONSchemaPatternPropertiesEntry';
  key: Scalars['String']['output'];
  value: FlagJsonSchema;
};

export type FlagJsonSchemaPropertiesEntry = {
  __typename?: 'FlagJSONSchemaPropertiesEntry';
  key: Scalars['String']['output'];
  value: FlagJsonSchema;
};

export type FlagListChannelFeatureFlagsResponse = {
  __typename?: 'FlagListChannelFeatureFlagsResponse';
  flags: Array<FlagFeatureFlagState>;
};

export type FlagListUserFeatureFlagsResponse = {
  __typename?: 'FlagListUserFeatureFlagsResponse';
  flags: Array<FlagFeatureFlagState>;
};

export type FloatType = {
  __typename?: 'FloatType';
  /** The wrapped value of type Float */
  value: Scalars['Float']['output'];
};

export type FriendsAcceptFriendRequestResponse = {
  __typename?: 'FriendsAcceptFriendRequestResponse';
  friend: ProfileProfile;
  friendId: Scalars['ID']['output'];
};

export type FriendsActivity = {
  __typename?: 'FriendsActivity';
  channel?: Maybe<ChannelChannel>;
  channelId: Scalars['ID']['output'];
  isOnline: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
};

export type FriendsBlockUserResponse = {
  __typename?: 'FriendsBlockUserResponse';
  blockedUser: ProfileProfile;
  blockedUserId: Scalars['ID']['output'];
};

export type FriendsChannelFriends = {
  __typename?: 'FriendsChannelFriends';
  channelId: Scalars['ID']['output'];
  totalCount: Scalars['Int']['output'];
  users: Array<FriendsUser>;
};

export type FriendsFriendStatusUpdateEvent = {
  __typename?: 'FriendsFriendStatusUpdateEvent';
  actorProfile: ProfileProfile;
  actorUserId: Scalars['ID']['output'];
  targetProfile: ProfileProfile;
  targetUserId: Scalars['ID']['output'];
  type: FriendsFriendStatusUpdateEventUpdateType;
};

export enum FriendsFriendStatusUpdateEventUpdateType {
  UpdateTypeFriendInvitation = 'UPDATE_TYPE_FRIEND_INVITATION',
  UpdateTypeInvitationAccepted = 'UPDATE_TYPE_INVITATION_ACCEPTED',
  UpdateTypeInvitationCancelled = 'UPDATE_TYPE_INVITATION_CANCELLED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUserBlocked = 'UPDATE_TYPE_USER_BLOCKED',
  UpdateTypeUserUnblocked = 'UPDATE_TYPE_USER_UNBLOCKED',
  UpdateTypeUserUnfriended = 'UPDATE_TYPE_USER_UNFRIENDED'
}

export type FriendsFriendsSettings = {
  __typename?: 'FriendsFriendsSettings';
  disableFriendRequests: Scalars['Boolean']['output'];
};

export type FriendsFriendsSettingsInput = {
  disableFriendRequests?: InputMaybe<Scalars['Boolean']['input']>;
};

export type FriendsFriendshipStatus = {
  __typename?: 'FriendsFriendshipStatus';
  activity?: Maybe<FriendsActivity>;
  lastStatusChange: Scalars['Timestamp']['output'];
  status: FriendsFriendshipStatusStatus;
};

export enum FriendsFriendshipStatusStatus {
  StatusBlocked = 'STATUS_BLOCKED',
  StatusBlockedBy = 'STATUS_BLOCKED_BY',
  StatusFriend = 'STATUS_FRIEND',
  StatusFriendRequestReceived = 'STATUS_FRIEND_REQUEST_RECEIVED',
  StatusFriendRequestSent = 'STATUS_FRIEND_REQUEST_SENT',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export type FriendsGetChannelActiveFriendsResponse = {
  __typename?: 'FriendsGetChannelActiveFriendsResponse';
  channelFriends: Array<FriendsChannelFriends>;
};

export type FriendsGetFriendshipStatusResponse = {
  __typename?: 'FriendsGetFriendshipStatusResponse';
  statuses: Array<FriendsFriendshipStatus>;
};

export type FriendsListBlockedUsersResponse = {
  __typename?: 'FriendsListBlockedUsersResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListFriendsRequestFilterInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  isOnline?: InputMaybe<Scalars['Boolean']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};

export type FriendsListFriendsResponse = {
  __typename?: 'FriendsListFriendsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListReceivedFriendRequestsResponse = {
  __typename?: 'FriendsListReceivedFriendRequestsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsListSentFriendRequestsResponse = {
  __typename?: 'FriendsListSentFriendRequestsResponse';
  pageInfo: ApiPageInfo;
  users: Array<FriendsUser>;
};

export type FriendsSendFriendRequestResponse = {
  __typename?: 'FriendsSendFriendRequestResponse';
  friend: ProfileProfile;
  friendId: Scalars['ID']['output'];
};

export type FriendsUnblockUserResponse = {
  __typename?: 'FriendsUnblockUserResponse';
  unblockedUser: ProfileProfile;
  unblockedUserId: Scalars['ID']['output'];
};

export type FriendsUser = {
  __typename?: 'FriendsUser';
  activity?: Maybe<FriendsActivity>;
  lastStatusChange: Scalars['Timestamp']['output'];
  profile: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export enum FtueDismissalType {
  DismissalTypeActionTaken = 'DISMISSAL_TYPE_ACTION_TAKEN',
  DismissalTypeClosed = 'DISMISSAL_TYPE_CLOSED',
  DismissalTypeUnspecified = 'DISMISSAL_TYPE_UNSPECIFIED'
}

export type FtueListDismissedTooltipsResponse = {
  __typename?: 'FtueListDismissedTooltipsResponse';
  tooltipIds: Array<Scalars['String']['output']>;
};

export type GameBatchGetGamesResponse = {
  __typename?: 'GameBatchGetGamesResponse';
  games: Array<GameGame>;
};

export type GameBatchGetSeasonsResponse = {
  __typename?: 'GameBatchGetSeasonsResponse';
  seasons: Array<GameSeason>;
};

export enum GameCardAssetType {
  AssetTypeThumbnail = 'ASSET_TYPE_THUMBNAIL',
  AssetTypeUnspecified = 'ASSET_TYPE_UNSPECIFIED',
  AssetTypeVideo = 'ASSET_TYPE_VIDEO'
}

export type GameCardBatchGetGameCardsResponse = {
  __typename?: 'GameCardBatchGetGameCardsResponse';
  cards: Array<GameLogicCard>;
};

export type GameCardBatchGetStreamerCardsResponse = {
  __typename?: 'GameCardBatchGetStreamerCardsResponse';
  cards: Array<GameLogicStreamerCard>;
};

export type GameCardCreateStreamerCardAssetUploadTokenResponse = {
  __typename?: 'GameCardCreateStreamerCardAssetUploadTokenResponse';
  token: Scalars['String']['output'];
};

export type GameCardHighScoringCardConfig = {
  __typename?: 'GameCardHighScoringCardConfig';
  cardRarity: RarityRarity;
  percentageOfMaxRequired: Scalars['Float']['output'];
  soloMultiplier: Scalars['Float']['output'];
  streamerCardPercentageOfMaxRequired: Scalars['Float']['output'];
};

export type GameCardHighScoringCardTimings = {
  __typename?: 'GameCardHighScoringCardTimings';
  cooldownBetweenCardScores: Scalars['Int']['output'];
  ghostWaitTime: Scalars['Int']['output'];
  speed: GameCardHighScoringCardTimingsSpeed;
};

export enum GameCardHighScoringCardTimingsSpeed {
  SpeedDefault = 'SPEED_DEFAULT',
  SpeedFast = 'SPEED_FAST',
  SpeedFastest = 'SPEED_FASTEST',
  SpeedSlow = 'SPEED_SLOW',
  SpeedSlowest = 'SPEED_SLOWEST',
  SpeedUnspecified = 'SPEED_UNSPECIFIED'
}

export type GameCardListBoostersResponse = {
  __typename?: 'GameCardListBoostersResponse';
  boosters: Array<GameLogicBooster>;
};

/** TODO: add game/stream based filtering */
export type GameCardListGameCardsResponse = {
  __typename?: 'GameCardListGameCardsResponse';
  cards: Array<GameLogicCard>;
};

export type GameCardListStreamerCardDraftsRequestFilterInput = {
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};

export type GameCardListStreamerCardDraftsResponse = {
  __typename?: 'GameCardListStreamerCardDraftsResponse';
  cards: Array<GameLogicStreamerCard>;
  pageInfo: ApiPageInfo;
};

export type GameCardListStreamerCardsRequestFilterInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};

export type GameCardListStreamerCardsResponse = {
  __typename?: 'GameCardListStreamerCardsResponse';
  cards: Array<GameLogicStreamerCard>;
  pageInfo: ApiPageInfo;
};

export type GameCardStreamerCardDraftUpdateInput = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type GameGame = {
  __typename?: 'GameGame';
  activeSeason: GameSeason;
  activeSeasonId: Scalars['ID']['output'];
  backdropUrl: Scalars['String']['output'];
  challengesEnabled: Scalars['Boolean']['output'];
  coverImageUrl: Scalars['String']['output'];
  gameEventsSource: GameGameEventsSource;
  iconUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  noicePredictionsEnabled: Scalars['Boolean']['output'];
  otherNames: Array<Scalars['String']['output']>;
  progression: GameUserProgression;
  publicAccess: Scalars['Boolean']['output'];
};

export enum GameGameEventsSource {
  GameEventsSourceGameIntegration = 'GAME_EVENTS_SOURCE_GAME_INTEGRATION',
  GameEventsSourceMl = 'GAME_EVENTS_SOURCE_ML',
  GameEventsSourceUnspecified = 'GAME_EVENTS_SOURCE_UNSPECIFIED'
}

export type GameListGamesResponse = {
  __typename?: 'GameListGamesResponse';
  games: Array<GameGame>;
};

export type GameListSeasonsResponse = {
  __typename?: 'GameListSeasonsResponse';
  seasons: Array<GameSeason>;
};

export type GameLogicActiveBooster = {
  __typename?: 'GameLogicActiveBooster';
  activationTime: Scalars['Int']['output'];
  activatorUserId: Scalars['ID']['output'];
  boosterId: Scalars['Int']['output'];
};

export type GameLogicActiveCard = {
  __typename?: 'GameLogicActiveCard';
  activeBoosters: Array<GameLogicActiveCardActiveBoostersEntry>;
  cardId: Scalars['ID']['output'];
  failureTargetValue: Scalars['Int']['output'];
  points: Scalars['Int']['output'];
  pointsMax: Scalars['Int']['output'];
  pointsMin: Scalars['Int']['output'];
  pointsTimeTarget: Scalars['Int']['output'];
  pointsUpdateTime: Scalars['Int']['output'];
  pointsUpdateTimer: GameLogicTimer;
  setTime: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
  targetValues: Array<GameLogicActiveCardTargetValuesEntry>;
  timerDuration: Scalars['Int']['output'];
};

export type GameLogicActiveCardActiveBoostersEntry = {
  __typename?: 'GameLogicActiveCardActiveBoostersEntry';
  key: Scalars['String']['output'];
  value: GameLogicActiveBooster;
};

export type GameLogicActiveCardSucceededMsg = {
  __typename?: 'GameLogicActiveCardSucceededMsg';
  allOrNothing: GameLogicAllOrNothing;
  bestPlay: GameLogicBestPlay;
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  card: GameLogicCard;
  cardId: Scalars['ID']['output'];
  groupId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type GameLogicActiveCardTargetValuesEntry = {
  __typename?: 'GameLogicActiveCardTargetValuesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type GameLogicAllOrNothing = {
  __typename?: 'GameLogicAllOrNothing';
  bestPlay: GameLogicBestPlay;
  cardActivations: Array<GameLogicCardActivationResult>;
  cardId: Scalars['ID']['output'];
  nextPoints: Scalars['Int']['output'];
  round: Scalars['Int']['output'];
  totalPoints: Scalars['Int']['output'];
  totalRounds: Scalars['Int']['output'];
};

export type GameLogicBestPlay = {
  __typename?: 'GameLogicBestPlay';
  activeBoosters: Array<GameLogicActiveBooster>;
  cardId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicBooster = {
  __typename?: 'GameLogicBooster';
  canTargetSelf: Scalars['Boolean']['output'];
  description: Scalars['String']['output'];
  descriptionCondition: Scalars['String']['output'];
  descriptionDefaultBenefit: Scalars['String']['output'];
  descriptionOtherBenefit: Scalars['String']['output'];
  descriptionTargetNoneBenefit: Scalars['String']['output'];
  descriptionTargetSelf: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  image: Scalars['String']['output'];
  isAvailableSolo: Scalars['Boolean']['output'];
  isSelfAndOtherEffect: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  removeOn: Array<Scalars['String']['output']>;
  timeActive: Scalars['Int']['output'];
  triggersOn: Array<Scalars['String']['output']>;
  valueOther: Scalars['Int']['output'];
  valueSelf: Scalars['Int']['output'];
};

export type GameLogicCard = {
  __typename?: 'GameLogicCard';
  activeStreamerCard?: Maybe<GameLogicStreamerCard>;
  activeStreamerCards: Array<GameLogicStreamerCard>;
  availableStreamerCards: Array<GameLogicStreamerCard>;
  backImage: Scalars['String']['output'];
  dealingModules: Array<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  failureModules: Array<Scalars['String']['output']>;
  failureTargetValue: Scalars['Int']['output'];
  familyId: Scalars['ID']['output'];
  frontImage: Scalars['String']['output'];
  gameModes: Array<Scalars['String']['output']>;
  icon: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isAllOrNothing: Scalars['Boolean']['output'];
  isDealtAtStart: Scalars['Boolean']['output'];
  isEnabled: Scalars['Boolean']['output'];
  isMatchCard: Scalars['Boolean']['output'];
  leveling: GameLogicCardLeveling;
  matchCardId: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  pointsMax: Scalars['Int']['output'];
  pointsMin: Scalars['Int']['output'];
  pointsTimeTarget: Scalars['Int']['output'];
  rarity: RarityRarity;
  roleCharacters: Array<Scalars['String']['output']>;
  scoredCounterIds: Array<Scalars['String']['output']>;
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
  sides: Array<Scalars['String']['output']>;
  successModules: Array<Scalars['String']['output']>;
  targetValue: Scalars['Int']['output'];
  targetValues: Array<GameLogicTargetValue>;
  timerDuration: Scalars['Int']['output'];
  unlockLevel: Scalars['Int']['output'];
};


export type GameLogicCardAvailableStreamerCardsArgs = {
  channel_id?: InputMaybe<Scalars['ID']['input']>;
};

export type GameLogicCardActivationResult = {
  __typename?: 'GameLogicCardActivationResult';
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  cardId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicCardDetails = {
  __typename?: 'GameLogicCardDetails';
  groupName: Scalars['String']['output'];
  succeedingCard: GameLogicActiveCardSucceededMsg;
};

export type GameLogicCardLeveling = {
  __typename?: 'GameLogicCardLeveling';
  currentLevel: Scalars['Int']['output'];
  nextLevelLimit: Scalars['Int']['output'];
  progressToNextLevel: Scalars['Int']['output'];
};

export type GameLogicChallenge = {
  __typename?: 'GameLogicChallenge';
  channelId: Scalars['ID']['output'];
  description: Scalars['String']['output'];
  disabled: Scalars['Boolean']['output'];
  failureModule: Scalars['String']['output'];
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  successModule: Scalars['String']['output'];
  targetValues: Array<GameLogicTargetValue>;
};

export enum GameLogicChallengeState {
  ChallengeStateFailure = 'CHALLENGE_STATE_FAILURE',
  ChallengeStateSuccess = 'CHALLENGE_STATE_SUCCESS',
  ChallengeStateUnresolved = 'CHALLENGE_STATE_UNRESOLVED',
  ChallengeStateUnspecified = 'CHALLENGE_STATE_UNSPECIFIED'
}

export type GameLogicChallengeStatus = {
  __typename?: 'GameLogicChallengeStatus';
  challenge: GameLogicChallenge;
  challengeId: Scalars['ID']['output'];
  challengeState: GameLogicChallengeState;
  pickRate: Scalars['Float']['output'];
  targetValues: Array<GameLogicTargetValue>;
};

export enum GameLogicContextualTeamActionStatus {
  ContextualTeamActionStatusFailed = 'CONTEXTUAL_TEAM_ACTION_STATUS_FAILED',
  ContextualTeamActionStatusOngoing = 'CONTEXTUAL_TEAM_ACTION_STATUS_ONGOING',
  ContextualTeamActionStatusSucceeded = 'CONTEXTUAL_TEAM_ACTION_STATUS_SUCCEEDED',
  ContextualTeamActionStatusUnspecified = 'CONTEXTUAL_TEAM_ACTION_STATUS_UNSPECIFIED'
}

export enum GameLogicContextualTeamActionType {
  ContextualTeamActionTypeHighScoringCardPromoted = 'CONTEXTUAL_TEAM_ACTION_TYPE_HIGH_SCORING_CARD_PROMOTED',
  ContextualTeamActionTypeStreamerActivated = 'CONTEXTUAL_TEAM_ACTION_TYPE_STREAMER_ACTIVATED',
  ContextualTeamActionTypeUnspecified = 'CONTEXTUAL_TEAM_ACTION_TYPE_UNSPECIFIED'
}

export type GameLogicGroup = {
  __typename?: 'GameLogicGroup';
  id: Scalars['ID']['output'];
  isParty: Scalars['Boolean']['output'];
  isSolo: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicGroupDetails = {
  __typename?: 'GameLogicGroupDetails';
  group: GameLogicGroup;
  players: Array<GameLogicPlayerDetails>;
  streamId: Scalars['ID']['output'];
};

export type GameLogicHand = {
  __typename?: 'GameLogicHand';
  cardIds: Array<Scalars['String']['output']>;
  matchEndCardIds: Array<Scalars['String']['output']>;
  previousCardIds: Array<Scalars['String']['output']>;
  votes: Array<GameLogicVote>;
};

export type GameLogicHighScoringCard = {
  __typename?: 'GameLogicHighScoringCard';
  boosterPoints: Array<GameLogicPlayerBoosterPoints>;
  card: GameLogicCard;
  cardId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
};

export type GameLogicHighScoringCardPromotedMsg = {
  __typename?: 'GameLogicHighScoringCardPromotedMsg';
  card: GameLogicHighScoringCard;
  groupId: Scalars['ID']['output'];
  groupName: Scalars['String']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type GameLogicLastActiveCard = {
  __typename?: 'GameLogicLastActiveCard';
  activeCard: GameLogicActiveCard;
  status: GameLogicLastActiveCardStatus;
};

export enum GameLogicLastActiveCardStatus {
  StatusFailed = 'STATUS_FAILED',
  StatusSucceeded = 'STATUS_SUCCEEDED',
  StatusUnspecified = 'STATUS_UNSPECIFIED'
}

export enum GameLogicMatchBonusType {
  MatchBonusTypeUnspecified = 'MATCH_BONUS_TYPE_UNSPECIFIED',
  MatchBonusTypeVictoryRoyal = 'MATCH_BONUS_TYPE_VICTORY_ROYAL'
}

export type GameLogicMatchConfiguration = {
  __typename?: 'GameLogicMatchConfiguration';
  aonPointMultipliers: Array<Scalars['Float']['output']>;
  boosterCooldowns: Array<Scalars['Int']['output']>;
  cardGlobalRefs: Array<Scalars['String']['output']>;
  cardSwitchOutTimerDuration: Scalars['Int']['output'];
  freeReshuffleCount: Scalars['Int']['output'];
  gameId: Scalars['ID']['output'];
  handSize: Scalars['Int']['output'];
  matchBonusActivationRule: Scalars['String']['output'];
  matchBonusPoints: Scalars['Int']['output'];
  matchBonusType: GameLogicMatchBonusType;
  matchType: GameLogicStreamStateMatchType;
  pointsGainTime: Scalars['Int']['output'];
  reshuffleBaseCost: Scalars['Int']['output'];
  reshuffleCostMultiplier: Scalars['Float']['output'];
  seasonId: Scalars['ID']['output'];
};

export type GameLogicMatchEndedMsg = {
  __typename?: 'GameLogicMatchEndedMsg';
  bestCard?: Maybe<GameLogicCardDetails>;
  bestGroup?: Maybe<GameLogicGroupDetails>;
  bestPlayer?: Maybe<GameLogicPlayerDetails>;
  challengeStatuses: Array<GameLogicChallengeStatus>;
  channelId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  group: GameLogicGroup;
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  players: Array<GameLogicPlayer>;
  streamId: Scalars['ID']['output'];
};

export type GameLogicMatchPauseStateChangedMsg = {
  __typename?: 'GameLogicMatchPauseStateChangedMsg';
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  paused: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
};

export type GameLogicMatchStartedMsg = {
  __typename?: 'GameLogicMatchStartedMsg';
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  streamId: Scalars['ID']['output'];
};

export type GameLogicPlayer = {
  __typename?: 'GameLogicPlayer';
  activeCard: GameLogicActiveCard;
  activeChallengeId: Scalars['ID']['output'];
  allOrNothing: GameLogicAllOrNothing;
  bestPlay: GameLogicBestPlay;
  boosterCooldownTimer: GameLogicTimer;
  cardSwitchOutTimer: GameLogicTimer;
  fullUser: Scalars['Boolean']['output'];
  hand: GameLogicHand;
  heldBoosterId: Scalars['Int']['output'];
  inactivityWarningOn: Scalars['Boolean']['output'];
  isOnline: Scalars['Boolean']['output'];
  lastActiveCard: GameLogicLastActiveCard;
  name: Scalars['String']['output'];
  points: Scalars['Int']['output'];
  remainingInactiveSeconds: Scalars['Int']['output'];
  reshuffleCount: Scalars['Int']['output'];
  selfUsedBoosterCount: Scalars['Int']['output'];
  usedBoosterCount: Scalars['Int']['output'];
  usedMatchCards: Array<GameLogicPlayerUsedMatchCardsEntry>;
  userId: Scalars['ID']['output'];
  userName: Scalars['String']['output'];
};

export type GameLogicPlayerBoosterPoints = {
  __typename?: 'GameLogicPlayerBoosterPoints';
  boosterId: Scalars['Int']['output'];
  cardUserId: Scalars['ID']['output'];
  donatorUserId: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
  userId: Scalars['ID']['output'];
};

export type GameLogicPlayerDetails = {
  __typename?: 'GameLogicPlayerDetails';
  groupName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  points: Scalars['Int']['output'];
  user: ProfileProfile;
};

export type GameLogicPlayerJoinedMsg = {
  __typename?: 'GameLogicPlayerJoinedMsg';
  groupId: Scalars['ID']['output'];
  player: GameLogicPlayer;
  playerCardIds: Array<Scalars['String']['output']>;
  serverTime: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type GameLogicPlayerUsedMatchCardsEntry = {
  __typename?: 'GameLogicPlayerUsedMatchCardsEntry';
  key: Scalars['Int']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameLogicStreamState = {
  __typename?: 'GameLogicStreamState';
  matchSeqNum: Scalars['Int']['output'];
  matchState: GameLogicStreamStateMatchState;
  matchType: GameLogicStreamStateMatchType;
  roundNumber: Scalars['Int']['output'];
  roundPhase: GameLogicStreamStateRoundPhase;
  roundPhaseDeadline: Scalars['Int']['output'];
};

export enum GameLogicStreamStateMatchState {
  MatchStateActive = 'MATCH_STATE_ACTIVE',
  MatchStateEnded = 'MATCH_STATE_ENDED',
  MatchStatePaused = 'MATCH_STATE_PAUSED',
  MatchStateUnspecified = 'MATCH_STATE_UNSPECIFIED'
}

export enum GameLogicStreamStateMatchType {
  MatchTypeMultiRound = 'MATCH_TYPE_MULTI_ROUND',
  MatchTypeSingleRound = 'MATCH_TYPE_SINGLE_ROUND',
  MatchTypeUnspecified = 'MATCH_TYPE_UNSPECIFIED'
}

export enum GameLogicStreamStateRoundPhase {
  RoundPhaseCompetition = 'ROUND_PHASE_COMPETITION',
  RoundPhaseEnded = 'ROUND_PHASE_ENDED',
  RoundPhasePreparation = 'ROUND_PHASE_PREPARATION',
  RoundPhaseUnspecified = 'ROUND_PHASE_UNSPECIFIED'
}

export type GameLogicStreamerCard = {
  __typename?: 'GameLogicStreamerCard';
  baseCard: GameLogicCard;
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  draft: Scalars['Boolean']['output'];
  facecam: Scalars['String']['output'];
  facecamUrl: Scalars['String']['output'];
  familyId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  image: Scalars['String']['output'];
  imageUrl: Scalars['String']['output'];
  name: Scalars['String']['output'];
  saleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  video: Scalars['String']['output'];
  videoUrl: Scalars['String']['output'];
};


export type GameLogicStreamerCardBaseCardArgs = {
  season_id?: InputMaybe<Scalars['String']['input']>;
};

export type GameLogicTargetValue = {
  __typename?: 'GameLogicTargetValue';
  label: Scalars['String']['output'];
  selector?: Maybe<GameLogicTargetValueSelector>;
  value: Scalars['Int']['output'];
};

export type GameLogicTargetValueSelector = {
  __typename?: 'GameLogicTargetValueSelector';
  attribute: Scalars['String']['output'];
  value?: Maybe<GameLogicTargetValueSelectorValueUnion>;
};

export type GameLogicTargetValueSelectorDefaultValue = {
  __typename?: 'GameLogicTargetValueSelectorDefaultValue';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type GameLogicTargetValueSelectorValueUnion = BooleanType | GameLogicTargetValueSelectorDefaultValue | IntType | StringType;

export type GameLogicTimer = {
  __typename?: 'GameLogicTimer';
  endTime: Scalars['Int']['output'];
  startTime: Scalars['Int']['output'];
};

export type GameLogicVote = {
  __typename?: 'GameLogicVote';
  cardId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type GameSeason = {
  __typename?: 'GameSeason';
  badgeUrl: Scalars['String']['output'];
  cardBackgroundUrls: Array<GameSeasonCardBackgroundAsset>;
  endTime: Scalars['Timestamp']['output'];
  game: GameGame;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  progression: ProgressionSeasonProgression;
  progressionPauseReason: Scalars['String']['output'];
  progressionPaused: Scalars['Boolean']['output'];
  seasonBreak: Scalars['Boolean']['output'];
  seasonBreakReason: Scalars['String']['output'];
  /** @deprecated field is deprecated */
  seasonPauseReason: Scalars['String']['output'];
  /** @deprecated field is deprecated */
  seasonPaused: Scalars['Boolean']['output'];
  startTime: Scalars['Timestamp']['output'];
};


export type GameSeasonProgressionArgs = {
  user_id?: InputMaybe<Scalars['ID']['input']>;
};

export type GameSeasonCardBackgroundAsset = {
  __typename?: 'GameSeasonCardBackgroundAsset';
  rarity: RarityRarity;
  url: Scalars['String']['output'];
};

export type GameStateAttributesState = {
  __typename?: 'GameStateAttributesState';
  boolAttributes: Array<GameStateAttributesStateBoolAttributesEntry>;
  intAttributes: Array<GameStateAttributesStateIntAttributesEntry>;
  stringAttributes: Array<GameStateAttributesStateStringAttributesEntry>;
};

export type GameStateAttributesStateBoolAttributesEntry = {
  __typename?: 'GameStateAttributesStateBoolAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateAttributesStateIntAttributesEntry = {
  __typename?: 'GameStateAttributesStateIntAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type GameStateAttributesStateStringAttributesEntry = {
  __typename?: 'GameStateAttributesStateStringAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type GameStateBoosterState = {
  __typename?: 'GameStateBoosterState';
  activeBooster: GameLogicActiveBooster;
  booster: GameLogicBooster;
  sourcePlayerId: Scalars['ID']['output'];
  targetPlayerId: Scalars['ID']['output'];
};

export type GameStateCalModule = {
  __typename?: 'GameStateCALModule';
  expression: GameStateCalModuleExpression;
};

export type GameStateCalModuleBinaryExpression = {
  __typename?: 'GameStateCALModuleBinaryExpression';
  left: GameStateCalModuleExpression;
  op: GameStateCalModuleBinaryOp;
  right: GameStateCalModuleExpression;
};

export enum GameStateCalModuleBinaryOp {
  BinaryOpAnd = 'BINARY_OP_AND',
  BinaryOpOr = 'BINARY_OP_OR',
  BinaryOpUnspecified = 'BINARY_OP_UNSPECIFIED'
}

export type GameStateCalModuleBinding = {
  __typename?: 'GameStateCALModuleBinding';
  ident: Scalars['String']['output'];
  selector: GameStateCalModuleBinding;
};

export type GameStateCalModuleCheck = {
  __typename?: 'GameStateCALModuleCheck';
  check?: Maybe<GameStateCalModuleCheckCheckUnion>;
  label: Scalars['String']['output'];
};

export type GameStateCalModuleCheckCheckUnion = GameStateCalModuleCountEventIntAttributeCheck | GameStateCalModuleEventBoolAttributeCheck | GameStateCalModuleEventIntAttributeCheck | GameStateCalModuleEventStringAttributeCheck | GameStateCalModuleEventTypeCheck | GameStateCalModuleEventTypeCheckAfterEventIntAttributeCheck | GameStateCalModuleGlobalAnyBoolAttributeCheck | GameStateCalModuleGlobalBoolAttributeCheck | GameStateCalModuleGlobalIntAttributeCheck | GameStateCalModuleGlobalIntAttributeSumCheck | GameStateCalModuleGlobalStringAttributeCheck | GameStateCalModuleIs | GameStateCalModuleRepeatedEventBoolAttributeCheck | GameStateCalModuleRepeatedEventIntAttributeCheck | GameStateCalModuleRepeatedEventStringAttributeCheck | GameStateCalModuleRepeatedEventTypeCheck | GameStateCalModuleTimeoutCheck;

export type GameStateCalModuleCheckParam = {
  __typename?: 'GameStateCALModuleCheckParam';
  value?: Maybe<GameStateCalModuleCheckParamValueUnion>;
};

export type GameStateCalModuleCheckParamValueUnion = BooleanType | GameStateCalModuleBinding | IntType | StringType;

export type GameStateCalModuleCheckSequence = {
  __typename?: 'GameStateCALModuleCheckSequence';
  activationTimes: Array<Scalars['Int']['output']>;
  expressions: Array<GameStateCalModuleExpression>;
  intervals: Array<Scalars['Int']['output']>;
  label: Scalars['String']['output'];
};

export type GameStateCalModuleCountEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleCountEventIntAttributeCheck';
  attributes: Array<Scalars['String']['output']>;
  calculateNegative: Scalars['Boolean']['output'];
  eventName: Scalars['String']['output'];
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleEventBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleEventBoolAttributeCheck';
  attribute: Scalars['String']['output'];
  eventName: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateCalModuleEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleEventIntAttributeCheck';
  attribute: Scalars['String']['output'];
  eventName: Scalars['String']['output'];
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int']['output'];
};

export type GameStateCalModuleEventStringAttributeCheck = {
  __typename?: 'GameStateCALModuleEventStringAttributeCheck';
  attribute: Scalars['String']['output'];
  eventName: Scalars['String']['output'];
  operator: GameStateStringComparisonOperator;
  values: Array<Scalars['String']['output']>;
};

export type GameStateCalModuleEventTypeCheck = {
  __typename?: 'GameStateCALModuleEventTypeCheck';
  eventNames: Array<Scalars['String']['output']>;
};

export type GameStateCalModuleEventTypeCheckAfterEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleEventTypeCheckAfterEventIntAttributeCheck';
  firstCheck: GameStateCalModuleEventIntAttributeCheck;
  firstCheckSuccessTime: Scalars['Int']['output'];
  secondCheck: GameStateCalModuleEventTypeCheck;
  timerDuration: Scalars['Int']['output'];
};

export type GameStateCalModuleExpression = {
  __typename?: 'GameStateCALModuleExpression';
  expression?: Maybe<GameStateCalModuleExpressionExpressionUnion>;
};

export type GameStateCalModuleExpressionExpressionUnion = GameStateCalModuleBinaryExpression | GameStateCalModuleCheck | GameStateCalModuleCheckSequence | GameStateCalModuleForDuration | GameStateCalModuleGroup | GameStateCalModuleRepeat | GameStateCalModuleUnaryExpression | GameStateCalModuleWhen;

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type GameStateCalModuleForDuration = {
  __typename?: 'GameStateCALModuleForDuration';
  expression: GameStateCalModuleExpression;
  resetting: Scalars['Boolean']['output'];
  timeout: GameStateCalModuleExpression;
};

export type GameStateCalModuleGlobalAnyBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalAnyBoolAttributeCheck';
  attributes: Array<Scalars['String']['output']>;
  value: Scalars['Boolean']['output'];
};

export type GameStateCalModuleGlobalBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalBoolAttributeCheck';
  attribute: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateCalModuleGlobalIntAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalIntAttributeCheck';
  attribute: Scalars['String']['output'];
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int']['output'];
};

export type GameStateCalModuleGlobalIntAttributeSumCheck = {
  __typename?: 'GameStateCALModuleGlobalIntAttributeSumCheck';
  attributes: Array<Scalars['String']['output']>;
  operator: GameStateIntComparisonOperator;
  value: Scalars['Int']['output'];
};

export type GameStateCalModuleGlobalStringAttributeCheck = {
  __typename?: 'GameStateCALModuleGlobalStringAttributeCheck';
  attribute: Scalars['String']['output'];
  operator: GameStateStringComparisonOperator;
  values: Array<Scalars['String']['output']>;
};

export type GameStateCalModuleGroup = {
  __typename?: 'GameStateCALModuleGroup';
  expression: GameStateCalModuleExpression;
};

export type GameStateCalModuleIs = {
  __typename?: 'GameStateCALModuleIs';
  checkParams: Array<GameStateCalModuleCheckParam>;
  op: GameStateComparisonOperator;
};

export type GameStateCalModuleRepeat = {
  __typename?: 'GameStateCALModuleRepeat';
  expression: GameStateCalModuleExpression;
  initialValue: Scalars['Int']['output'];
  label: Scalars['String']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventBoolAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventBoolAttributeCheck';
  check: GameStateCalModuleEventBoolAttributeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventIntAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventIntAttributeCheck';
  check: GameStateCalModuleEventIntAttributeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventStringAttributeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventStringAttributeCheck';
  check: GameStateCalModuleEventStringAttributeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleRepeatedEventTypeCheck = {
  __typename?: 'GameStateCALModuleRepeatedEventTypeCheck';
  check: GameStateCalModuleEventTypeCheck;
  initialValue: Scalars['Int']['output'];
  targetValue: Scalars['Int']['output'];
};

export type GameStateCalModuleTimeoutCheck = {
  __typename?: 'GameStateCALModuleTimeoutCheck';
  duration: Scalars['Int']['output'];
  lastStateChangeTimestamp: Scalars['Int']['output'];
  lastTimestamp: Scalars['Int']['output'];
  timeLeft: Scalars['Int']['output'];
};

export type GameStateCalModuleUnaryExpression = {
  __typename?: 'GameStateCALModuleUnaryExpression';
  expression: GameStateCalModuleExpression;
  op: GameStateCalModuleUnaryOp;
};

export enum GameStateCalModuleUnaryOp {
  UnaryOpNot = 'UNARY_OP_NOT',
  UnaryOpUnspecified = 'UNARY_OP_UNSPECIFIED'
}

export type GameStateCalModuleWhen = {
  __typename?: 'GameStateCALModuleWhen';
  attribute: Scalars['String']['output'];
  cases: Array<GameStateCalModuleWhenCase>;
};

export type GameStateCalModuleWhenCase = {
  __typename?: 'GameStateCALModuleWhenCase';
  expression: GameStateCalModuleExpression;
  value?: Maybe<GameStateCalModuleWhenCaseValueUnion>;
};

export type GameStateCalModuleWhenCaseDefault = {
  __typename?: 'GameStateCALModuleWhenCaseDefault';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type GameStateCalModuleWhenCaseValueUnion = BooleanType | GameStateCalModuleWhenCaseDefault | IntType | StringType;

export type GameStateCardDealingState = {
  __typename?: 'GameStateCardDealingState';
  cardAvailability: Array<GameStateCardDealingStateCardAvailabilityEntry>;
  cardDealingModules: Array<GameStateCardDealingStateCardDealingModulesEntry>;
  cards: Array<GameStateCardDealingStateCardsEntry>;
};

export type GameStateCardDealingStateCalModulesList = {
  __typename?: 'GameStateCardDealingStateCALModulesList';
  modules: Array<GameStateCalModule>;
};

export type GameStateCardDealingStateCardAvailabilityEntry = {
  __typename?: 'GameStateCardDealingStateCardAvailabilityEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateCardDealingStateCardDealingModulesEntry = {
  __typename?: 'GameStateCardDealingStateCardDealingModulesEntry';
  key: Scalars['String']['output'];
  value: GameStateCardDealingStateCalModulesList;
};

export type GameStateCardDealingStateCardsEntry = {
  __typename?: 'GameStateCardDealingStateCardsEntry';
  key: Scalars['String']['output'];
  value: GameLogicCard;
};

export type GameStateCardState = {
  __typename?: 'GameStateCardState';
  failureModules: Array<GameStateCalModule>;
  successModules: Array<GameStateCalModule>;
};

export type GameStateChallengeState = {
  __typename?: 'GameStateChallengeState';
  challengeId: Scalars['ID']['output'];
  challengeState: GameLogicChallengeState;
  failureModule: GameStateCalModule;
  pickRate: Scalars['Float']['output'];
  successModule: GameStateCalModule;
  targetValues: Array<GameStateChallengeStateTargetValuesEntry>;
};

export type GameStateChallengeStateTargetValuesEntry = {
  __typename?: 'GameStateChallengeStateTargetValuesEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export type GameStateClientSession = {
  __typename?: 'GameStateClientSession';
  mailbox: Scalars['String']['output'];
  timestamp: Scalars['Int']['output'];
  token: Scalars['String']['output'];
};

export type GameStateClientSessionList = {
  __typename?: 'GameStateClientSessionList';
  sessions: Array<GameStateClientSession>;
};

export enum GameStateComparisonOperator {
  ComparisonOperatorEqual = 'COMPARISON_OPERATOR_EQUAL',
  ComparisonOperatorExists = 'COMPARISON_OPERATOR_EXISTS',
  ComparisonOperatorGreater = 'COMPARISON_OPERATOR_GREATER',
  ComparisonOperatorGreaterOrEqual = 'COMPARISON_OPERATOR_GREATER_OR_EQUAL',
  ComparisonOperatorIn = 'COMPARISON_OPERATOR_IN',
  ComparisonOperatorLess = 'COMPARISON_OPERATOR_LESS',
  ComparisonOperatorLessOrEqual = 'COMPARISON_OPERATOR_LESS_OR_EQUAL',
  ComparisonOperatorNotEqual = 'COMPARISON_OPERATOR_NOT_EQUAL',
  ComparisonOperatorNotExists = 'COMPARISON_OPERATOR_NOT_EXISTS',
  ComparisonOperatorNotIn = 'COMPARISON_OPERATOR_NOT_IN',
  ComparisonOperatorUnspecified = 'COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateContextualTeamActionState = {
  __typename?: 'GameStateContextualTeamActionState';
  deadlineMs: Scalars['Int']['output'];
  participants: Array<GameStateContextualTeamActionStateParticipantsEntry>;
  status: GameLogicContextualTeamActionStatus;
  type: GameLogicContextualTeamActionType;
};

export type GameStateContextualTeamActionStateParticipantsEntry = {
  __typename?: 'GameStateContextualTeamActionStateParticipantsEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateGameConfig = {
  __typename?: 'GameStateGameConfig';
  boosters: Array<GameStateGameConfigBoostersEntry>;
  challengeConfig: GameStateGameConfigChallengeConfig;
  featureFlags: Array<GameStateGameConfigFeatureFlagsEntry>;
  highScoringCardConfig: GameStateGameConfigHighScoringCardConfig;
  inactivityTimeouts: ConfigMetagameConfigInactivityTimeouts;
  matchConfiguration: GameLogicMatchConfiguration;
  uiTimings: ConfigMetagameConfigUiTimings;
};

export type GameStateGameConfigBoostersEntry = {
  __typename?: 'GameStateGameConfigBoostersEntry';
  key: Scalars['Int']['output'];
  value: GameLogicBooster;
};

export type GameStateGameConfigChallengeConfig = {
  __typename?: 'GameStateGameConfigChallengeConfig';
  availableChallengesCount: Scalars['Int']['output'];
  challenges: Array<GameStateGameConfigChallengeConfigChallengesEntry>;
  isEnabled: Scalars['Boolean']['output'];
};

export type GameStateGameConfigChallengeConfigChallengesEntry = {
  __typename?: 'GameStateGameConfigChallengeConfigChallengesEntry';
  key: Scalars['String']['output'];
  value: GameLogicChallenge;
};

export type GameStateGameConfigFeatureFlagsEntry = {
  __typename?: 'GameStateGameConfigFeatureFlagsEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type GameStateGameConfigHighScoringCardConfig = {
  __typename?: 'GameStateGameConfigHighScoringCardConfig';
  highScoringCardConfigs: Array<GameCardHighScoringCardConfig>;
  highScoringCardTimings: Array<GameCardHighScoringCardTimings>;
};

export type GameStateGroupRunnerState = {
  __typename?: 'GameStateGroupRunnerState';
  gameConfig: GameStateGameConfig;
  groupStartTime: Scalars['Int']['output'];
  groupState: GameStateGroupState;
  matchEndTime: Scalars['Int']['output'];
  matchPauseStartTime: Scalars['Int']['output'];
  matchPauseTimeTotal: Scalars['Int']['output'];
  matchTimeTrackerState: GameStateMatchTimeTrackerState;
  players: Array<GameStateGroupRunnerStatePlayersEntry>;
  randomState: GameStateRandomState;
  sessionTrackerState: GameStateSessionTrackerState;
  started: Scalars['Boolean']['output'];
  stepTimestamp: Scalars['Int']['output'];
  streamTrackerState: GameStateStreamTrackerState;
  timeOffset: Scalars['Int']['output'];
  timer: GameStateTimerState;
};

export type GameStateGroupRunnerStatePlayersEntry = {
  __typename?: 'GameStateGroupRunnerStatePlayersEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type GameStateGroupState = {
  __typename?: 'GameStateGroupState';
  activeChallenges: Array<GameStateChallengeState>;
  addedPlayers: Array<GameStateGroupStateAddedPlayersEntry>;
  boosterUsages: Array<GameStateGroupStateBoosterUsage>;
  contextualTeamActionState: GameStateContextualTeamActionState;
  group: GameLogicGroup;
  matchBonusActivationRule: GameStateCalModule;
  players: Array<GameStateGroupStatePlayersEntry>;
  removedPlayers: Array<GameStatePlayerState>;
  streamInfo: StreamInfoStreamInfo;
  timeTrackerState: GameStateTimeTrackerState;
};

export type GameStateGroupStateAddedPlayersEntry = {
  __typename?: 'GameStateGroupStateAddedPlayersEntry';
  key: Scalars['String']['output'];
  value: GameStatePlayerState;
};

export type GameStateGroupStateBoosterUsage = {
  __typename?: 'GameStateGroupStateBoosterUsage';
  boosterState: GameStateBoosterState;
  sourcePlayerId: Scalars['ID']['output'];
  targetPlayerId: Scalars['ID']['output'];
};

export type GameStateGroupStatePlayersEntry = {
  __typename?: 'GameStateGroupStatePlayersEntry';
  key: Scalars['String']['output'];
  value: GameStatePlayerState;
};

export type GameStateHighScoringCardState = {
  __typename?: 'GameStateHighScoringCardState';
  activeGroups: Array<GameStateHighScoringCardStateActiveGroupsEntry>;
  card: GameLogicHighScoringCard;
  deadline: Scalars['Int']['output'];
  groupId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type GameStateHighScoringCardStateActiveGroupsEntry = {
  __typename?: 'GameStateHighScoringCardStateActiveGroupsEntry';
  key: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export enum GameStateIntComparisonOperator {
  IntComparisonOperatorEqual = 'INT_COMPARISON_OPERATOR_EQUAL',
  IntComparisonOperatorGreater = 'INT_COMPARISON_OPERATOR_GREATER',
  IntComparisonOperatorGreaterOrEqual = 'INT_COMPARISON_OPERATOR_GREATER_OR_EQUAL',
  IntComparisonOperatorLess = 'INT_COMPARISON_OPERATOR_LESS',
  IntComparisonOperatorLessOrEqual = 'INT_COMPARISON_OPERATOR_LESS_OR_EQUAL',
  IntComparisonOperatorNotEqual = 'INT_COMPARISON_OPERATOR_NOT_EQUAL',
  IntComparisonOperatorUnspecified = 'INT_COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateMatchTimeTrackerState = {
  __typename?: 'GameStateMatchTimeTrackerState';
  time: Scalars['Int']['output'];
  timeOffset: Scalars['Int']['output'];
  timer: GameStateTimerState;
};

export type GameStatePlayerState = {
  __typename?: 'GameStatePlayerState';
  cardDealingState: GameStateCardDealingState;
  cardState: GameStateCardState;
  debugEvents: Scalars['Boolean']['output'];
  groupId: Scalars['ID']['output'];
  lastHeldBoosterId: Scalars['Int']['output'];
  player: GameLogicPlayer;
  streamId: Scalars['ID']['output'];
};

export type GameStateRandomState = {
  __typename?: 'GameStateRandomState';
  seed: Scalars['Int']['output'];
};

export type GameStateSessionTrackerState = {
  __typename?: 'GameStateSessionTrackerState';
  playerSessions: Array<GameStateSessionTrackerStatePlayerSessionsEntry>;
  spectatorSessions: Array<GameStateSessionTrackerStateSpectatorSessionsEntry>;
};

export type GameStateSessionTrackerStatePlayerSessionsEntry = {
  __typename?: 'GameStateSessionTrackerStatePlayerSessionsEntry';
  key: Scalars['String']['output'];
  value: GameStateClientSessionList;
};

export type GameStateSessionTrackerStateSpectatorSessionsEntry = {
  __typename?: 'GameStateSessionTrackerStateSpectatorSessionsEntry';
  key: Scalars['String']['output'];
  value: GameStateClientSessionList;
};

export type GameStateStreamGroupsTrackerState = {
  __typename?: 'GameStateStreamGroupsTrackerState';
  bestCard: GameLogicCardDetails;
  bestGroup: GameLogicGroupDetails;
  bestPlayer: GameLogicPlayerDetails;
};

export type GameStateStreamState = {
  __typename?: 'GameStateStreamState';
  groups: Array<Scalars['String']['output']>;
  streamGroupsTracker: GameStateStreamGroupsTrackerState;
  streamInfo: StreamInfoStreamInfo;
  streamTracker: GameStateStreamTrackerState;
};

export type GameStateStreamTrackerState = {
  __typename?: 'GameStateStreamTrackerState';
  globalAttributes: GameStateAttributesState;
  globalAttributesHash: Scalars['Int']['output'];
  globalsChanged: Scalars['Boolean']['output'];
  matchEndTime: Scalars['Int']['output'];
  matchPauseStartTime: Scalars['Int']['output'];
  matchPauseTimeTotal: Scalars['Int']['output'];
  matchStartTime: Scalars['Int']['output'];
  matchStateChanged: Scalars['Boolean']['output'];
  previousMatchState: GameLogicStreamStateMatchState;
  roundPhaseChanged: Scalars['Boolean']['output'];
  streamState: GameLogicStreamState;
};

export enum GameStateStringComparisonOperator {
  StringComparisonOperatorEqual = 'STRING_COMPARISON_OPERATOR_EQUAL',
  StringComparisonOperatorIn = 'STRING_COMPARISON_OPERATOR_IN',
  StringComparisonOperatorNotEqual = 'STRING_COMPARISON_OPERATOR_NOT_EQUAL',
  StringComparisonOperatorNotIn = 'STRING_COMPARISON_OPERATOR_NOT_IN',
  StringComparisonOperatorUnspecified = 'STRING_COMPARISON_OPERATOR_UNSPECIFIED'
}

export type GameStateTimeTrackerState = {
  __typename?: 'GameStateTimeTrackerState';
  entries: Array<GameStateTimeTrackerStateEntriesEntry>;
  matchActive: Scalars['Boolean']['output'];
};

export type GameStateTimeTrackerStateEntriesEntry = {
  __typename?: 'GameStateTimeTrackerStateEntriesEntry';
  key: Scalars['String']['output'];
  value: GameStateTimeTrackerStateTimeTrackerEntry;
};

export type GameStateTimeTrackerStateTimeTrackerEntry = {
  __typename?: 'GameStateTimeTrackerStateTimeTrackerEntry';
  disconnectedTimestamp: Scalars['Int']['output'];
  idle: Scalars['Boolean']['output'];
  idleTimestamp: Scalars['Int']['output'];
  lastOnlineTimestamp: Scalars['Int']['output'];
  online: Scalars['Boolean']['output'];
  totalIdleTime: Scalars['Int']['output'];
  totalTime: Scalars['Int']['output'];
};

export type GameStateTimerState = {
  __typename?: 'GameStateTimerState';
  activeTimeout: GameStateTimerStateTimeout;
  /** @deprecated field is deprecated */
  activeTimerDeadline: Scalars['Int']['output'];
  /** @deprecated field is deprecated */
  timeouts: Array<Scalars['Int']['output']>;
  timeoutsWithMetadata: Array<GameStateTimerStateTimeout>;
};

export type GameStateTimerStateMetadata = {
  __typename?: 'GameStateTimerStateMetadata';
  source: Scalars['String']['output'];
};

export type GameStateTimerStateTimeout = {
  __typename?: 'GameStateTimerStateTimeout';
  expirationTimestamp: Scalars['Int']['output'];
  metadata: GameStateTimerStateMetadata;
};

export type GameUserProgression = {
  __typename?: 'GameUserProgression';
  experiencePoints: Scalars['Int']['output'];
  level: Scalars['Int']['output'];
  userId: Scalars['ID']['output'];
};

export type GoalCardBatchGetGoalCardsResponse = {
  __typename?: 'GoalCardBatchGetGoalCardsResponse';
  goalCards: Array<GoalCardGoalCard>;
};

export type GoalCardGetSlotOptionsResponse = {
  __typename?: 'GoalCardGetSlotOptionsResponse';
  cardOptions: Array<GoalCardGoalCard>;
};

export type GoalCardGoalCard = {
  __typename?: 'GoalCardGoalCard';
  cardGoalGroup: Scalars['String']['output'];
  /** counter_config_ids defines which counters the goal card is tracking */
  counterConfigIds: Array<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  disabled: Scalars['Boolean']['output'];
  game?: Maybe<GameGame>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  rarity: RarityRarity;
  requiredItemIds: Array<Scalars['String']['output']>;
  requiresTeam: Scalars['Boolean']['output'];
  reward: RewardRewardType;
  /**
   * target is the target value for the counter where an award is awarded to
   *  the user
   */
  target: Scalars['Float']['output'];
  targetType: GoalCardGoalCardTargetType;
};

export type GoalCardGoalCardSlot = {
  __typename?: 'GoalCardGoalCardSlot';
  cardOptions?: Maybe<Array<GoalCardGoalCard>>;
  goalCard?: Maybe<GoalCardGoalCard>;
  goalCardId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  progress?: Maybe<GoalCardGoalCardSlotProgress>;
  resetTime?: Maybe<Scalars['Timestamp']['output']>;
  reward?: Maybe<RewardReward>;
};

export type GoalCardGoalCardSlotProgress = {
  __typename?: 'GoalCardGoalCardSlotProgress';
  completed: Scalars['Boolean']['output'];
  percentage: Scalars['Float']['output'];
  value: Scalars['Float']['output'];
};

export enum GoalCardGoalCardTargetType {
  TargetTypeSingleUpdate = 'TARGET_TYPE_SINGLE_UPDATE',
  TargetTypeTotal = 'TARGET_TYPE_TOTAL',
  TargetTypeUnspecified = 'TARGET_TYPE_UNSPECIFIED',
  TargetTypeUpdateCount = 'TARGET_TYPE_UPDATE_COUNT'
}

export type GoalCardListGoalCardSlotsResponse = {
  __typename?: 'GoalCardListGoalCardSlotsResponse';
  slots: Array<GoalCardGoalCardSlot>;
};

export type GoalCardReshuffleSlotResponse = {
  __typename?: 'GoalCardReshuffleSlotResponse';
  cardOptions: Array<GoalCardGoalCard>;
};

export type GoalCardSetGoalCardSlotResponse = {
  __typename?: 'GoalCardSetGoalCardSlotResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

/**
 * A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *
 *      service Foo {
 *        rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *      }
 *
 *  The JSON representation for `Empty` is empty JSON object `{}`.
 */
export type GoogleProtobufEmpty = {
  __typename?: 'GoogleProtobufEmpty';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

/**
 * `FieldMask` represents a set of symbolic field paths, for example:
 *
 *      paths: "f.a"
 *      paths: "f.b.d"
 *
 *  Here `f` represents a field in some root message, `a` and `b`
 *  fields in the message found in `f`, and `d` a field found in the
 *  message in `f.b`.
 *
 *  Field masks are used to specify a subset of fields that should be
 *  returned by a get operation or modified by an update operation.
 *  Field masks also have a custom JSON encoding (see below).
 *
 *  # Field Masks in Projections
 *
 *  When used in the context of a projection, a response message or
 *  sub-message is filtered by the API to only contain those fields as
 *  specified in the mask. For example, if the mask in the previous
 *  example is applied to a response message as follows:
 *
 *      f {
 *        a : 22
 *        b {
 *          d : 1
 *          x : 2
 *        }
 *        y : 13
 *      }
 *      z: 8
 *
 *  The result will not contain specific values for fields x,y and z
 *  (their value will be set to the default, and omitted in proto text
 *  output):
 *
 *
 *      f {
 *        a : 22
 *        b {
 *          d : 1
 *        }
 *      }
 *
 *  A repeated field is not allowed except at the last position of a
 *  paths string.
 *
 *  If a FieldMask object is not present in a get operation, the
 *  operation applies to all fields (as if a FieldMask of all fields
 *  had been specified).
 *
 *  Note that a field mask does not necessarily apply to the
 *  top-level response message. In case of a REST get operation, the
 *  field mask applies directly to the response, but in case of a REST
 *  list operation, the mask instead applies to each individual message
 *  in the returned resource list. In case of a REST custom method,
 *  other definitions may be used. Where the mask applies will be
 *  clearly documented together with its declaration in the API.  In
 *  any case, the effect on the returned resource/resources is required
 *  behavior for APIs.
 *
 *  # Field Masks in Update Operations
 *
 *  A field mask in update operations specifies which fields of the
 *  targeted resource are going to be updated. The API is required
 *  to only change the values of the fields as specified in the mask
 *  and leave the others untouched. If a resource is passed in to
 *  describe the updated values, the API ignores the values of all
 *  fields not covered by the mask.
 *
 *  If a repeated field is specified for an update operation, new values will
 *  be appended to the existing repeated field in the target resource. Note that
 *  a repeated field is only allowed in the last position of a `paths` string.
 *
 *  If a sub-message is specified in the last position of the field mask for an
 *  update operation, then new value will be merged into the existing sub-message
 *  in the target resource.
 *
 *  For example, given the target message:
 *
 *      f {
 *        b {
 *          d: 1
 *          x: 2
 *        }
 *        c: [1]
 *      }
 *
 *  And an update message:
 *
 *      f {
 *        b {
 *          d: 10
 *        }
 *        c: [2]
 *      }
 *
 *  then if the field mask is:
 *
 *   paths: ["f.b", "f.c"]
 *
 *  then the result will be:
 *
 *      f {
 *        b {
 *          d: 10
 *          x: 2
 *        }
 *        c: [1, 2]
 *      }
 *
 *  An implementation may provide options to override this default behavior for
 *  repeated and message fields.
 *
 *  In order to reset a field's value to the default, the field must
 *  be in the mask and set to the default value in the provided resource.
 *  Hence, in order to reset all fields of a resource, provide a default
 *  instance of the resource and set all fields in the mask, or do
 *  not provide a mask as described below.
 *
 *  If a field mask is not present on update, the operation applies to
 *  all fields (as if a field mask of all fields has been specified).
 *  Note that in the presence of schema evolution, this may mean that
 *  fields the client does not know and has therefore not filled into
 *  the request will be reset to their default. If this is unwanted
 *  behavior, a specific service may require a client to always specify
 *  a field mask, producing an error if not.
 *
 *  As with get operations, the location of the resource which
 *  describes the updated values in the request message depends on the
 *  operation kind. In any case, the effect of the field mask is
 *  required to be honored by the API.
 *
 *  ## Considerations for HTTP REST
 *
 *  The HTTP kind of an update operation which uses a field mask must
 *  be set to PATCH instead of PUT in order to satisfy HTTP semantics
 *  (PUT must only be used for full updates).
 *
 *  # JSON Encoding of Field Masks
 *
 *  In JSON, a field mask is encoded as a single string where paths are
 *  separated by a comma. Fields name in each path are converted
 *  to/from lower-camel naming conventions.
 *
 *  As an example, consider the following message declarations:
 *
 *      message Profile {
 *        User user = 1;
 *        Photo photo = 2;
 *      }
 *      message User {
 *        string display_name = 1;
 *        string address = 2;
 *      }
 *
 *  In proto a field mask for `Profile` may look as such:
 *
 *      mask {
 *        paths: "user.display_name"
 *        paths: "photo"
 *      }
 *
 *  In JSON, the same mask is represented as below:
 *
 *      {
 *        mask: "user.displayName,photo"
 *      }
 *
 *  # Field Masks and Oneof Fields
 *
 *  Field masks treat fields in oneofs just as regular fields. Consider the
 *  following message:
 *
 *      message SampleMessage {
 *        oneof test_oneof {
 *          string name = 4;
 *          SubMessage sub_message = 9;
 *        }
 *      }
 *
 *  The field mask can be:
 *
 *      mask {
 *        paths: "name"
 *      }
 *
 *  Or:
 *
 *      mask {
 *        paths: "sub_message"
 *      }
 *
 *  Note that oneof type names ("test_oneof" in this case) cannot be used in
 *  paths.
 *
 *  ## Field Mask Verification
 *
 *  The implementation of any API method which has a FieldMask type field in the
 *  request should verify the included field paths, and return an
 *  `INVALID_ARGUMENT` error if any path is unmappable.
 */
export type GoogleProtobufFieldMaskInput = {
  /** The set of field mask paths. */
  paths?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type IntType = {
  __typename?: 'IntType';
  /** The wrapped value of type Int */
  value: Scalars['Int']['output'];
};

export type InventoryAddEntitlementsResponse = {
  __typename?: 'InventoryAddEntitlementsResponse';
  items: Array<InventoryInventoryItem>;
};

export type InventoryConsumeItemResponse = {
  __typename?: 'InventoryConsumeItemResponse';
  items: Array<InventoryInventoryItem>;
};

export type InventoryInventoryEvent = {
  __typename?: 'InventoryInventoryEvent';
  event?: Maybe<InventoryInventoryEventEventUnion>;
  id: Scalars['ID']['output'];
  reason: ReasonReason;
  userId: Scalars['ID']['output'];
};

export type InventoryInventoryEventEventUnion = InventoryItemConsumption | InventoryItemEntitlement;

export type InventoryInventoryItem = {
  __typename?: 'InventoryInventoryItem';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type InventoryInventoryUpdateEvent = {
  __typename?: 'InventoryInventoryUpdateEvent';
  events: Array<InventoryInventoryEvent>;
};

export type InventoryItemConsumption = {
  __typename?: 'InventoryItemConsumption';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type InventoryItemConsumptionInput = {
  itemCount?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
};

export type InventoryItemEntitlement = {
  __typename?: 'InventoryItemEntitlement';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type InventoryItemEntitlementInput = {
  itemCount?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
};

export type InventoryListUserInventoryRequestFilterAttributeFilterInput = {
  key?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type InventoryListUserInventoryRequestFilterInput = {
  /** attribute optional attribute filter */
  attribute?: InputMaybe<InventoryListUserInventoryRequestFilterAttributeFilterInput>;
  /** game_id optional game filter */
  gameId?: InputMaybe<Scalars['ID']['input']>;
  /** item_type optional item type filter */
  itemType?: InputMaybe<ItemItemType>;
  /** season_id optional season filter */
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

export type InventoryListUserInventoryResponse = {
  __typename?: 'InventoryListUserInventoryResponse';
  items: Array<InventoryInventoryItem>;
  pageInfo: ApiPageInfo;
};

export type InvitationCreateInvitationCodesResponse = {
  __typename?: 'InvitationCreateInvitationCodesResponse';
  codes: Array<InvitationInvitationCode>;
};

export type InvitationInvitationCode = {
  __typename?: 'InvitationInvitationCode';
  code: Scalars['String']['output'];
  createdAt: Scalars['Timestamp']['output'];
  ownerId: Scalars['ID']['output'];
  usedAt?: Maybe<Scalars['Timestamp']['output']>;
  usedBy?: Maybe<ProfileProfile>;
  usedById?: Maybe<Scalars['ID']['output']>;
};

export type InvitationInvitationCodeUpdateEvent = {
  __typename?: 'InvitationInvitationCodeUpdateEvent';
  codes: Array<InvitationInvitationCode>;
  updateType: InvitationInvitationCodeUpdateEventUpdateType;
  updatedAt: Scalars['Timestamp']['output'];
};

export enum InvitationInvitationCodeUpdateEventUpdateType {
  UpdateTypeCreated = 'UPDATE_TYPE_CREATED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUsed = 'UPDATE_TYPE_USED'
}

export type InvitationListInvitationCodesResponse = {
  __typename?: 'InvitationListInvitationCodesResponse';
  codes: Array<InvitationInvitationCode>;
};

export type ItemBatchExpandItemsResponse = {
  __typename?: 'ItemBatchExpandItemsResponse';
  items: Array<ItemItem>;
};

export type ItemBatchGetItemsResponse = {
  __typename?: 'ItemBatchGetItemsResponse';
  items: Array<ItemItem>;
};

export type ItemExpandItemResponse = {
  __typename?: 'ItemExpandItemResponse';
  items: Array<ItemItem>;
};

export type ItemGetItemResponse = {
  __typename?: 'ItemGetItemResponse';
  item: ItemItem;
};

export type ItemItem = {
  __typename?: 'ItemItem';
  attributes: AttributeAttributeMap;
  bootstraps?: Maybe<Array<ItemItemBootstrap>>;
  channel?: Maybe<ChannelChannel>;
  channelId: Scalars['ID']['output'];
  children?: Maybe<Array<ItemItem>>;
  consumable: Scalars['Boolean']['output'];
  details?: Maybe<ItemItemDetailsUnion>;
  disabled: Scalars['Boolean']['output'];
  game?: Maybe<GameGame>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  inventoryItem: InventoryInventoryItem;
  name: Scalars['String']['output'];
  /** if the parent item is owned, this item is owned as well */
  parentItemId: Scalars['ID']['output'];
  season?: Maybe<GameSeason>;
  seasonId: Scalars['ID']['output'];
  type: ItemItemType;
  /** unlock_item_id what if any item is required to unlock this item for bundles and other consumption */
  unlockItemId: Scalars['ID']['output'];
  updatedAt: Scalars['Timestamp']['output'];
};


export type ItemItemInventoryItemArgs = {
  user_id: Scalars['ID']['input'];
};

export type ItemItemBootstrap = {
  __typename?: 'ItemItemBootstrap';
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
  revision: Scalars['String']['output'];
};

export type ItemItemBootstrapInput = {
  itemCount?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
};

export type ItemItemCount = {
  __typename?: 'ItemItemCount';
  count: Scalars['Int']['output'];
  type: ItemItemType;
};

export type ItemItemDetailsUnion = AvatarAnimation | AvatarAvatarPart | EmojiEmoji | GameLogicCard | GameLogicStreamerCard;

export type ItemItemStat = {
  __typename?: 'ItemItemStat';
  counts: Array<ItemItemCount>;
  gameId: Scalars['ID']['output'];
};

export type ItemItemTotalCount = {
  __typename?: 'ItemItemTotalCount';
  disabled: Scalars['Int']['output'];
  total: Scalars['Int']['output'];
};

export enum ItemItemType {
  TypeAvatarItem = 'TYPE_AVATAR_ITEM',
  TypeBootstrap = 'TYPE_BOOTSTRAP',
  TypeDailyGoalCardSlot = 'TYPE_DAILY_GOAL_CARD_SLOT',
  TypeEmoji = 'TYPE_EMOJI',
  TypeEmote = 'TYPE_EMOTE',
  TypeGameCard = 'TYPE_GAME_CARD',
  TypeStreamerCard = 'TYPE_STREAMER_CARD',
  TypeSubscription = 'TYPE_SUBSCRIPTION',
  TypeUnlock = 'TYPE_UNLOCK',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type ItemListItemsRequestFilterAttributeInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<AttributeAttributeInput>;
};

export type ItemListItemsRequestFilterInput = {
  attribute?: InputMaybe<ItemListItemsRequestFilterAttributeInput>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<ItemItemType>;
  parentId?: InputMaybe<Scalars['ID']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

export type ItemListItemsResponse = {
  __typename?: 'ItemListItemsResponse';
  count?: Maybe<ItemItemTotalCount>;
  items: Array<ItemItem>;
  pageInfo: ApiPageInfo;
};

export type MatchCardCount = {
  __typename?: 'MatchCardCount';
  card: GameLogicCard;
  cardId: Scalars['ID']['output'];
  count: Scalars['Int']['output'];
};

export type MatchChallengeUpdate = {
  __typename?: 'MatchChallengeUpdate';
  content?: Maybe<MatchChallengeUpdateContentUnion>;
};

export type MatchChallengeUpdateContentUnion = MatchChallengeUpdateReset | MatchChallengeUpdateStatusUpdate;

export type MatchChallengeUpdateReset = {
  __typename?: 'MatchChallengeUpdateReset';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type MatchChallengeUpdateStatusUpdate = {
  __typename?: 'MatchChallengeUpdateStatusUpdate';
  challenges: Array<GameLogicChallengeStatus>;
};

export type MatchGetGroupChatIdResponse = {
  __typename?: 'MatchGetGroupChatIDResponse';
  chatId: Scalars['ID']['output'];
};

export type MatchGetGroupStateResponse = {
  __typename?: 'MatchGetGroupStateResponse';
  runnerState: GameStateGroupRunnerState;
  /** @deprecated field is deprecated */
  state: GameStateGroupState;
};

export type MatchGetMatchStateResponse = {
  __typename?: 'MatchGetMatchStateResponse';
  matchState: GameLogicStreamStateMatchState;
};

export type MatchGetStreamStateResponse = {
  __typename?: 'MatchGetStreamStateResponse';
  gameConfig: GameStateGameConfig;
  groups: Array<Scalars['String']['output']>;
  highScoringCard: GameStateHighScoringCardState;
  started: Scalars['Boolean']['output'];
  streamGroupsTracker: GameStateStreamGroupsTrackerState;
  streamInfo: StreamInfoStreamInfo;
  streamTracker: GameStateStreamTrackerState;
};

export type MatchGetTopActiveCardsResponse = {
  __typename?: 'MatchGetTopActiveCardsResponse';
  topCards: Array<MatchCardCount>;
};

export type MatchStreamSpectatorChangeGroupEvent = {
  __typename?: 'MatchStreamSpectatorChangeGroupEvent';
  groupId: Scalars['ID']['output'];
};

export type MatchStreamSpectatorCoordinationEvent = {
  __typename?: 'MatchStreamSpectatorCoordinationEvent';
  event?: Maybe<MatchStreamSpectatorCoordinationEventEventUnion>;
};

export type MatchStreamSpectatorCoordinationEventEventUnion = MatchStreamSpectatorChangeGroupEvent;

export type MatchTopCardsUpdate = {
  __typename?: 'MatchTopCardsUpdate';
  content?: Maybe<MatchTopCardsUpdateContentUnion>;
};

export type MatchTopCardsUpdateCardCountUpdate = {
  __typename?: 'MatchTopCardsUpdateCardCountUpdate';
  cards: Array<MatchCardCount>;
};

export type MatchTopCardsUpdateContentUnion = MatchTopCardsUpdateCardCountUpdate | MatchTopCardsUpdateReset;

export type MatchTopCardsUpdateReset = {
  __typename?: 'MatchTopCardsUpdateReset';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type MediaBatchGetMediaUrlResponse = {
  __typename?: 'MediaBatchGetMediaURLResponse';
  urls: Array<Scalars['String']['output']>;
};

export type MediaMediaOptionsInput = {
  height?: InputMaybe<Scalars['Int']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

export type MlControllerGetHudScaleResponse = {
  __typename?: 'MlControllerGetHUDScaleResponse';
  estimatedScale: Scalars['Int']['output'];
  isScaleSufficient: Scalars['Boolean']['output'];
  mlDisabled: Scalars['Boolean']['output'];
  suggestedMinimumScale: Scalars['Int']['output'];
};

export enum ModerationAppealStatus {
  AppealStatusAccepted = 'APPEAL_STATUS_ACCEPTED',
  AppealStatusDeclined = 'APPEAL_STATUS_DECLINED',
  AppealStatusPending = 'APPEAL_STATUS_PENDING',
  AppealStatusUnspecified = 'APPEAL_STATUS_UNSPECIFIED'
}

export enum ModerationBanStatus {
  BanStatusActive = 'BAN_STATUS_ACTIVE',
  BanStatusInactive = 'BAN_STATUS_INACTIVE',
  BanStatusUnspecified = 'BAN_STATUS_UNSPECIFIED'
}

export type ModerationListPlatformBanAppealsResponse = {
  __typename?: 'ModerationListPlatformBanAppealsResponse';
  appeals: Array<ModerationPlatformBanAppeal>;
  pageInfo: ApiPageInfo;
};

export type ModerationPlatformBan = {
  __typename?: 'ModerationPlatformBan';
  appeal?: Maybe<ModerationPlatformBanAppeal>;
  appealApproved: Scalars['Boolean']['output'];
  banId: Scalars['ID']['output'];
  bannedAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  moderator: ProfileProfile;
  moderatorId: Scalars['ID']['output'];
  status: ModerationBanStatus;
  unbannedAt?: Maybe<Scalars['Timestamp']['output']>;
  unbannedBy: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
  violation: ModerationViolation;
};

export type ModerationPlatformBanAppeal = {
  __typename?: 'ModerationPlatformBanAppeal';
  appealText: Scalars['String']['output'];
  ban: ModerationPlatformBan;
  banId: Scalars['ID']['output'];
  closedAt?: Maybe<Scalars['Timestamp']['output']>;
  createdAt: Scalars['Timestamp']['output'];
  reviewer?: Maybe<ProfileProfile>;
  reviewerComment: Scalars['String']['output'];
  reviewerId: Scalars['ID']['output'];
  status: ModerationAppealStatus;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type ModerationPlatformUserBannedNotification = {
  __typename?: 'ModerationPlatformUserBannedNotification';
  bannedAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  userId: Scalars['ID']['output'];
  violation: ModerationViolation;
};

export enum ModerationViolation {
  ViolationChildSafety = 'VIOLATION_CHILD_SAFETY',
  ViolationCircumventionEvasion = 'VIOLATION_CIRCUMVENTION_EVASION',
  ViolationExtremism = 'VIOLATION_EXTREMISM',
  ViolationGraphicRealWorldMedia = 'VIOLATION_GRAPHIC_REAL_WORLD_MEDIA',
  ViolationHarassmentTargetedAbuse = 'VIOLATION_HARASSMENT_TARGETED_ABUSE',
  ViolationHatefulBehavior = 'VIOLATION_HATEFUL_BEHAVIOR',
  ViolationIllegalHarmfulAndRestrictedActivity = 'VIOLATION_ILLEGAL_HARMFUL_AND_RESTRICTED_ACTIVITY',
  ViolationOffPlatformBehavior = 'VIOLATION_OFF_PLATFORM_BEHAVIOR',
  ViolationOther = 'VIOLATION_OTHER',
  ViolationPlatformManipulation = 'VIOLATION_PLATFORM_MANIPULATION',
  ViolationRepeatedCopyrightInfringement = 'VIOLATION_REPEATED_COPYRIGHT_INFRINGEMENT',
  ViolationResponsibleStreaming = 'VIOLATION_RESPONSIBLE_STREAMING',
  ViolationRestrictedGamesAndGamesWithGraphicFootage = 'VIOLATION_RESTRICTED_GAMES_AND_GAMES_WITH_GRAPHIC_FOOTAGE',
  ViolationSelfHarm = 'VIOLATION_SELF_HARM',
  ViolationSexualBehavior = 'VIOLATION_SEXUAL_BEHAVIOR',
  ViolationSpam = 'VIOLATION_SPAM',
  ViolationUnspecified = 'VIOLATION_UNSPECIFIED',
  ViolationViolence = 'VIOLATION_VIOLENCE'
}

export type Mutation = {
  __typename?: 'Mutation';
  /** FriendsService.AcceptFriendRequest */
  acceptFriendRequest?: Maybe<FriendsAcceptFriendRequestResponse>;
  /** ChannelService.AcceptMonetizationTerms */
  acceptMonetizationTerms?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.AddOAuth2Consent */
  addOAuth2Consent?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.CreatePushNotificationToken */
  addPushNotificationToken?: Maybe<GoogleProtobufEmpty>;
  /** ReactionService.AddReaction */
  addReaction?: Maybe<ReactionReactionState>;
  /** UserInventoryAdminService.AddEntitlements */
  addUserEntitlements?: Maybe<InventoryAddEntitlementsResponse>;
  /** WalletAdminService.AddCurrencies */
  addWalletCurrencies?: Maybe<WalletAddCurrenciesResponse>;
  /** ChatModerationService.AllowModerationItem */
  allowChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.BanUser */
  banChannelUser?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.BanUser */
  banPlatformUser?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.BatchDeleteNotifications */
  batchDeleteNotifications?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.BatchMarkNotificationsRead */
  batchMarkNotificationsRead?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.BlockUser */
  blockUser?: Maybe<FriendsBlockUserResponse>;
  /** StoreServiceV2.BuyWithInGameCurrency */
  buyWithInGameCurrency?: Maybe<StoreV2BuyWithInGameCurrencyResponse>;
  /** StoreServiceV2.BuyWithPayment */
  buyWithPayment?: Maybe<StoreV2BuyWithPaymentResponse>;
  /** ChannelSubscriptionService.CancelSubscription */
  cancelChannelSubscription?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.CancelDeletion */
  cancelDataDeletion?: Maybe<GoogleProtobufEmpty>;
  /** StoreServiceV2.CancelOrder */
  cancelOrder?: Maybe<GoogleProtobufEmpty>;
  /** ChannelSubscriptionService.CheckoutExistingSubscription */
  checkoutExistingChannelSubscription?: Maybe<SubscriptionCheckoutExistingSubscriptionResponse>;
  /** ChannelSubscriptionService.CheckoutNewSubscription */
  checkoutNewChannelSubscription?: Maybe<SubscriptionCheckoutNewSubscriptionResponse>;
  /** RewardService.ClaimReward */
  claimReward?: Maybe<RewardClaimRewardResponse>;
  /** ChatModerationService.ClearModerationItem */
  clearChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.ClearPushNotifications */
  clearPushNotifications?: Maybe<GoogleProtobufEmpty>;
  /** UserInventoryAdminService.ConsumeItem */
  consumeUserItem?: Maybe<InventoryConsumeItemResponse>;
  /** AuthAdminService.CreateAccount */
  createAccount?: Maybe<AuthAccount>;
  /** AnnouncementService.CreateAnnouncement */
  createAnnouncement?: Maybe<AnnouncementAnnouncement>;
  /** AnnouncementService.CreateAnnouncementImageUploadToken */
  createAnnouncementImageUploadToken?: Maybe<AnnouncementCreateAnnouncementImageUploadTokenResponse>;
  /** ChallengeService.CreateChallenge */
  createChallenge?: Maybe<GameLogicChallenge>;
  /** ChallengeSessionService.CreateChallengeSession */
  createChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelService.CreateChannel */
  createChannel?: Maybe<ChannelChannel>;
  /** ChannelService.CreateChannelAssetUploadToken */
  createChannelAssetUploadToken?: Maybe<ChannelCreateChannelAssetUploadTokenResponse>;
  /** ChannelModerationService.CreateBanAppeal */
  createChannelBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** ChannelEmojiService.CreateChannelEmoji */
  createChannelEmoji?: Maybe<EmojiEmoji>;
  /** EmojiService.CreateEmojiUploadToken */
  createEmojiUploadToken?: Maybe<EmojiCreateEmojiUploadTokenResponse>;
  /** StreamIngestConfigService.CreateIngestConfigs */
  createIngestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** InvitationService.CreateInvitationCodes */
  createInvitationCodes?: Maybe<InvitationCreateInvitationCodesResponse>;
  /** ItemService.CreateItemBootstrap */
  createItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.CreateParty */
  createParty?: Maybe<PartyParty>;
  /** PartyService.CreatePartyInvitation */
  createPartyInvitation?: Maybe<PartyPartyInvitation>;
  /** PartyService.CreatePartyMember */
  createPartyMember?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.CreateUserPlatformBanAppeal */
  createPlatformBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.CreatePlatformEmoji */
  createPlatformEmoji?: Maybe<EmojiEmoji>;
  /** SupportService.CreateReport */
  createReport?: Maybe<SupportReport>;
  /** ChannelConfigService.CreateStreamBackendConfig */
  createStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StreamerCardService.CreateStreamerCardAssetUploadToken */
  createStreamerCardAssetUploadToken?: Maybe<GameCardCreateStreamerCardAssetUploadTokenResponse>;
  /** StreamerCardService.CreateStreamerCardDraft */
  createStreamerCardDraft?: Maybe<GameLogicStreamerCard>;
  /** StoreServiceV2.CreateStreamerCardSaleConfig */
  createStreamerCardSaleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  /** SupportService.CreateTicket */
  createSupportTicket?: Maybe<GoogleProtobufEmpty>;
  /** AnnouncementService.DeleteAnnouncement */
  deleteAnnouncement?: Maybe<GoogleProtobufEmpty>;
  /** AnnouncementService.DeleteAnnouncementImage */
  deleteAnnouncementImage?: Maybe<GoogleProtobufEmpty>;
  /** ChallengeService.DeleteChallenge */
  deleteChallenge?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.DeleteChannel */
  deleteChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.DeleteChannelAsset */
  deleteChannelAsset?: Maybe<GoogleProtobufEmpty>;
  /** ChannelEmojiService.DeleteChannelEmoji */
  deleteChannelEmoji?: Maybe<GoogleProtobufEmpty>;
  /** FTUEService.DeleteDismissedTooltip */
  deleteDismissedTooltip?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.DeleteExternalAccount */
  deleteExternalAccount?: Maybe<GoogleProtobufEmpty>;
  /** StreamIngestConfigService.DeleteIngestConfigs */
  deleteIngestConfigs?: Maybe<GoogleProtobufEmpty>;
  /** ItemService.DeleteItemBootstrap */
  deleteItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.DeleteNotification */
  deleteNotification?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.DeleteOAuth2Consent */
  deleteOAuth2Consent?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.DeletePartyInvitation */
  deletePartyInvitation?: Maybe<GoogleProtobufEmpty>;
  /** PartyService.DeletePartyMember */
  deletePartyMember?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.DeletePlatformEmoji */
  deletePlatformEmoji?: Maybe<GoogleProtobufEmpty>;
  /** PushNotificationService.DeletePushNotificationToken */
  deletePushNotificationToken?: Maybe<GoogleProtobufEmpty>;
  /** ChannelConfigService.DeleteStreamBackendConfig */
  deleteStreamBackendConfig?: Maybe<GoogleProtobufEmpty>;
  /** StreamerCardService.DeleteStreamerCardDraft */
  deleteStreamerCardDraft?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.DeleteUserData */
  deleteUserData?: Maybe<PrivacyDeleteUserDataResponse>;
  /** ChatModerationService.DenyModerationItem */
  denyChatModerationItem?: Maybe<GoogleProtobufEmpty>;
  /** FTUEService.DismissTooltip */
  dismissTooltip?: Maybe<GoogleProtobufEmpty>;
  /** PrivacyService.ExportUserData */
  exportUserData?: Maybe<PrivacyExportUserDataResponse>;
  /** ChannelService.FollowChannel - Following APIs */
  followChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.HideChatMessage */
  hideChatMessage?: Maybe<GoogleProtobufEmpty>;
  /** NotificationService.MarkNotificationRead */
  markNotificationRead?: Maybe<NotificationNotification>;
  /** MLControllerService.TriggerMatchEnd */
  mlTriggerMatchEnd?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.MuteChatUser */
  muteChatUser?: Maybe<GoogleProtobufEmpty>;
  /** ChallengeSessionService.PickChallenge */
  pickChallenge?: Maybe<ChallengesessionChallengePick>;
  /** ChallengeSessionService.ProgressChallengeSession */
  progressChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** StreamerCardService.PublishStreamerCardDraft */
  publishStreamerCardDraft?: Maybe<GoogleProtobufEmpty>;
  /** ChannelSubscriptionService.ReactivateSubscription */
  reactivateChannelSubscription?: Maybe<GoogleProtobufEmpty>;
  /** StreamIngestConfigService.RefreshIngestConfigs */
  refreshIngestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** ProfileService.RejectUsername */
  rejectUsername?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.DeleteFriend */
  removeFriend?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.DeleteFriendRequest */
  removeFriendRequest?: Maybe<GoogleProtobufEmpty>;
  /** ReactionService.RemoveReaction */
  removeReaction?: Maybe<ReactionReactionState>;
  /** GoalCardService.ReshuffleSlot */
  reshuffleGoalCardSlot?: Maybe<GoalCardReshuffleSlotResponse>;
  /** ChallengeSessionService.ResolveChallenge */
  resolveChallenge?: Maybe<ChallengesessionChallengeSession>;
  /** PlacementsService.RewardPlacement */
  rewardPlacement?: Maybe<GoogleProtobufEmpty>;
  /** ChannelConfigService.SelectStreamBackendConfig */
  selectStreamBackendConfig?: Maybe<GoogleProtobufEmpty>;
  /** ChatService.SendChatMessage */
  sendChatMessage?: Maybe<ChatSendMessageResponse>;
  /** FriendsService.SendFriendRequest */
  sendFriendRequest?: Maybe<FriendsSendFriendRequestResponse>;
  /** PushNotificationService.SendPushNotification */
  sendPushNotification?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.SetBirthday */
  setBirthday?: Maybe<GoogleProtobufEmpty>;
  /** FeatureFlagService.SetFeatureFlagConfig */
  setFeatureFlagConfig?: Maybe<FlagFeatureFlagConfig>;
  /** GoalCardService.SetGoalCardSlot */
  setGoalCardSlot?: Maybe<GoalCardSetGoalCardSlotResponse>;
  /** ChannelService.SetUserChannelRoles */
  setUserChannelRoles?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.SignAgreements */
  signAgreements?: Maybe<GoogleProtobufEmpty>;
  /** StreamerService.ActivateContextualTeamAction */
  streamerActivateContextualTeamAction?: Maybe<StreamerActivateContextualTeamActionResponse>;
  /** StreamerService.TriggerCameraTransition */
  streamerTriggerCameraTransition?: Maybe<StreamerTriggerCameraTransitionResponse>;
  /** WalletAdminService.SubtractCurrencies */
  subtractWalletCurrencies?: Maybe<WalletSubtractCurrenciesResponse>;
  /** ChannelModerationService.SuspendChannelFeature */
  suspendChannelFeature?: Maybe<GoogleProtobufEmpty>;
  /** UserActionService.TriggerEmoji */
  triggerEmoji?: Maybe<GoogleProtobufEmpty>;
  /** UserActionService.TriggerEmote */
  triggerEmote?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.UnbanUser */
  unbanChannelUser?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.UnbanUser */
  unbanPlatformUser?: Maybe<GoogleProtobufEmpty>;
  /** FriendsService.UnblockUser */
  unblockUser?: Maybe<FriendsUnblockUserResponse>;
  /** ChannelService.UnfollowChannel */
  unfollowChannel?: Maybe<GoogleProtobufEmpty>;
  /** ChatModerationService.UnmuteChatUser */
  unmuteChatUser?: Maybe<GoogleProtobufEmpty>;
  /** ChannelModerationService.UnsuspendChannelFeature */
  unsuspendChannelFeature?: Maybe<GoogleProtobufEmpty>;
  /** AuthAdminService.UpdateAccount */
  updateAccount?: Maybe<AuthAccount>;
  /** AnnouncementService.UpdateAnnouncement */
  updateAnnouncement?: Maybe<AnnouncementAnnouncement>;
  /** AvatarService.UpdateAvatar */
  updateAvatar?: Maybe<AvatarAvatar>;
  /** ChallengeService.UpdateChallenge */
  updateChallenge?: Maybe<GameLogicChallenge>;
  /** ChallengeSessionService.UpdateChallengeSession */
  updateChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelModerationService.UpdateBanAppeal */
  updateChannelBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** ChannelService.UpdateChannelDetails */
  updateChannelDetails?: Maybe<ChannelChannel>;
  /** ChannelEmojiService.UpdateChannelEmoji */
  updateChannelEmoji?: Maybe<EmojiEmoji>;
  /** ChannelModerationService.UpdateModerationSettings */
  updateChannelModerationSettings?: Maybe<ChannelModerationSettings>;
  /** ChannelService.UpdateMonetizationSettings */
  updateChannelMonetizationSettings?: Maybe<ChannelMonetizationSettings>;
  /** ChannelNotificationService.UpdateNotificationSettings */
  updateChannelNotificationSettings?: Maybe<ChannelNotificationSettings>;
  /** ChannelSubscriptionService.UpdateChannelSubscriptionConfig */
  updateChannelSubscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  /** ChannelNotificationService.UpdateFollowerNotificationSettings */
  updateFollowerNotificationSettings?: Maybe<ChannelFollowerNotificationSettings>;
  /** FriendsService.UpdateFriendsSettings */
  updateFriendsSettings?: Maybe<FriendsFriendsSettings>;
  /** ItemService.UpdateItemBootstrap */
  updateItemBootstrap?: Maybe<GoogleProtobufEmpty>;
  /** AuthServiceV4.UpdateMarketingConsent */
  updateMarketingConsent?: Maybe<GoogleProtobufEmpty>;
  /** PlatformModerationService.UpdatePlatformBanAppeal */
  updatePlatformBanAppeal?: Maybe<GoogleProtobufEmpty>;
  /** PlatformEmojiService.UpdatePlatformEmoji */
  updatePlatformEmoji?: Maybe<EmojiEmoji>;
  /** ProfileService.UpdatePrivacySettings */
  updatePrivacySettings?: Maybe<ProfilePrivacySettings>;
  /** ProfileService.UpdateProfile */
  updateProfile?: Maybe<ProfileProfile>;
  /** ProfileService.UpdateProfileAvatar */
  updateProfileAvatar?: Maybe<GoogleProtobufEmpty>;
  /** ProfileService.UpdateProfileAvatarV2 */
  updateProfileAvatarV2?: Maybe<AvatarAvatar>;
  /** ChannelConfigService.UpdateRestreamingConfig */
  updateRestreamingConfig?: Maybe<ChannelRestreamingConfig>;
  /** ChannelConfigService.UpdateStreamBackendConfig */
  updateStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StreamerCardService.UpdateStreamerCardDraft */
  updateStreamerCardDraft?: Maybe<GameLogicStreamerCard>;
  /** StoreServiceV2.UpdateStreamerCardSaleConfig */
  updateStreamerCardSaleConfig?: Maybe<StoreV2StreamerCardSaleConfig>;
  /** ChannelSubscriptionService.UpdateSubscriptionPaymentMethod - protolint:disable:next MAX_LINE_LENGTH */
  updateSubscriptionPaymentMethod?: Maybe<SubscriptionUpdateSubscriptionPaymentMethodResponse>;
  /** InvitationService.UseInvitationCode */
  useInvitationCode?: Maybe<GoogleProtobufEmpty>;
  /** AvatarService.ValidateAvatarComposition */
  validateAvatarComposition?: Maybe<AvatarValidateAvatarCompositionResponse>;
};


export type MutationAcceptFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAcceptMonetizationTermsArgs = {
  address?: InputMaybe<ApiAddressInput>;
  birthday?: InputMaybe<ApiDateInput>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<ChannelGender>;
  lastName?: InputMaybe<Scalars['String']['input']>;
};


export type MutationAddOAuth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']['input']>;
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAddPushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']['input']>;
  tokenType?: InputMaybe<NotificationPushNotificationTokenType>;
};


export type MutationAddReactionArgs = {
  parentId?: InputMaybe<Scalars['ID']['input']>;
  parentType?: InputMaybe<Scalars['String']['input']>;
  reactionType?: InputMaybe<ReactionReactionType>;
  resourceId?: InputMaybe<Scalars['ID']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
};


export type MutationAddUserEntitlementsArgs = {
  entitlements?: InputMaybe<Array<InventoryItemEntitlementInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAddWalletCurrenciesArgs = {
  currencies?: InputMaybe<Array<WalletWalletCurrencyInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationAllowChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  moderationItemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationBanChannelUserArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  keepRecentMessages?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
  violation?: InputMaybe<ChannelViolation>;
};


export type MutationBanPlatformUserArgs = {
  description?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Duration']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
  violation?: InputMaybe<ModerationViolation>;
};


export type MutationBatchDeleteNotificationsArgs = {
  notificationIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type MutationBatchMarkNotificationsReadArgs = {
  notificationIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type MutationBlockUserArgs = {
  blockedUserId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationBuyWithInGameCurrencyArgs = {
  currencyId?: InputMaybe<Scalars['ID']['input']>;
  giftOptions?: InputMaybe<StoreV2GiftOptionsInput>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  signature?: InputMaybe<Scalars['String']['input']>;
};


export type MutationBuyWithPaymentArgs = {
  giftOptions?: InputMaybe<StoreV2GiftOptionsInput>;
  itemId?: InputMaybe<Scalars['ID']['input']>;
  paymentMethod?: InputMaybe<StoreV2PaymentMethod>;
  signature?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCancelChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCancelDataDeletionArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCancelOrderArgs = {
  orderId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCheckoutExistingChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCheckoutNewChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  tier?: InputMaybe<Scalars['Int']['input']>;
};


export type MutationClaimRewardArgs = {
  rewardId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationClearChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  moderationItemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationConsumeUserItemArgs = {
  consumptions?: InputMaybe<Array<InventoryItemConsumptionInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateAccountArgs = {
  displayName?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  isBot?: InputMaybe<Scalars['Boolean']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateAnnouncementArgs = {
  category?: InputMaybe<AnnouncementAnnouncementCategory>;
  endTime?: InputMaybe<Scalars['Timestamp']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  startTime?: InputMaybe<Scalars['Timestamp']['input']>;
  targets?: InputMaybe<AnnouncementTargetsInput>;
  text?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateAnnouncementImageUploadTokenArgs = {
  announcementId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChallengeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChallengeSessionArgs = {
  challenges?: InputMaybe<Array<ChallengesessionChallengeInput>>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
  submissionWindowLength?: InputMaybe<Scalars['Int']['input']>;
};


export type MutationCreateChannelArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
  streamerId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChannelAssetUploadTokenArgs = {
  assetType?: InputMaybe<ChannelAssetType>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateChannelBanAppealArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateChannelEmojiArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateEmojiUploadTokenArgs = {
  itemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateInvitationCodesArgs = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateItemBootstrapArgs = {
  bootstrap?: InputMaybe<ItemItemBootstrapInput>;
};


export type MutationCreatePartyArgs = {
  inviteeIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type MutationCreatePartyInvitationArgs = {
  inviteeId?: InputMaybe<Scalars['ID']['input']>;
  inviterId?: InputMaybe<Scalars['ID']['input']>;
  partyId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreatePartyMemberArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreatePlatformBanAppealArgs = {
  appealText?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreatePlatformEmojiArgs = {
  label?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateReportArgs = {
  context?: InputMaybe<SupportReportContextInput>;
  description?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<SupportReportReason>;
};


export type MutationCreateStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  crConfig?: InputMaybe<ChannelContentRendererConfigInput>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  mlConfig?: InputMaybe<ChannelMachineLearningConfigInput>;
  recConfig?: InputMaybe<ChannelStreamRecorderConfigInput>;
  transcoderConfig?: InputMaybe<ChannelStreamTranscoderConfigInput>;
};


export type MutationCreateStreamerCardAssetUploadTokenArgs = {
  assetType?: InputMaybe<GameCardAssetType>;
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationCreateStreamerCardDraftArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  familyId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateStreamerCardSaleConfigArgs = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  excludeFromBundles?: InputMaybe<Scalars['Boolean']['input']>;
  period?: InputMaybe<StoreV2PeriodInput>;
};


export type MutationCreateSupportTicketArgs = {
  description?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDeleteAnnouncementArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteAnnouncementImageArgs = {
  announcementId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChannelArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChannelAssetArgs = {
  assetType?: InputMaybe<ChannelAssetType>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteChannelEmojiArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteDismissedTooltipArgs = {
  tooltipId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteExternalAccountArgs = {
  idType?: InputMaybe<AuthIdentityType>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteItemBootstrapArgs = {
  itemId?: InputMaybe<Scalars['ID']['input']>;
  revision?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDeleteNotificationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteOAuth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePartyInvitationArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePartyMemberArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePlatformEmojiArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeletePushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDeleteStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteStreamerCardDraftArgs = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDeleteUserDataArgs = {
  gracePeriod?: InputMaybe<Scalars['Duration']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDenyChatModerationItemArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  moderationItemId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDismissTooltipArgs = {
  dismissalType?: InputMaybe<FtueDismissalType>;
  tooltipId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationFollowChannelArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationHideChatMessageArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  messageId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationMarkNotificationReadArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationMlTriggerMatchEndArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationMuteChatUserArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Duration']['input']>;
  reason?: InputMaybe<ChatReason>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationPickChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
  stake?: InputMaybe<ChallengesessionStakeInput>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationProgressChallengeSessionArgs = {
  phase?: InputMaybe<ChallengesessionChallengeSessionPhase>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationPublishStreamerCardDraftArgs = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationReactivateChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRefreshIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRejectUsernameArgs = {
  currentUsername?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<ModerationViolation>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRemoveFriendArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRemoveFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRemoveReactionArgs = {
  parentId?: InputMaybe<Scalars['ID']['input']>;
  parentType?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['ID']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
};


export type MutationReshuffleGoalCardSlotArgs = {
  slotId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationResolveChallengeArgs = {
  challenge?: InputMaybe<ChallengesessionChallengeInput>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationRewardPlacementArgs = {
  placementId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSelectStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  configId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSendChatMessageArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  consentToModeration?: InputMaybe<Scalars['Boolean']['input']>;
  content?: InputMaybe<ChatMessageContentInput>;
};


export type MutationSendFriendRequestArgs = {
  friendId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSendPushNotificationArgs = {
  body?: InputMaybe<Scalars['String']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  link?: InputMaybe<Scalars['String']['input']>;
  payload?: InputMaybe<NotificationPushNotificationPayloadInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  topic?: InputMaybe<Scalars['String']['input']>;
};


export type MutationSetBirthdayArgs = {
  birthday?: InputMaybe<AuthDateInput>;
};


export type MutationSetFeatureFlagConfigArgs = {
  config?: InputMaybe<FlagFeatureFlagConfigInput>;
  previousRevision?: InputMaybe<Scalars['String']['input']>;
  validateSchema?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationSetGoalCardSlotArgs = {
  goalCardId?: InputMaybe<Scalars['ID']['input']>;
  goalCardSlotId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSetUserChannelRolesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  roles?: InputMaybe<Array<ChannelChannelRole>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSignAgreementsArgs = {
  agreements?: InputMaybe<Array<AuthTermsVersionInput>>;
};


export type MutationStreamerActivateContextualTeamActionArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationStreamerTriggerCameraTransitionArgs = {
  cameraTransitionTarget?: InputMaybe<RenderingCameraTransitionRequestTransitionTarget>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSubtractWalletCurrenciesArgs = {
  currencies?: InputMaybe<Array<WalletWalletCurrencyInput>>;
  reason?: InputMaybe<ReasonReasonInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationSuspendChannelFeatureArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Duration']['input']>;
  feature?: InputMaybe<ChannelChannelFeature>;
  reason?: InputMaybe<ChannelSuspensionReason>;
};


export type MutationTriggerEmojiArgs = {
  emojiId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationTriggerEmoteArgs = {
  emoteId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnbanChannelUserArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnbanPlatformUserArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnblockUserArgs = {
  blockedUserId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnfollowChannelArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnmuteChatUserArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUnsuspendChannelFeatureArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  feature?: InputMaybe<ChannelChannelFeature>;
};


export type MutationUpdateAccountArgs = {
  body?: InputMaybe<AuthAccountUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateAnnouncementArgs = {
  body?: InputMaybe<AnnouncementAnnouncementInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateAvatarArgs = {
  body?: InputMaybe<AvatarAvatarInput>;
};


export type MutationUpdateChallengeArgs = {
  body?: InputMaybe<ChallengeChallengeUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChallengeSessionArgs = {
  body?: InputMaybe<ChallengesessionChallengeSessionUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelBanAppealArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<ChannelAppealStatus>;
  text?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateChannelDetailsArgs = {
  body?: InputMaybe<ChannelChannelDetailsUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelEmojiArgs = {
  body?: InputMaybe<EmojiUpdateChannelEmojiParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelModerationSettingsArgs = {
  body?: InputMaybe<ChannelModerationSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelMonetizationSettingsArgs = {
  body?: InputMaybe<ChannelMonetizationSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelNotificationSettingsArgs = {
  body?: InputMaybe<ChannelUpdateNotificationSettingsParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateChannelSubscriptionConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  subscriptionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationUpdateFollowerNotificationSettingsArgs = {
  body?: InputMaybe<ChannelUpdateFollowerNotificationSettingsParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateFriendsSettingsArgs = {
  body?: InputMaybe<FriendsFriendsSettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateItemBootstrapArgs = {
  body?: InputMaybe<ItemItemBootstrapInput>;
};


export type MutationUpdateMarketingConsentArgs = {
  marketingConsent?: InputMaybe<AuthConsentStatus>;
};


export type MutationUpdatePlatformBanAppealArgs = {
  banId?: InputMaybe<Scalars['ID']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ModerationAppealStatus>;
};


export type MutationUpdatePlatformEmojiArgs = {
  body?: InputMaybe<EmojiUpdatePlatformEmojiParamsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdatePrivacySettingsArgs = {
  body?: InputMaybe<ProfilePrivacySettingsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateProfileArgs = {
  body?: InputMaybe<ProfileProfileUpdateInput>;
  options?: InputMaybe<ProfileUpdateProfileRequestOptionsInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateProfileAvatarArgs = {
  modelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateProfileAvatarV2Args = {
  modelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationUpdateRestreamingConfigArgs = {
  body?: InputMaybe<ChannelRestreamingConfigInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamBackendConfigArgs = {
  body?: InputMaybe<ChannelStreamBackendConfigInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamerCardDraftArgs = {
  body?: InputMaybe<GameCardStreamerCardDraftUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUpdateStreamerCardSaleConfigArgs = {
  body?: InputMaybe<StoreV2StreamerCardSaleConfigUpdateInput>;
  updateMask?: InputMaybe<GoogleProtobufFieldMaskInput>;
};


export type MutationUseInvitationCodeArgs = {
  code?: InputMaybe<Scalars['String']['input']>;
};


export type MutationValidateAvatarCompositionArgs = {
  composition?: InputMaybe<AvatarAvatarCompositionInput>;
};

export type NotificationForcedSignoutEvent = {
  __typename?: 'NotificationForcedSignoutEvent';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type NotificationGiftSubscription = {
  __typename?: 'NotificationGiftSubscription';
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  giver?: Maybe<ProfileProfile>;
  giverId: Scalars['ID']['output'];
  tier: Scalars['Int']['output'];
};

export type NotificationListNotificationsResponse = {
  __typename?: 'NotificationListNotificationsResponse';
  notifications: Array<NotificationNotification>;
};

export type NotificationNotification = {
  __typename?: 'NotificationNotification';
  content: NotificationNotificationContent;
  createdAt: Scalars['Timestamp']['output'];
  id: Scalars['ID']['output'];
  new: Scalars['Boolean']['output'];
  persisted: Scalars['Boolean']['output'];
};

export type NotificationNotificationContent = {
  __typename?: 'NotificationNotificationContent';
  content?: Maybe<NotificationNotificationContentContentUnion>;
};

export type NotificationNotificationContentContentUnion = AdsPlacementStateEvent | ChannelUserBannedNotification | FriendsFriendStatusUpdateEvent | GoalCardGoalCardSlot | IntType | InventoryInventoryUpdateEvent | InvitationInvitationCodeUpdateEvent | ModerationPlatformUserBannedNotification | NotificationForcedSignoutEvent | NotificationGiftSubscription | PartyPartyInvitationUpdateEvent | PrivacyUserDataExportCompleteEvent | ProfileUsernameChange | ProgressionProgressionUpdateEvent | RewardReward | SubscriptionChannelSubscriptionUpdateEvent | WalletTransactionEvent;

export type NotificationPushNotificationPayloadChannelLiveInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  channelName?: InputMaybe<Scalars['String']['input']>;
};

export type NotificationPushNotificationPayloadInput = {
  channelLive?: InputMaybe<NotificationPushNotificationPayloadChannelLiveInput>;
};

export type NotificationPushNotificationToken = {
  __typename?: 'NotificationPushNotificationToken';
  token: Scalars['String']['output'];
  tokenType: NotificationPushNotificationTokenType;
  userId: Scalars['ID']['output'];
};

export enum NotificationPushNotificationTokenType {
  PushNotificationTokenTypeFirebase = 'PUSH_NOTIFICATION_TOKEN_TYPE_FIREBASE',
  PushNotificationTokenTypeUnspecified = 'PUSH_NOTIFICATION_TOKEN_TYPE_UNSPECIFIED'
}

export type PartyParty = {
  __typename?: 'PartyParty';
  channel?: Maybe<ChannelChannel>;
  id: Scalars['ID']['output'];
  leaderId: Scalars['ID']['output'];
  members: Array<PartyPartyMember>;
  name: Scalars['String']['output'];
  public: Scalars['Boolean']['output'];
  streamId: Scalars['ID']['output'];
};

export type PartyPartyInvitation = {
  __typename?: 'PartyPartyInvitation';
  inviteeId: Scalars['ID']['output'];
  inviterId: Scalars['ID']['output'];
  partyId: Scalars['ID']['output'];
};

export type PartyPartyInvitationUpdateEvent = {
  __typename?: 'PartyPartyInvitationUpdateEvent';
  partyInvitation: PartyPartyInvitation;
  type: PartyPartyInvitationUpdateEventUpdateType;
};

export enum PartyPartyInvitationUpdateEventUpdateType {
  UpdateTypeInvitationAccepted = 'UPDATE_TYPE_INVITATION_ACCEPTED',
  UpdateTypeInvitationCreated = 'UPDATE_TYPE_INVITATION_CREATED',
  UpdateTypeInvitationDeclined = 'UPDATE_TYPE_INVITATION_DECLINED',
  UpdateTypeInvitationDeleted = 'UPDATE_TYPE_INVITATION_DELETED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED'
}

export type PartyPartyMember = {
  __typename?: 'PartyPartyMember';
  profile: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type PartyPartyUpdateEvent = {
  __typename?: 'PartyPartyUpdateEvent';
  party: PartyParty;
};

export type PaymentAmount = {
  __typename?: 'PaymentAmount';
  currency: PaymentCurrency;
  value: Scalars['Int']['output'];
};

export type PaymentAmountInput = {
  currency?: InputMaybe<PaymentCurrency>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentAppStoreSession = {
  __typename?: 'PaymentAppStoreSession';
  paymentId: Scalars['ID']['output'];
  productId: Scalars['ID']['output'];
};

export enum PaymentCurrency {
  CurrencyAed = 'CURRENCY_AED',
  CurrencyAfn = 'CURRENCY_AFN',
  CurrencyAll = 'CURRENCY_ALL',
  CurrencyAmd = 'CURRENCY_AMD',
  CurrencyAng = 'CURRENCY_ANG',
  CurrencyAoa = 'CURRENCY_AOA',
  CurrencyArs = 'CURRENCY_ARS',
  CurrencyAud = 'CURRENCY_AUD',
  CurrencyAwg = 'CURRENCY_AWG',
  CurrencyAzn = 'CURRENCY_AZN',
  CurrencyBam = 'CURRENCY_BAM',
  CurrencyBbd = 'CURRENCY_BBD',
  CurrencyBdt = 'CURRENCY_BDT',
  CurrencyBgn = 'CURRENCY_BGN',
  CurrencyBhd = 'CURRENCY_BHD',
  CurrencyBif = 'CURRENCY_BIF',
  CurrencyBmd = 'CURRENCY_BMD',
  CurrencyBnd = 'CURRENCY_BND',
  CurrencyBob = 'CURRENCY_BOB',
  CurrencyBov = 'CURRENCY_BOV',
  CurrencyBrl = 'CURRENCY_BRL',
  CurrencyBsd = 'CURRENCY_BSD',
  CurrencyBtn = 'CURRENCY_BTN',
  CurrencyBwp = 'CURRENCY_BWP',
  CurrencyByn = 'CURRENCY_BYN',
  CurrencyBzd = 'CURRENCY_BZD',
  CurrencyCad = 'CURRENCY_CAD',
  CurrencyCdf = 'CURRENCY_CDF',
  CurrencyChe = 'CURRENCY_CHE',
  CurrencyChf = 'CURRENCY_CHF',
  CurrencyChw = 'CURRENCY_CHW',
  CurrencyClf = 'CURRENCY_CLF',
  CurrencyClp = 'CURRENCY_CLP',
  CurrencyCny = 'CURRENCY_CNY',
  CurrencyCop = 'CURRENCY_COP',
  CurrencyCou = 'CURRENCY_COU',
  CurrencyCrc = 'CURRENCY_CRC',
  CurrencyCuc = 'CURRENCY_CUC',
  CurrencyCup = 'CURRENCY_CUP',
  CurrencyCve = 'CURRENCY_CVE',
  CurrencyCzk = 'CURRENCY_CZK',
  CurrencyDjf = 'CURRENCY_DJF',
  CurrencyDkk = 'CURRENCY_DKK',
  CurrencyDop = 'CURRENCY_DOP',
  CurrencyDzd = 'CURRENCY_DZD',
  CurrencyEgp = 'CURRENCY_EGP',
  CurrencyErn = 'CURRENCY_ERN',
  CurrencyEtb = 'CURRENCY_ETB',
  CurrencyEur = 'CURRENCY_EUR',
  CurrencyFjd = 'CURRENCY_FJD',
  CurrencyFkp = 'CURRENCY_FKP',
  CurrencyGbp = 'CURRENCY_GBP',
  CurrencyGel = 'CURRENCY_GEL',
  CurrencyGhs = 'CURRENCY_GHS',
  CurrencyGip = 'CURRENCY_GIP',
  CurrencyGmd = 'CURRENCY_GMD',
  CurrencyGnf = 'CURRENCY_GNF',
  CurrencyGtq = 'CURRENCY_GTQ',
  CurrencyGyd = 'CURRENCY_GYD',
  CurrencyHkd = 'CURRENCY_HKD',
  CurrencyHnl = 'CURRENCY_HNL',
  CurrencyHtg = 'CURRENCY_HTG',
  CurrencyHuf = 'CURRENCY_HUF',
  CurrencyIdr = 'CURRENCY_IDR',
  CurrencyIls = 'CURRENCY_ILS',
  CurrencyInr = 'CURRENCY_INR',
  CurrencyIqd = 'CURRENCY_IQD',
  CurrencyIrr = 'CURRENCY_IRR',
  CurrencyIsk = 'CURRENCY_ISK',
  CurrencyJmd = 'CURRENCY_JMD',
  CurrencyJod = 'CURRENCY_JOD',
  CurrencyJpy = 'CURRENCY_JPY',
  CurrencyKes = 'CURRENCY_KES',
  CurrencyKgs = 'CURRENCY_KGS',
  CurrencyKhr = 'CURRENCY_KHR',
  CurrencyKmf = 'CURRENCY_KMF',
  CurrencyKpw = 'CURRENCY_KPW',
  CurrencyKrw = 'CURRENCY_KRW',
  CurrencyKwd = 'CURRENCY_KWD',
  CurrencyKyd = 'CURRENCY_KYD',
  CurrencyKzt = 'CURRENCY_KZT',
  CurrencyLak = 'CURRENCY_LAK',
  CurrencyLbp = 'CURRENCY_LBP',
  CurrencyLkr = 'CURRENCY_LKR',
  CurrencyLrd = 'CURRENCY_LRD',
  CurrencyLsl = 'CURRENCY_LSL',
  CurrencyLyd = 'CURRENCY_LYD',
  CurrencyMad = 'CURRENCY_MAD',
  CurrencyMdl = 'CURRENCY_MDL',
  CurrencyMga = 'CURRENCY_MGA',
  CurrencyMkd = 'CURRENCY_MKD',
  CurrencyMmk = 'CURRENCY_MMK',
  CurrencyMnt = 'CURRENCY_MNT',
  CurrencyMop = 'CURRENCY_MOP',
  CurrencyMru = 'CURRENCY_MRU',
  CurrencyMur = 'CURRENCY_MUR',
  CurrencyMvr = 'CURRENCY_MVR',
  CurrencyMwk = 'CURRENCY_MWK',
  CurrencyMxn = 'CURRENCY_MXN',
  CurrencyMxv = 'CURRENCY_MXV',
  CurrencyMyr = 'CURRENCY_MYR',
  CurrencyMzn = 'CURRENCY_MZN',
  CurrencyNad = 'CURRENCY_NAD',
  CurrencyNgn = 'CURRENCY_NGN',
  CurrencyNio = 'CURRENCY_NIO',
  CurrencyNok = 'CURRENCY_NOK',
  CurrencyNpr = 'CURRENCY_NPR',
  CurrencyNzd = 'CURRENCY_NZD',
  CurrencyOmr = 'CURRENCY_OMR',
  CurrencyPab = 'CURRENCY_PAB',
  CurrencyPen = 'CURRENCY_PEN',
  CurrencyPgk = 'CURRENCY_PGK',
  CurrencyPhp = 'CURRENCY_PHP',
  CurrencyPkr = 'CURRENCY_PKR',
  CurrencyPln = 'CURRENCY_PLN',
  CurrencyPyg = 'CURRENCY_PYG',
  CurrencyQar = 'CURRENCY_QAR',
  CurrencyRon = 'CURRENCY_RON',
  CurrencyRsd = 'CURRENCY_RSD',
  CurrencyRub = 'CURRENCY_RUB',
  CurrencyRwf = 'CURRENCY_RWF',
  CurrencySar = 'CURRENCY_SAR',
  CurrencySbd = 'CURRENCY_SBD',
  CurrencyScr = 'CURRENCY_SCR',
  CurrencySdg = 'CURRENCY_SDG',
  CurrencySek = 'CURRENCY_SEK',
  CurrencySgd = 'CURRENCY_SGD',
  CurrencyShp = 'CURRENCY_SHP',
  CurrencySle = 'CURRENCY_SLE',
  CurrencySos = 'CURRENCY_SOS',
  CurrencySrd = 'CURRENCY_SRD',
  CurrencySsp = 'CURRENCY_SSP',
  CurrencyStn = 'CURRENCY_STN',
  CurrencySvc = 'CURRENCY_SVC',
  CurrencySyp = 'CURRENCY_SYP',
  CurrencySzl = 'CURRENCY_SZL',
  CurrencyThb = 'CURRENCY_THB',
  CurrencyTjs = 'CURRENCY_TJS',
  CurrencyTmt = 'CURRENCY_TMT',
  CurrencyTnd = 'CURRENCY_TND',
  CurrencyTop = 'CURRENCY_TOP',
  CurrencyTry = 'CURRENCY_TRY',
  CurrencyTtd = 'CURRENCY_TTD',
  CurrencyTwd = 'CURRENCY_TWD',
  CurrencyTzs = 'CURRENCY_TZS',
  CurrencyUah = 'CURRENCY_UAH',
  CurrencyUgx = 'CURRENCY_UGX',
  CurrencyUnspecified = 'CURRENCY_UNSPECIFIED',
  CurrencyUsd = 'CURRENCY_USD',
  CurrencyUsn = 'CURRENCY_USN',
  CurrencyUyi = 'CURRENCY_UYI',
  CurrencyUyu = 'CURRENCY_UYU',
  CurrencyUyw = 'CURRENCY_UYW',
  CurrencyUzs = 'CURRENCY_UZS',
  CurrencyVed = 'CURRENCY_VED',
  CurrencyVes = 'CURRENCY_VES',
  CurrencyVnd = 'CURRENCY_VND',
  CurrencyVuv = 'CURRENCY_VUV',
  CurrencyWst = 'CURRENCY_WST',
  CurrencyXaf = 'CURRENCY_XAF',
  CurrencyXag = 'CURRENCY_XAG',
  CurrencyXau = 'CURRENCY_XAU',
  CurrencyXba = 'CURRENCY_XBA',
  CurrencyXbb = 'CURRENCY_XBB',
  CurrencyXbc = 'CURRENCY_XBC',
  CurrencyXbd = 'CURRENCY_XBD',
  CurrencyXcd = 'CURRENCY_XCD',
  CurrencyXdr = 'CURRENCY_XDR',
  CurrencyXof = 'CURRENCY_XOF',
  CurrencyXpd = 'CURRENCY_XPD',
  CurrencyXpf = 'CURRENCY_XPF',
  CurrencyXpt = 'CURRENCY_XPT',
  CurrencyXsu = 'CURRENCY_XSU',
  CurrencyXts = 'CURRENCY_XTS',
  CurrencyXua = 'CURRENCY_XUA',
  CurrencyXxx = 'CURRENCY_XXX',
  CurrencyYer = 'CURRENCY_YER',
  CurrencyZar = 'CURRENCY_ZAR',
  CurrencyZmw = 'CURRENCY_ZMW',
  CurrencyZwl = 'CURRENCY_ZWL'
}

export type PaymentLineItem = {
  __typename?: 'PaymentLineItem';
  currency: PaymentCurrency;
  description: Scalars['String']['output'];
  price: Scalars['Int']['output'];
  quantity: Scalars['Int']['output'];
};

export type PaymentListPaymentsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  statuses?: InputMaybe<Array<PaymentPaymentStatus>>;
  to?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type PaymentListPaymentsResponse = {
  __typename?: 'PaymentListPaymentsResponse';
  pageInfo: ApiPageInfo;
  payments: Array<PaymentPayment>;
};

export type PaymentListSuccessfulPaymentsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  to?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type PaymentListSuccessfulPaymentsResponse = {
  __typename?: 'PaymentListSuccessfulPaymentsResponse';
  pageInfo: ApiPageInfo;
  payments: Array<PaymentPayment>;
};

export type PaymentPayment = {
  __typename?: 'PaymentPayment';
  amount: PaymentAmount;
  externalReference: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  info: PaymentPaymentInfo;
  items: Array<PaymentLineItem>;
  meta: PaymentSessionMeta;
  provider: PaymentPaymentProvider;
  status: PaymentPaymentStatus;
  tax: PaymentTax;
  timestamp: Scalars['Timestamp']['output'];
  userId: Scalars['ID']['output'];
};

export type PaymentPaymentInfo = {
  __typename?: 'PaymentPaymentInfo';
  cardHolderName: Scalars['String']['output'];
  cardIssuingCountry: Scalars['String']['output'];
  cardSummary: Scalars['String']['output'];
};

export enum PaymentPaymentProvider {
  PaymentProviderAdyen = 'PAYMENT_PROVIDER_ADYEN',
  PaymentProviderAppstore = 'PAYMENT_PROVIDER_APPSTORE',
  PaymentProviderUnspecified = 'PAYMENT_PROVIDER_UNSPECIFIED'
}

export enum PaymentPaymentStatus {
  PaymentStatusExpired = 'PAYMENT_STATUS_EXPIRED',
  PaymentStatusFailed = 'PAYMENT_STATUS_FAILED',
  PaymentStatusPending = 'PAYMENT_STATUS_PENDING',
  PaymentStatusReversed = 'PAYMENT_STATUS_REVERSED',
  PaymentStatusSuccess = 'PAYMENT_STATUS_SUCCESS',
  PaymentStatusUnspecified = 'PAYMENT_STATUS_UNSPECIFIED'
}

export type PaymentSession = {
  __typename?: 'PaymentSession';
  session?: Maybe<PaymentSessionSessionUnion>;
};

export type PaymentSessionMeta = {
  __typename?: 'PaymentSessionMeta';
  attributes: Array<PaymentSessionMetaAttributesEntry>;
  namespace: Scalars['String']['output'];
};

export type PaymentSessionMetaAttributesEntry = {
  __typename?: 'PaymentSessionMetaAttributesEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type PaymentSessionSessionUnion = AdyenSession | PaymentAppStoreSession;

export type PaymentTax = {
  __typename?: 'PaymentTax';
  amount?: Maybe<PaymentAmount>;
  rate: Scalars['Int']['output'];
  rateInBasisPoints: Scalars['Int']['output'];
};

export type PlayerStatsPlayerStats = {
  __typename?: 'PlayerStatsPlayerStats';
  adsWatched: Scalars['Int']['output'];
  boosterUsage?: Maybe<PlayerStatsPlayerStatsBoosterUsage>;
  cardBundlesPurchased: Scalars['Int']['output'];
  cardLevelUps: Scalars['Int']['output'];
  cardsPlayed: Scalars['Int']['output'];
  cardsSucceeded: Scalars['Int']['output'];
  currencySpending?: Maybe<PlayerStatsPlayerStatsCurrencySpending>;
  dailyGoalCardsCompleted: Scalars['Int']['output'];
  dailyGoalCardsSet: Scalars['Int']['output'];
  matchesPlayed: Scalars['Int']['output'];
  partyMatchesPlayed: Scalars['Int']['output'];
  shufflesUsed: Scalars['Int']['output'];
  soloMatchesPlayed: Scalars['Int']['output'];
  timePlayed?: Maybe<Scalars['Duration']['output']>;
};

export type PlayerStatsPlayerStatsBoosterUsage = {
  __typename?: 'PlayerStatsPlayerStatsBoosterUsage';
  doubt: Scalars['Int']['output'];
  goodCall: Scalars['Int']['output'];
  letsGo: Scalars['Int']['output'];
  nextUp: Scalars['Int']['output'];
  scavenge: Scalars['Int']['output'];
  speedUp: Scalars['Int']['output'];
  total: Scalars['Int']['output'];
};

export type PlayerStatsPlayerStatsCurrencySpending = {
  __typename?: 'PlayerStatsPlayerStatsCurrencySpending';
  channelCurrency: Scalars['Int']['output'];
  hardCurrency: Scalars['Int']['output'];
  softCurrency: Scalars['Int']['output'];
};

export type PrivacyDeleteUserDataResponse = {
  __typename?: 'PrivacyDeleteUserDataResponse';
  taskId: Scalars['ID']['output'];
};

export type PrivacyExportUserDataResponse = {
  __typename?: 'PrivacyExportUserDataResponse';
  taskId: Scalars['ID']['output'];
};

export type PrivacyUserDataExportCompleteEvent = {
  __typename?: 'PrivacyUserDataExportCompleteEvent';
  dataUrl: Scalars['String']['output'];
  taskId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ProfileBatchGetProfilesResponse = {
  __typename?: 'ProfileBatchGetProfilesResponse';
  profiles: Array<ProfileProfile>;
};

export enum ProfileColor {
  Color_6Ec9F7 = 'COLOR_6EC9F7',
  Color_56F6C0 = 'COLOR_56F6C0',
  Color_63F655 = 'COLOR_63F655',
  Color_8686F9 = 'COLOR_8686F9',
  ColorB26Afb = 'COLOR_B26AFB',
  ColorC0F656 = 'COLOR_C0F656',
  ColorF6Ce56 = 'COLOR_F6CE56',
  ColorF6F656 = 'COLOR_F6F656',
  ColorF76Ef7 = 'COLOR_F76EF7',
  ColorF69856 = 'COLOR_F69856',
  ColorUnspecified = 'COLOR_UNSPECIFIED'
}

export type ProfileGetUsernameHistoryResponse = {
  __typename?: 'ProfileGetUsernameHistoryResponse';
  changes: Array<ProfileUsernameChange>;
};

export type ProfileListPlayedGamesResponse = {
  __typename?: 'ProfileListPlayedGamesResponse';
  games: Array<ProfilePlayedGame>;
  pageInfo: ApiPageInfo;
};

export type ProfileListProfilesResponse = {
  __typename?: 'ProfileListProfilesResponse';
  pageInfo: ApiPageInfo;
  profiles: Array<ProfileProfile>;
};

export type ProfilePlayedGame = {
  __typename?: 'ProfilePlayedGame';
  game: GameGame;
  id: Scalars['ID']['output'];
  lastPlayedAt: Scalars['Timestamp']['output'];
  progression: GameUserProgression;
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export enum ProfilePresenceStatus {
  PresenceStatusOffline = 'PRESENCE_STATUS_OFFLINE',
  PresenceStatusOnline = 'PRESENCE_STATUS_ONLINE',
  PresenceStatusUnspecified = 'PRESENCE_STATUS_UNSPECIFIED'
}

export type ProfilePrivacySettings = {
  __typename?: 'ProfilePrivacySettings';
  anonymisePurchaseHighlights: Scalars['Boolean']['output'];
  discordUsernameVisibility: ProfilePrivacySettingsVisibility;
  hideOnlineStatus: Scalars['Boolean']['output'];
  showMatureContentWarning: Scalars['Boolean']['output'];
  visibility: ProfilePrivacySettingsVisibility;
};

export type ProfilePrivacySettingsInput = {
  anonymisePurchaseHighlights?: InputMaybe<Scalars['Boolean']['input']>;
  discordUsernameVisibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
  hideOnlineStatus?: InputMaybe<Scalars['Boolean']['input']>;
  showMatureContentWarning?: InputMaybe<Scalars['Boolean']['input']>;
  visibility?: InputMaybe<ProfilePrivacySettingsVisibility>;
};

export enum ProfilePrivacySettingsVisibility {
  VisibilityAll = 'VISIBILITY_ALL',
  VisibilityFriends = 'VISIBILITY_FRIENDS',
  VisibilityOnlyMe = 'VISIBILITY_ONLY_ME',
  VisibilityUnspecified = 'VISIBILITY_UNSPECIFIED'
}

/** Profile message contains user profile information */
export type ProfileProfile = {
  __typename?: 'ProfileProfile';
  account?: Maybe<AuthAccount>;
  avatarConfig?: Maybe<ProfileProfileAvatarConfig>;
  /**
   * contains a concatenated list of different avatar urls (use avatars object instead)
   * @deprecated field is deprecated
   */
  avatarUrl: Scalars['String']['output'];
  avatars?: Maybe<ProfileProfileAvatars>;
  badges: Array<BadgeBadge>;
  bio: Scalars['String']['output'];
  canChangeUsernameAt?: Maybe<Scalars['Timestamp']['output']>;
  channel?: Maybe<ChannelChannel>;
  discordUsername?: Maybe<Scalars['String']['output']>;
  /** @deprecated field is deprecated */
  displayName: Scalars['String']['output'];
  friends: Array<ProfileProfile>;
  friendshipStatus: FriendsFriendshipStatus;
  isNewUsername: Scalars['Boolean']['output'];
  lastSeen?: Maybe<Scalars['Timestamp']['output']>;
  onlineStatus: ProfilePresenceStatus;
  playedGames: Array<ProfilePlayedGame>;
  preferredColor: ProfileColor;
  settings?: Maybe<ProfileProfileSettings>;
  state: ApiEntityState;
  stats: PlayerStatsPlayerStats;
  temporary: Scalars['Boolean']['output'];
  userId: Scalars['ID']['output'];
  userTag: Scalars['String']['output'];
  usernameHistory?: Maybe<Array<ProfileUsernameChange>>;
  visibility: ProfileProfileVisibility;
};


/** Profile message contains user profile information */
export type ProfileProfileBadgesArgs = {
  channel_id?: InputMaybe<Scalars['ID']['input']>;
};


/** Profile message contains user profile information */
export type ProfileProfileStatsArgs = {
  season_id?: InputMaybe<Scalars['String']['input']>;
};


/** Profile message contains user profile information */
export type ProfileProfileUsernameHistoryArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type ProfileProfileAvatarConfig = {
  __typename?: 'ProfileProfileAvatarConfig';
  model: AvatarAvatar;
  modelId: Scalars['ID']['output'];
};

export type ProfileProfileAvatars = {
  __typename?: 'ProfileProfileAvatars';
  avatar2D: Scalars['String']['output'];
  avatar3D: Scalars['String']['output'];
  avatarFullbody: Scalars['String']['output'];
  avatarGender: Scalars['String']['output'];
};

export type ProfileProfileSettings = {
  __typename?: 'ProfileProfileSettings';
  friends: FriendsFriendsSettings;
  privacy: ProfilePrivacySettings;
};

export type ProfileProfileUpdateInput = {
  bio?: InputMaybe<Scalars['String']['input']>;
  discordUsername?: InputMaybe<Scalars['String']['input']>;
  /** @deprecated field is deprecated */
  displayName?: InputMaybe<Scalars['String']['input']>;
  preferredColor?: InputMaybe<ProfileColor>;
  userId?: InputMaybe<Scalars['ID']['input']>;
  userTag?: InputMaybe<Scalars['String']['input']>;
};

export enum ProfileProfileVisibility {
  ProfileVisibilityPrivate = 'PROFILE_VISIBILITY_PRIVATE',
  ProfileVisibilityPublic = 'PROFILE_VISIBILITY_PUBLIC',
  ProfileVisibilityUnspecified = 'PROFILE_VISIBILITY_UNSPECIFIED'
}

export type ProfileResolveUserTagsResponse = {
  __typename?: 'ProfileResolveUserTagsResponse';
  profiles: Array<ProfileProfile>;
  userIds: Array<ProfileResolveUserTagsResponseUserIdsEntry>;
};

export type ProfileResolveUserTagsResponseUserIdsEntry = {
  __typename?: 'ProfileResolveUserTagsResponseUserIdsEntry';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type ProfileUpdateProfileRequestOptionsInput = {
  omitNameValidation?: InputMaybe<Scalars['Boolean']['input']>;
  omitRankValidation?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProfileUsernameChange = {
  __typename?: 'ProfileUsernameChange';
  changedAt: Scalars['Timestamp']['output'];
  changedBy: Scalars['String']['output'];
  changer?: Maybe<ProfileProfile>;
  newUsername: Scalars['String']['output'];
  oldUsername: Scalars['String']['output'];
  reason: ModerationViolation;
};

export type ProgressionBatchGetSeasonProgressionRequestQueryInput = {
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ProgressionBatchGetSeasonProgressionResponse = {
  __typename?: 'ProgressionBatchGetSeasonProgressionResponse';
  progression: Array<ProgressionSeasonProgression>;
};

export type ProgressionChannel = {
  __typename?: 'ProgressionChannel';
  channelId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ProgressionExperiencePoints = {
  __typename?: 'ProgressionExperiencePoints';
  amount: Scalars['Int']['output'];
  target?: Maybe<ProgressionExperiencePointsTargetUnion>;
};

export type ProgressionExperiencePointsTargetUnion = ProgressionChannel | ProgressionFan | ProgressionSeason;

export type ProgressionFan = {
  __typename?: 'ProgressionFan';
  userId: Scalars['ID']['output'];
};

export type ProgressionGetDailyParticipationLimitResponse = {
  __typename?: 'ProgressionGetDailyParticipationLimitResponse';
  remainingDailyParticipationMinutes: Scalars['Int']['output'];
};

export type ProgressionGetDailyXpBoostLimitResponse = {
  __typename?: 'ProgressionGetDailyXPBoostLimitResponse';
  remainingDailyXpBoost: Scalars['Int']['output'];
};

export type ProgressionGetDailyXpEarningsLimitResponse = {
  __typename?: 'ProgressionGetDailyXPEarningsLimitResponse';
  remainingDailyXpEarningsMinutes: Scalars['Int']['output'];
};

export type ProgressionLevel = {
  __typename?: 'ProgressionLevel';
  number: Scalars['Int']['output'];
  target?: Maybe<ProgressionLevelTargetUnion>;
};

export type ProgressionLevelConfig = {
  __typename?: 'ProgressionLevelConfig';
  /**
   * channel_id is an optional configuration for channel loyalty related level
   *  configs
   */
  channelId: Scalars['ID']['output'];
  number: Scalars['Int']['output'];
  rewards: Array<RewardRewardType>;
  /** season_id is an optional configuration for season related level configs */
  seasonId: Scalars['ID']['output'];
  threshold: Scalars['Int']['output'];
};

export type ProgressionLevelTargetUnion = ProgressionChannel | ProgressionFan | ProgressionSeason;

export type ProgressionListLevelConfigsResponse = {
  __typename?: 'ProgressionListLevelConfigsResponse';
  levelConfigs: Array<ProgressionLevelConfig>;
};

export type ProgressionListSeasonProgressionResponse = {
  __typename?: 'ProgressionListSeasonProgressionResponse';
  progression: Array<ProgressionSeasonProgression>;
};

export type ProgressionProgressionUpdateEvent = {
  __typename?: 'ProgressionProgressionUpdateEvent';
  reason: ReasonReason;
  updates: Array<ProgressionProgressionUpdateEventUpdate>;
};

export type ProgressionProgressionUpdateEventUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdate';
  update?: Maybe<ProgressionProgressionUpdateEventUpdateUpdateUnion>;
};

export type ProgressionProgressionUpdateEventUpdateExperiencePointUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdateExperiencePointUpdate';
  newPoints: ProgressionExperiencePoints;
  oldPoints: ProgressionExperiencePoints;
};

export type ProgressionProgressionUpdateEventUpdateLevelUpdate = {
  __typename?: 'ProgressionProgressionUpdateEventUpdateLevelUpdate';
  newLevel: ProgressionLevel;
  oldLevel: ProgressionLevel;
};

export type ProgressionProgressionUpdateEventUpdateUpdateUnion = ProgressionProgressionUpdateEventUpdateExperiencePointUpdate | ProgressionProgressionUpdateEventUpdateLevelUpdate;

export type ProgressionSeason = {
  __typename?: 'ProgressionSeason';
  seasonId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type ProgressionSeasonProgression = {
  __typename?: 'ProgressionSeasonProgression';
  level: Scalars['Int']['output'];
  nextLevel: Scalars['Int']['output'];
  nextLevelThreshold: Scalars['Int']['output'];
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
  xpAmount: Scalars['Int']['output'];
};

export type Query = {
  __typename?: 'Query';
  /** AuthServiceV4.GetAccount */
  account?: Maybe<AuthAccount>;
  /** AgreementService.ListAgreements */
  agreements?: Maybe<AgreementListAgreementResponse>;
  /** AnnouncementService.ListAnnouncements */
  announcements?: Maybe<AnnouncementListAnnouncementsResponse>;
  /** ArenaService.GetArena */
  arena?: Maybe<ArenaArena>;
  /** ArenaService.ListArenas */
  arenas?: Maybe<ArenaListArenasResponse>;
  /** AvatarService.GetAvatar */
  avatar?: Maybe<AvatarAvatar>;
  /** AvatarAnimationService.GetAnimation */
  avatarAnimation?: Maybe<AvatarAnimation>;
  /** AvatarAnimationService.BatchGetAnimations */
  avatarAnimationBatch?: Maybe<AvatarBatchGetAnimationsResponse>;
  /** AvatarAnimationService.ListAnimations */
  avatarAnimations?: Maybe<AvatarListAnimationsResponse>;
  /** StoreServiceV2.GetAvatarEditorStoreFront */
  avatarEditorStoreFront?: Maybe<StoreV2StoreFront>;
  /** AvatarService.GetAvatarPart */
  avatarPart?: Maybe<AvatarAvatarPart>;
  /** AvatarService.ListAvatarParts */
  avatarParts?: Maybe<AvatarListAvatarPartsResponse>;
  /** AvatarService.BatchGetAvatarParts */
  avatarPartsBatch?: Maybe<AvatarBatchGetAvatarPartsResponse>;
  /** AvatarService.ListAvatars */
  avatars?: Maybe<AvatarListAvatarsResponse>;
  /** AvatarService.BatchGetAvatars */
  avatarsBatch?: Maybe<AvatarBatchGetAvatarsResponse>;
  /** ProgressionService.BatchGetSeasonProgression */
  batchGetSeasonProgression?: Maybe<ProgressionBatchGetSeasonProgressionResponse>;
  /** BadgeService.BatchGetUserBadges */
  batchGetUserBadges?: Maybe<BadgeBatchGetUserBadgesResponse>;
  /** FriendsService.ListBlockedUsers */
  blockedUsers?: Maybe<FriendsListBlockedUsersResponse>;
  /** BoosterService.GetBooster */
  booster?: Maybe<GameLogicBooster>;
  /** BoosterService.ListBoosters */
  boosters?: Maybe<GameCardListBoostersResponse>;
  /** ChallengeService.GetChallenge */
  challenge?: Maybe<GameLogicChallenge>;
  /** ChallengeService.GetChallengeRewards */
  challengeRewards?: Maybe<ChallengeGetChallengeRewardsResponse>;
  /** ChallengeService.BatchGetChallenges */
  challengesBatch?: Maybe<ChallengeListChallengesResponse>;
  /** ChannelService.GetChannel */
  channel?: Maybe<ChannelChannel>;
  /** FriendsService.GetChannelActiveFriends */
  channelActiveFriends?: Maybe<FriendsGetChannelActiveFriendsResponse>;
  /** StreamerService.ListChannelActivityEvents */
  channelActivityEvents?: Maybe<StreamerListChannelActivityEventsResponse>;
  /** ChannelModerationService.ListBanAppeals */
  channelBanAppeals?: Maybe<ChannelListBanAppealsResponse>;
  /** ChannelModerationService.GetUserBanStatus */
  channelBanUserStatus?: Maybe<ChannelUserBanStatus>;
  /** ChannelModerationService.BatchGetUserBanStatus */
  channelBanUserStatuses?: Maybe<ChannelBatchGetUserBanStatusResponse>;
  /** ChannelModerationService.ListBannedUsers */
  channelBannedUsers?: Maybe<ChannelListBannedUsersResponse>;
  /** ChannelService.GetChannelByName */
  channelByName?: Maybe<ChannelChannel>;
  /** ChannelEmojiService.ListChannelEmojis */
  channelEmojis?: Maybe<EmojiListChannelEmojisResponse>;
  /** FeatureFlagService.GetChannelFeatureFlag */
  channelFeatureFlag?: Maybe<FlagFeatureFlagState>;
  /** FeatureFlagService.ListChannelFeatureFlags */
  channelFeatureFlags?: Maybe<FlagListChannelFeatureFlagsResponse>;
  /** ChannelNotificationService.GetFollowerNotificationSettings */
  channelFollowerNotificationSettings?: Maybe<ChannelFollowerNotificationSettings>;
  /** ChannelService.GetChannelFollowerStatus */
  channelFollowerStatus?: Maybe<ChannelGetChannelFollowerStatusResponse>;
  /** ChannelService.ListGameStats */
  channelGameStats?: Maybe<ChannelListGameStatsResponse>;
  /** ChannelService.BatchGetGameStats */
  channelGameStatsBatch?: Maybe<ChannelBatchGetGameStatsResponse>;
  /** ChannelModerationService.GetModerationSettings */
  channelModerationSettings?: Maybe<ChannelModerationSettings>;
  /** ChannelNotificationService.GetNotificationSettings */
  channelNotificationSettings?: Maybe<ChannelNotificationSettings>;
  /** ChannelService.ListChannelPrivilegedUsers */
  channelPrivilegedUsers?: Maybe<ChannelListChannelPrivilegedUsersResponse>;
  /** StoreServiceV2.GetChannelStoreFront */
  channelStoreFront?: Maybe<StoreV2StoreFront>;
  /** ChannelSubscriptionService.GetChannelSubscriptionConfig */
  channelSubscriptionConfig?: Maybe<SubscriptionChannelSubscriptionConfig>;
  /** ChannelSubscriptionService.ListChannelSubscriptionTiers */
  channelSubscriptionTiers?: Maybe<SubscriptionListChannelSubscriptionTiersResponse>;
  /** ChannelSubscriptionService.ListChannelSubscriptions */
  channelSubscriptions?: Maybe<SubscriptionListChannelSubscriptionsResponse>;
  /** ChannelService.ListChannels */
  channels?: Maybe<ChannelListChannelsResponse>;
  /** ChatService.ListMessages */
  chatMessages?: Maybe<ChatListMessagesResponse>;
  /** ChatModerationService.GetChatUserStatus */
  chatUserStatus?: Maybe<ChatGetChatUserStatusResponse>;
  /** ChatService.ListChatUsers */
  chatUsers?: Maybe<ChatListChatUsersResponse>;
  /** ArenaService.GetClientSideArena */
  clientSideArena?: Maybe<ArenaClientSideArena>;
  /** ArenaService.ListClientSideArenas */
  clientSideArenas?: Maybe<ArenaListClientSideArenasResponse>;
  /** ProgressionService.GetDailyParticipationLimit */
  dailyParticipationLimit?: Maybe<ProgressionGetDailyParticipationLimitResponse>;
  /** ProgressionService.GetDailyXPBoostLimit */
  dailyXPBoostLimit?: Maybe<ProgressionGetDailyXpBoostLimitResponse>;
  /** ProgressionService.GetDailyXPEarningsLimit */
  dailyXPEarningsLimit?: Maybe<ProgressionGetDailyXpEarningsLimitResponse>;
  /** FTUEService.ListDismissedTooltips */
  dismissedTooltips?: Maybe<FtueListDismissedTooltipsResponse>;
  /** EmojiService.GetEmoji */
  emoji?: Maybe<EmojiEmoji>;
  /** EmojiService.BatchGetEmojis */
  emojisBatch?: Maybe<EmojiBatchGetEmojisResponse>;
  /** FeatureFlagService.GetFeatureFlagConfig */
  featureFlagConfig?: Maybe<FlagFeatureFlagConfig>;
  /** FeatureFlagService.GetFeatureFlagSchema */
  featureFlagSchema?: Maybe<FlagFeatureFlagSchema>;
  /** ChannelService.GetFollowStatus */
  followStatuses?: Maybe<ChannelGetFollowStatusResponse>;
  /** ChannelService.GetUserFollowedChannels */
  followedChannels?: Maybe<ChannelGetUserFollowedChannelsResponse>;
  /** FriendsService.ListFriends */
  friends?: Maybe<FriendsListFriendsResponse>;
  /** FriendsService.GetFriendshipStatus */
  friendshipStatuses?: Maybe<FriendsGetFriendshipStatusResponse>;
  /** GameService.GetGame */
  game?: Maybe<GameGame>;
  /** GameCardService.BatchGetGameCards */
  gameCards?: Maybe<GameCardBatchGetGameCardsResponse>;
  /** GameService.BatchGetGames */
  games?: Maybe<GameBatchGetGamesResponse>;
  /** ChallengeSessionService.GetChallengeSession */
  getChallengeSession?: Maybe<ChallengesessionChallengeSession>;
  /** ChannelService.BatchGetChannels */
  getChannels?: Maybe<ChannelBatchGetChannelsResponse>;
  /** ChannelService.BatchStreamGetChannel */
  getStreamChannels?: Maybe<ChannelBatchStreamGetChannelResponse>;
  /** StoreServiceV2.ListGiftSellableItems */
  giftSellableItems?: Maybe<StoreV2ListGiftSellableItemsResponse>;
  /** GoalCardService.GetGoalCard */
  goalCard?: Maybe<GoalCardGoalCard>;
  /** GoalCardService.GetSlotOptions */
  goalCardSlotOptions?: Maybe<GoalCardGetSlotOptionsResponse>;
  /** GoalCardService.ListGoalCardSlots */
  goalCardSlots?: Maybe<GoalCardListGoalCardSlotsResponse>;
  /** GoalCardService.BatchGetGoalCards */
  goalCards?: Maybe<GoalCardBatchGetGoalCardsResponse>;
  /** ChannelService.ListHighlightedChannels */
  highlightedChannels?: Maybe<ChannelListHighlightedChannelsResponse>;
  /** StreamIngestConfigService.GetIngestConfig */
  ingestConfig?: Maybe<StreamIngestConfigChannelIngestConfig>;
  /** StreamIngestConfigService.ListIngestConfigs */
  ingestConfigs?: Maybe<StreamIngestConfigChannelIngestConfigs>;
  /** UserInventoryService.ListUserInventory */
  inventory?: Maybe<InventoryListUserInventoryResponse>;
  /** InvitationService.ListInvitationCodes */
  invitationCodes?: Maybe<InvitationListInvitationCodesResponse>;
  /** ItemService.GetItem */
  item?: Maybe<ItemGetItemResponse>;
  /** ItemService.ExpandItem */
  itemExpand?: Maybe<ItemExpandItemResponse>;
  /** ItemService.ListItems */
  items?: Maybe<ItemListItemsResponse>;
  /** ItemService.BatchGetItems */
  itemsBatch?: Maybe<ItemBatchGetItemsResponse>;
  /** ItemService.BatchExpandItems */
  itemsBatchExpand?: Maybe<ItemBatchExpandItemsResponse>;
  /** ChallengeService.ListChallenges */
  listChallenges?: Maybe<ChallengeListChallengesResponse>;
  /** GameCardService.ListGameCards */
  listGameCards?: Maybe<GameCardListGameCardsResponse>;
  /** GameService.ListGames */
  listGames?: Maybe<GameListGamesResponse>;
  /** ProgressionService.ListLevelConfigs */
  listLevelConfigs?: Maybe<ProgressionListLevelConfigsResponse>;
  /** ProgressionService.ListSeasonProgression */
  listSeasonProgression?: Maybe<ProgressionListSeasonProgressionResponse>;
  /** GameService.ListSeasons */
  listSeasons?: Maybe<GameListSeasonsResponse>;
  /** MatchServiceV2.GetGroupChatID */
  matchGroupChatID?: Maybe<MatchGetGroupChatIdResponse>;
  /** MatchAdminService.GetGroupState */
  matchGroupState?: Maybe<MatchGetGroupStateResponse>;
  /** MatchServiceV2.GetMatchState */
  matchState?: Maybe<MatchGetMatchStateResponse>;
  /** MatchAdminService.GetStreamState */
  matchStreamState?: Maybe<MatchGetStreamStateResponse>;
  /** MediaService.BatchGetMediaUrl */
  mediaUrlsBatch?: Maybe<MediaBatchGetMediaUrlResponse>;
  /** MLControllerService.GetHUDScale */
  mlHUDScale?: Maybe<MlControllerGetHudScaleResponse>;
  /** ChannelModerationService.ListModerationEvents */
  moderationEvents?: Maybe<ChannelListModerationEventsResponse>;
  /** NotificationService.ListNotifications */
  notifications?: Maybe<NotificationListNotificationsResponse>;
  /** AuthServiceV4.GetOAuth2Consent */
  oauth2Consent?: Maybe<AuthV4GetOAuth2ConsentResponse>;
  /** PartyService.GetParty */
  party?: Maybe<PartyParty>;
  /** PaymentService.GetPayment */
  payment?: Maybe<PaymentPayment>;
  /** PaymentService.ListPayments */
  payments?: Maybe<PaymentListPaymentsResponse>;
  /** PlacementsService.GetPlacement */
  placement?: Maybe<AdsGetPlacementResponse>;
  /** PlatformModerationService.GetUserPlatformBan */
  platformBan?: Maybe<ModerationPlatformBan>;
  /** PlatformModerationService.ListPlatformBanAppeals */
  platformBanAppeals?: Maybe<ModerationListPlatformBanAppealsResponse>;
  /** PlatformEmojiService.ListPlatformEmojis */
  platformEmojis?: Maybe<EmojiListPlatformEmojisResponse>;
  /** StoreServiceV2.GetPlatformStoreFront */
  platformStoreFront?: Maybe<StoreV2StoreFront>;
  /** ProfileService.ListPlayedGames */
  playedGames?: Maybe<ProfileListPlayedGamesResponse>;
  /** ProfileService.GetProfile - Returns user profiles based on a given userID */
  profile?: Maybe<ProfileProfile>;
  /** ProfileService.BatchGetProfiles */
  profileBatch?: Maybe<ProfileBatchGetProfilesResponse>;
  /** ProfileService.ListProfiles */
  profiles?: Maybe<ProfileListProfilesResponse>;
  /** SearchService.PublicSearch */
  publicSearch?: Maybe<SearchSearchResponse>;
  /** PushNotificationService.GetNotificationToken */
  pushNotificationToken?: Maybe<NotificationPushNotificationToken>;
  /** FriendsService.ListReceivedFriendRequests */
  receivedFriendRequests?: Maybe<FriendsListReceivedFriendRequestsResponse>;
  /** SupportService.GetReportCase */
  reportCase?: Maybe<SupportReportCase>;
  /** SupportService.ListReports */
  reports?: Maybe<SupportListReportsResponse>;
  /** ProfileService.ResolveUserTags */
  resolveUserTags?: Maybe<ProfileResolveUserTagsResponse>;
  /** ChannelConfigService.GetRestreamingConfig */
  restreamingConfig?: Maybe<ChannelRestreamingConfig>;
  /** RewardService.ListRewards */
  rewards?: Maybe<RewardListRewardsResponse>;
  /** SearchService.Search */
  search?: Maybe<SearchSearchResponse>;
  /** GameService.GetSeason */
  season?: Maybe<GameSeason>;
  /** ProgressionService.GetSeasonProgression */
  seasonProgression?: Maybe<ProgressionSeasonProgression>;
  /** GameService.BatchGetSeasons */
  seasons?: Maybe<GameBatchGetSeasonsResponse>;
  /** ChannelConfigService.GetSelectedStreamBackendConfig */
  selectedStreamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** StoreServiceV2.GetSellableItem */
  sellableItem?: Maybe<StoreV2SellableItem>;
  /** StoreServiceV2.ListSellableItems */
  sellableItems?: Maybe<StoreV2ListSellableItemsResponse>;
  /** FriendsService.ListSentFriendRequests */
  sentFriendRequests?: Maybe<FriendsListSentFriendRequestsResponse>;
  /** ChannelService.GetStream */
  stream?: Maybe<ChannelStream>;
  /** StreamerService.GetStreamAudienceInsights */
  streamAudienceInsights?: Maybe<StreamerStreamAudienceInsights>;
  /** ChannelConfigService.GetStreamBackendConfig */
  streamBackendConfig?: Maybe<ChannelStreamBackendConfig>;
  /** ChannelConfigService.ListStreamBackendConfigs */
  streamBackendConfigs?: Maybe<ChannelListStreamBackendConfigsResponse>;
  /** ChannelService.GetStreamSummary */
  streamSummary?: Maybe<ChannelStreamSummary>;
  /** ChannelService.BatchGetStreamSummary */
  streamSummaryBatch?: Maybe<ChannelBatchGetStreamSummaryResponse>;
  /** MatchServiceV2.GetTopActiveCards */
  streamTopActiveCards?: Maybe<MatchGetTopActiveCardsResponse>;
  /** StreamerCardService.GetStreamerCard */
  streamerCard?: Maybe<GameLogicStreamerCard>;
  /** StreamerCardService.ListStreamerCardDrafts */
  streamerCardDrafts?: Maybe<GameCardListStreamerCardDraftsResponse>;
  /** StoreServiceV2.ListStreamerCardSaleConfigs */
  streamerCardSaleConfigs?: Maybe<StoreV2ListStreamerCardSaleConfigsResponse>;
  /** StreamerCardService.ListStreamerCards */
  streamerCards?: Maybe<GameCardListStreamerCardsResponse>;
  /** StreamerCardService.BatchGetStreamerCards */
  streamerCardsBatch?: Maybe<GameCardBatchGetStreamerCardsResponse>;
  /** ChannelService.ListStreams */
  streams?: Maybe<ChannelListStreamsResponse>;
  /** PaymentService.ListSuccessfulPayments */
  successfulPayments?: Maybe<PaymentListSuccessfulPaymentsResponse>;
  /** SupportService.GetArticle */
  supportArticle?: Maybe<SupportArticle>;
  /** StoreServiceV2.ListTopUpSellableItems */
  topUpSellableItems?: Maybe<StoreV2ListTopUpSellableItemsResponse>;
  /** AnnouncementService.ListUserAnnouncements */
  userAnnouncements?: Maybe<AnnouncementListUserAnnouncementsResponse>;
  /** BadgeService.GetUserBadges */
  userBadges?: Maybe<BadgeGetUserBadgesResponse>;
  /** ChannelService.GetUserChannel */
  userChannel?: Maybe<ChannelChannel>;
  /** ChannelModerationService.ListUserChannelBans */
  userChannelBans?: Maybe<ChannelListUserChannelBansResponse>;
  /** ChannelService.ListUserChannelRoles */
  userChannelRoles?: Maybe<ChannelListUserChannelRolesResponse>;
  /** ChannelSubscriptionService.GetUserChannelSubscription */
  userChannelSubscription?: Maybe<SubscriptionChannelSubscription>;
  /** ChannelSubscriptionService.ListUserChannelSubscriptions */
  userChannelSubscriptions?: Maybe<SubscriptionListUserChannelSubscriptionsResponse>;
  /** FeatureFlagService.GetUserFeatureFlag */
  userFeatureFlag?: Maybe<FlagFeatureFlagState>;
  /** FeatureFlagService.ListUserFeatureFlags */
  userFeatureFlags?: Maybe<FlagListUserFeatureFlagsResponse>;
  /** PartyService.GetUserParty */
  userParty?: Maybe<PartyParty>;
  /** ChannelService.ListUserPrivilegedChannels */
  userPrivilegedChannels?: Maybe<ChannelListUserPrivilegedChannelsResponse>;
  /** ProfileService.GetUsernameHistory */
  usernameHistory?: Maybe<ProfileGetUsernameHistoryResponse>;
  /** WalletService.GetWallet */
  wallet?: Maybe<WalletGetWalletResponse>;
  /** WalletService.ListWalletTransactions */
  walletTransactions?: Maybe<WalletListWalletTransactionsResponse>;
};


export type QueryAccountArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAgreementsArgs = {
  includeOldRevisions?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAnnouncementsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<AnnouncementAnnouncementFilterInput>;
};


export type QueryArenaArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryArenasArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryAvatarArgs = {
  avatarId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAvatarAnimationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAvatarAnimationBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryAvatarPartArgs = {
  avatarPartId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAvatarPartsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryAvatarsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  listAll?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAvatarsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryBatchGetSeasonProgressionArgs = {
  queries?: InputMaybe<Array<ProgressionBatchGetSeasonProgressionRequestQueryInput>>;
};


export type QueryBatchGetUserBadgesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type QueryBlockedUsersArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryBoosterArgs = {
  id?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryChallengeArgs = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChallengeRewardsArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChallengesBatchArgs = {
  challengeIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryChannelArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelActiveFriendsArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelActivityEventsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<StreamerChannelActivityEventFilterInput>;
};


export type QueryChannelBanAppealsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelBanUserStatusArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelBanUserStatusesArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelBannedUsersArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelByNameArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
};


export type QueryChannelEmojisArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  includeCount?: InputMaybe<Scalars['Boolean']['input']>;
  includeDisabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryChannelFeatureFlagArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  flagName?: InputMaybe<Scalars['String']['input']>;
};


export type QueryChannelFeatureFlagsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelFollowerNotificationSettingsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelFollowerStatusArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelGameStatsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<ChannelListGameStatsRequestFilterInput>>;
};


export type QueryChannelGameStatsBatchArgs = {
  gameIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryChannelModerationSettingsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelNotificationSettingsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelPrivilegedUsersArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChannelStoreFrontArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelSubscriptionConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelSubscriptionTiersArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChannelSubscriptionsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<SubscriptionListChannelSubscriptionsRequestFilterInput>>;
};


export type QueryChannelsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  liveStatus?: InputMaybe<ChannelLiveStatus>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type QueryChatMessagesArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryChatUserStatusArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryChatUsersArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  sortBy?: InputMaybe<Scalars['String']['input']>;
  userLabel?: InputMaybe<ChatUserLabel>;
};


export type QueryClientSideArenaArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryClientSideArenasArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryDismissedTooltipsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryEmojiArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryEmojisBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryFeatureFlagConfigArgs = {
  revision?: InputMaybe<Scalars['String']['input']>;
};


export type QueryFollowStatusesArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryFollowedChannelsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  liveStatus?: InputMaybe<ChannelLiveStatus>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryFriendsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<FriendsListFriendsRequestFilterInput>>;
  priorityOrder?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryFriendshipStatusesArgs = {
  friendIds?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGameArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGameCardsArgs = {
  cardIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGamesArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGetChallengeSessionArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGetChannelsArgs = {
  channelIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGetStreamChannelsArgs = {
  streamIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryGiftSellableItemsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};


export type QueryGoalCardArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGoalCardSlotOptionsArgs = {
  slotId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGoalCardsArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryHighlightedChannelsArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIngestConfigArgs = {
  ftlId?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryIngestConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryInventoryArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<InventoryListUserInventoryRequestFilterInput>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryInvitationCodesArgs = {
  includeUsed?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryItemArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryItemExpandArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryItemsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<ItemListItemsRequestFilterInput>>;
};


export type QueryItemsBatchArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryItemsBatchExpandArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryListChallengesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListGameCardsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListGamesArgs = {
  gameName?: InputMaybe<Scalars['String']['input']>;
};


export type QueryListLevelConfigsArgs = {
  maxLevel?: InputMaybe<Scalars['Int']['input']>;
  minLevel?: InputMaybe<Scalars['Int']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListSeasonProgressionArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryListSeasonsArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchGroupChatIdArgs = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchGroupStateArgs = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchStateArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMatchStreamStateArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryMediaUrlsBatchArgs = {
  options?: InputMaybe<MediaMediaOptionsInput>;
  urls?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryMlHudScaleArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryModerationEventsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<ChannelModerationEventsFilterInput>;
};


export type QueryNotificationsArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};


export type QueryOauth2ConsentArgs = {
  clientId?: InputMaybe<Scalars['ID']['input']>;
  scopes?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPartyArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPaymentArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPaymentsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<PaymentListPaymentsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlacementArgs = {
  placementId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlatformBanArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlatformBanAppealsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  status?: InputMaybe<ModerationAppealStatus>;
};


export type QueryPlatformEmojisArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  includeCount?: InputMaybe<Scalars['Boolean']['input']>;
  includeDisabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryPlatformStoreFrontArgs = {
  gameId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPlayedGamesArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryProfileArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryProfileBatchArgs = {
  userIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryProfilesArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryPublicSearchArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  entityTypes?: InputMaybe<Array<SearchEntityType>>;
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QueryPushNotificationTokenArgs = {
  token?: InputMaybe<Scalars['String']['input']>;
};


export type QueryReceivedFriendRequestsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryReportCaseArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryReportsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<SupportReportsFilterInput>;
};


export type QueryResolveUserTagsArgs = {
  userTags?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryRestreamingConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRewardsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySearchArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  entityTypes?: InputMaybe<Array<SearchEntityType>>;
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySeasonArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySeasonProgressionArgs = {
  seasonId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySeasonsArgs = {
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QuerySelectedStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySellableItemArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySellableItemsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<StoreV2ListSellableItemsRequestFilterInput>;
};


export type QuerySentFriendRequestsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamAudienceInsightsArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamBackendConfigArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamBackendConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamSummaryArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamSummaryBatchArgs = {
  streamIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryStreamTopActiveCardsArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamerCardArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStreamerCardDraftsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<GameCardListStreamerCardDraftsRequestFilterInput>>;
};


export type QueryStreamerCardSaleConfigsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QueryStreamerCardsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<GameCardListStreamerCardsRequestFilterInput>>;
};


export type QueryStreamerCardsBatchArgs = {
  streamerCardIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryStreamsArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
};


export type QuerySuccessfulPaymentsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<PaymentListSuccessfulPaymentsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySupportArticleArgs = {
  attachmentBaseUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTopUpSellableItemsArgs = {
  currencyId?: InputMaybe<Scalars['ID']['input']>;
  minAmount?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryUserAnnouncementsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  target?: InputMaybe<AnnouncementAnnouncementTarget>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserBadgesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelBansArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelRolesArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelSubscriptionArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserChannelSubscriptionsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<SubscriptionListUserChannelSubscriptionsRequestFilterInput>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserFeatureFlagArgs = {
  flagName?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserFeatureFlagsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserPartyArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUserPrivilegedChannelsArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryUsernameHistoryArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryWalletArgs = {
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryWalletTransactionsArgs = {
  cursor?: InputMaybe<ApiCursorInput>;
  filter?: InputMaybe<WalletListWalletTransactionsRequestFilterInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export enum RarityRarity {
  RarityCommon = 'RARITY_COMMON',
  RarityEpic = 'RARITY_EPIC',
  RarityLegendary = 'RARITY_LEGENDARY',
  RarityRare = 'RARITY_RARE',
  RarityUncommon = 'RARITY_UNCOMMON',
  RarityUnspecified = 'RARITY_UNSPECIFIED'
}

export type ReactionReactionEvent = {
  __typename?: 'ReactionReactionEvent';
  event?: Maybe<ReactionReactionEventEventUnion>;
  parentId: Scalars['ID']['output'];
  parentType: Scalars['String']['output'];
};

export type ReactionReactionEventAdd = {
  __typename?: 'ReactionReactionEventAdd';
  reactionType: ReactionReactionType;
  resourceId: Scalars['ID']['output'];
  resourceType: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
};

export type ReactionReactionEventEventUnion = ReactionReactionEventAdd | ReactionReactionEventInitial | ReactionReactionEventRemove;

export type ReactionReactionEventInitial = {
  __typename?: 'ReactionReactionEventInitial';
  states: Array<ReactionReactionState>;
};

export type ReactionReactionEventRemove = {
  __typename?: 'ReactionReactionEventRemove';
  reactionType: ReactionReactionType;
  resourceId: Scalars['ID']['output'];
  resourceType: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
};

export type ReactionReactionState = {
  __typename?: 'ReactionReactionState';
  /** reactions is a map of reaction type (enum string) to count */
  reactions: Array<ReactionReactionStateReactionsEntry>;
  resourceId: Scalars['ID']['output'];
  resourceType: Scalars['String']['output'];
  userHasReacted: Scalars['Boolean']['output'];
};

export type ReactionReactionStateReactionsEntry = {
  __typename?: 'ReactionReactionStateReactionsEntry';
  key: Scalars['String']['output'];
  value: Scalars['Int']['output'];
};

export enum ReactionReactionType {
  ReactionTypeLike = 'REACTION_TYPE_LIKE',
  ReactionTypeUnspecified = 'REACTION_TYPE_UNSPECIFIED'
}

export type ReasonReason = {
  __typename?: 'ReasonReason';
  metadata?: Maybe<AttributeAttributeMap>;
  reason?: Maybe<ReasonReasonReasonUnion>;
};

export type ReasonReasonAdWatched = {
  __typename?: 'ReasonReasonAdWatched';
  placementId: Scalars['ID']['output'];
};

export type ReasonReasonAdWatchedInput = {
  placementId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonAdministrative = {
  __typename?: 'ReasonReasonAdministrative';
  reason: Scalars['String']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type ReasonReasonAdministrativeInput = {
  reason?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonChallengeSuccessful = {
  __typename?: 'ReasonReasonChallengeSuccessful';
  challengeId: Scalars['ID']['output'];
};

export type ReasonReasonChallengeSuccessfulInput = {
  challengeId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonChannelOwner = {
  __typename?: 'ReasonReasonChannelOwner';
  channelId: Scalars['ID']['output'];
};

export type ReasonReasonChannelOwnerInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonChannelSubscription = {
  __typename?: 'ReasonReasonChannelSubscription';
  channelId: Scalars['ID']['output'];
};

export type ReasonReasonChannelSubscriptionInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithInGameCurrency = {
  __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID']['output'];
  revenueShares: Array<ReasonRevenueShare>;
  senderId: Scalars['ID']['output'];
  sku: Scalars['String']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithInGameCurrencyInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  senderId?: InputMaybe<Scalars['ID']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithPayment = {
  __typename?: 'ReasonReasonGiftPurchaseWithPayment';
  cardIssuingCountry: Scalars['String']['output'];
  orderId: Scalars['ID']['output'];
  price: PaymentAmount;
  reference: Scalars['String']['output'];
  senderId: Scalars['ID']['output'];
  sku: Scalars['String']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonGiftPurchaseWithPaymentInput = {
  cardIssuingCountry?: InputMaybe<Scalars['String']['input']>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  price?: InputMaybe<PaymentAmountInput>;
  reference?: InputMaybe<Scalars['String']['input']>;
  senderId?: InputMaybe<Scalars['ID']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type ReasonReasonGoalCardComplete = {
  __typename?: 'ReasonReasonGoalCardComplete';
  goalCard: GoalCardGoalCard;
  goalCardId: Scalars['ID']['output'];
  goalCardSlotId: Scalars['ID']['output'];
};

export type ReasonReasonGoalCardCompleteInput = {
  goalCardId?: InputMaybe<Scalars['ID']['input']>;
  goalCardSlotId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonGoalCardSlotReshuffle = {
  __typename?: 'ReasonReasonGoalCardSlotReshuffle';
  goalCardSlotId: Scalars['ID']['output'];
};

export type ReasonReasonGoalCardSlotReshuffleInput = {
  goalCardSlotId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonInput = {
  adWatched?: InputMaybe<ReasonReasonAdWatchedInput>;
  administrative?: InputMaybe<ReasonReasonAdministrativeInput>;
  challengeSuccessful?: InputMaybe<ReasonReasonChallengeSuccessfulInput>;
  channelOwner?: InputMaybe<ReasonReasonChannelOwnerInput>;
  channelSubscription?: InputMaybe<ReasonReasonChannelSubscriptionInput>;
  giftPurchaseWithInGameCurrency?: InputMaybe<ReasonReasonGiftPurchaseWithInGameCurrencyInput>;
  giftPurchaseWithPayment?: InputMaybe<ReasonReasonGiftPurchaseWithPaymentInput>;
  goalCardComplete?: InputMaybe<ReasonReasonGoalCardCompleteInput>;
  goalCardSlotReshuffle?: InputMaybe<ReasonReasonGoalCardSlotReshuffleInput>;
  levelUp?: InputMaybe<ReasonReasonLevelUpInput>;
  matchEnd?: InputMaybe<ReasonReasonMatchEndInput>;
  metadata?: InputMaybe<AttributeAttributeMapInput>;
  provision?: InputMaybe<ReasonReasonProvisionInput>;
  purchaseWithInGameCurrency?: InputMaybe<ReasonReasonPurchaseWithInGameCurrencyInput>;
  purchaseWithPayment?: InputMaybe<ReasonReasonPurchaseWithPaymentInput>;
  reshuffle?: InputMaybe<ReasonReasonReshuffleInput>;
  rewardClaimed?: InputMaybe<ReasonReasonRewardClaimedInput>;
  storeOrderPayment?: InputMaybe<ReasonReasonStoreOrderPaymentInput>;
};

export type ReasonReasonLevelUp = {
  __typename?: 'ReasonReasonLevelUp';
  level: Scalars['Int']['output'];
  season: GameSeason;
  seasonId: Scalars['ID']['output'];
};

export type ReasonReasonLevelUpInput = {
  level?: InputMaybe<Scalars['Int']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonMatchEnd = {
  __typename?: 'ReasonReasonMatchEnd';
  groupId: Scalars['ID']['output'];
};

export type ReasonReasonMatchEndInput = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonProvision = {
  __typename?: 'ReasonReasonProvision';
  rev: Scalars['String']['output'];
  seasonId: Scalars['ID']['output'];
};

export type ReasonReasonProvisionInput = {
  rev?: InputMaybe<Scalars['String']['input']>;
  seasonId?: InputMaybe<Scalars['ID']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithInGameCurrency = {
  __typename?: 'ReasonReasonPurchaseWithInGameCurrency';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID']['output'];
  revenueShares: Array<ReasonRevenueShare>;
  sku: Scalars['String']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithInGameCurrencyInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithPayment = {
  __typename?: 'ReasonReasonPurchaseWithPayment';
  cardIssuingCountry: Scalars['String']['output'];
  orderId: Scalars['ID']['output'];
  price: PaymentAmount;
  reference: Scalars['String']['output'];
  sku: Scalars['String']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type ReasonReasonPurchaseWithPaymentInput = {
  cardIssuingCountry?: InputMaybe<Scalars['String']['input']>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  price?: InputMaybe<PaymentAmountInput>;
  reference?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type ReasonReasonReasonUnion = ReasonReasonAdWatched | ReasonReasonAdministrative | ReasonReasonChallengeSuccessful | ReasonReasonChannelOwner | ReasonReasonChannelSubscription | ReasonReasonGiftPurchaseWithInGameCurrency | ReasonReasonGiftPurchaseWithPayment | ReasonReasonGoalCardComplete | ReasonReasonGoalCardSlotReshuffle | ReasonReasonLevelUp | ReasonReasonMatchEnd | ReasonReasonProvision | ReasonReasonPurchaseWithInGameCurrency | ReasonReasonPurchaseWithPayment | ReasonReasonReshuffle | ReasonReasonRewardClaimed | ReasonReasonStoreOrderPayment;

export type ReasonReasonReshuffle = {
  __typename?: 'ReasonReasonReshuffle';
  groupId: Scalars['ID']['output'];
  matchId: Scalars['ID']['output'];
  streamId: Scalars['ID']['output'];
};

export type ReasonReasonReshuffleInput = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
  matchId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};

export type ReasonReasonRewardClaimed = {
  __typename?: 'ReasonReasonRewardClaimed';
  rewardId: Scalars['ID']['output'];
  rewardReason: ReasonReason;
};

export type ReasonReasonRewardClaimedInput = {
  rewardId?: InputMaybe<Scalars['ID']['input']>;
  rewardReason?: InputMaybe<ReasonReasonInput>;
};

export type ReasonReasonStoreOrderPayment = {
  __typename?: 'ReasonReasonStoreOrderPayment';
  adRevenueShares: Array<ReasonRevenueShare>;
  itemType: StoreV2ItemType;
  orderId: Scalars['ID']['output'];
  revenueShares: Array<ReasonRevenueShare>;
  sku: Scalars['String']['output'];
};

export type ReasonReasonStoreOrderPaymentInput = {
  adRevenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  itemType?: InputMaybe<StoreV2ItemType>;
  orderId?: InputMaybe<Scalars['ID']['input']>;
  revenueShares?: InputMaybe<Array<ReasonRevenueShareInput>>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

export type ReasonRevenueRecipient = {
  __typename?: 'ReasonRevenueRecipient';
  kind: ReasonRevenueRecipientKind;
  recipientId: Scalars['ID']['output'];
};

export type ReasonRevenueRecipientInput = {
  kind?: InputMaybe<ReasonRevenueRecipientKind>;
  recipientId?: InputMaybe<Scalars['ID']['input']>;
};

export enum ReasonRevenueRecipientKind {
  KindChannel = 'KIND_CHANNEL',
  KindPlatform = 'KIND_PLATFORM',
  KindUnspecified = 'KIND_UNSPECIFIED'
}

export type ReasonRevenueShare = {
  __typename?: 'ReasonRevenueShare';
  percent: Scalars['Int']['output'];
  recipient: ReasonRevenueRecipient;
};

export type ReasonRevenueShareInput = {
  percent?: InputMaybe<Scalars['Int']['input']>;
  recipient?: InputMaybe<ReasonRevenueRecipientInput>;
};

export enum RenderingCameraTransitionRequestTransitionTarget {
  TransitionTargetArena = 'TRANSITION_TARGET_ARENA',
  TransitionTargetCameraDrive1 = 'TRANSITION_TARGET_CAMERA_DRIVE1',
  TransitionTargetSpotlight = 'TRANSITION_TARGET_SPOTLIGHT',
  TransitionTargetUnspecified = 'TRANSITION_TARGET_UNSPECIFIED'
}

export type RewardClaimRewardResponse = {
  __typename?: 'RewardClaimRewardResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type RewardListRewardsResponse = {
  __typename?: 'RewardListRewardsResponse';
  rewards: Array<RewardReward>;
};

export type RewardReward = {
  __typename?: 'RewardReward';
  id: Scalars['ID']['output'];
  reason: ReasonReason;
  rewardedAt: Scalars['Timestamp']['output'];
  type: RewardRewardType;
  userId: Scalars['ID']['output'];
};

export type RewardRewardType = {
  __typename?: 'RewardRewardType';
  reward?: Maybe<RewardRewardTypeRewardUnion>;
};

export type RewardRewardTypeCurrency = {
  __typename?: 'RewardRewardTypeCurrency';
  currencyAmount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
};

export type RewardRewardTypeItem = {
  __typename?: 'RewardRewardTypeItem';
  item: ItemItem;
  itemCount: Scalars['Int']['output'];
  itemId: Scalars['ID']['output'];
};

export type RewardRewardTypeRewardUnion = RewardRewardTypeCurrency | RewardRewardTypeItem;

export enum SearchEntityType {
  EntityTypeChannel = 'ENTITY_TYPE_CHANNEL',
  EntityTypeGame = 'ENTITY_TYPE_GAME',
  EntityTypeUnspecified = 'ENTITY_TYPE_UNSPECIFIED',
  EntityTypeUser = 'ENTITY_TYPE_USER'
}

export type SearchResultItem = {
  __typename?: 'SearchResultItem';
  entity?: Maybe<SearchResultItemEntityUnion>;
  entityId: Scalars['ID']['output'];
  entityType: SearchEntityType;
  matchedProperties: Array<Scalars['String']['output']>;
  score: Scalars['Float']['output'];
};

export type SearchResultItemEntityUnion = ChannelChannel | ChannelGameStats | ProfileProfile;

export type SearchSearchResponse = {
  __typename?: 'SearchSearchResponse';
  pageInfo: ApiPageInfo;
  resultItems: Array<SearchResultItem>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2BuyWithInGameCurrencyResponse = {
  __typename?: 'StoreV2BuyWithInGameCurrencyResponse';
  orderId: Scalars['ID']['output'];
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2BuyWithPaymentResponse = {
  __typename?: 'StoreV2BuyWithPaymentResponse';
  orderId: Scalars['ID']['output'];
  session: PaymentSession;
};

export type StoreV2Content = {
  __typename?: 'StoreV2Content';
  value?: Maybe<StoreV2ContentValueUnion>;
};

export type StoreV2ContentValueUnion = StoreV2CurrencyRef | StoreV2ItemRef | StoreV2SubscriptionRef;

export type StoreV2CurrencyRef = {
  __typename?: 'StoreV2CurrencyRef';
  amount: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
};

export type StoreV2GiftOptionsInput = {
  giftAnonymously?: InputMaybe<Scalars['Boolean']['input']>;
  recipientIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** protolint:disable:next MESSAGE_NAMES_EXCLUDE_PREPOSITIONS */
export type StoreV2InGameCurrencyPrice = {
  __typename?: 'StoreV2InGameCurrencyPrice';
  amount: Scalars['Int']['output'];
  amountWithoutDiscount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
  default: Scalars['Boolean']['output'];
};

export type StoreV2ItemRef = {
  __typename?: 'StoreV2ItemRef';
  count: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  inventoryState?: Maybe<InventoryInventoryItem>;
  item: ItemItem;
};

export enum StoreV2ItemType {
  ItemTypeAvatarPart = 'ITEM_TYPE_AVATAR_PART',
  ItemTypeCurrencyPack = 'ITEM_TYPE_CURRENCY_PACK',
  ItemTypeGiftSubscription = 'ITEM_TYPE_GIFT_SUBSCRIPTION',
  ItemTypePremiumCardBundle = 'ITEM_TYPE_PREMIUM_CARD_BUNDLE',
  ItemTypeStandardCardBundle = 'ITEM_TYPE_STANDARD_CARD_BUNDLE',
  ItemTypeStreamerCard = 'ITEM_TYPE_STREAMER_CARD',
  ItemTypeUnspecified = 'ITEM_TYPE_UNSPECIFIED'
}

export type StoreV2ListGiftSellableItemsResponse = {
  __typename?: 'StoreV2ListGiftSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
};

export type StoreV2ListSellableItemsRequestChannelStoreFilterInput = {
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};

export type StoreV2ListSellableItemsRequestFilterInput = {
  channel?: InputMaybe<StoreV2ListSellableItemsRequestChannelStoreFilterInput>;
  platform?: InputMaybe<StoreV2ListSellableItemsRequestPlatformStoreFilterInput>;
};

export type StoreV2ListSellableItemsRequestPlatformStoreFilterInput = {
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  gameId?: InputMaybe<Scalars['ID']['input']>;
  itemType?: InputMaybe<StoreV2ItemType>;
};

export type StoreV2ListSellableItemsResponse = {
  __typename?: 'StoreV2ListSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
  pageInfo: ApiPageInfo;
};

export type StoreV2ListStreamerCardSaleConfigsResponse = {
  __typename?: 'StoreV2ListStreamerCardSaleConfigsResponse';
  configs: Array<StoreV2StreamerCardSaleConfig>;
  pageInfo: ApiPageInfo;
};

export type StoreV2ListTopUpSellableItemsResponse = {
  __typename?: 'StoreV2ListTopUpSellableItemsResponse';
  items: Array<StoreV2SellableItem>;
};

export enum StoreV2PaymentMethod {
  PaymentMethodAdyen = 'PAYMENT_METHOD_ADYEN',
  PaymentMethodAppstore = 'PAYMENT_METHOD_APPSTORE',
  PaymentMethodUnspecified = 'PAYMENT_METHOD_UNSPECIFIED'
}

export type StoreV2Period = {
  __typename?: 'StoreV2Period';
  from: Scalars['Timestamp']['output'];
  until: Scalars['Timestamp']['output'];
};

export type StoreV2PeriodInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  until?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type StoreV2Price = {
  __typename?: 'StoreV2Price';
  amount: Scalars['Int']['output'];
  amountWithoutDiscount: Scalars['Int']['output'];
  currency: PaymentCurrency;
};

export type StoreV2PurchaseLimits = {
  __typename?: 'StoreV2PurchaseLimits';
  perItem: Scalars['Int']['output'];
  perUser: Scalars['Int']['output'];
};

export enum StoreV2RecipientRestriction {
  RecipientRestrictionGiftOnly = 'RECIPIENT_RESTRICTION_GIFT_ONLY',
  RecipientRestrictionSelfOnly = 'RECIPIENT_RESTRICTION_SELF_ONLY',
  RecipientRestrictionUnspecified = 'RECIPIENT_RESTRICTION_UNSPECIFIED'
}

export type StoreV2SellableItem = {
  __typename?: 'StoreV2SellableItem';
  availableUntil?: Maybe<Scalars['Timestamp']['output']>;
  content: Array<StoreV2Content>;
  discountPercent: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  igcPrices?: Maybe<Array<StoreV2InGameCurrencyPrice>>;
  meta: StoreV2SellableItemMeta;
  name: Scalars['String']['output'];
  price?: Maybe<StoreV2Price>;
  promotionName: Scalars['String']['output'];
  purchaseLimits: StoreV2PurchaseLimits;
  recipientRestriction: StoreV2RecipientRestriction;
  signature: Scalars['String']['output'];
  sku: Scalars['String']['output'];
  type: StoreV2ItemType;
};

export type StoreV2SellableItemMeta = {
  __typename?: 'StoreV2SellableItemMeta';
  channelId: Scalars['ID']['output'];
  configId: Scalars['ID']['output'];
  itemType: StoreV2ItemType;
  promotionId: Scalars['ID']['output'];
  storeFrontId: Scalars['ID']['output'];
  storeType: StoreV2StoreType;
};

export type StoreV2StoreFront = {
  __typename?: 'StoreV2StoreFront';
  categories?: Maybe<Array<StoreV2StoreFrontCategory>>;
  gameId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  type: StoreV2StoreType;
};

export type StoreV2StoreFrontCategory = {
  __typename?: 'StoreV2StoreFrontCategory';
  id: Scalars['ID']['output'];
  itemType: StoreV2ItemType;
  sellableItems: Array<StoreV2SellableItem>;
};

export enum StoreV2StoreType {
  StoreTypeAvatarEditor = 'STORE_TYPE_AVATAR_EDITOR',
  StoreTypeChannel = 'STORE_TYPE_CHANNEL',
  StoreTypePlatform = 'STORE_TYPE_PLATFORM',
  StoreTypeUnspecified = 'STORE_TYPE_UNSPECIFIED'
}

export type StoreV2StreamerCardSaleConfig = {
  __typename?: 'StoreV2StreamerCardSaleConfig';
  cardId: Scalars['ID']['output'];
  channelId: Scalars['ID']['output'];
  enabled: Scalars['Boolean']['output'];
  excludeFromBundles: Scalars['Boolean']['output'];
  period?: Maybe<StoreV2Period>;
};

export type StoreV2StreamerCardSaleConfigUpdateInput = {
  cardId?: InputMaybe<Scalars['ID']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  excludeFromBundles?: InputMaybe<Scalars['Boolean']['input']>;
  period?: InputMaybe<StoreV2PeriodInput>;
  unsetPeriod?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StoreV2SubscriptionRef = {
  __typename?: 'StoreV2SubscriptionRef';
  amount: Scalars['Int']['output'];
  channelId: Scalars['ID']['output'];
  /** this is not used */
  id: Scalars['ID']['output'];
  tier: Scalars['Int']['output'];
};

export enum StreamDeploymentStreamDeploymentStatusComponentStatus {
  ComponentStatusContainersUnready = 'COMPONENT_STATUS_CONTAINERS_UNREADY',
  ComponentStatusDeployingContainers = 'COMPONENT_STATUS_DEPLOYING_CONTAINERS',
  ComponentStatusDeployingPod = 'COMPONENT_STATUS_DEPLOYING_POD',
  ComponentStatusDeploymentStarted = 'COMPONENT_STATUS_DEPLOYMENT_STARTED',
  ComponentStatusDisabled = 'COMPONENT_STATUS_DISABLED',
  ComponentStatusOffline = 'COMPONENT_STATUS_OFFLINE',
  ComponentStatusProvisioningNode = 'COMPONENT_STATUS_PROVISIONING_NODE',
  ComponentStatusReady = 'COMPONENT_STATUS_READY',
  ComponentStatusUnspecified = 'COMPONENT_STATUS_UNSPECIFIED'
}

export type StreamInfoStreamInfo = {
  __typename?: 'StreamInfoStreamInfo';
  channelId: Scalars['ID']['output'];
  gameId: Scalars['ID']['output'];
  seasonId: Scalars['ID']['output'];
  streamId: Scalars['ID']['output'];
};

export type StreamIngestConfigChannelIngestConfig = {
  __typename?: 'StreamIngestConfigChannelIngestConfig';
  channelId: Scalars['ID']['output'];
  config: StreamIngestConfigIngestConfig;
  streamingStatus: StreamIngestConfigStreamingStatus;
};

export type StreamIngestConfigChannelIngestConfigs = {
  __typename?: 'StreamIngestConfigChannelIngestConfigs';
  channelId: Scalars['ID']['output'];
  configs: Array<StreamIngestConfigIngestConfig>;
};

export type StreamIngestConfigIngestConfig = {
  __typename?: 'StreamIngestConfigIngestConfig';
  ingest?: Maybe<StreamIngestConfigIngestConfigIngestUnion>;
};

export type StreamIngestConfigIngestConfigFtlConfig = {
  __typename?: 'StreamIngestConfigIngestConfigFTLConfig';
  sharedKey: Scalars['String']['output'];
  streamId: Scalars['Int']['output'];
  streamKey: Scalars['String']['output'];
};

export type StreamIngestConfigIngestConfigIngestUnion = StreamIngestConfigIngestConfigFtlConfig;

export enum StreamIngestConfigStreamingStatus {
  StreamingStatusStreamingDisabled = 'STREAMING_STATUS_STREAMING_DISABLED',
  StreamingStatusUnspecified = 'STREAMING_STATUS_UNSPECIFIED',
  StreamingStatusUserSuspended = 'STREAMING_STATUS_USER_SUSPENDED'
}

export type StreamerActivateContextualTeamActionResponse = {
  __typename?: 'StreamerActivateContextualTeamActionResponse';
  activated: Scalars['Boolean']['output'];
  cooldown: Scalars['Duration']['output'];
};

export type StreamerAvatarItemPurchased = {
  __typename?: 'StreamerAvatarItemPurchased';
  item: ItemItem;
  itemId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerBundlePurchased = {
  __typename?: 'StreamerBundlePurchased';
  bundleName: Scalars['String']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerChannelActivityEvent = {
  __typename?: 'StreamerChannelActivityEvent';
  content?: Maybe<StreamerChannelActivityEventContentUnion>;
  id: Scalars['ID']['output'];
  timestamp: Scalars['Timestamp']['output'];
};

export type StreamerChannelActivityEventContentUnion = GameLogicHighScoringCardPromotedMsg | StreamerAvatarItemPurchased | StreamerBundlePurchased | StreamerChannelFollowed | StreamerChannelSubscribed | StreamerMatchEnded | StreamerMatchStarted | StreamerPlayerJoined | StreamerStreamEnded | StreamerStreamStarted | StreamerStreamTitleChanged | StreamerStreamerCardPurchased | StreamerSubscriptionGifted | StreamerSubscriptionRenewed;

export enum StreamerChannelActivityEventFilterEventType {
  EventTypeAvatarItemPurchased = 'EVENT_TYPE_AVATAR_ITEM_PURCHASED',
  EventTypeBundlePurchased = 'EVENT_TYPE_BUNDLE_PURCHASED',
  EventTypeChannelFollowed = 'EVENT_TYPE_CHANNEL_FOLLOWED',
  EventTypeChannelSubscribed = 'EVENT_TYPE_CHANNEL_SUBSCRIBED',
  EventTypeChannelSubscriptionGifted = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_GIFTED',
  EventTypeChannelSubscriptionRenewed = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_RENEWED',
  EventTypeHighScoringCardPromoted = 'EVENT_TYPE_HIGH_SCORING_CARD_PROMOTED',
  EventTypeMatchEnded = 'EVENT_TYPE_MATCH_ENDED',
  EventTypeMatchStarted = 'EVENT_TYPE_MATCH_STARTED',
  EventTypePlayerJoined = 'EVENT_TYPE_PLAYER_JOINED',
  EventTypeStreamerCardPurchased = 'EVENT_TYPE_STREAMER_CARD_PURCHASED',
  EventTypeStreamEnded = 'EVENT_TYPE_STREAM_ENDED',
  EventTypeStreamStarted = 'EVENT_TYPE_STREAM_STARTED',
  EventTypeStreamTitleChanged = 'EVENT_TYPE_STREAM_TITLE_CHANGED',
  EventTypeUnspecified = 'EVENT_TYPE_UNSPECIFIED'
}

export type StreamerChannelActivityEventFilterInput = {
  eventTypes?: InputMaybe<Array<StreamerChannelActivityEventFilterEventType>>;
};

export type StreamerChannelFollowed = {
  __typename?: 'StreamerChannelFollowed';
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type StreamerChannelSubscribed = {
  __typename?: 'StreamerChannelSubscribed';
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerListChannelActivityEventsResponse = {
  __typename?: 'StreamerListChannelActivityEventsResponse';
  events: Array<StreamerChannelActivityEvent>;
  pageInfo: ApiPageInfo;
};

export type StreamerMatchEnded = {
  __typename?: 'StreamerMatchEnded';
  bestCard?: Maybe<GameLogicCardDetails>;
  bestGroup?: Maybe<GameLogicGroupDetails>;
  bestPlayer?: Maybe<GameLogicPlayerDetails>;
  challengeStatuses?: Maybe<Array<GameLogicChallengeStatus>>;
  streamId: Scalars['ID']['output'];
};

export type StreamerMatchStarted = {
  __typename?: 'StreamerMatchStarted';
  streamId: Scalars['ID']['output'];
};

export type StreamerPlayerJoined = {
  __typename?: 'StreamerPlayerJoined';
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type StreamerStreamAudienceInsights = {
  __typename?: 'StreamerStreamAudienceInsights';
  chatters: Scalars['Int']['output'];
  followers: Scalars['Int']['output'];
  players: Scalars['Int']['output'];
  subscribers: Scalars['Int']['output'];
  viewers: Scalars['Int']['output'];
};

export type StreamerStreamDiagnosticsEvent = {
  __typename?: 'StreamerStreamDiagnosticsEvent';
  channelId: Scalars['ID']['output'];
  obsNoiceValidator: StreamerStreamDiagnosticsEventObsNoiceValidator;
  obsPluginInfo: StreamerStreamDiagnosticsEventObsPluginInfo;
  streamId: Scalars['ID']['output'];
};

export type StreamerStreamDiagnosticsEventObsNoiceValidator = {
  __typename?: 'StreamerStreamDiagnosticsEventObsNoiceValidator';
  missingValidator: Scalars['Boolean']['output'];
  occludingSourceNames: Array<Scalars['String']['output']>;
};

export type StreamerStreamDiagnosticsEventObsPluginInfo = {
  __typename?: 'StreamerStreamDiagnosticsEventObsPluginInfo';
  obsVersion: Scalars['String']['output'];
  pluginVersion: Scalars['String']['output'];
};

export type StreamerStreamDiagnosticsUpdate = {
  __typename?: 'StreamerStreamDiagnosticsUpdate';
  content?: Maybe<StreamerStreamDiagnosticsUpdateContentUnion>;
};

export type StreamerStreamDiagnosticsUpdateContentUnion = IntType | StreamerStreamDiagnosticsEvent;

export type StreamerStreamEnded = {
  __typename?: 'StreamerStreamEnded';
  streamId: Scalars['ID']['output'];
};

export type StreamerStreamEvent = {
  __typename?: 'StreamerStreamEvent';
  content?: Maybe<StreamerStreamEventContentUnion>;
  timestamp: Scalars['Timestamp']['output'];
};

export type StreamerStreamEventContentUnion = GameLogicActiveCardSucceededMsg | GameLogicHighScoringCardPromotedMsg | GameLogicMatchEndedMsg | GameLogicMatchPauseStateChangedMsg | GameLogicMatchStartedMsg | GameLogicPlayerJoinedMsg | GameStateStreamState | IntType | StreamerChannelFollowed | StreamerChannelSubscribed | StreamerSubscriptionGifted;

export enum StreamerStreamEventFilterEventType {
  EventTypeActiveCardSucceeded = 'EVENT_TYPE_ACTIVE_CARD_SUCCEEDED',
  EventTypeChannelFollowed = 'EVENT_TYPE_CHANNEL_FOLLOWED',
  EventTypeChannelSubscribed = 'EVENT_TYPE_CHANNEL_SUBSCRIBED',
  EventTypeChannelSubscriptionGifted = 'EVENT_TYPE_CHANNEL_SUBSCRIPTION_GIFTED',
  EventTypeHighScoringCardPromoted = 'EVENT_TYPE_HIGH_SCORING_CARD_PROMOTED',
  EventTypePlayerJoined = 'EVENT_TYPE_PLAYER_JOINED',
  EventTypeUnspecified = 'EVENT_TYPE_UNSPECIFIED'
}

export type StreamerStreamEventFilterInput = {
  eventTypes?: InputMaybe<Array<StreamerStreamEventFilterEventType>>;
};

export type StreamerStreamStarted = {
  __typename?: 'StreamerStreamStarted';
  streamId: Scalars['ID']['output'];
};

export type StreamerStreamTitleChanged = {
  __typename?: 'StreamerStreamTitleChanged';
  title: Scalars['String']['output'];
};

export type StreamerStreamerCardPurchased = {
  __typename?: 'StreamerStreamerCardPurchased';
  streamerCard: GameLogicStreamerCard;
  streamerCardId: Scalars['ID']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerSubscriptionGifted = {
  __typename?: 'StreamerSubscriptionGifted';
  recipientUserIds: Array<Scalars['String']['output']>;
  recipients?: Maybe<Array<ProfileProfile>>;
  tier: Scalars['Int']['output'];
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerSubscriptionRenewed = {
  __typename?: 'StreamerSubscriptionRenewed';
  user?: Maybe<ProfileProfile>;
  userId: Scalars['ID']['output'];
};

export type StreamerTriggerCameraTransitionResponse = {
  __typename?: 'StreamerTriggerCameraTransitionResponse';
  success: Scalars['Boolean']['output'];
};

export type StringType = {
  __typename?: 'StringType';
  /** The wrapped value of type String */
  value: Scalars['String']['output'];
};

export type Subscription = {
  __typename?: 'Subscription';
  /** StreamerService.ChannelActivityEvents */
  channelActivityEventsSubscribe?: Maybe<StreamerChannelActivityEvent>;
  /** ChannelService.ChannelEventStream */
  channelEventsSubscribe?: Maybe<ChannelChannelEvent>;
  /** ChannelService.FollowerCountUpdates */
  channelFollowerCountSubscribe?: Maybe<ChannelFollowerCountEvent>;
  /** ChannelService.LiveStatusUpdates - Subscription APIs */
  channelLiveStatusSubscribe?: Maybe<ChannelLiveStatusEvent>;
  /** ChannelService.ChannelStreamDetailUpdates */
  channelStreamDetailSubscribe?: Maybe<ChannelChannelStreamDetailEvent>;
  /** ChannelService.ViewerCountUpdates */
  channelViewerCountSubscribe?: Maybe<ChannelViewerCountEvent>;
  /** ChatModerationService.StreamAutoModQueue */
  chatAutoModQueueSubscribe?: Maybe<ChatAutoModQueueEvent>;
  /** ChatService.ChatMessageStream */
  chatMessageSubscribe?: Maybe<ChatChatEvent>;
  /** ChannelConfigService.IngestStatsUpdates */
  ingestStatsSubscribe?: Maybe<ChannelIngestStatsEvent>;
  /** MLControllerService.StreamHUDScaleUpdates */
  mlHUDScaleUpdatesSubscribe?: Maybe<MlControllerGetHudScaleResponse>;
  /** ChannelModerationService.ModerationEventsStream */
  moderationEventsSubscribe?: Maybe<ChannelModerationEvent>;
  /** NotificationService.Notifications */
  notificationSubscribe?: Maybe<NotificationNotification>;
  /** PartyService.StreamPartyUpdates */
  partyUpdateSubscribe?: Maybe<PartyPartyUpdateEvent>;
  /** ReactionService.StreamReactions */
  reactionsSubscription?: Maybe<ReactionReactionEvent>;
  /** ChallengeSessionService.ChallengeSessionEvents */
  streamChallengeSessionEvents?: Maybe<ChallengesessionChallengeSessionEvent>;
  /** MatchServiceV2.ChallengeUpdates */
  streamChallengeUpdatesSubscribe?: Maybe<MatchChallengeUpdate>;
  /** StreamerService.StreamDiagnosticsUpdates */
  streamDiagnosticsSubscribe?: Maybe<StreamerStreamDiagnosticsUpdate>;
  /** StreamerService.StreamEvents */
  streamEventsSubscribe?: Maybe<StreamerStreamEvent>;
  /** MatchServiceV2.StreamSpectatorCoordinationEvents */
  streamSpectatorCoordinationEventsSubscribe?: Maybe<MatchStreamSpectatorCoordinationEvent>;
  /** ChannelConfigService.StreamStatusUpdates */
  streamStatusSubscribe?: Maybe<ChannelStreamStatusEvent>;
  /** MatchServiceV2.TopCardUpdates */
  streamTopActiveCardsSubscribe?: Maybe<MatchTopCardsUpdate>;
  /** FeatureFlagService.StreamConfigUpdates */
  subscribeFeatureFlagConfigUpdates?: Maybe<FlagFeatureFlagConfig>;
};


export type SubscriptionChannelActivityEventsSubscribeArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  channelId?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<StreamerChannelActivityEventFilterInput>;
};


export type SubscriptionChannelEventsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelFollowerCountSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelLiveStatusSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelStreamDetailSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChannelViewerCountSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChatAutoModQueueSubscribeArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionChatMessageSubscribeArgs = {
  chatId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionIngestStatsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionMlHudScaleUpdatesSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionModerationEventsSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  filter?: InputMaybe<ChannelModerationEventsFilterInput>;
};


export type SubscriptionNotificationSubscribeArgs = {
  cursor?: InputMaybe<Scalars['String']['input']>;
};


export type SubscriptionPartyUpdateSubscribeArgs = {
  partyId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionReactionsSubscriptionArgs = {
  parentId?: InputMaybe<Scalars['ID']['input']>;
  parentType?: InputMaybe<Scalars['String']['input']>;
};


export type SubscriptionStreamChallengeSessionEventsArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamChallengeUpdatesSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamDiagnosticsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamEventsSubscribeArgs = {
  filter?: InputMaybe<StreamerStreamEventFilterInput>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamSpectatorCoordinationEventsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamStatusSubscribeArgs = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionStreamTopActiveCardsSubscribeArgs = {
  streamId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionSubscribeFeatureFlagConfigUpdatesArgs = {
  revision?: InputMaybe<Scalars['String']['input']>;
};

export type SubscriptionChannelSubscription = {
  __typename?: 'SubscriptionChannelSubscription';
  activatedAt?: Maybe<Scalars['Timestamp']['output']>;
  cancelReason: SubscriptionChannelSubscriptionCancelReason;
  cancelledAt?: Maybe<Scalars['Timestamp']['output']>;
  channel: ChannelChannel;
  channelId: Scalars['ID']['output'];
  createdAt: Scalars['Timestamp']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  externalReference: Scalars['String']['output'];
  giverId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  paymentFailedAt?: Maybe<Scalars['Timestamp']['output']>;
  paymentSucceededAt?: Maybe<Scalars['Timestamp']['output']>;
  provider: SubscriptionChannelSubscriptionProvider;
  renewedAt?: Maybe<Scalars['Timestamp']['output']>;
  state: SubscriptionChannelSubscriptionState;
  terminatedAt?: Maybe<Scalars['Timestamp']['output']>;
  tier: Scalars['Int']['output'];
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export enum SubscriptionChannelSubscriptionCancelReason {
  CancelReasonCurrencyIncompatibleWithGateway = 'CANCEL_REASON_CURRENCY_INCOMPATIBLE_WITH_GATEWAY',
  CancelReasonFraudReviewFailed = 'CANCEL_REASON_FRAUD_REVIEW_FAILED',
  CancelReasonNonCompliantCustomer = 'CANCEL_REASON_NON_COMPLIANT_CUSTOMER',
  CancelReasonNonCompliantEuCustomer = 'CANCEL_REASON_NON_COMPLIANT_EU_CUSTOMER',
  CancelReasonNotPaid = 'CANCEL_REASON_NOT_PAID',
  CancelReasonNoCard = 'CANCEL_REASON_NO_CARD',
  CancelReasonTaxCalculationFailed = 'CANCEL_REASON_TAX_CALCULATION_FAILED',
  CancelReasonUnspecified = 'CANCEL_REASON_UNSPECIFIED'
}

export type SubscriptionChannelSubscriptionConfig = {
  __typename?: 'SubscriptionChannelSubscriptionConfig';
  channelId: Scalars['ID']['output'];
  subscriptionsEnabled: Scalars['Boolean']['output'];
  tiers: Array<SubscriptionChannelSubscriptionTier>;
};

export type SubscriptionChannelSubscriptionEntitlement = {
  __typename?: 'SubscriptionChannelSubscriptionEntitlement';
  amount: Scalars['Int']['output'];
  item: ItemItem;
  itemId: Scalars['ID']['output'];
};

export enum SubscriptionChannelSubscriptionProvider {
  ProviderApple = 'PROVIDER_APPLE',
  ProviderChargebee = 'PROVIDER_CHARGEBEE',
  ProviderUnspecified = 'PROVIDER_UNSPECIFIED'
}

export enum SubscriptionChannelSubscriptionState {
  StateActive = 'STATE_ACTIVE',
  StateCancelled = 'STATE_CANCELLED',
  StateExpired = 'STATE_EXPIRED',
  StateLocked = 'STATE_LOCKED',
  StatePending = 'STATE_PENDING',
  StateTerminated = 'STATE_TERMINATED',
  StateUnspecified = 'STATE_UNSPECIFIED'
}

export type SubscriptionChannelSubscriptionTier = {
  __typename?: 'SubscriptionChannelSubscriptionTier';
  description: Scalars['String']['output'];
  entitlements: Array<SubscriptionChannelSubscriptionEntitlement>;
  level: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  prices: Array<SubscriptionSubscriptionPrice>;
};

export type SubscriptionChannelSubscriptionUpdateEvent = {
  __typename?: 'SubscriptionChannelSubscriptionUpdateEvent';
  meta: SubscriptionSubscriptionUpdateMeta;
  subscription: SubscriptionChannelSubscription;
  updateType: SubscriptionChannelSubscriptionUpdateEventUpdateType;
  updatedAt: Scalars['Timestamp']['output'];
};

export enum SubscriptionChannelSubscriptionUpdateEventUpdateType {
  UpdateTypeActivated = 'UPDATE_TYPE_ACTIVATED',
  UpdateTypeCancellationRemoved = 'UPDATE_TYPE_CANCELLATION_REMOVED',
  UpdateTypeCancellationRequested = 'UPDATE_TYPE_CANCELLATION_REQUESTED',
  UpdateTypeCancelled = 'UPDATE_TYPE_CANCELLED',
  UpdateTypeCreated = 'UPDATE_TYPE_CREATED',
  UpdateTypeExpired = 'UPDATE_TYPE_EXPIRED',
  UpdateTypePaymentFailed = 'UPDATE_TYPE_PAYMENT_FAILED',
  UpdateTypePaymentSucceeded = 'UPDATE_TYPE_PAYMENT_SUCCEEDED',
  UpdateTypeRenewed = 'UPDATE_TYPE_RENEWED',
  UpdateTypeTerminated = 'UPDATE_TYPE_TERMINATED',
  UpdateTypeUnspecified = 'UPDATE_TYPE_UNSPECIFIED',
  UpdateTypeUpgraded = 'UPDATE_TYPE_UPGRADED'
}

export type SubscriptionCheckoutExistingSubscriptionResponse = {
  __typename?: 'SubscriptionCheckoutExistingSubscriptionResponse';
  sessionData: Scalars['String']['output'];
};

export type SubscriptionCheckoutNewSubscriptionResponse = {
  __typename?: 'SubscriptionCheckoutNewSubscriptionResponse';
  sessionData: Scalars['String']['output'];
};

export type SubscriptionListChannelSubscriptionTiersResponse = {
  __typename?: 'SubscriptionListChannelSubscriptionTiersResponse';
  tiers: Array<SubscriptionChannelSubscriptionTier>;
};

export type SubscriptionListChannelSubscriptionsRequestFilterInput = {
  state?: InputMaybe<SubscriptionChannelSubscriptionState>;
};

export type SubscriptionListChannelSubscriptionsResponse = {
  __typename?: 'SubscriptionListChannelSubscriptionsResponse';
  pageInfo: ApiPageInfo;
  subscriptions: Array<SubscriptionChannelSubscription>;
};

export type SubscriptionListUserChannelSubscriptionsRequestFilterInput = {
  paymentFailed?: InputMaybe<Scalars['Boolean']['input']>;
  state?: InputMaybe<SubscriptionChannelSubscriptionState>;
};

export type SubscriptionListUserChannelSubscriptionsResponse = {
  __typename?: 'SubscriptionListUserChannelSubscriptionsResponse';
  pageInfo: ApiPageInfo;
  subscriptions: Array<SubscriptionChannelSubscription>;
};

export type SubscriptionSubscriptionPrice = {
  __typename?: 'SubscriptionSubscriptionPrice';
  currency: PaymentCurrency;
  period: SubscriptionSubscriptionPricePeriod;
  price: Scalars['Int']['output'];
};

export enum SubscriptionSubscriptionPricePeriod {
  PeriodMonth = 'PERIOD_MONTH',
  PeriodUnspecified = 'PERIOD_UNSPECIFIED',
  PeriodYear = 'PERIOD_YEAR'
}

export type SubscriptionSubscriptionUpdateMeta = {
  __typename?: 'SubscriptionSubscriptionUpdateMeta';
  giverId: Scalars['ID']['output'];
};

export type SubscriptionUpdateSubscriptionPaymentMethodResponse = {
  __typename?: 'SubscriptionUpdateSubscriptionPaymentMethodResponse';
  sessionData: Scalars['String']['output'];
};

export type SupportArticle = {
  __typename?: 'SupportArticle';
  body: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  locale: Scalars['String']['output'];
  title: Scalars['String']['output'];
};

export type SupportListReportsResponse = {
  __typename?: 'SupportListReportsResponse';
  pageInfo: ApiPageInfo;
  reports: Array<SupportReport>;
};

export type SupportReport = {
  __typename?: 'SupportReport';
  caseId: Scalars['ID']['output'];
  context: SupportReportContext;
  createdAt: Scalars['Timestamp']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  reason: SupportReportReason;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type SupportReportCase = {
  __typename?: 'SupportReportCase';
  closedAt: Scalars['Timestamp']['output'];
  closedBy: Scalars['String']['output'];
  context: SupportReportContext;
  createdAt: Scalars['Timestamp']['output'];
  firstDescription: Scalars['String']['output'];
  firstReason: SupportReportReason;
  firstReporterId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  moderatorComment: Scalars['String']['output'];
  resolution: SupportReportCaseResolution;
  status: SupportReportCaseStatus;
};

export enum SupportReportCaseResolution {
  ReportCaseResolutionAllowContent = 'REPORT_CASE_RESOLUTION_ALLOW_CONTENT',
  ReportCaseResolutionRemoveContent = 'REPORT_CASE_RESOLUTION_REMOVE_CONTENT',
  ReportCaseResolutionUnspecified = 'REPORT_CASE_RESOLUTION_UNSPECIFIED'
}

export enum SupportReportCaseStatus {
  ReportCaseStatusClosed = 'REPORT_CASE_STATUS_CLOSED',
  ReportCaseStatusOpen = 'REPORT_CASE_STATUS_OPEN',
  ReportCaseStatusUnspecified = 'REPORT_CASE_STATUS_UNSPECIFIED'
}

export type SupportReportContext = {
  __typename?: 'SupportReportContext';
  value?: Maybe<SupportReportContextValueUnion>;
};

export type SupportReportContextChannel = {
  __typename?: 'SupportReportContextChannel';
  channelId: Scalars['ID']['output'];
  target: SupportReportContextChannelTarget;
};

export type SupportReportContextChannelInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  target?: InputMaybe<SupportReportContextChannelTarget>;
};

export enum SupportReportContextChannelTarget {
  TargetDescription = 'TARGET_DESCRIPTION',
  TargetName = 'TARGET_NAME',
  TargetUnspecified = 'TARGET_UNSPECIFIED'
}

export type SupportReportContextChatMessage = {
  __typename?: 'SupportReportContextChatMessage';
  channelId: Scalars['ID']['output'];
  chatId: Scalars['ID']['output'];
  messageId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type SupportReportContextChatMessageInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  chatId?: InputMaybe<Scalars['ID']['input']>;
  messageId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type SupportReportContextInput = {
  channel?: InputMaybe<SupportReportContextChannelInput>;
  chatMessage?: InputMaybe<SupportReportContextChatMessageInput>;
  stream?: InputMaybe<SupportReportContextStreamInput>;
  user?: InputMaybe<SupportReportContextUserInput>;
};

export type SupportReportContextStream = {
  __typename?: 'SupportReportContextStream';
  channelId: Scalars['ID']['output'];
  startAt: Scalars['Int']['output'];
  streamId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type SupportReportContextStreamInput = {
  channelId?: InputMaybe<Scalars['ID']['input']>;
  startAt?: InputMaybe<Scalars['Int']['input']>;
  streamId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type SupportReportContextUser = {
  __typename?: 'SupportReportContextUser';
  target: SupportReportContextUserTarget;
  userId: Scalars['ID']['output'];
};

export type SupportReportContextUserInput = {
  target?: InputMaybe<SupportReportContextUserTarget>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export enum SupportReportContextUserTarget {
  TargetName = 'TARGET_NAME',
  TargetUnspecified = 'TARGET_UNSPECIFIED'
}

export type SupportReportContextValueUnion = SupportReportContextChannel | SupportReportContextChatMessage | SupportReportContextStream | SupportReportContextUser;

export enum SupportReportReason {
  ReportReasonChildSafetyChildAbuse = 'REPORT_REASON_CHILD_SAFETY_CHILD_ABUSE',
  ReportReasonChildSafetyCse = 'REPORT_REASON_CHILD_SAFETY_CSE',
  ReportReasonChildSafetyDangerous = 'REPORT_REASON_CHILD_SAFETY_DANGEROUS',
  ReportReasonChildSafetyUnderageUser = 'REPORT_REASON_CHILD_SAFETY_UNDERAGE_USER',
  ReportReasonGraphicMediaAnimalAbuse = 'REPORT_REASON_GRAPHIC_MEDIA_ANIMAL_ABUSE',
  ReportReasonGraphicMediaGore = 'REPORT_REASON_GRAPHIC_MEDIA_GORE',
  ReportReasonGraphicMediaViolence = 'REPORT_REASON_GRAPHIC_MEDIA_VIOLENCE',
  ReportReasonHarassment = 'REPORT_REASON_HARASSMENT',
  ReportReasonHarassmentBlackmail = 'REPORT_REASON_HARASSMENT_BLACKMAIL',
  ReportReasonHarassmentIncitement = 'REPORT_REASON_HARASSMENT_INCITEMENT',
  ReportReasonHarassmentNonConsensualIntimateImages = 'REPORT_REASON_HARASSMENT_NON_CONSENSUAL_INTIMATE_IMAGES',
  ReportReasonHarassmentSexualNonConsensual = 'REPORT_REASON_HARASSMENT_SEXUAL_NON_CONSENSUAL',
  ReportReasonHarassmentStalking = 'REPORT_REASON_HARASSMENT_STALKING',
  ReportReasonHatefulBehavior = 'REPORT_REASON_HATEFUL_BEHAVIOR',
  ReportReasonIllegalActivitySale = 'REPORT_REASON_ILLEGAL_ACTIVITY_SALE',
  ReportReasonIllegalActivityWeapons = 'REPORT_REASON_ILLEGAL_ACTIVITY_WEAPONS',
  ReportReasonIllegalAlcoholNicotine = 'REPORT_REASON_ILLEGAL_ALCOHOL_NICOTINE',
  ReportReasonIllegalDrugs = 'REPORT_REASON_ILLEGAL_DRUGS',
  ReportReasonIllegalManipulation = 'REPORT_REASON_ILLEGAL_MANIPULATION',
  ReportReasonIllegalSpam = 'REPORT_REASON_ILLEGAL_SPAM',
  ReportReasonImpersonation = 'REPORT_REASON_IMPERSONATION',
  ReportReasonInauthenticGameplay = 'REPORT_REASON_INAUTHENTIC_GAMEPLAY',
  ReportReasonOffPlatform = 'REPORT_REASON_OFF_PLATFORM',
  ReportReasonPlatformRulesViolation = 'REPORT_REASON_PLATFORM_RULES_VIOLATION',
  ReportReasonPossibleIllegalActivity = 'REPORT_REASON_POSSIBLE_ILLEGAL_ACTIVITY',
  ReportReasonRestrictedGamesInherentlyViolative = 'REPORT_REASON_RESTRICTED_GAMES_INHERENTLY_VIOLATIVE',
  ReportReasonRestrictedGamesMature = 'REPORT_REASON_RESTRICTED_GAMES_MATURE',
  ReportReasonSelfHarm = 'REPORT_REASON_SELF_HARM',
  ReportReasonSexualBehaviorExplicit = 'REPORT_REASON_SEXUAL_BEHAVIOR_EXPLICIT',
  ReportReasonSexualBehaviorSuggestive = 'REPORT_REASON_SEXUAL_BEHAVIOR_SUGGESTIVE',
  ReportReasonSpam = 'REPORT_REASON_SPAM',
  ReportReasonSpamSuspensionEvasion = 'REPORT_REASON_SPAM_SUSPENSION_EVASION',
  ReportReasonUnknown = 'REPORT_REASON_UNKNOWN',
  ReportReasonUnspecified = 'REPORT_REASON_UNSPECIFIED',
  ReportReasonViolenceExtremism = 'REPORT_REASON_VIOLENCE_EXTREMISM'
}

export type SupportReportsFilterInput = {
  caseId?: InputMaybe<Scalars['ID']['input']>;
};

export type WalletAddCurrenciesResponse = {
  __typename?: 'WalletAddCurrenciesResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type WalletGetWalletResponse = {
  __typename?: 'WalletGetWalletResponse';
  wallet: WalletWallet;
};

export type WalletListWalletTransactionsRequestFilterInput = {
  from?: InputMaybe<Scalars['InputTimestamp']['input']>;
  reasons?: InputMaybe<Array<WalletTransactionReason>>;
  to?: InputMaybe<Scalars['InputTimestamp']['input']>;
};

export type WalletListWalletTransactionsResponse = {
  __typename?: 'WalletListWalletTransactionsResponse';
  pageInfo: ApiPageInfo;
  transactions: Array<WalletTransaction>;
};

export type WalletOperation = {
  __typename?: 'WalletOperation';
  currencyAmount: Scalars['Int']['output'];
  currencyBalance: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
  type: WalletOperationType;
};

export enum WalletOperationType {
  TypeAdd = 'TYPE_ADD',
  TypeSubtract = 'TYPE_SUBTRACT',
  TypeUnspecified = 'TYPE_UNSPECIFIED'
}

export type WalletSubtractCurrenciesResponse = {
  __typename?: 'WalletSubtractCurrenciesResponse';
  emptyTypeWorkaround: Scalars['Boolean']['output'];
};

export type WalletTransaction = {
  __typename?: 'WalletTransaction';
  createdAt: Scalars['Timestamp']['output'];
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  id: Scalars['ID']['output'];
  operations: Array<WalletOperation>;
  reason: ReasonReason;
  state: WalletTransactionState;
  user: ProfileProfile;
  userId: Scalars['ID']['output'];
};

export type WalletTransactionEvent = {
  __typename?: 'WalletTransactionEvent';
  transaction: WalletTransaction;
};

export enum WalletTransactionReason {
  TransactionReasonAdministrative = 'TRANSACTION_REASON_ADMINISTRATIVE',
  TransactionReasonAdWatched = 'TRANSACTION_REASON_AD_WATCHED',
  TransactionReasonChannelSubscription = 'TRANSACTION_REASON_CHANNEL_SUBSCRIPTION',
  TransactionReasonGoalCardComplete = 'TRANSACTION_REASON_GOAL_CARD_COMPLETE',
  TransactionReasonGoalCardSlotReshuffle = 'TRANSACTION_REASON_GOAL_CARD_SLOT_RESHUFFLE',
  TransactionReasonLevelUp = 'TRANSACTION_REASON_LEVEL_UP',
  TransactionReasonMatchEnd = 'TRANSACTION_REASON_MATCH_END',
  TransactionReasonProvision = 'TRANSACTION_REASON_PROVISION',
  TransactionReasonPurchaseWithInGameCurrency = 'TRANSACTION_REASON_PURCHASE_WITH_IN_GAME_CURRENCY',
  TransactionReasonPurchaseWithPayment = 'TRANSACTION_REASON_PURCHASE_WITH_PAYMENT',
  TransactionReasonReshuffle = 'TRANSACTION_REASON_RESHUFFLE',
  TransactionReasonRewardClaimed = 'TRANSACTION_REASON_REWARD_CLAIMED',
  TransactionReasonStoreOrderPayment = 'TRANSACTION_REASON_STORE_ORDER_PAYMENT',
  TransactionReasonUnspecified = 'TRANSACTION_REASON_UNSPECIFIED'
}

export enum WalletTransactionState {
  TransactionStateCancelled = 'TRANSACTION_STATE_CANCELLED',
  TransactionStateCommitted = 'TRANSACTION_STATE_COMMITTED',
  TransactionStatePending = 'TRANSACTION_STATE_PENDING',
  TransactionStateUnspecified = 'TRANSACTION_STATE_UNSPECIFIED'
}

export type WalletWallet = {
  __typename?: 'WalletWallet';
  currencies: Array<WalletWalletCurrency>;
  userId: Scalars['ID']['output'];
};

export type WalletWalletCurrency = {
  __typename?: 'WalletWalletCurrency';
  currencyAmount: Scalars['Int']['output'];
  currencyId: Scalars['ID']['output'];
};

export type WalletWalletCurrencyInput = {
  currencyAmount?: InputMaybe<Scalars['Int']['input']>;
  currencyId?: InputMaybe<Scalars['ID']['input']>;
};

export type ChannelSelectResultItemFragment = { __typename?: 'SearchResultItem', matchedProperties: Array<string>, entity?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string, title: string, streamer: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null } } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile' } | null };

export type ChannelSelectChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string, title: string, streamer: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null } };

export type ChannelSelectSearchQueryVariables = Exact<{
  query?: InputMaybe<Scalars['String']['input']>;
}>;


export type ChannelSelectSearchQuery = { __typename?: 'Query', search?: { __typename?: 'SearchSearchResponse', resultItems: Array<{ __typename?: 'SearchResultItem', entityId: string, matchedProperties: Array<string>, entity?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string, title: string, streamer: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null } } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile' } | null }> } | null };

export type EmojiTableEmojiFragment = { __typename?: 'EmojiEmoji', id: string, image: string, label: string, disabled: boolean };

export type ModeratorProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type UserPermissionsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type UserPermissionsQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', uid: string, roles: Array<AuthPlatformRole> } | null } | null };

export type HiddenEmailTextFieldProfileFragment = { __typename?: 'ProfileProfile', account?: { __typename?: 'AuthAccount', email: string } | null };

export type ProfileSelectResultItemFragment = { __typename?: 'SearchResultItem', matchedProperties: Array<string>, entity?: { __typename?: 'ChannelChannel' } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile', userId: string, userTag: string, bio: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, account?: { __typename?: 'AuthAccount', email: string } | null } | null };

export type ProfileSelectProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, bio: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, account?: { __typename?: 'AuthAccount', email: string } | null };

export type ProfileSelectSearchQueryVariables = Exact<{
  query?: InputMaybe<Scalars['String']['input']>;
}>;


export type ProfileSelectSearchQuery = { __typename?: 'Query', search?: { __typename?: 'SearchSearchResponse', resultItems: Array<{ __typename?: 'SearchResultItem', entityId: string, matchedProperties: Array<string>, entity?: { __typename?: 'ChannelChannel' } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile', userId: string, userTag: string, bio: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, account?: { __typename?: 'AuthAccount', email: string } | null } | null }> } | null };

export type DefaultValueProfileSelectQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type DefaultValueProfileSelectQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, bio: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, account?: { __typename?: 'AuthAccount', email: string } | null } | null };

export type UsernameTableCellProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ProtectedRoutePermissionQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ProtectedRoutePermissionQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', uid: string, roles: Array<AuthPlatformRole> } | null } | null };

export type SearchMatchResultChannelFragment = { __typename?: 'ChannelChannel', name: string, title: string, streamer: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null } };

export type SearchMatchResultProfileFragment = { __typename?: 'ProfileProfile', userId: string, bio: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null };

export type MonetizationCalloutDataQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type MonetizationCalloutDataQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', channelId: string, enabled: boolean } } | null };

export type SidebarChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type SidebarChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, currentStreamId: string, logo: string, name: string, state: ApiEntityState, liveStatus: ChannelLiveStatus, features: { __typename?: 'ChannelChannelFeatures', streaming: { __typename?: 'ChannelStreamingFeatureStatus', enabled: boolean } } } | null };

export type SidebarChannelFragment = { __typename?: 'ChannelChannel', currentStreamId: string, logo: string, name: string, state: ApiEntityState, liveStatus: ChannelLiveStatus, features: { __typename?: 'ChannelChannelFeatures', streaming: { __typename?: 'ChannelStreamingFeatureStatus', enabled: boolean } } };

export type ChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  skipConfigs?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type ChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, description: string, followerCount: number, subscriberCount: number, title: string, isPublic: boolean, streamerId: string, currentStreamId: string, priority: number, state: ApiEntityState, links: Array<{ __typename?: 'ChannelChannelLink', url: string, name: string, type: ChannelChannelLinkLinkType }> } | null, streamBackendConfigs?: { __typename?: 'ChannelListStreamBackendConfigsResponse', configs: Array<{ __typename?: 'ChannelStreamBackendConfig', gameId: string, id: string }> } | null, selectedStreamBackendConfig?: { __typename?: 'ChannelStreamBackendConfig', gameId: string } | null, ingestConfigs?: { __typename?: 'StreamIngestConfigChannelIngestConfigs', channelId: string, configs: Array<{ __typename?: 'StreamIngestConfigIngestConfig', ingest?: { __typename?: 'StreamIngestConfigIngestConfigFTLConfig', streamKey: string } | null }> } | null };

export type ChannelUserProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ChannelUserProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null, account?: { __typename?: 'AuthAccount', acceptedTerms: Array<{ __typename?: 'AuthTermsVersion', name: string }> } | null } | null };

export type DeleteChannelChannelFragment = { __typename?: 'ChannelChannel', state: ApiEntityState, id: string, name: string };

export type DeleteChannelMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteChannelMutation = { __typename?: 'Mutation', deleteChannel?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type DeleteChannelModalChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string };

export type ChannelBannedUsersQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelBannedUsersQuery = { __typename?: 'Query', channelBannedUsers?: { __typename?: 'ChannelListBannedUsersResponse', users: Array<{ __typename?: 'ChannelBannedUser', userId: string, channelId: string, bannedAt: string, violation: ChannelViolation, description: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string }, moderator: { __typename?: 'ProfileProfile', userId: string, userTag: string } }> } | null, channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type ChannelBanDrawerUserQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type ChannelBanDrawerUserQuery = { __typename?: 'Query', channelBanUserStatus?: { __typename?: 'ChannelUserBanStatus', bannedAt?: string | null, violation: ChannelViolation, description: string } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type ChannelBanDrawerUserUnBanMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type ChannelBanDrawerUserUnBanMutation = { __typename?: 'Mutation', unbanChannelUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChannelEmojiAddDrawerChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string };

export type AddChannelEmojiMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  label: Scalars['String']['input'];
}>;


export type AddChannelEmojiMutation = { __typename?: 'Mutation', createChannelEmoji?: { __typename?: 'EmojiEmoji', id: string, label: string, channelId: string, disabled: boolean } | null };

export type EnableCreatedChannelEmojiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type EnableCreatedChannelEmojiMutation = { __typename?: 'Mutation', updateChannelEmoji?: { __typename?: 'EmojiEmoji', id: string, disabled: boolean } | null };

export type ChannelEmojiDrawerChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string };

export type ChannelEmojiDrawerEmojiQueryVariables = Exact<{
  emojiId: Scalars['ID']['input'];
}>;


export type ChannelEmojiDrawerEmojiQuery = { __typename?: 'Query', emoji?: { __typename?: 'EmojiEmoji', id: string, disabled: boolean, label: string, image: string, channelId: string } | null };

export type ChannelEmojiEditDrawerEmojiFragment = { __typename?: 'EmojiEmoji', disabled: boolean, id: string, label: string, image: string, channelId: string };

export type ChannelEmojiEditDrawerChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string };

export type EditChannelEmojiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  label: Scalars['String']['input'];
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type EditChannelEmojiMutation = { __typename?: 'Mutation', updateChannelEmoji?: { __typename?: 'EmojiEmoji', id: string, disabled: boolean, label: string } | null };

export type DeleteChannelEmojiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
}>;


export type DeleteChannelEmojiMutation = { __typename?: 'Mutation', deleteChannelEmoji?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChannelEmojisQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  cursor?: InputMaybe<ApiCursorInput>;
  includeDisabled?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type ChannelEmojisQuery = { __typename?: 'Query', channelEmojis?: { __typename?: 'EmojiListChannelEmojisResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string }, emojis: Array<{ __typename?: 'EmojiEmoji', id: string, image: string, label: string, disabled: boolean }>, count?: { __typename?: 'ItemItemTotalCount', disabled: number, total: number } | null } | null };

export type ChannelEmojisChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelEmojisChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type ChannelFeatureFlagsQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelFeatureFlagsQuery = { __typename?: 'Query', channelFeatureFlags?: { __typename?: 'FlagListChannelFeatureFlagsResponse', flags: Array<{ __typename?: 'FlagFeatureFlagState', name: string, value: string }> } | null };

export type ChannelModerationQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ChannelModerationQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, followerCount: number, subscriberCount: number, liveStatus: ChannelLiveStatus, logo: string, features: { __typename?: 'ChannelChannelFeatures', streaming: { __typename?: 'ChannelStreamingFeatureStatus', enabled: boolean, suspension?: { __typename?: 'ChannelSuspension', until?: string | null, suspendedAt: string, description: string, moderator?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null } | null } } } | null };

export type LiftForceChannelOfflineMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type LiftForceChannelOfflineMutation = { __typename?: 'Mutation', unsuspendChannelFeature?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ForceChannelOfflineMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
}>;


export type ForceChannelOfflineMutation = { __typename?: 'Mutation', suspendChannelFeature?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ForceChannelOfflineModalChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, followerCount: number, subscriberCount: number, liveStatus: ChannelLiveStatus, logo: string };

export type ChannelUserRolesQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type ChannelUserRolesQuery = { __typename?: 'Query', channelPrivilegedUsers?: { __typename?: 'ChannelListChannelPrivilegedUsersResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, users: Array<{ __typename?: 'ChannelPrivilegedUser', roles: Array<ChannelChannelRole>, userId: string, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> } | null };

export type ChannelSettingsUpdateCrConfigMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  containerImage?: InputMaybe<Scalars['String']['input']>;
  controllerContainerImage?: InputMaybe<Scalars['String']['input']>;
  arenaId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ChannelSettingsUpdateCrConfigMutation = { __typename?: 'Mutation', updateStreamBackendConfig?: { __typename?: 'ChannelStreamBackendConfig', id: string, crConfig?: { __typename?: 'ChannelContentRendererConfig', arenaId: string, containerImage: string, controllerContainerImage: string } | null } | null };

export type ArenaCrowdChannelStreamBackendConfigFragment = { __typename?: 'ChannelStreamBackendConfig', id: string, crConfig?: { __typename?: 'ChannelContentRendererConfig', arenaId: string, containerImage: string, controllerContainerImage: string } | null };

export type ArenaCrowdArenaFragment = { __typename?: 'ArenaArena', id: string, name: string, enabled: boolean };

export type ChannelOwnerAgreementsFragment = { __typename?: 'ProfileProfile', account?: { __typename?: 'AuthAccount', acceptedTerms: Array<{ __typename?: 'AuthTermsVersion', name: string }> } | null };

export type ChannelMonetizationChannelFragment = { __typename?: 'ChannelChannel', id: string, streamerId: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', channelId: string, enabled: boolean, eligible: boolean }, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null };

export type ChannelUpdateMonetizationSettingsMutationVariables = Exact<{
  body: ChannelMonetizationSettingsInput;
}>;


export type ChannelUpdateMonetizationSettingsMutation = { __typename?: 'Mutation', updateChannelMonetizationSettings?: { __typename?: 'ChannelMonetizationSettings', channelId: string, enabled: boolean, eligible: boolean } | null };

export type SubscriptionMonetizationUpdateFragment = { __typename?: 'ChannelChannel', id: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', channelId: string, enabled: boolean, eligible: boolean } };

export type ChannelSettingsQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  skipConfigs?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type ChannelSettingsQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, liveStatus: ChannelLiveStatus, priority: number, riskTier: ChannelRiskTier, isPublic: boolean, streamerId: string, monetizationSettings: { __typename?: 'ChannelMonetizationSettings', channelId: string, enabled: boolean, eligible: boolean }, subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, subscriptionsEnabled: boolean } | null } | null, selectedStreamBackendConfig?: { __typename?: 'ChannelStreamBackendConfig', id: string, mlConfig?: { __typename?: 'ChannelMachineLearningConfig', containerImage: string } | null, crConfig?: { __typename?: 'ChannelContentRendererConfig', arenaId: string, containerImage: string, controllerContainerImage: string } | null, recConfig?: { __typename?: 'ChannelStreamRecorderConfig', containerImage: string } | null } | null, arenas?: { __typename?: 'ArenaListArenasResponse', arenas: Array<{ __typename?: 'ArenaArena', id: string, name: string, enabled: boolean }> } | null };

export type ChannelVisibilityChannelFragment = { __typename?: 'ChannelChannel', id: string, isPublic: boolean };

export type ChannelUpdatePrivacyMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type ChannelUpdatePrivacyMutation = { __typename?: 'Mutation', updateChannelDetails?: { __typename?: 'ChannelChannel', id: string, isPublic: boolean } | null };

export type PrivacyUpdateChannelFragment = { __typename?: 'ChannelChannel', id: string, isPublic: boolean };

export type ChannelSettingsUpdateMlConfigMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  containerImage: Scalars['String']['input'];
}>;


export type ChannelSettingsUpdateMlConfigMutation = { __typename?: 'Mutation', updateStreamBackendConfig?: { __typename?: 'ChannelStreamBackendConfig', id: string, mlConfig?: { __typename?: 'ChannelMachineLearningConfig', containerImage: string } | null } | null };

export type PredictionGameChannelStreamBackendConfigFragment = { __typename?: 'ChannelStreamBackendConfig', id: string, mlConfig?: { __typename?: 'ChannelMachineLearningConfig', containerImage: string } | null };

export type ChannelUpdatePriorityMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  priority?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ChannelUpdatePriorityMutation = { __typename?: 'Mutation', updateChannelDetails?: { __typename?: 'ChannelChannel', id: string, priority: number } | null };

export type PriorityUpdateChannelFragment = { __typename?: 'ChannelChannel', id: string, priority: number };

export type ChannelSettingsUpdateRecConfigMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  channelId: Scalars['ID']['input'];
  containerImage: Scalars['String']['input'];
}>;


export type ChannelSettingsUpdateRecConfigMutation = { __typename?: 'Mutation', updateStreamBackendConfig?: { __typename?: 'ChannelStreamBackendConfig', id: string, recConfig?: { __typename?: 'ChannelStreamRecorderConfig', containerImage: string } | null } | null };

export type RecordingChannelStreamBackendConfigFragment = { __typename?: 'ChannelStreamBackendConfig', id: string, recConfig?: { __typename?: 'ChannelStreamRecorderConfig', containerImage: string } | null };

export type ChannelUpdateRiskTierMutationVariables = Exact<{
  channelId: Scalars['ID']['input'];
  riskTier: ChannelRiskTier;
}>;


export type ChannelUpdateRiskTierMutation = { __typename?: 'Mutation', updateChannelDetails?: { __typename?: 'ChannelChannel', id: string, riskTier: ChannelRiskTier } | null };

export type RiskTierUpdateChannelFragment = { __typename?: 'ChannelChannel', id: string, riskTier: ChannelRiskTier };

export type ChannelStreamsStreamQueryVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type ChannelStreamsStreamQuery = { __typename?: 'Query', stream?: { __typename?: 'ChannelStream', streamId: string, matureRatedContent: boolean, segments: Array<{ __typename?: 'ChannelStreamSegment', startTime: string, endTime?: string | null, gameId: string, title: string }> } | null };

export type ChannelStreamsQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type ChannelStreamsQuery = { __typename?: 'Query', streams?: { __typename?: 'ChannelListStreamsResponse', streams: Array<{ __typename?: 'ChannelStream', channelId: string, streamId: string, segments: Array<{ __typename?: 'ChannelStreamSegment', startTime: string, endTime?: string | null, gameId: string }> }>, pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean } } | null };

export type ChannelListQueryVariables = Exact<{
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type ChannelListQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string, subscriberCount: number, followerCount: number, isPublic: boolean, liveStatus: ChannelLiveStatus, streamer: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> } | null };

export type CreateChannelDrawerUserCheckQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type CreateChannelDrawerUserCheckQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string } | null, userPrivilegedChannels?: { __typename?: 'ChannelListUserPrivilegedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannelRoles', channelId: string, roles: Array<ChannelChannelRole> }> } | null };

export type CreateChannelMutationVariables = Exact<{
  name: Scalars['String']['input'];
  streamerId: Scalars['ID']['input'];
}>;


export type CreateChannelMutation = { __typename?: 'Mutation', createChannel?: { __typename?: 'ChannelChannel', name: string, streamerId: string } | null };

export type FtueDismissTooltipsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FtueDismissTooltipsQuery = { __typename?: 'Query', dismissedTooltips?: { __typename?: 'FtueListDismissedTooltipsResponse', tooltipIds: Array<string> } | null };

export type FtueDismissTooltipMutationVariables = Exact<{
  tooltipId: Scalars['ID']['input'];
  type: FtueDismissalType;
}>;


export type FtueDismissTooltipMutation = { __typename?: 'Mutation', dismissTooltip?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type FtueDeleteDismissTooltipMutationVariables = Exact<{
  tooltipId: Scalars['ID']['input'];
}>;


export type FtueDeleteDismissTooltipMutation = { __typename?: 'Mutation', deleteDismissedTooltip?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ChannelSelectorListQueryVariables = Exact<{
  cursor?: InputMaybe<Scalars['String']['input']>;
  pageSize?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ChannelSelectorListQuery = { __typename?: 'Query', channels?: { __typename?: 'ChannelListChannelsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean }, channels: Array<{ __typename?: 'ChannelChannel', id: string, name: string }> } | null };

export type ChannelSelectorChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string };

export type CreateAnnouncementMutationVariables = Exact<{
  category: AnnouncementAnnouncementCategory;
  title: Scalars['String']['input'];
  text: Scalars['String']['input'];
  published: Scalars['Boolean']['input'];
  startTime?: InputMaybe<Scalars['Timestamp']['input']>;
  endTime?: InputMaybe<Scalars['Timestamp']['input']>;
  targets?: InputMaybe<AnnouncementTargetsInput>;
}>;


export type CreateAnnouncementMutation = { __typename?: 'Mutation', createAnnouncement?: { __typename?: 'AnnouncementAnnouncement', id: string, status: AnnouncementAnnouncementStatus } | null };

export type AnnouncementDrawerAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', id: string, title: string, category: AnnouncementAnnouncementCategory, text: string, startTime?: string | null, endTime?: string | null, published: boolean, image: string, status: AnnouncementAnnouncementStatus, targets: { __typename?: 'AnnouncementTargets', web: boolean, studio: boolean } };

export type AnnouncementEditFormAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', id: string, title: string, category: AnnouncementAnnouncementCategory, text: string, startTime?: string | null, endTime?: string | null, published: boolean, image: string, status: AnnouncementAnnouncementStatus, targets: { __typename?: 'AnnouncementTargets', web: boolean, studio: boolean } };

export type DeleteAnnouncementMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteAnnouncementMutation = { __typename?: 'Mutation', deleteAnnouncement?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type EditAnnouncementMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  category: AnnouncementAnnouncementCategory;
  title: Scalars['String']['input'];
  text: Scalars['String']['input'];
  published: Scalars['Boolean']['input'];
  startTime?: InputMaybe<Scalars['InputTimestamp']['input']>;
  endTime?: InputMaybe<Scalars['InputTimestamp']['input']>;
  targets: AnnouncementTargetsInput;
}>;


export type EditAnnouncementMutation = { __typename?: 'Mutation', updateAnnouncement?: { __typename?: 'AnnouncementAnnouncement', id: string, title: string, category: AnnouncementAnnouncementCategory, published: boolean, startTime?: string | null, endTime?: string | null, status: AnnouncementAnnouncementStatus, targets: { __typename?: 'AnnouncementTargets', web: boolean, studio: boolean } } | null };

export type AnnouncementAssetDeleteImageMutationVariables = Exact<{
  announcementId: Scalars['ID']['input'];
}>;


export type AnnouncementAssetDeleteImageMutation = { __typename?: 'Mutation', deleteAnnouncementImage?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type AssetDeleteAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', id: string, image: string };

export type AnnouncementEditFormCacheAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', id: string, title: string, category: AnnouncementAnnouncementCategory, published: boolean, startTime?: string | null, endTime?: string | null, status: AnnouncementAnnouncementStatus, targets: { __typename?: 'AnnouncementTargets', web: boolean, studio: boolean } };

export type AnnouncementFormContentAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', startTime?: string | null, endTime?: string | null, id: string, title: string, text: string, category: AnnouncementAnnouncementCategory, image: string };

export type AnnouncementAmountsQueryVariables = Exact<{ [key: string]: never; }>;


export type AnnouncementAmountsQuery = { __typename?: 'Query', active?: { __typename?: 'AnnouncementListAnnouncementsResponse', totalCount: number } | null, scheduled?: { __typename?: 'AnnouncementListAnnouncementsResponse', totalCount: number } | null, draft?: { __typename?: 'AnnouncementListAnnouncementsResponse', totalCount: number } | null, past?: { __typename?: 'AnnouncementListAnnouncementsResponse', totalCount: number } | null };

export type AnnouncementTableAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', id: string, title: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, endTime?: string | null, status: AnnouncementAnnouncementStatus, creator: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } };

export type AnnouncementAssetCreateTokenMutationVariables = Exact<{
  announcementId: Scalars['ID']['input'];
}>;


export type AnnouncementAssetCreateTokenMutation = { __typename?: 'Mutation', createAnnouncementImageUploadToken?: { __typename?: 'AnnouncementCreateAnnouncementImageUploadTokenResponse', token: string } | null };

export type AssetUploadAnnouncementAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', id: string, image: string };

export type ActiveAnnouncementsQueryVariables = Exact<{
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type ActiveAnnouncementsQuery = { __typename?: 'Query', announcements?: { __typename?: 'AnnouncementListAnnouncementsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, announcements: Array<{ __typename?: 'AnnouncementAnnouncement', id: string, title: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, endTime?: string | null, status: AnnouncementAnnouncementStatus, text: string, published: boolean, image: string, creator: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, targets: { __typename?: 'AnnouncementTargets', web: boolean, studio: boolean } }> } | null };

export type DraftAnnouncementsQueryVariables = Exact<{
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type DraftAnnouncementsQuery = { __typename?: 'Query', announcements?: { __typename?: 'AnnouncementListAnnouncementsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, announcements: Array<{ __typename?: 'AnnouncementAnnouncement', id: string, title: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, endTime?: string | null, status: AnnouncementAnnouncementStatus, text: string, published: boolean, image: string, creator: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, targets: { __typename?: 'AnnouncementTargets', web: boolean, studio: boolean } }> } | null };

export type PastAnnouncementsQueryVariables = Exact<{
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type PastAnnouncementsQuery = { __typename?: 'Query', announcements?: { __typename?: 'AnnouncementListAnnouncementsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, announcements: Array<{ __typename?: 'AnnouncementAnnouncement', id: string, title: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, endTime?: string | null, status: AnnouncementAnnouncementStatus, text: string, published: boolean, image: string, creator: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, targets: { __typename?: 'AnnouncementTargets', web: boolean, studio: boolean } }> } | null };

export type ScheduledAnnouncementsQueryVariables = Exact<{
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type ScheduledAnnouncementsQuery = { __typename?: 'Query', announcements?: { __typename?: 'AnnouncementListAnnouncementsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, announcements: Array<{ __typename?: 'AnnouncementAnnouncement', id: string, title: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, endTime?: string | null, status: AnnouncementAnnouncementStatus, text: string, published: boolean, image: string, creator: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null }, targets: { __typename?: 'AnnouncementTargets', web: boolean, studio: boolean } }> } | null };

export type PlatformEmojisQueryVariables = Exact<{
  cursor?: InputMaybe<ApiCursorInput>;
  includeDisabled?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type PlatformEmojisQuery = { __typename?: 'Query', platformEmojis?: { __typename?: 'EmojiListPlatformEmojisResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string }, emojis: Array<{ __typename?: 'EmojiEmoji', id: string, image: string, label: string, disabled: boolean }>, count?: { __typename?: 'ItemItemTotalCount', disabled: number, total: number } | null } | null };

export type AddPlatformEmojiMutationVariables = Exact<{
  label: Scalars['String']['input'];
}>;


export type AddPlatformEmojiMutation = { __typename?: 'Mutation', createPlatformEmoji?: { __typename?: 'EmojiEmoji', id: string, label: string, disabled: boolean } | null };

export type EnableCreatedPlatformEmojiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type EnableCreatedPlatformEmojiMutation = { __typename?: 'Mutation', updatePlatformEmoji?: { __typename?: 'EmojiEmoji', id: string, disabled: boolean } | null };

export type PlatformEmojiDrawerEmojiQueryVariables = Exact<{
  emojiId: Scalars['ID']['input'];
}>;


export type PlatformEmojiDrawerEmojiQuery = { __typename?: 'Query', emoji?: { __typename?: 'EmojiEmoji', id: string, disabled: boolean, label: string, image: string } | null };

export type PlatformEmojiEditDrawerEmojiFragment = { __typename?: 'EmojiEmoji', disabled: boolean, id: string, label: string, image: string };

export type EditPlatformEmojiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  label: Scalars['String']['input'];
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type EditPlatformEmojiMutation = { __typename?: 'Mutation', updatePlatformEmoji?: { __typename?: 'EmojiEmoji', id: string, disabled: boolean, label: string } | null };

export type DeletePlatformEmojiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeletePlatformEmojiMutation = { __typename?: 'Mutation', deletePlatformEmoji?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type GameConditionGameListQueryVariables = Exact<{ [key: string]: never; }>;


export type GameConditionGameListQuery = { __typename?: 'Query', listGames?: { __typename?: 'GameListGamesResponse', games: Array<{ __typename?: 'GameGame', id: string, name: string }> } | null };

export type FeatureFlagChannelConditionChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type FeatureFlagChannelConditionChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string } | null };

export type FeatureFlagGameConditionGameQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type FeatureFlagGameConditionGameQuery = { __typename?: 'Query', game?: { __typename?: 'GameGame', id: string, name: string } | null };

export type FeatureFlagSchemaFlagFragment = { __typename?: 'FlagFeatureFlagSchemaFlagsEntry', value: { __typename?: 'FlagJSONSchema', description: string, type: string, enum: Array<string>, pattern: string, minimum: number, maximum: number, multipleOf: number } };

export type FeatureFlagDrawerSchemaFlagFragment = { __typename?: 'FlagFeatureFlagSchemaFlagsEntry', key: string };

export type FeatureFlagGroupSchemaFragment = { __typename?: 'FlagJSONSchema', type: string, enum: Array<string>, pattern: string, minimum: number, maximum: number, multipleOf: number };

export type FeatureFlagListSchemaFlagFragment = { __typename?: 'FlagFeatureFlagSchemaFlagsEntry', key: string, value: { __typename?: 'FlagJSONSchema', description: string, type: string, enum: Array<string>, pattern: string, minimum: number, maximum: number, multipleOf: number } };

export type FeatureFlagNewValueSchemaFragment = { __typename?: 'FlagJSONSchema', type: string, enum: Array<string>, pattern: string, minimum: number, maximum: number, multipleOf: number };

export type FeatureFlagSchemaQueryVariables = Exact<{ [key: string]: never; }>;


export type FeatureFlagSchemaQuery = { __typename?: 'Query', featureFlagSchema?: { __typename?: 'FlagFeatureFlagSchema', flags: Array<{ __typename?: 'FlagFeatureFlagSchemaFlagsEntry', key: string, value: { __typename?: 'FlagJSONSchema', description: string, type: string, enum: Array<string>, pattern: string, minimum: number, maximum: number, multipleOf: number } }> } | null };

export type FeatureFlagUserConditionProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type FeatureFlagUserConditionProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type FeatureFlagConfigSubscriptionSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type FeatureFlagConfigSubscriptionSubscription = { __typename?: 'Subscription', updates?: { __typename?: 'FlagFeatureFlagConfig', revision: string, userFlags: { __typename?: 'FlagFeatureFlagList', flags: Array<{ __typename?: 'FlagFeatureFlag', name: string, description: string, enabled: boolean, groups: Array<{ __typename?: 'FlagFeatureFlagGroup', id: string, enabled: boolean, default: boolean, values: Array<{ __typename?: 'FlagFeatureFlagGroupValue', value: string, weight: number }>, conditions: Array<{ __typename?: 'FlagFeatureFlagGroupCondition', rule?: { __typename?: 'FlagFeatureFlagGroupConditionAny', field: string, values: Array<string> } | { __typename?: 'FlagFeatureFlagGroupConditionEq', field: string, value: string } | { __typename?: 'FlagFeatureFlagGroupConditionGte', field: string, value: string } | { __typename?: 'FlagFeatureFlagGroupConditionLte', field: string, value: string } | null }> }> }> }, channelFlags: { __typename?: 'FlagFeatureFlagList', flags: Array<{ __typename?: 'FlagFeatureFlag', name: string, description: string, enabled: boolean, groups: Array<{ __typename?: 'FlagFeatureFlagGroup', id: string, enabled: boolean, default: boolean, values: Array<{ __typename?: 'FlagFeatureFlagGroupValue', value: string, weight: number }>, conditions: Array<{ __typename?: 'FlagFeatureFlagGroupCondition', rule?: { __typename?: 'FlagFeatureFlagGroupConditionAny', field: string, values: Array<string> } | { __typename?: 'FlagFeatureFlagGroupConditionEq', field: string, value: string } | { __typename?: 'FlagFeatureFlagGroupConditionGte', field: string, value: string } | { __typename?: 'FlagFeatureFlagGroupConditionLte', field: string, value: string } | null }> }> }> } } | null };

export type FeatureFlagListFragment = { __typename?: 'FlagFeatureFlagList', flags: Array<{ __typename?: 'FlagFeatureFlag', name: string, description: string, enabled: boolean, groups: Array<{ __typename?: 'FlagFeatureFlagGroup', id: string, enabled: boolean, default: boolean, values: Array<{ __typename?: 'FlagFeatureFlagGroupValue', value: string, weight: number }>, conditions: Array<{ __typename?: 'FlagFeatureFlagGroupCondition', rule?: { __typename?: 'FlagFeatureFlagGroupConditionAny', field: string, values: Array<string> } | { __typename?: 'FlagFeatureFlagGroupConditionEq', field: string, value: string } | { __typename?: 'FlagFeatureFlagGroupConditionGte', field: string, value: string } | { __typename?: 'FlagFeatureFlagGroupConditionLte', field: string, value: string } | null }> }> }> };

export type SetFeatureFlagConfigMutationVariables = Exact<{
  previousRevision: Scalars['String']['input'];
  newConfig: FlagFeatureFlagConfigInput;
}>;


export type SetFeatureFlagConfigMutation = { __typename?: 'Mutation', setFeatureFlagConfig?: { __typename?: 'FlagFeatureFlagConfig', revision: string } | null };

export type VideoReportChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, streamer: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } };

export type VideoReportFragment = { __typename?: 'SupportReport', id: string, createdAt: string, description: string, reason: SupportReportReason, context: { __typename?: 'SupportReportContext', value?: { __typename?: 'SupportReportContextChannel' } | { __typename?: 'SupportReportContextChatMessage' } | { __typename?: 'SupportReportContextStream', startAt: number } | { __typename?: 'SupportReportContextUser' } | null }, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } };

export type VideoReportCaseQueryVariables = Exact<{
  caseId: Scalars['ID']['input'];
}>;


export type VideoReportCaseQuery = { __typename?: 'Query', reportCase?: { __typename?: 'SupportReportCase', id: string, status: SupportReportCaseStatus, resolution: SupportReportCaseResolution, context: { __typename?: 'SupportReportContext', value?: { __typename?: 'SupportReportContextChannel' } | { __typename?: 'SupportReportContextChatMessage' } | { __typename?: 'SupportReportContextStream', streamId: string, startAt: number } | { __typename?: 'SupportReportContextUser' } | null } } | null, reports?: { __typename?: 'SupportListReportsResponse', reports: Array<{ __typename?: 'SupportReport', id: string, createdAt: string, description: string, reason: SupportReportReason, context: { __typename?: 'SupportReportContext', value?: { __typename?: 'SupportReportContextChannel' } | { __typename?: 'SupportReportContextChatMessage' } | { __typename?: 'SupportReportContextStream', startAt: number } | { __typename?: 'SupportReportContextUser' } | null }, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> } | null };

export type VideoReportStreamQueryVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type VideoReportStreamQuery = { __typename?: 'Query', stream?: { __typename?: 'ChannelStream', channelId: string, streamId: string } | null };

export type VideoReportChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type VideoReportChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, streamer: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | null };

export type ChannelSearchQueryVariables = Exact<{
  query?: InputMaybe<Scalars['String']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type ChannelSearchQuery = { __typename?: 'Query', search?: { __typename?: 'SearchSearchResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, resultItems: Array<{ __typename?: 'SearchResultItem', entityId: string, entity?: { __typename?: 'ChannelChannel', id: string, name: string, followerCount: number, isPublic: boolean, liveStatus: ChannelLiveStatus, streamer: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile' } | null }> } | null };

export type UserSearchQueryVariables = Exact<{
  query?: InputMaybe<Scalars['String']['input']>;
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type UserSearchQuery = { __typename?: 'Query', search?: { __typename?: 'SearchSearchResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, resultItems: Array<{ __typename?: 'SearchResultItem', entityId: string, entity?: { __typename?: 'ChannelChannel' } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null }> } | null };

export type PlatformSuspensionAppealDrawerQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type PlatformSuspensionAppealDrawerQuery = { __typename?: 'Query', platformBan?: { __typename?: 'ModerationPlatformBan', banId: string, description: string, violation: ModerationViolation, appeal?: { __typename?: 'ModerationPlatformBanAppeal', appealText: string, banId: string } | null } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', createdAt: string } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type PlatformSuspensionAppealsQueryVariables = Exact<{
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type PlatformSuspensionAppealsQuery = { __typename?: 'Query', platformBanAppeals?: { __typename?: 'ModerationListPlatformBanAppealsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, appeals: Array<{ __typename?: 'ModerationPlatformBanAppeal', banId: string, createdAt: string, ban: { __typename?: 'ModerationPlatformBan', banId: string, bannedAt: string, moderator: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }, user: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> } | null };

export type SidebarUserQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  skipBan?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type SidebarUserQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, isNewUsername: boolean, account?: { __typename?: 'AuthAccount', state: ApiEntityState } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, platformBan?: { __typename?: 'ModerationPlatformBan', banId: string } | null };

export type CancelUserDeletionMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type CancelUserDeletionMutation = { __typename?: 'Mutation', cancelDataDeletion?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type CancelDeletionMutationProfileFragment = { __typename?: 'ProfileProfile', account?: { __typename?: 'AuthAccount', flags: Array<AuthAccountStatusFlag> } | null };

export type DeleteUserProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', state: ApiEntityState, flags: Array<AuthAccountStatusFlag> } | null };

export type UserAccountStateFragment = { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', state: ApiEntityState } | null };

export type DeleteUserDataContentProfileFragment = { __typename?: 'ProfileProfile', account?: { __typename?: 'AuthAccount', state: ApiEntityState, flags: Array<AuthAccountStatusFlag> } | null };

export type DeleteUserMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type DeleteUserMutation = { __typename?: 'Mutation', deleteUserData?: { __typename?: 'PrivacyDeleteUserDataResponse', taskId: string } | null };

export type EditUsernameModalProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string };

export type EditUsernameMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  username: Scalars['String']['input'];
}>;


export type EditUsernameMutation = { __typename?: 'Mutation', updateProfile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type EditUsernameModalProfileUpdateFragment = { __typename?: 'ProfileProfile', userTag: string };

export type UserStatsFragment = { __typename?: 'PlayerStatsPlayerStats', matchesPlayed: number, timePlayed?: string | null, cardsPlayed: number, shufflesUsed: number, cardsSucceeded: number, dailyGoalCardsCompleted: number, dailyGoalCardsSet: number, cardBundlesPurchased: number, adsWatched: number, cardLevelUps: number, currencySpending?: { __typename?: 'PlayerStatsPlayerStatsCurrencySpending', softCurrency: number, hardCurrency: number, channelCurrency: number } | null, boosterUsage?: { __typename?: 'PlayerStatsPlayerStatsBoosterUsage', total: number, doubt: number, goodCall: number, letsGo: number, nextUp: number, scavenge: number, speedUp: number } | null };

export type TermsAndAgreementsAuthAccountFragment = { __typename?: 'AuthAccount', marketingConsent: AuthConsentStatus, acceptedTerms: Array<{ __typename?: 'AuthTermsVersion', name: string, revision: string, signature: string }>, pendingAgreements: Array<{ __typename?: 'AgreementAgreementRevision', name: string, revision: string }> };

export type UserQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type UserQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, bio: string, account?: { __typename?: 'AuthAccount', signupLocation: string, createdAt: string, uid: string, matureRatedContentAllowed: boolean, roles: Array<AuthPlatformRole>, state: ApiEntityState, email: string, flags: Array<AuthAccountStatusFlag>, marketingConsent: AuthConsentStatus, externalIds: Array<{ __typename?: 'AuthIdentity', type: AuthIdentityType, id: string }>, acceptedTerms: Array<{ __typename?: 'AuthTermsVersion', name: string, revision: string, signature: string }>, pendingAgreements: Array<{ __typename?: 'AgreementAgreementRevision', name: string, revision: string }> } | null, stats: { __typename?: 'PlayerStatsPlayerStats', matchesPlayed: number, timePlayed?: string | null, cardsPlayed: number, shufflesUsed: number, cardsSucceeded: number, dailyGoalCardsCompleted: number, dailyGoalCardsSet: number, cardBundlesPurchased: number, adsWatched: number, cardLevelUps: number, currencySpending?: { __typename?: 'PlayerStatsPlayerStatsCurrencySpending', softCurrency: number, hardCurrency: number, channelCurrency: number } | null, boosterUsage?: { __typename?: 'PlayerStatsPlayerStatsBoosterUsage', total: number, doubt: number, goodCall: number, letsGo: number, nextUp: number, scavenge: number, speedUp: number } | null } } | null, userPrivilegedChannels?: { __typename?: 'ChannelListUserPrivilegedChannelsResponse', channels: Array<{ __typename?: 'ChannelChannelRoles', channelId: string, roles: Array<ChannelChannelRole>, channel: { __typename?: 'ChannelChannel', id: string, name: string } }> } | null };

export type UserChannelRolesFragment = { __typename?: 'ChannelChannelRoles', roles: Array<ChannelChannelRole>, channel: { __typename?: 'ChannelChannel', id: string, name: string } };

export type UserRolesUpdateAccountMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  roles: Array<AuthPlatformRole> | AuthPlatformRole;
}>;


export type UserRolesUpdateAccountMutation = { __typename?: 'Mutation', updateAccount?: { __typename?: 'AuthAccount', uid: string, roles: Array<AuthPlatformRole> } | null };

export type UserRoleUpdateProfileFragment = { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', roles: Array<AuthPlatformRole> } | null };

export type UserRoleProfileFragment = { __typename?: 'ProfileProfile', userId: string, account?: { __typename?: 'AuthAccount', roles: Array<AuthPlatformRole> } | null };

export type UserSubscriptionsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<ApiCursorInput>;
  filters?: InputMaybe<Array<SubscriptionListUserChannelSubscriptionsRequestFilterInput> | SubscriptionListUserChannelSubscriptionsRequestFilterInput>;
}>;


export type UserSubscriptionsQuery = { __typename?: 'Query', userChannelSubscriptions?: { __typename?: 'SubscriptionListUserChannelSubscriptionsResponse', subscriptions: Array<{ __typename?: 'SubscriptionChannelSubscription', cancelledAt?: string | null, createdAt: string, expiresAt?: string | null, id: string, paymentFailedAt?: string | null, renewedAt?: string | null, state: SubscriptionChannelSubscriptionState, tier: number, channel: { __typename?: 'ChannelChannel', id: string, name: string } }>, pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean } } | null };

export type UserFeatureFlagsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type UserFeatureFlagsQuery = { __typename?: 'Query', userFeatureFlags?: { __typename?: 'FlagListUserFeatureFlagsResponse', flags: Array<{ __typename?: 'FlagFeatureFlagState', name: string, value: string }> } | null };

export type UserFriendsQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UserFriendsQuery = { __typename?: 'Query', friends?: { __typename?: 'FriendsListFriendsResponse', users: Array<{ __typename?: 'FriendsUser', userId: string, profile: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } }> } | null };

export type UserProgressionsQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UserProgressionsQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userTag: string, userId: string, playedGames: Array<{ __typename?: 'ProfilePlayedGame', id: string, userId: string, progression: { __typename?: 'GameUserProgression', level: number }, season: { __typename?: 'GameSeason', id: string, name: string }, game: { __typename?: 'GameGame', id: string, name: string } }> } | null };

export type UserWalletQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UserWalletQuery = { __typename?: 'Query', wallet?: { __typename?: 'WalletGetWalletResponse', wallet: { __typename?: 'WalletWallet', userId: string, currencies: Array<{ __typename?: 'WalletWalletCurrency', currencyId: string, currencyAmount: number }> } } | null };

export type UserWalletAddCurrencyMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  currencies?: InputMaybe<Array<WalletWalletCurrencyInput> | WalletWalletCurrencyInput>;
  reason: ReasonReasonInput;
}>;


export type UserWalletAddCurrencyMutation = { __typename?: 'Mutation', addWalletCurrencies?: { __typename?: 'WalletAddCurrenciesResponse', emptyTypeWorkaround: boolean } | null };

export type UserWalletSubtractCurrencyMutationVariables = Exact<{
  userId?: InputMaybe<Scalars['ID']['input']>;
  currencies?: InputMaybe<Array<WalletWalletCurrencyInput> | WalletWalletCurrencyInput>;
  reason: ReasonReasonInput;
}>;


export type UserWalletSubtractCurrencyMutation = { __typename?: 'Mutation', subtractWalletCurrencies?: { __typename?: 'WalletSubtractCurrenciesResponse', emptyTypeWorkaround: boolean } | null };

export type UserDrawerQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type UserDrawerQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, lastSeen?: string | null, account?: { __typename?: 'AuthAccount', email: string, acceptedTerms: Array<{ __typename?: 'AuthTermsVersion', revision: string, name: string, signature: string }>, pendingAgreements: Array<{ __typename?: 'AgreementAgreementRevision', name: string, revision: string }> } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type UsersQueryVariables = Exact<{
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type UsersQuery = { __typename?: 'Query', profiles?: { __typename?: 'ProfileListProfilesResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, profiles: Array<{ __typename?: 'ProfileProfile', userId: string, userTag: string, lastSeen?: string | null, account?: { __typename?: 'AuthAccount', email: string, roles: Array<AuthPlatformRole> } | null }> } | null };

export type UpdateSuspensionAppealMutationVariables = Exact<{
  banId: Scalars['ID']['input'];
  status: ModerationAppealStatus;
}>;


export type UpdateSuspensionAppealMutation = { __typename?: 'Mutation', updatePlatformBanAppeal?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type PlatformSuspensionAppealFormSuspensionFragment = { __typename?: 'ModerationPlatformBan', banId: string, description: string, violation: ModerationViolation, appeal?: { __typename?: 'ModerationPlatformBanAppeal', appealText: string, banId: string } | null };

export type PlatformSuspensionAppealFormProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', createdAt: string } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type UserWalletPaymentsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type UserWalletPaymentsQuery = { __typename?: 'Query', successfulPayments?: { __typename?: 'PaymentListSuccessfulPaymentsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, payments: Array<{ __typename?: 'PaymentPayment', id: string, timestamp: string, items: Array<{ __typename?: 'PaymentLineItem', description: string }>, info: { __typename?: 'PaymentPaymentInfo', cardSummary: string }, amount: { __typename?: 'PaymentAmount', currency: PaymentCurrency, value: number }, tax: { __typename?: 'PaymentTax', rate: number, amount?: { __typename?: 'PaymentAmount', currency: PaymentCurrency, value: number } | null } }> } | null };

export type UserWalletPaymentFragment = { __typename?: 'PaymentPayment', id: string, timestamp: string, items: Array<{ __typename?: 'PaymentLineItem', description: string }>, info: { __typename?: 'PaymentPaymentInfo', cardSummary: string }, amount: { __typename?: 'PaymentAmount', currency: PaymentCurrency, value: number }, tax: { __typename?: 'PaymentTax', rate: number, amount?: { __typename?: 'PaymentAmount', currency: PaymentCurrency, value: number } | null } };

export type UserWallerTransactionsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type UserWallerTransactionsQuery = { __typename?: 'Query', walletTransactions?: { __typename?: 'WalletListWalletTransactionsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, transactions: Array<{ __typename?: 'WalletTransaction', id: string, createdAt: string, operations: Array<{ __typename?: 'WalletOperation', type: WalletOperationType, currencyId: string, currencyBalance: number, currencyAmount: number }>, reason: { __typename?: 'ReasonReason', reason?: { __typename?: 'ReasonReasonAdWatched' } | { __typename?: 'ReasonReasonAdministrative', reason: string } | { __typename?: 'ReasonReasonChallengeSuccessful' } | { __typename?: 'ReasonReasonChannelOwner' } | { __typename?: 'ReasonReasonChannelSubscription' } | { __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonGiftPurchaseWithPayment' } | { __typename?: 'ReasonReasonGoalCardComplete' } | { __typename?: 'ReasonReasonGoalCardSlotReshuffle' } | { __typename?: 'ReasonReasonLevelUp' } | { __typename?: 'ReasonReasonMatchEnd' } | { __typename?: 'ReasonReasonProvision', seasonId: string, rev: string } | { __typename?: 'ReasonReasonPurchaseWithInGameCurrency', sku: string, orderId: string, itemType: StoreV2ItemType } | { __typename?: 'ReasonReasonPurchaseWithPayment', sku: string, orderId: string, reference: string, price: { __typename?: 'PaymentAmount', value: number, currency: PaymentCurrency } } | { __typename?: 'ReasonReasonReshuffle' } | { __typename?: 'ReasonReasonRewardClaimed' } | { __typename?: 'ReasonReasonStoreOrderPayment', sku: string, orderId: string, itemType: StoreV2ItemType } | null } }> } | null };

export type UserWalletTransactionFragment = { __typename?: 'WalletTransaction', id: string, createdAt: string, operations: Array<{ __typename?: 'WalletOperation', type: WalletOperationType, currencyId: string, currencyBalance: number, currencyAmount: number }>, reason: { __typename?: 'ReasonReason', reason?: { __typename?: 'ReasonReasonAdWatched' } | { __typename?: 'ReasonReasonAdministrative', reason: string } | { __typename?: 'ReasonReasonChallengeSuccessful' } | { __typename?: 'ReasonReasonChannelOwner' } | { __typename?: 'ReasonReasonChannelSubscription' } | { __typename?: 'ReasonReasonGiftPurchaseWithInGameCurrency' } | { __typename?: 'ReasonReasonGiftPurchaseWithPayment' } | { __typename?: 'ReasonReasonGoalCardComplete' } | { __typename?: 'ReasonReasonGoalCardSlotReshuffle' } | { __typename?: 'ReasonReasonLevelUp' } | { __typename?: 'ReasonReasonMatchEnd' } | { __typename?: 'ReasonReasonProvision', seasonId: string, rev: string } | { __typename?: 'ReasonReasonPurchaseWithInGameCurrency', sku: string, orderId: string, itemType: StoreV2ItemType } | { __typename?: 'ReasonReasonPurchaseWithPayment', sku: string, orderId: string, reference: string, price: { __typename?: 'PaymentAmount', value: number, currency: PaymentCurrency } } | { __typename?: 'ReasonReasonReshuffle' } | { __typename?: 'ReasonReasonRewardClaimed' } | { __typename?: 'ReasonReasonStoreOrderPayment', sku: string, orderId: string, itemType: StoreV2ItemType } | null } };

export type AddNewUserMutationVariables = Exact<{
  email: Scalars['String']['input'];
  username: Scalars['String']['input'];
  isBot?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type AddNewUserMutation = { __typename?: 'Mutation', createAccount?: { __typename?: 'AuthAccount', uid: string } | null };

export type InventoryItemToggleInventoryItemFragment = { __typename?: 'InventoryInventoryItem', itemId: string, itemCount: number };

export type InventoryItemToggleItemFragment = { __typename?: 'ItemItem', id: string, name: string, inventoryItem: { __typename?: 'InventoryInventoryItem', itemCount: number }, details?: { __typename?: 'AvatarAnimation', id: string } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string } | { __typename?: 'GameLogicCard', id: string } | { __typename?: 'GameLogicStreamerCard', id: string } | null };

export type IncreaseInventoryItemCountMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  itemId: Scalars['ID']['input'];
  itemCount: Scalars['Int']['input'];
  reason: ReasonReasonInput;
}>;


export type IncreaseInventoryItemCountMutation = { __typename?: 'Mutation', addUserEntitlements?: { __typename?: 'InventoryAddEntitlementsResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemCount: number, itemId: string }> } | null };

export type DecreaseInventoryItemCountMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  itemId: Scalars['ID']['input'];
  itemCount: Scalars['Int']['input'];
  reason: ReasonReasonInput;
}>;


export type DecreaseInventoryItemCountMutation = { __typename?: 'Mutation', consumeUserItem?: { __typename?: 'InventoryConsumeItemResponse', items: Array<{ __typename?: 'InventoryInventoryItem', itemCount: number, itemId: string }> } | null };

export type EditedInventoryItemFragment = { __typename?: 'ItemItem', id: string, name: string, inventoryItem: { __typename?: 'InventoryInventoryItem', itemCount: number }, details?: { __typename?: 'AvatarAnimation', id: string } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string } | { __typename?: 'GameLogicCard', id: string } | { __typename?: 'GameLogicStreamerCard', id: string } | null };

export type InventoryAvatarPartsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type InventoryAvatarPartsQuery = { __typename?: 'Query', items?: { __typename?: 'ItemListItemsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, items: Array<{ __typename?: 'ItemItem', id: string, name: string, inventoryItem: { __typename?: 'InventoryInventoryItem', itemCount: number, itemId: string }, details?: { __typename?: 'AvatarAnimation', id: string } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string } | { __typename?: 'GameLogicCard', id: string } | { __typename?: 'GameLogicStreamerCard', id: string } | null }> } | null };

export type InventoryCardsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  filters?: InputMaybe<Array<ItemListItemsRequestFilterInput> | ItemListItemsRequestFilterInput>;
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type InventoryCardsQuery = { __typename?: 'Query', items?: { __typename?: 'ItemListItemsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, items: Array<{ __typename?: 'ItemItem', id: string, name: string, type: ItemItemType, game?: { __typename?: 'GameGame', id: string, name: string } | null, season?: { __typename?: 'GameSeason', id: string, name: string } | null, details?: { __typename?: 'AvatarAnimation', id: string } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string } | { __typename?: 'GameLogicCard', id: string, name: string, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } } | { __typename?: 'GameLogicStreamerCard', id: string, baseCard: { __typename?: 'GameLogicCard', id: string, name: string, leveling: { __typename?: 'GameLogicCardLeveling', currentLevel: number } } } | null, inventoryItem: { __typename?: 'InventoryInventoryItem', itemCount: number, itemId: string } }> } | null };

export type InventoryCardsEditPopoverItemFragment = { __typename?: 'ItemItem', id: string, name: string, inventoryItem: { __typename?: 'InventoryInventoryItem', itemCount: number }, details?: { __typename?: 'AvatarAnimation', id: string } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string } | { __typename?: 'GameLogicCard', id: string } | { __typename?: 'GameLogicStreamerCard', id: string } | null };

export type InventoryCardsEditPopoverInventoryItemFragment = { __typename?: 'InventoryInventoryItem', itemId: string, itemCount: number };

export type CardFilterGamesQueryVariables = Exact<{ [key: string]: never; }>;


export type CardFilterGamesQuery = { __typename?: 'Query', listGames?: { __typename?: 'GameListGamesResponse', games: Array<{ __typename?: 'GameGame', id: string, name: string }> } | null };

export type CardFilterGameSeasonsQueryVariables = Exact<{
  gameId: Scalars['ID']['input'];
}>;


export type CardFilterGameSeasonsQuery = { __typename?: 'Query', listSeasons?: { __typename?: 'GameListSeasonsResponse', seasons: Array<{ __typename?: 'GameSeason', id: string, name: string }> } | null };

export type InventoryEmojisQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type InventoryEmojisQuery = { __typename?: 'Query', items?: { __typename?: 'ItemListItemsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, items: Array<{ __typename?: 'ItemItem', id: string, name: string, inventoryItem: { __typename?: 'InventoryInventoryItem', itemCount: number, itemId: string }, details?: { __typename?: 'AvatarAnimation', id: string } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string } | { __typename?: 'GameLogicCard', id: string } | { __typename?: 'GameLogicStreamerCard', id: string } | null }> } | null };

export type InventoryEmotesQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type InventoryEmotesQuery = { __typename?: 'Query', items?: { __typename?: 'ItemListItemsResponse', pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean }, items: Array<{ __typename?: 'ItemItem', id: string, name: string, inventoryItem: { __typename?: 'InventoryInventoryItem', itemCount: number, itemId: string }, details?: { __typename?: 'AvatarAnimation', id: string } | { __typename?: 'AvatarAvatarPart' } | { __typename?: 'EmojiEmoji', id: string } | { __typename?: 'GameLogicCard', id: string } | { __typename?: 'GameLogicStreamerCard', id: string } | null }> } | null };

export type ModerationChannelBanFragment = { __typename?: 'ChannelBannedUser', bannedAt: string, violation: ChannelViolation, channel: { __typename?: 'ChannelChannel', id: string, name: string } };

export type UserModerationQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type UserModerationQuery = { __typename?: 'Query', platformBan?: { __typename?: 'ModerationPlatformBan', banId: string, violation: ModerationViolation, description: string, bannedAt: string, expiresAt?: string | null, appeal?: { __typename?: 'ModerationPlatformBanAppeal', banId: string, status: ModerationAppealStatus, closedAt?: string | null, reviewerComment: string, appealText: string, reviewer?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null } | null, moderator: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } } | null, profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, moderationEvents?: Array<{ __typename?: 'ProfileUsernameChange', oldUsername: string, changedAt: string, reason: ModerationViolation, changer?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null }> | null, account?: { __typename?: 'AuthAccount', createdAt: string } | null, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', newUsername: string, oldUsername: string, reason: ModerationViolation }> | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null, userChannelBans?: { __typename?: 'ChannelListUserChannelBansResponse', bans: Array<{ __typename?: 'ChannelBannedUser', userId: string, channelId: string, bannedAt: string, violation: ChannelViolation, channel: { __typename?: 'ChannelChannel', id: string, name: string } }> } | null };

export type ModerationUnsuspendPlatformUserMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ModerationUnsuspendPlatformUserMutation = { __typename?: 'Mutation', unbanPlatformUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type ModerationEventsProfileUsernameChangeFragment = { __typename?: 'ProfileUsernameChange', oldUsername: string, changedAt: string, reason: ModerationViolation, changer?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type UnsuspendPlatformUserMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type UnsuspendPlatformUserMutation = { __typename?: 'Mutation', unbanPlatformUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SuspendedUserPlatformSuspensionFragment = { __typename?: 'ModerationPlatformBan', bannedAt: string, banId: string, userId: string, description: string, violation: ModerationViolation, appeal?: { __typename?: 'ModerationPlatformBanAppeal', status: ModerationAppealStatus, banId: string } | null, moderator: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } };

export type SuspendPlatformUserMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  violation: ModerationViolation;
  description: Scalars['String']['input'];
  duration?: InputMaybe<Scalars['Duration']['input']>;
}>;


export type SuspendPlatformUserMutation = { __typename?: 'Mutation', banPlatformUser?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type PlatformSuspensionModerationModalProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', createdAt: string } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type SuspensionStatusPlatformSuspensionFragment = { __typename?: 'ModerationPlatformBan', bannedAt: string, violation: ModerationViolation, description: string, expiresAt?: string | null, appeal?: { __typename?: 'ModerationPlatformBanAppeal', banId: string, status: ModerationAppealStatus, closedAt?: string | null, reviewerComment: string, reviewer?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null } | null, moderator: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } };

export type UsernameRejectionProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', createdAt: string } | null, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', newUsername: string, oldUsername: string, reason: ModerationViolation }> | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type RejectUsernameMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  reason: ModerationViolation;
}>;


export type RejectUsernameMutation = { __typename?: 'Mutation', rejectUsername?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type UsernameRejectionUpdateQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type UsernameRejectionUpdateQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, usernameHistory?: Array<{ __typename?: 'ProfileUsernameChange', newUsername: string, oldUsername: string, reason: ModerationViolation }> | null } | null };

export type UserChannelBansQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
  cursor?: InputMaybe<ApiCursorInput>;
}>;


export type UserChannelBansQuery = { __typename?: 'Query', userChannelBans?: { __typename?: 'ChannelListUserChannelBansResponse', bans: Array<{ __typename?: 'ChannelBannedUser', userId: string, channelId: string, bannedAt: string, violation: ChannelViolation, description: string, channel: { __typename?: 'ChannelChannel', id: string, name: string }, moderator: { __typename?: 'ProfileProfile', userId: string, userTag: string } }>, pageInfo: { __typename?: 'APIPageInfo', endCursor: string, hasNextPage: boolean, startCursor: string, hasPreviousPage: boolean } } | null };

export type BreadcrumbsUserQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type BreadcrumbsUserQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string } | null };

export type BreadcrumbsChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type BreadcrumbsChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string } | null };

export type SearchBoxProfileResultItemFragment = { __typename?: 'SearchResultItem', matchedProperties: Array<string>, entity?: { __typename?: 'ChannelChannel' } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile', userId: string, userTag: string, bio: string, account?: { __typename?: 'AuthAccount', email: string } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type SearchBoxChannelResultItemFragment = { __typename?: 'SearchResultItem', matchedProperties: Array<string>, entity?: { __typename?: 'ChannelChannel', id: string, name: string, title: string, liveStatus: ChannelLiveStatus, logo: string, streamer: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null } } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile' } | null };

export type SearchBoxChannelLinkChannelFragment = { __typename?: 'ChannelChannel', id: string, name: string, title: string, liveStatus: ChannelLiveStatus, logo: string, streamer: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null } };

export type SearchBoxProfileLinkProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, bio: string, account?: { __typename?: 'AuthAccount', email: string } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type SearchBoxSearchQueryVariables = Exact<{
  query?: InputMaybe<Scalars['String']['input']>;
}>;


export type SearchBoxSearchQuery = { __typename?: 'Query', userSearch?: { __typename?: 'SearchSearchResponse', resultItems: Array<{ __typename?: 'SearchResultItem', entityId: string, matchedProperties: Array<string>, entity?: { __typename?: 'ChannelChannel' } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile', userId: string, userTag: string, bio: string, account?: { __typename?: 'AuthAccount', email: string } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null }> } | null, channelSearch?: { __typename?: 'SearchSearchResponse', resultItems: Array<{ __typename?: 'SearchResultItem', entityId: string, matchedProperties: Array<string>, entity?: { __typename?: 'ChannelChannel', id: string, name: string, title: string, liveStatus: ChannelLiveStatus, logo: string, streamer: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null } } | { __typename?: 'ChannelGameStats' } | { __typename?: 'ProfileProfile' } | null }> } | null };

export type NoAccessPermissionQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type NoAccessPermissionQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', uid: string, roles: Array<AuthPlatformRole> } | null } | null };

export type ReasonDescriptionInputProfileFragment = { __typename?: 'ProfileProfile', userTag: string };

export type ReasonDescriptionInputChannelFragment = { __typename?: 'ChannelChannel', name: string };

export type ReasonSelectProfileFragment = { __typename?: 'ProfileProfile', userTag: string };

export type ReasonSelectChannelFragment = { __typename?: 'ChannelChannel', name: string };

export type ReportUserMutationVariables = Exact<{
  reason: SupportReportReason;
  description?: InputMaybe<Scalars['String']['input']>;
  context: SupportReportContextInput;
}>;


export type ReportUserMutation = { __typename?: 'Mutation', createReport?: { __typename?: 'SupportReport', createdAt: string } | null };

export type ReportedUserProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type ReportedUserProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'ProfileProfile', userId: string, userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null } | null };

export type ReportedChannelQueryVariables = Exact<{
  channelId: Scalars['ID']['input'];
}>;


export type ReportedChannelQuery = { __typename?: 'Query', channel?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string } | null };

export type ReportedChannelFragment = { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, logo: string };

export type ReportedUserProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ReportStreamTimestampQueryVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type ReportStreamTimestampQuery = { __typename?: 'Query', stream?: { __typename?: 'ChannelStream', streamId: string, segments: Array<{ __typename?: 'ChannelStreamSegment', startTime: string }> } | null };

export type SignupFlowChannelQueryVariables = Exact<{
  channelName: Scalars['String']['input'];
}>;


export type SignupFlowChannelQuery = { __typename?: 'Query', channelByName?: { __typename?: 'ChannelChannel', id: string, name: string, liveStatus: ChannelLiveStatus, logo: string } | null };

export type SignupFlowChannelFragment = { __typename?: 'ChannelChannel', name: string, liveStatus: ChannelLiveStatus, logo: string };

export type ChannelBannerChannelFragment = { __typename?: 'ChannelChannel', offlineBanner: string };

export type ChannelLogoChannelFragment = { __typename?: 'ChannelChannel', liveStatus: ChannelLiveStatus, logo: string, name: string };

export type PlatformAnnouncementFragment = { __typename?: 'AnnouncementAnnouncement', id: string, title: string, text: string, category: AnnouncementAnnouncementCategory, startTime?: string | null, image: string };

export type ProfileImageProfileFragment = { __typename?: 'ProfileProfile', userTag: string, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ProfileImageShowOnlineStatusProfileFragment = { __typename?: 'ProfileProfile', onlineStatus: ProfilePresenceStatus, userTag: string, settings?: { __typename?: 'ProfileProfileSettings', privacy: { __typename?: 'ProfilePrivacySettings', hideOnlineStatus: boolean } } | null, avatars?: { __typename?: 'ProfileProfileAvatars', avatar2D: string } | null };

export type ChannelAssetCreateTokenMutationVariables = Exact<{
  channelId?: InputMaybe<Scalars['ID']['input']>;
  assetType?: InputMaybe<ChannelAssetType>;
}>;


export type ChannelAssetCreateTokenMutation = { __typename?: 'Mutation', createChannelAssetUploadToken?: { __typename?: 'ChannelCreateChannelAssetUploadTokenResponse', token: string } | null };

export type LogoUpdateChannelChannelFragment = { __typename?: 'ChannelChannel', id: string, logo: string };

export type BannerUpdateChannelChannelFragment = { __typename?: 'ChannelChannel', id: string, offlineBanner: string };

export type EmojiAssetCreateTokenMutationVariables = Exact<{
  itemId: Scalars['ID']['input'];
}>;


export type EmojiAssetCreateTokenMutation = { __typename?: 'Mutation', createEmojiUploadToken?: { __typename?: 'EmojiCreateEmojiUploadTokenResponse', token: string } | null };

export type AssetUploadEmojiEmojiFragment = { __typename?: 'EmojiEmoji', image: string };

export type WalletQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type WalletQuery = { __typename?: 'Query', wallet?: { __typename?: 'WalletGetWalletResponse', wallet: { __typename?: 'WalletWallet', currencies: Array<{ __typename?: 'WalletWalletCurrency', currencyId: string, currencyAmount: number }> } } | null };

export type WalletCurrencyFragment = { __typename?: 'WalletWalletCurrency', currencyId: string, currencyAmount: number };

export type ZendeskPrefillProfileFragment = { __typename?: 'ProfileProfile', userId: string, userTag: string, account?: { __typename?: 'AuthAccount', email: string } | null };

export type StreamSpectatorCoordinationSubscribeSubscriptionVariables = Exact<{
  streamId: Scalars['ID']['input'];
}>;


export type StreamSpectatorCoordinationSubscribeSubscription = { __typename?: 'Subscription', streamSpectatorCoordinationEventsSubscribe?: { __typename?: 'MatchStreamSpectatorCoordinationEvent', event?: { __typename?: 'MatchStreamSpectatorChangeGroupEvent', groupId: string } | null } | null };

export type UpdateAvatarMutationVariables = Exact<{
  avatarId: Scalars['ID']['input'];
}>;


export type UpdateAvatarMutation = { __typename?: 'Mutation', updateProfileAvatar?: { __typename?: 'GoogleProtobufEmpty', emptyTypeWorkaround: boolean } | null };

export type SubscriptionGetChannelEmojisChannelFragment = { __typename?: 'ChannelChannel', subscriptionConfig?: { __typename?: 'SubscriptionChannelSubscriptionConfig', channelId: string, tiers: Array<{ __typename?: 'SubscriptionChannelSubscriptionTier', level: number, entitlements: Array<{ __typename?: 'SubscriptionChannelSubscriptionEntitlement', itemId: string, item: { __typename?: 'ItemItem', id: string, type: ItemItemType, children?: Array<{ __typename?: 'ItemItem', id: string, type: ItemItemType, details?: { __typename?: 'AvatarAnimation' } | { __typename?: 'AvatarAvatarPart' } | { __typename: 'EmojiEmoji', id: string, image: string, name: string } | { __typename?: 'GameLogicCard' } | { __typename?: 'GameLogicStreamerCard' } | null }> | null } }> }> } | null };

export type SubscriptionGetChannelEmojisChannelEmojiFragment = { __typename: 'EmojiEmoji', id: string, image: string, name: string };

export const ChannelLogoChannelFragmentDoc = gql`
    fragment ChannelLogoChannel on ChannelChannel {
  liveStatus
  logo
  name
}
    `;
export const SearchMatchResultChannelFragmentDoc = gql`
    fragment SearchMatchResultChannel on ChannelChannel {
  name
  title
  streamer {
    userId
    userTag
    account {
      email
    }
  }
}
    `;
export const ChannelSelectChannelFragmentDoc = gql`
    fragment ChannelSelectChannel on ChannelChannel {
  id
  name
  ...ChannelLogoChannel
  ...SearchMatchResultChannel
}
    ${ChannelLogoChannelFragmentDoc}
${SearchMatchResultChannelFragmentDoc}`;
export const ChannelSelectResultItemFragmentDoc = gql`
    fragment ChannelSelectResultItem on SearchResultItem {
  entity {
    ... on ChannelChannel {
      ...ChannelSelectChannel
    }
  }
  matchedProperties
}
    ${ChannelSelectChannelFragmentDoc}`;
export const EmojiTableEmojiFragmentDoc = gql`
    fragment EmojiTableEmoji on EmojiEmoji {
  id
  image
  label
  disabled
}
    `;
export const HiddenEmailTextFieldProfileFragmentDoc = gql`
    fragment HiddenEmailTextFieldProfile on ProfileProfile {
  account {
    email
  }
}
    `;
export const ProfileImageProfileFragmentDoc = gql`
    fragment ProfileImageProfile on ProfileProfile {
  avatars {
    avatar2D
  }
  userTag
}
    `;
export const SearchMatchResultProfileFragmentDoc = gql`
    fragment SearchMatchResultProfile on ProfileProfile {
  userId
  bio
  userTag
  account {
    email
  }
}
    `;
export const ProfileSelectProfileFragmentDoc = gql`
    fragment ProfileSelectProfile on ProfileProfile {
  userId
  userTag
  ...ProfileImageProfile
  ...SearchMatchResultProfile
}
    ${ProfileImageProfileFragmentDoc}
${SearchMatchResultProfileFragmentDoc}`;
export const ProfileSelectResultItemFragmentDoc = gql`
    fragment ProfileSelectResultItem on SearchResultItem {
  entity {
    ... on ProfileProfile {
      ...ProfileSelectProfile
    }
  }
  matchedProperties
}
    ${ProfileSelectProfileFragmentDoc}`;
export const SidebarChannelFragmentDoc = gql`
    fragment SidebarChannel on ChannelChannel {
  currentStreamId
  logo
  name
  state
  features {
    streaming {
      enabled
    }
  }
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const DeleteChannelModalChannelFragmentDoc = gql`
    fragment DeleteChannelModalChannel on ChannelChannel {
  id
  name
}
    `;
export const DeleteChannelChannelFragmentDoc = gql`
    fragment DeleteChannelChannel on ChannelChannel {
  state
  ...DeleteChannelModalChannel
}
    ${DeleteChannelModalChannelFragmentDoc}`;
export const ChannelEmojiEditDrawerChannelFragmentDoc = gql`
    fragment ChannelEmojiEditDrawerChannel on ChannelChannel {
  id
  name
}
    `;
export const ChannelEmojiAddDrawerChannelFragmentDoc = gql`
    fragment ChannelEmojiAddDrawerChannel on ChannelChannel {
  id
  name
}
    `;
export const ChannelEmojiDrawerChannelFragmentDoc = gql`
    fragment ChannelEmojiDrawerChannel on ChannelChannel {
  ...ChannelEmojiEditDrawerChannel
  ...ChannelEmojiAddDrawerChannel
}
    ${ChannelEmojiEditDrawerChannelFragmentDoc}
${ChannelEmojiAddDrawerChannelFragmentDoc}`;
export const ChannelEmojiEditDrawerEmojiFragmentDoc = gql`
    fragment ChannelEmojiEditDrawerEmoji on EmojiEmoji {
  disabled
  id
  label
  image
  channelId
}
    `;
export const ForceChannelOfflineModalChannelFragmentDoc = gql`
    fragment ForceChannelOfflineModalChannel on ChannelChannel {
  id
  name
  followerCount
  subscriberCount
  liveStatus
  logo
}
    `;
export const ArenaCrowdChannelStreamBackendConfigFragmentDoc = gql`
    fragment ArenaCrowdChannelStreamBackendConfig on ChannelStreamBackendConfig {
  id
  crConfig {
    arenaId
    containerImage
    controllerContainerImage
  }
}
    `;
export const ArenaCrowdArenaFragmentDoc = gql`
    fragment ArenaCrowdArena on ArenaArena {
  id
  name
  enabled
}
    `;
export const ChannelOwnerAgreementsFragmentDoc = gql`
    fragment ChannelOwnerAgreements on ProfileProfile {
  account {
    acceptedTerms {
      name
    }
  }
}
    `;
export const ChannelMonetizationChannelFragmentDoc = gql`
    fragment ChannelMonetizationChannel on ChannelChannel {
  id
  monetizationSettings {
    channelId
    enabled
    eligible
  }
  streamerId
  subscriptionConfig {
    channelId
    subscriptionsEnabled
  }
}
    `;
export const SubscriptionMonetizationUpdateFragmentDoc = gql`
    fragment SubscriptionMonetizationUpdate on ChannelChannel {
  id
  monetizationSettings {
    channelId
    enabled
    eligible
  }
}
    `;
export const ChannelVisibilityChannelFragmentDoc = gql`
    fragment ChannelVisibilityChannel on ChannelChannel {
  id
  isPublic
}
    `;
export const PrivacyUpdateChannelFragmentDoc = gql`
    fragment PrivacyUpdateChannel on ChannelChannel {
  id
  isPublic
}
    `;
export const PredictionGameChannelStreamBackendConfigFragmentDoc = gql`
    fragment PredictionGameChannelStreamBackendConfig on ChannelStreamBackendConfig {
  id
  mlConfig {
    containerImage
  }
}
    `;
export const PriorityUpdateChannelFragmentDoc = gql`
    fragment PriorityUpdateChannel on ChannelChannel {
  id
  priority
}
    `;
export const RecordingChannelStreamBackendConfigFragmentDoc = gql`
    fragment RecordingChannelStreamBackendConfig on ChannelStreamBackendConfig {
  id
  recConfig {
    containerImage
  }
}
    `;
export const RiskTierUpdateChannelFragmentDoc = gql`
    fragment RiskTierUpdateChannel on ChannelChannel {
  id
  riskTier
}
    `;
export const ChannelSelectorChannelFragmentDoc = gql`
    fragment ChannelSelectorChannel on ChannelChannel {
  id
  name
}
    `;
export const PlatformAnnouncementFragmentDoc = gql`
    fragment PlatformAnnouncement on AnnouncementAnnouncement {
  id
  title
  text
  category
  startTime
  image
}
    `;
export const AnnouncementFormContentAnnouncementFragmentDoc = gql`
    fragment AnnouncementFormContentAnnouncement on AnnouncementAnnouncement {
  startTime
  endTime
  ...PlatformAnnouncement
}
    ${PlatformAnnouncementFragmentDoc}`;
export const AnnouncementEditFormAnnouncementFragmentDoc = gql`
    fragment AnnouncementEditFormAnnouncement on AnnouncementAnnouncement {
  id
  title
  category
  text
  startTime
  endTime
  published
  image
  status
  targets {
    web
    studio
  }
  ...AnnouncementFormContentAnnouncement
}
    ${AnnouncementFormContentAnnouncementFragmentDoc}`;
export const AnnouncementDrawerAnnouncementFragmentDoc = gql`
    fragment AnnouncementDrawerAnnouncement on AnnouncementAnnouncement {
  id
  ...AnnouncementEditFormAnnouncement
}
    ${AnnouncementEditFormAnnouncementFragmentDoc}`;
export const AssetDeleteAnnouncementFragmentDoc = gql`
    fragment AssetDeleteAnnouncement on AnnouncementAnnouncement {
  id
  image
}
    `;
export const AnnouncementEditFormCacheAnnouncementFragmentDoc = gql`
    fragment AnnouncementEditFormCacheAnnouncement on AnnouncementAnnouncement {
  id
  title
  category
  published
  startTime
  endTime
  status
  targets {
    web
    studio
  }
}
    `;
export const UsernameTableCellProfileFragmentDoc = gql`
    fragment UsernameTableCellProfile on ProfileProfile {
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const AnnouncementTableAnnouncementFragmentDoc = gql`
    fragment AnnouncementTableAnnouncement on AnnouncementAnnouncement {
  id
  title
  category
  startTime
  endTime
  status
  creator {
    userId
    ...UsernameTableCellProfile
  }
}
    ${UsernameTableCellProfileFragmentDoc}`;
export const AssetUploadAnnouncementAnnouncementFragmentDoc = gql`
    fragment AssetUploadAnnouncementAnnouncement on AnnouncementAnnouncement {
  id
  image
}
    `;
export const PlatformEmojiEditDrawerEmojiFragmentDoc = gql`
    fragment PlatformEmojiEditDrawerEmoji on EmojiEmoji {
  disabled
  id
  label
  image
}
    `;
export const FeatureFlagDrawerSchemaFlagFragmentDoc = gql`
    fragment FeatureFlagDrawerSchemaFlag on FlagFeatureFlagSchemaFlagsEntry {
  key
}
    `;
export const FeatureFlagNewValueSchemaFragmentDoc = gql`
    fragment FeatureFlagNewValueSchema on FlagJSONSchema {
  type
  enum
  pattern
  minimum
  maximum
  multipleOf
}
    `;
export const FeatureFlagGroupSchemaFragmentDoc = gql`
    fragment FeatureFlagGroupSchema on FlagJSONSchema {
  ...FeatureFlagNewValueSchema
}
    ${FeatureFlagNewValueSchemaFragmentDoc}`;
export const FeatureFlagSchemaFlagFragmentDoc = gql`
    fragment FeatureFlagSchemaFlag on FlagFeatureFlagSchemaFlagsEntry {
  value {
    description
    type
    enum
    pattern
    minimum
    maximum
    multipleOf
  }
}
    `;
export const FeatureFlagListSchemaFlagFragmentDoc = gql`
    fragment FeatureFlagListSchemaFlag on FlagFeatureFlagSchemaFlagsEntry {
  key
  ...FeatureFlagSchemaFlag
}
    ${FeatureFlagSchemaFlagFragmentDoc}`;
export const FeatureFlagListFragmentDoc = gql`
    fragment FeatureFlagList on FlagFeatureFlagList {
  flags {
    name
    description
    enabled
    groups {
      id
      enabled
      default
      values {
        value
        weight
      }
      conditions {
        rule {
          ... on FlagFeatureFlagGroupConditionEq {
            field
            value
          }
          ... on FlagFeatureFlagGroupConditionAny {
            field
            values
          }
          ... on FlagFeatureFlagGroupConditionLte {
            field
            value
          }
          ... on FlagFeatureFlagGroupConditionGte {
            field
            value
          }
        }
      }
    }
  }
}
    `;
export const VideoReportChannelFragmentDoc = gql`
    fragment VideoReportChannel on ChannelChannel {
  id
  name
  streamer {
    userId
    userTag
    ...ProfileImageProfile
  }
}
    ${ProfileImageProfileFragmentDoc}`;
export const VideoReportFragmentDoc = gql`
    fragment VideoReport on SupportReport {
  id
  createdAt
  description
  reason
  context {
    value {
      ... on SupportReportContextStream {
        startAt
      }
    }
  }
  user {
    userId
    userTag
    ...ProfileImageProfile
  }
}
    ${ProfileImageProfileFragmentDoc}`;
export const CancelDeletionMutationProfileFragmentDoc = gql`
    fragment CancelDeletionMutationProfile on ProfileProfile {
  account {
    flags
  }
}
    `;
export const DeleteUserDataContentProfileFragmentDoc = gql`
    fragment DeleteUserDataContentProfile on ProfileProfile {
  account {
    state
    flags
  }
}
    `;
export const DeleteUserProfileFragmentDoc = gql`
    fragment DeleteUserProfile on ProfileProfile {
  userId
  userTag
  ...DeleteUserDataContentProfile
}
    ${DeleteUserDataContentProfileFragmentDoc}`;
export const UserAccountStateFragmentDoc = gql`
    fragment UserAccountState on ProfileProfile {
  userId
  account {
    state
  }
}
    `;
export const EditUsernameModalProfileFragmentDoc = gql`
    fragment EditUsernameModalProfile on ProfileProfile {
  userId
  userTag
}
    `;
export const EditUsernameModalProfileUpdateFragmentDoc = gql`
    fragment EditUsernameModalProfileUpdate on ProfileProfile {
  userTag
}
    `;
export const UserStatsFragmentDoc = gql`
    fragment UserStats on PlayerStatsPlayerStats {
  matchesPlayed
  timePlayed
  cardsPlayed
  shufflesUsed
  cardsSucceeded
  dailyGoalCardsCompleted
  dailyGoalCardsSet
  cardBundlesPurchased
  adsWatched
  cardLevelUps
  currencySpending {
    softCurrency
    hardCurrency
    channelCurrency
  }
  boosterUsage {
    total
    doubt
    goodCall
    letsGo
    nextUp
    scavenge
    speedUp
  }
}
    `;
export const TermsAndAgreementsAuthAccountFragmentDoc = gql`
    fragment TermsAndAgreementsAuthAccount on AuthAccount {
  acceptedTerms {
    name
    revision
    signature
  }
  pendingAgreements {
    name
    revision
  }
  marketingConsent
}
    `;
export const UserChannelRolesFragmentDoc = gql`
    fragment UserChannelRoles on ChannelChannelRoles {
  roles
  channel {
    id
    name
  }
}
    `;
export const UserRoleUpdateProfileFragmentDoc = gql`
    fragment UserRoleUpdateProfile on ProfileProfile {
  userId
  account {
    roles
  }
}
    `;
export const UserRoleProfileFragmentDoc = gql`
    fragment UserRoleProfile on ProfileProfile {
  userId
  account {
    roles
  }
}
    `;
export const PlatformSuspensionAppealFormSuspensionFragmentDoc = gql`
    fragment PlatformSuspensionAppealFormSuspension on ModerationPlatformBan {
  banId
  appeal {
    appealText
    banId
  }
  description
  violation
}
    `;
export const PlatformSuspensionAppealFormProfileFragmentDoc = gql`
    fragment PlatformSuspensionAppealFormProfile on ProfileProfile {
  userId
  userTag
  account {
    createdAt
  }
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const UserWalletPaymentFragmentDoc = gql`
    fragment UserWalletPayment on PaymentPayment {
  id
  timestamp
  items {
    description
  }
  info {
    cardSummary
  }
  amount {
    currency
    value
  }
  tax {
    amount {
      currency
      value
    }
    rate
  }
}
    `;
export const UserWalletTransactionFragmentDoc = gql`
    fragment UserWalletTransaction on WalletTransaction {
  id
  createdAt
  operations {
    type
    currencyId
    currencyBalance
    currencyAmount
  }
  reason {
    reason {
      ... on ReasonReasonAdministrative {
        reason
      }
      ... on ReasonReasonStoreOrderPayment {
        sku
        orderId
        itemType
      }
      ... on ReasonReasonPurchaseWithInGameCurrency {
        sku
        orderId
        itemType
      }
      ... on ReasonReasonPurchaseWithPayment {
        sku
        orderId
        reference
        price {
          value
          currency
        }
      }
      ... on ReasonReasonProvision {
        seasonId
        rev
      }
    }
  }
}
    `;
export const InventoryItemToggleInventoryItemFragmentDoc = gql`
    fragment InventoryItemToggleInventoryItem on InventoryInventoryItem {
  itemId
  itemCount
}
    `;
export const EditedInventoryItemFragmentDoc = gql`
    fragment EditedInventoryItem on ItemItem {
  id
  name
  inventoryItem(user_id: $userId) {
    itemCount
  }
  details {
    ... on GameLogicCard {
      id
    }
    ... on GameLogicStreamerCard {
      id
    }
    ... on AvatarAnimation {
      id
    }
    ... on EmojiEmoji {
      id
    }
  }
}
    `;
export const InventoryItemToggleItemFragmentDoc = gql`
    fragment InventoryItemToggleItem on ItemItem {
  ...EditedInventoryItem
}
    ${EditedInventoryItemFragmentDoc}`;
export const InventoryCardsEditPopoverItemFragmentDoc = gql`
    fragment InventoryCardsEditPopoverItem on ItemItem {
  ...EditedInventoryItem
}
    ${EditedInventoryItemFragmentDoc}`;
export const InventoryCardsEditPopoverInventoryItemFragmentDoc = gql`
    fragment InventoryCardsEditPopoverInventoryItem on InventoryInventoryItem {
  itemId
  itemCount
}
    `;
export const ModerationChannelBanFragmentDoc = gql`
    fragment ModerationChannelBan on ChannelBannedUser {
  channel {
    id
    name
  }
  bannedAt
  violation
}
    `;
export const ModerationEventsProfileUsernameChangeFragmentDoc = gql`
    fragment ModerationEventsProfileUsernameChange on ProfileUsernameChange {
  oldUsername
  changedAt
  reason
  changer {
    userId
    ...UsernameTableCellProfile
  }
}
    ${UsernameTableCellProfileFragmentDoc}`;
export const SuspendedUserPlatformSuspensionFragmentDoc = gql`
    fragment SuspendedUserPlatformSuspension on ModerationPlatformBan {
  appeal {
    status
    banId
  }
  bannedAt
  banId
  userId
  description
  moderator {
    userId
    userTag
    ...ProfileImageProfile
  }
  violation
}
    ${ProfileImageProfileFragmentDoc}`;
export const PlatformSuspensionModerationModalProfileFragmentDoc = gql`
    fragment PlatformSuspensionModerationModalProfile on ProfileProfile {
  userId
  userTag
  account {
    createdAt
  }
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const ModeratorProfileFragmentDoc = gql`
    fragment ModeratorProfile on ProfileProfile {
  userId
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const SuspensionStatusPlatformSuspensionFragmentDoc = gql`
    fragment SuspensionStatusPlatformSuspension on ModerationPlatformBan {
  appeal {
    banId
    status
    reviewer {
      userId
      userTag
      ...ProfileImageProfile
    }
    closedAt
    reviewerComment
  }
  moderator {
    userId
    ...ModeratorProfile
  }
  bannedAt
  violation
  description
  expiresAt
}
    ${ProfileImageProfileFragmentDoc}
${ModeratorProfileFragmentDoc}`;
export const UsernameRejectionProfileFragmentDoc = gql`
    fragment UsernameRejectionProfile on ProfileProfile {
  userId
  userTag
  account {
    createdAt
  }
  usernameHistory(limit: 1) {
    newUsername
    oldUsername
    reason
  }
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const SearchBoxProfileLinkProfileFragmentDoc = gql`
    fragment SearchBoxProfileLinkProfile on ProfileProfile {
  userId
  userTag
  ...SearchMatchResultProfile
  ...ProfileImageProfile
}
    ${SearchMatchResultProfileFragmentDoc}
${ProfileImageProfileFragmentDoc}`;
export const SearchBoxProfileResultItemFragmentDoc = gql`
    fragment SearchBoxProfileResultItem on SearchResultItem {
  entity {
    ... on ProfileProfile {
      ...SearchBoxProfileLinkProfile
    }
  }
  matchedProperties
}
    ${SearchBoxProfileLinkProfileFragmentDoc}`;
export const SearchBoxChannelLinkChannelFragmentDoc = gql`
    fragment SearchBoxChannelLinkChannel on ChannelChannel {
  id
  name
  ...SearchMatchResultChannel
  ...ChannelLogoChannel
}
    ${SearchMatchResultChannelFragmentDoc}
${ChannelLogoChannelFragmentDoc}`;
export const SearchBoxChannelResultItemFragmentDoc = gql`
    fragment SearchBoxChannelResultItem on SearchResultItem {
  entity {
    ... on ChannelChannel {
      ...SearchBoxChannelLinkChannel
    }
  }
  matchedProperties
}
    ${SearchBoxChannelLinkChannelFragmentDoc}`;
export const ReasonDescriptionInputProfileFragmentDoc = gql`
    fragment ReasonDescriptionInputProfile on ProfileProfile {
  userTag
}
    `;
export const ReasonSelectProfileFragmentDoc = gql`
    fragment ReasonSelectProfile on ProfileProfile {
  ...ReasonDescriptionInputProfile
}
    ${ReasonDescriptionInputProfileFragmentDoc}`;
export const ReasonDescriptionInputChannelFragmentDoc = gql`
    fragment ReasonDescriptionInputChannel on ChannelChannel {
  name
}
    `;
export const ReasonSelectChannelFragmentDoc = gql`
    fragment ReasonSelectChannel on ChannelChannel {
  ...ReasonDescriptionInputChannel
}
    ${ReasonDescriptionInputChannelFragmentDoc}`;
export const ReportedChannelFragmentDoc = gql`
    fragment ReportedChannel on ChannelChannel {
  name
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const ReportedUserProfileFragmentDoc = gql`
    fragment ReportedUserProfile on ProfileProfile {
  userTag
  ...ProfileImageProfile
}
    ${ProfileImageProfileFragmentDoc}`;
export const SignupFlowChannelFragmentDoc = gql`
    fragment SignupFlowChannel on ChannelChannel {
  name
  liveStatus
  ...ChannelLogoChannel
}
    ${ChannelLogoChannelFragmentDoc}`;
export const ChannelBannerChannelFragmentDoc = gql`
    fragment ChannelBannerChannel on ChannelChannel {
  offlineBanner
}
    `;
export const ProfileImageShowOnlineStatusProfileFragmentDoc = gql`
    fragment ProfileImageShowOnlineStatusProfile on ProfileProfile {
  ...ProfileImageProfile
  onlineStatus
  settings {
    privacy {
      hideOnlineStatus
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;
export const LogoUpdateChannelChannelFragmentDoc = gql`
    fragment LogoUpdateChannelChannel on ChannelChannel {
  id
  logo
}
    `;
export const BannerUpdateChannelChannelFragmentDoc = gql`
    fragment BannerUpdateChannelChannel on ChannelChannel {
  id
  offlineBanner
}
    `;
export const AssetUploadEmojiEmojiFragmentDoc = gql`
    fragment AssetUploadEmojiEmoji on EmojiEmoji {
  image
}
    `;
export const WalletCurrencyFragmentDoc = gql`
    fragment WalletCurrency on WalletWalletCurrency {
  currencyId
  currencyAmount
}
    `;
export const ZendeskPrefillProfileFragmentDoc = gql`
    fragment ZendeskPrefillProfile on ProfileProfile {
  userId
  userTag
  account {
    email
  }
}
    `;
export const SubscriptionGetChannelEmojisChannelEmojiFragmentDoc = gql`
    fragment SubscriptionGetChannelEmojisChannelEmoji on EmojiEmoji {
  __typename
  id
  image
  name
}
    `;
export const SubscriptionGetChannelEmojisChannelFragmentDoc = gql`
    fragment SubscriptionGetChannelEmojisChannel on ChannelChannel {
  subscriptionConfig {
    channelId
    tiers {
      level
      entitlements {
        itemId
        item {
          id
          type
          children {
            id
            type
            details {
              ... on EmojiEmoji {
                ...SubscriptionGetChannelEmojisChannelEmoji
              }
            }
          }
        }
      }
    }
  }
}
    ${SubscriptionGetChannelEmojisChannelEmojiFragmentDoc}`;
export const ChannelSelectSearchDocument = gql`
    query ChannelSelectSearch($query: String) {
  search(query: $query, entityTypes: [ENTITY_TYPE_CHANNEL], cursor: {first: 5}) {
    resultItems {
      entityId
      ...ChannelSelectResultItem
    }
  }
}
    ${ChannelSelectResultItemFragmentDoc}`;

/**
 * __useChannelSelectSearchQuery__
 *
 * To run a query within a React component, call `useChannelSelectSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelSelectSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelSelectSearchQuery({
 *   variables: {
 *      query: // value for 'query'
 *   },
 * });
 */
export function useChannelSelectSearchQuery(baseOptions?: Apollo.QueryHookOptions<ChannelSelectSearchQuery, ChannelSelectSearchQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelSelectSearchQuery, ChannelSelectSearchQueryVariables>(ChannelSelectSearchDocument, options);
      }
export function useChannelSelectSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelSelectSearchQuery, ChannelSelectSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelSelectSearchQuery, ChannelSelectSearchQueryVariables>(ChannelSelectSearchDocument, options);
        }
export type ChannelSelectSearchQueryHookResult = ReturnType<typeof useChannelSelectSearchQuery>;
export type ChannelSelectSearchLazyQueryHookResult = ReturnType<typeof useChannelSelectSearchLazyQuery>;
export type ChannelSelectSearchQueryResult = Apollo.QueryResult<ChannelSelectSearchQuery, ChannelSelectSearchQueryVariables>;
export const UserPermissionsDocument = gql`
    query UserPermissions($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      uid
      roles
    }
  }
}
    `;

/**
 * __useUserPermissionsQuery__
 *
 * To run a query within a React component, call `useUserPermissionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserPermissionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserPermissionsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserPermissionsQuery(baseOptions: Apollo.QueryHookOptions<UserPermissionsQuery, UserPermissionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserPermissionsQuery, UserPermissionsQueryVariables>(UserPermissionsDocument, options);
      }
export function useUserPermissionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserPermissionsQuery, UserPermissionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserPermissionsQuery, UserPermissionsQueryVariables>(UserPermissionsDocument, options);
        }
export type UserPermissionsQueryHookResult = ReturnType<typeof useUserPermissionsQuery>;
export type UserPermissionsLazyQueryHookResult = ReturnType<typeof useUserPermissionsLazyQuery>;
export type UserPermissionsQueryResult = Apollo.QueryResult<UserPermissionsQuery, UserPermissionsQueryVariables>;
export const ProfileSelectSearchDocument = gql`
    query ProfileSelectSearch($query: String) {
  search(query: $query, entityTypes: [ENTITY_TYPE_USER], cursor: {first: 5}) {
    resultItems {
      entityId
      ...ProfileSelectResultItem
    }
  }
}
    ${ProfileSelectResultItemFragmentDoc}`;

/**
 * __useProfileSelectSearchQuery__
 *
 * To run a query within a React component, call `useProfileSelectSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileSelectSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileSelectSearchQuery({
 *   variables: {
 *      query: // value for 'query'
 *   },
 * });
 */
export function useProfileSelectSearchQuery(baseOptions?: Apollo.QueryHookOptions<ProfileSelectSearchQuery, ProfileSelectSearchQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileSelectSearchQuery, ProfileSelectSearchQueryVariables>(ProfileSelectSearchDocument, options);
      }
export function useProfileSelectSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileSelectSearchQuery, ProfileSelectSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileSelectSearchQuery, ProfileSelectSearchQueryVariables>(ProfileSelectSearchDocument, options);
        }
export type ProfileSelectSearchQueryHookResult = ReturnType<typeof useProfileSelectSearchQuery>;
export type ProfileSelectSearchLazyQueryHookResult = ReturnType<typeof useProfileSelectSearchLazyQuery>;
export type ProfileSelectSearchQueryResult = Apollo.QueryResult<ProfileSelectSearchQuery, ProfileSelectSearchQueryVariables>;
export const DefaultValueProfileSelectDocument = gql`
    query DefaultValueProfileSelect($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ProfileSelectProfile
  }
}
    ${ProfileSelectProfileFragmentDoc}`;

/**
 * __useDefaultValueProfileSelectQuery__
 *
 * To run a query within a React component, call `useDefaultValueProfileSelectQuery` and pass it any options that fit your needs.
 * When your component renders, `useDefaultValueProfileSelectQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDefaultValueProfileSelectQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useDefaultValueProfileSelectQuery(baseOptions: Apollo.QueryHookOptions<DefaultValueProfileSelectQuery, DefaultValueProfileSelectQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DefaultValueProfileSelectQuery, DefaultValueProfileSelectQueryVariables>(DefaultValueProfileSelectDocument, options);
      }
export function useDefaultValueProfileSelectLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DefaultValueProfileSelectQuery, DefaultValueProfileSelectQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DefaultValueProfileSelectQuery, DefaultValueProfileSelectQueryVariables>(DefaultValueProfileSelectDocument, options);
        }
export type DefaultValueProfileSelectQueryHookResult = ReturnType<typeof useDefaultValueProfileSelectQuery>;
export type DefaultValueProfileSelectLazyQueryHookResult = ReturnType<typeof useDefaultValueProfileSelectLazyQuery>;
export type DefaultValueProfileSelectQueryResult = Apollo.QueryResult<DefaultValueProfileSelectQuery, DefaultValueProfileSelectQueryVariables>;
export const ProtectedRoutePermissionDocument = gql`
    query ProtectedRoutePermission($userId: ID!) {
  profile(userId: $userId) {
    userId
    account {
      uid
      roles
    }
  }
}
    `;

/**
 * __useProtectedRoutePermissionQuery__
 *
 * To run a query within a React component, call `useProtectedRoutePermissionQuery` and pass it any options that fit your needs.
 * When your component renders, `useProtectedRoutePermissionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProtectedRoutePermissionQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useProtectedRoutePermissionQuery(baseOptions: Apollo.QueryHookOptions<ProtectedRoutePermissionQuery, ProtectedRoutePermissionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProtectedRoutePermissionQuery, ProtectedRoutePermissionQueryVariables>(ProtectedRoutePermissionDocument, options);
      }
export function useProtectedRoutePermissionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProtectedRoutePermissionQuery, ProtectedRoutePermissionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProtectedRoutePermissionQuery, ProtectedRoutePermissionQueryVariables>(ProtectedRoutePermissionDocument, options);
        }
export type ProtectedRoutePermissionQueryHookResult = ReturnType<typeof useProtectedRoutePermissionQuery>;
export type ProtectedRoutePermissionLazyQueryHookResult = ReturnType<typeof useProtectedRoutePermissionLazyQuery>;
export type ProtectedRoutePermissionQueryResult = Apollo.QueryResult<ProtectedRoutePermissionQuery, ProtectedRoutePermissionQueryVariables>;
export const MonetizationCalloutDataDocument = gql`
    query MonetizationCalloutData($channelId: ID!) {
  channel(id: $channelId) {
    id
    monetizationSettings {
      channelId
      enabled
    }
  }
}
    `;

/**
 * __useMonetizationCalloutDataQuery__
 *
 * To run a query within a React component, call `useMonetizationCalloutDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useMonetizationCalloutDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMonetizationCalloutDataQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useMonetizationCalloutDataQuery(baseOptions: Apollo.QueryHookOptions<MonetizationCalloutDataQuery, MonetizationCalloutDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MonetizationCalloutDataQuery, MonetizationCalloutDataQueryVariables>(MonetizationCalloutDataDocument, options);
      }
export function useMonetizationCalloutDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MonetizationCalloutDataQuery, MonetizationCalloutDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MonetizationCalloutDataQuery, MonetizationCalloutDataQueryVariables>(MonetizationCalloutDataDocument, options);
        }
export type MonetizationCalloutDataQueryHookResult = ReturnType<typeof useMonetizationCalloutDataQuery>;
export type MonetizationCalloutDataLazyQueryHookResult = ReturnType<typeof useMonetizationCalloutDataLazyQuery>;
export type MonetizationCalloutDataQueryResult = Apollo.QueryResult<MonetizationCalloutDataQuery, MonetizationCalloutDataQueryVariables>;
export const SidebarChannelDocument = gql`
    query SidebarChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    ...SidebarChannel
  }
}
    ${SidebarChannelFragmentDoc}`;

/**
 * __useSidebarChannelQuery__
 *
 * To run a query within a React component, call `useSidebarChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useSidebarChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSidebarChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useSidebarChannelQuery(baseOptions: Apollo.QueryHookOptions<SidebarChannelQuery, SidebarChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SidebarChannelQuery, SidebarChannelQueryVariables>(SidebarChannelDocument, options);
      }
export function useSidebarChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SidebarChannelQuery, SidebarChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SidebarChannelQuery, SidebarChannelQueryVariables>(SidebarChannelDocument, options);
        }
export type SidebarChannelQueryHookResult = ReturnType<typeof useSidebarChannelQuery>;
export type SidebarChannelLazyQueryHookResult = ReturnType<typeof useSidebarChannelLazyQuery>;
export type SidebarChannelQueryResult = Apollo.QueryResult<SidebarChannelQuery, SidebarChannelQueryVariables>;
export const ChannelDocument = gql`
    query Channel($channelId: ID!, $skipConfigs: Boolean = false) {
  channel(id: $channelId) {
    id
    name
    description
    followerCount
    subscriberCount
    title
    links {
      url
      name
      type
    }
    isPublic
    streamerId
    currentStreamId
    ...DeleteChannelChannel
    priority
  }
  streamBackendConfigs(channelId: $channelId) @skip(if: $skipConfigs) {
    configs {
      gameId
      id
    }
  }
  selectedStreamBackendConfig(channelId: $channelId) @skip(if: $skipConfigs) {
    gameId
  }
  ingestConfigs(channelId: $channelId) @skip(if: $skipConfigs) {
    channelId
    configs {
      ingest {
        ... on StreamIngestConfigIngestConfigFTLConfig {
          streamKey
        }
      }
    }
  }
}
    ${DeleteChannelChannelFragmentDoc}`;

/**
 * __useChannelQuery__
 *
 * To run a query within a React component, call `useChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      skipConfigs: // value for 'skipConfigs'
 *   },
 * });
 */
export function useChannelQuery(baseOptions: Apollo.QueryHookOptions<ChannelQuery, ChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelQuery, ChannelQueryVariables>(ChannelDocument, options);
      }
export function useChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelQuery, ChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelQuery, ChannelQueryVariables>(ChannelDocument, options);
        }
export type ChannelQueryHookResult = ReturnType<typeof useChannelQuery>;
export type ChannelLazyQueryHookResult = ReturnType<typeof useChannelLazyQuery>;
export type ChannelQueryResult = Apollo.QueryResult<ChannelQuery, ChannelQueryVariables>;
export const ChannelUserProfileDocument = gql`
    query ChannelUserProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    ...ProfileImageProfile
    ...ChannelOwnerAgreements
  }
}
    ${ProfileImageProfileFragmentDoc}
${ChannelOwnerAgreementsFragmentDoc}`;

/**
 * __useChannelUserProfileQuery__
 *
 * To run a query within a React component, call `useChannelUserProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelUserProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelUserProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChannelUserProfileQuery(baseOptions: Apollo.QueryHookOptions<ChannelUserProfileQuery, ChannelUserProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelUserProfileQuery, ChannelUserProfileQueryVariables>(ChannelUserProfileDocument, options);
      }
export function useChannelUserProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelUserProfileQuery, ChannelUserProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelUserProfileQuery, ChannelUserProfileQueryVariables>(ChannelUserProfileDocument, options);
        }
export type ChannelUserProfileQueryHookResult = ReturnType<typeof useChannelUserProfileQuery>;
export type ChannelUserProfileLazyQueryHookResult = ReturnType<typeof useChannelUserProfileLazyQuery>;
export type ChannelUserProfileQueryResult = Apollo.QueryResult<ChannelUserProfileQuery, ChannelUserProfileQueryVariables>;
export const DeleteChannelDocument = gql`
    mutation DeleteChannel($id: ID!) {
  deleteChannel(id: $id) {
    emptyTypeWorkaround
  }
}
    `;
export type DeleteChannelMutationFn = Apollo.MutationFunction<DeleteChannelMutation, DeleteChannelMutationVariables>;

/**
 * __useDeleteChannelMutation__
 *
 * To run a mutation, you first call `useDeleteChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteChannelMutation, { data, loading, error }] = useDeleteChannelMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteChannelMutation(baseOptions?: Apollo.MutationHookOptions<DeleteChannelMutation, DeleteChannelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteChannelMutation, DeleteChannelMutationVariables>(DeleteChannelDocument, options);
      }
export type DeleteChannelMutationHookResult = ReturnType<typeof useDeleteChannelMutation>;
export type DeleteChannelMutationResult = Apollo.MutationResult<DeleteChannelMutation>;
export type DeleteChannelMutationOptions = Apollo.BaseMutationOptions<DeleteChannelMutation, DeleteChannelMutationVariables>;
export const ChannelBannedUsersDocument = gql`
    query ChannelBannedUsers($channelId: ID!) {
  channelBannedUsers(channelId: $channelId) {
    users {
      userId
      channelId
      bannedAt
      violation
      description
      user {
        userId
        userTag
      }
      moderator {
        userId
        userTag
      }
    }
  }
  channel(id: $channelId) {
    id
    name
  }
}
    `;

/**
 * __useChannelBannedUsersQuery__
 *
 * To run a query within a React component, call `useChannelBannedUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelBannedUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelBannedUsersQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelBannedUsersQuery(baseOptions: Apollo.QueryHookOptions<ChannelBannedUsersQuery, ChannelBannedUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelBannedUsersQuery, ChannelBannedUsersQueryVariables>(ChannelBannedUsersDocument, options);
      }
export function useChannelBannedUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelBannedUsersQuery, ChannelBannedUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelBannedUsersQuery, ChannelBannedUsersQueryVariables>(ChannelBannedUsersDocument, options);
        }
export type ChannelBannedUsersQueryHookResult = ReturnType<typeof useChannelBannedUsersQuery>;
export type ChannelBannedUsersLazyQueryHookResult = ReturnType<typeof useChannelBannedUsersLazyQuery>;
export type ChannelBannedUsersQueryResult = Apollo.QueryResult<ChannelBannedUsersQuery, ChannelBannedUsersQueryVariables>;
export const ChannelBanDrawerUserDocument = gql`
    query ChannelBanDrawerUser($channelId: ID!, $userId: ID!) {
  channelBanUserStatus(channelId: $channelId, userId: $userId) {
    bannedAt
    violation
    description
  }
  profile(userId: $userId) {
    userId
    userTag
  }
}
    `;

/**
 * __useChannelBanDrawerUserQuery__
 *
 * To run a query within a React component, call `useChannelBanDrawerUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelBanDrawerUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelBanDrawerUserQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useChannelBanDrawerUserQuery(baseOptions: Apollo.QueryHookOptions<ChannelBanDrawerUserQuery, ChannelBanDrawerUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelBanDrawerUserQuery, ChannelBanDrawerUserQueryVariables>(ChannelBanDrawerUserDocument, options);
      }
export function useChannelBanDrawerUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelBanDrawerUserQuery, ChannelBanDrawerUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelBanDrawerUserQuery, ChannelBanDrawerUserQueryVariables>(ChannelBanDrawerUserDocument, options);
        }
export type ChannelBanDrawerUserQueryHookResult = ReturnType<typeof useChannelBanDrawerUserQuery>;
export type ChannelBanDrawerUserLazyQueryHookResult = ReturnType<typeof useChannelBanDrawerUserLazyQuery>;
export type ChannelBanDrawerUserQueryResult = Apollo.QueryResult<ChannelBanDrawerUserQuery, ChannelBanDrawerUserQueryVariables>;
export const ChannelBanDrawerUserUnBanDocument = gql`
    mutation ChannelBanDrawerUserUnBan($userId: ID!, $channelId: ID!) {
  unbanChannelUser(userId: $userId, channelId: $channelId) {
    emptyTypeWorkaround
  }
}
    `;
export type ChannelBanDrawerUserUnBanMutationFn = Apollo.MutationFunction<ChannelBanDrawerUserUnBanMutation, ChannelBanDrawerUserUnBanMutationVariables>;

/**
 * __useChannelBanDrawerUserUnBanMutation__
 *
 * To run a mutation, you first call `useChannelBanDrawerUserUnBanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelBanDrawerUserUnBanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelBanDrawerUserUnBanMutation, { data, loading, error }] = useChannelBanDrawerUserUnBanMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelBanDrawerUserUnBanMutation(baseOptions?: Apollo.MutationHookOptions<ChannelBanDrawerUserUnBanMutation, ChannelBanDrawerUserUnBanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelBanDrawerUserUnBanMutation, ChannelBanDrawerUserUnBanMutationVariables>(ChannelBanDrawerUserUnBanDocument, options);
      }
export type ChannelBanDrawerUserUnBanMutationHookResult = ReturnType<typeof useChannelBanDrawerUserUnBanMutation>;
export type ChannelBanDrawerUserUnBanMutationResult = Apollo.MutationResult<ChannelBanDrawerUserUnBanMutation>;
export type ChannelBanDrawerUserUnBanMutationOptions = Apollo.BaseMutationOptions<ChannelBanDrawerUserUnBanMutation, ChannelBanDrawerUserUnBanMutationVariables>;
export const AddChannelEmojiDocument = gql`
    mutation AddChannelEmoji($channelId: ID!, $label: String!) {
  createChannelEmoji(channelId: $channelId, label: $label) {
    id
    label
    channelId
    disabled
  }
}
    `;
export type AddChannelEmojiMutationFn = Apollo.MutationFunction<AddChannelEmojiMutation, AddChannelEmojiMutationVariables>;

/**
 * __useAddChannelEmojiMutation__
 *
 * To run a mutation, you first call `useAddChannelEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddChannelEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addChannelEmojiMutation, { data, loading, error }] = useAddChannelEmojiMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      label: // value for 'label'
 *   },
 * });
 */
export function useAddChannelEmojiMutation(baseOptions?: Apollo.MutationHookOptions<AddChannelEmojiMutation, AddChannelEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddChannelEmojiMutation, AddChannelEmojiMutationVariables>(AddChannelEmojiDocument, options);
      }
export type AddChannelEmojiMutationHookResult = ReturnType<typeof useAddChannelEmojiMutation>;
export type AddChannelEmojiMutationResult = Apollo.MutationResult<AddChannelEmojiMutation>;
export type AddChannelEmojiMutationOptions = Apollo.BaseMutationOptions<AddChannelEmojiMutation, AddChannelEmojiMutationVariables>;
export const EnableCreatedChannelEmojiDocument = gql`
    mutation EnableCreatedChannelEmoji($id: ID!, $channelId: ID!) {
  updateChannelEmoji(body: {id: $id, channelId: $channelId, disabled: false}) {
    id
    disabled
  }
}
    `;
export type EnableCreatedChannelEmojiMutationFn = Apollo.MutationFunction<EnableCreatedChannelEmojiMutation, EnableCreatedChannelEmojiMutationVariables>;

/**
 * __useEnableCreatedChannelEmojiMutation__
 *
 * To run a mutation, you first call `useEnableCreatedChannelEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEnableCreatedChannelEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [enableCreatedChannelEmojiMutation, { data, loading, error }] = useEnableCreatedChannelEmojiMutation({
 *   variables: {
 *      id: // value for 'id'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useEnableCreatedChannelEmojiMutation(baseOptions?: Apollo.MutationHookOptions<EnableCreatedChannelEmojiMutation, EnableCreatedChannelEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EnableCreatedChannelEmojiMutation, EnableCreatedChannelEmojiMutationVariables>(EnableCreatedChannelEmojiDocument, options);
      }
export type EnableCreatedChannelEmojiMutationHookResult = ReturnType<typeof useEnableCreatedChannelEmojiMutation>;
export type EnableCreatedChannelEmojiMutationResult = Apollo.MutationResult<EnableCreatedChannelEmojiMutation>;
export type EnableCreatedChannelEmojiMutationOptions = Apollo.BaseMutationOptions<EnableCreatedChannelEmojiMutation, EnableCreatedChannelEmojiMutationVariables>;
export const ChannelEmojiDrawerEmojiDocument = gql`
    query ChannelEmojiDrawerEmoji($emojiId: ID!) {
  emoji(id: $emojiId) {
    id
    ...ChannelEmojiEditDrawerEmoji
  }
}
    ${ChannelEmojiEditDrawerEmojiFragmentDoc}`;

/**
 * __useChannelEmojiDrawerEmojiQuery__
 *
 * To run a query within a React component, call `useChannelEmojiDrawerEmojiQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelEmojiDrawerEmojiQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelEmojiDrawerEmojiQuery({
 *   variables: {
 *      emojiId: // value for 'emojiId'
 *   },
 * });
 */
export function useChannelEmojiDrawerEmojiQuery(baseOptions: Apollo.QueryHookOptions<ChannelEmojiDrawerEmojiQuery, ChannelEmojiDrawerEmojiQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelEmojiDrawerEmojiQuery, ChannelEmojiDrawerEmojiQueryVariables>(ChannelEmojiDrawerEmojiDocument, options);
      }
export function useChannelEmojiDrawerEmojiLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelEmojiDrawerEmojiQuery, ChannelEmojiDrawerEmojiQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelEmojiDrawerEmojiQuery, ChannelEmojiDrawerEmojiQueryVariables>(ChannelEmojiDrawerEmojiDocument, options);
        }
export type ChannelEmojiDrawerEmojiQueryHookResult = ReturnType<typeof useChannelEmojiDrawerEmojiQuery>;
export type ChannelEmojiDrawerEmojiLazyQueryHookResult = ReturnType<typeof useChannelEmojiDrawerEmojiLazyQuery>;
export type ChannelEmojiDrawerEmojiQueryResult = Apollo.QueryResult<ChannelEmojiDrawerEmojiQuery, ChannelEmojiDrawerEmojiQueryVariables>;
export const EditChannelEmojiDocument = gql`
    mutation EditChannelEmoji($id: ID!, $channelId: ID!, $label: String!, $disabled: Boolean) {
  updateChannelEmoji(
    body: {id: $id, channelId: $channelId, label: $label, disabled: $disabled}
  ) {
    id
    disabled
    label
  }
}
    `;
export type EditChannelEmojiMutationFn = Apollo.MutationFunction<EditChannelEmojiMutation, EditChannelEmojiMutationVariables>;

/**
 * __useEditChannelEmojiMutation__
 *
 * To run a mutation, you first call `useEditChannelEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditChannelEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editChannelEmojiMutation, { data, loading, error }] = useEditChannelEmojiMutation({
 *   variables: {
 *      id: // value for 'id'
 *      channelId: // value for 'channelId'
 *      label: // value for 'label'
 *      disabled: // value for 'disabled'
 *   },
 * });
 */
export function useEditChannelEmojiMutation(baseOptions?: Apollo.MutationHookOptions<EditChannelEmojiMutation, EditChannelEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditChannelEmojiMutation, EditChannelEmojiMutationVariables>(EditChannelEmojiDocument, options);
      }
export type EditChannelEmojiMutationHookResult = ReturnType<typeof useEditChannelEmojiMutation>;
export type EditChannelEmojiMutationResult = Apollo.MutationResult<EditChannelEmojiMutation>;
export type EditChannelEmojiMutationOptions = Apollo.BaseMutationOptions<EditChannelEmojiMutation, EditChannelEmojiMutationVariables>;
export const DeleteChannelEmojiDocument = gql`
    mutation DeleteChannelEmoji($id: ID!, $channelId: ID!) {
  deleteChannelEmoji(id: $id, channelId: $channelId) {
    emptyTypeWorkaround
  }
}
    `;
export type DeleteChannelEmojiMutationFn = Apollo.MutationFunction<DeleteChannelEmojiMutation, DeleteChannelEmojiMutationVariables>;

/**
 * __useDeleteChannelEmojiMutation__
 *
 * To run a mutation, you first call `useDeleteChannelEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteChannelEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteChannelEmojiMutation, { data, loading, error }] = useDeleteChannelEmojiMutation({
 *   variables: {
 *      id: // value for 'id'
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useDeleteChannelEmojiMutation(baseOptions?: Apollo.MutationHookOptions<DeleteChannelEmojiMutation, DeleteChannelEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteChannelEmojiMutation, DeleteChannelEmojiMutationVariables>(DeleteChannelEmojiDocument, options);
      }
export type DeleteChannelEmojiMutationHookResult = ReturnType<typeof useDeleteChannelEmojiMutation>;
export type DeleteChannelEmojiMutationResult = Apollo.MutationResult<DeleteChannelEmojiMutation>;
export type DeleteChannelEmojiMutationOptions = Apollo.BaseMutationOptions<DeleteChannelEmojiMutation, DeleteChannelEmojiMutationVariables>;
export const ChannelEmojisDocument = gql`
    query ChannelEmojis($channelId: ID!, $cursor: APICursorInput, $includeDisabled: Boolean) {
  channelEmojis(
    channelId: $channelId
    cursor: $cursor
    includeCount: true
    includeDisabled: $includeDisabled
  ) {
    pageInfo {
      endCursor
      hasNextPage
      hasPreviousPage
      startCursor
    }
    emojis {
      id
      ...EmojiTableEmoji
    }
    count {
      disabled
      total
    }
  }
}
    ${EmojiTableEmojiFragmentDoc}`;

/**
 * __useChannelEmojisQuery__
 *
 * To run a query within a React component, call `useChannelEmojisQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelEmojisQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelEmojisQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      cursor: // value for 'cursor'
 *      includeDisabled: // value for 'includeDisabled'
 *   },
 * });
 */
export function useChannelEmojisQuery(baseOptions: Apollo.QueryHookOptions<ChannelEmojisQuery, ChannelEmojisQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelEmojisQuery, ChannelEmojisQueryVariables>(ChannelEmojisDocument, options);
      }
export function useChannelEmojisLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelEmojisQuery, ChannelEmojisQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelEmojisQuery, ChannelEmojisQueryVariables>(ChannelEmojisDocument, options);
        }
export type ChannelEmojisQueryHookResult = ReturnType<typeof useChannelEmojisQuery>;
export type ChannelEmojisLazyQueryHookResult = ReturnType<typeof useChannelEmojisLazyQuery>;
export type ChannelEmojisQueryResult = Apollo.QueryResult<ChannelEmojisQuery, ChannelEmojisQueryVariables>;
export const ChannelEmojisChannelDocument = gql`
    query ChannelEmojisChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    ...ChannelEmojiDrawerChannel
  }
}
    ${ChannelEmojiDrawerChannelFragmentDoc}`;

/**
 * __useChannelEmojisChannelQuery__
 *
 * To run a query within a React component, call `useChannelEmojisChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelEmojisChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelEmojisChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelEmojisChannelQuery(baseOptions: Apollo.QueryHookOptions<ChannelEmojisChannelQuery, ChannelEmojisChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelEmojisChannelQuery, ChannelEmojisChannelQueryVariables>(ChannelEmojisChannelDocument, options);
      }
export function useChannelEmojisChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelEmojisChannelQuery, ChannelEmojisChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelEmojisChannelQuery, ChannelEmojisChannelQueryVariables>(ChannelEmojisChannelDocument, options);
        }
export type ChannelEmojisChannelQueryHookResult = ReturnType<typeof useChannelEmojisChannelQuery>;
export type ChannelEmojisChannelLazyQueryHookResult = ReturnType<typeof useChannelEmojisChannelLazyQuery>;
export type ChannelEmojisChannelQueryResult = Apollo.QueryResult<ChannelEmojisChannelQuery, ChannelEmojisChannelQueryVariables>;
export const ChannelFeatureFlagsDocument = gql`
    query ChannelFeatureFlags($channelId: ID!) {
  channelFeatureFlags(channelId: $channelId) {
    flags {
      name
      value
    }
  }
}
    `;

/**
 * __useChannelFeatureFlagsQuery__
 *
 * To run a query within a React component, call `useChannelFeatureFlagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelFeatureFlagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelFeatureFlagsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelFeatureFlagsQuery(baseOptions: Apollo.QueryHookOptions<ChannelFeatureFlagsQuery, ChannelFeatureFlagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelFeatureFlagsQuery, ChannelFeatureFlagsQueryVariables>(ChannelFeatureFlagsDocument, options);
      }
export function useChannelFeatureFlagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelFeatureFlagsQuery, ChannelFeatureFlagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelFeatureFlagsQuery, ChannelFeatureFlagsQueryVariables>(ChannelFeatureFlagsDocument, options);
        }
export type ChannelFeatureFlagsQueryHookResult = ReturnType<typeof useChannelFeatureFlagsQuery>;
export type ChannelFeatureFlagsLazyQueryHookResult = ReturnType<typeof useChannelFeatureFlagsLazyQuery>;
export type ChannelFeatureFlagsQueryResult = Apollo.QueryResult<ChannelFeatureFlagsQuery, ChannelFeatureFlagsQueryVariables>;
export const ChannelModerationDocument = gql`
    query ChannelModeration($channelId: ID!) {
  channel(id: $channelId) {
    features {
      streaming {
        enabled
        suspension {
          until
          moderator {
            ...ModeratorProfile
          }
          suspendedAt
          description
        }
      }
    }
    ...ForceChannelOfflineModalChannel
  }
}
    ${ModeratorProfileFragmentDoc}
${ForceChannelOfflineModalChannelFragmentDoc}`;

/**
 * __useChannelModerationQuery__
 *
 * To run a query within a React component, call `useChannelModerationQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelModerationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelModerationQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useChannelModerationQuery(baseOptions: Apollo.QueryHookOptions<ChannelModerationQuery, ChannelModerationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelModerationQuery, ChannelModerationQueryVariables>(ChannelModerationDocument, options);
      }
export function useChannelModerationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelModerationQuery, ChannelModerationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelModerationQuery, ChannelModerationQueryVariables>(ChannelModerationDocument, options);
        }
export type ChannelModerationQueryHookResult = ReturnType<typeof useChannelModerationQuery>;
export type ChannelModerationLazyQueryHookResult = ReturnType<typeof useChannelModerationLazyQuery>;
export type ChannelModerationQueryResult = Apollo.QueryResult<ChannelModerationQuery, ChannelModerationQueryVariables>;
export const LiftForceChannelOfflineDocument = gql`
    mutation LiftForceChannelOffline($channelId: ID!) {
  unsuspendChannelFeature(
    feature: CHANNEL_FEATURE_STREAMING
    channelId: $channelId
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type LiftForceChannelOfflineMutationFn = Apollo.MutationFunction<LiftForceChannelOfflineMutation, LiftForceChannelOfflineMutationVariables>;

/**
 * __useLiftForceChannelOfflineMutation__
 *
 * To run a mutation, you first call `useLiftForceChannelOfflineMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLiftForceChannelOfflineMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [liftForceChannelOfflineMutation, { data, loading, error }] = useLiftForceChannelOfflineMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useLiftForceChannelOfflineMutation(baseOptions?: Apollo.MutationHookOptions<LiftForceChannelOfflineMutation, LiftForceChannelOfflineMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LiftForceChannelOfflineMutation, LiftForceChannelOfflineMutationVariables>(LiftForceChannelOfflineDocument, options);
      }
export type LiftForceChannelOfflineMutationHookResult = ReturnType<typeof useLiftForceChannelOfflineMutation>;
export type LiftForceChannelOfflineMutationResult = Apollo.MutationResult<LiftForceChannelOfflineMutation>;
export type LiftForceChannelOfflineMutationOptions = Apollo.BaseMutationOptions<LiftForceChannelOfflineMutation, LiftForceChannelOfflineMutationVariables>;
export const ForceChannelOfflineDocument = gql`
    mutation ForceChannelOffline($channelId: ID!, $description: String) {
  suspendChannelFeature(
    channelId: $channelId
    description: $description
    feature: CHANNEL_FEATURE_STREAMING
    duration: "86400s"
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type ForceChannelOfflineMutationFn = Apollo.MutationFunction<ForceChannelOfflineMutation, ForceChannelOfflineMutationVariables>;

/**
 * __useForceChannelOfflineMutation__
 *
 * To run a mutation, you first call `useForceChannelOfflineMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useForceChannelOfflineMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [forceChannelOfflineMutation, { data, loading, error }] = useForceChannelOfflineMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      description: // value for 'description'
 *   },
 * });
 */
export function useForceChannelOfflineMutation(baseOptions?: Apollo.MutationHookOptions<ForceChannelOfflineMutation, ForceChannelOfflineMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ForceChannelOfflineMutation, ForceChannelOfflineMutationVariables>(ForceChannelOfflineDocument, options);
      }
export type ForceChannelOfflineMutationHookResult = ReturnType<typeof useForceChannelOfflineMutation>;
export type ForceChannelOfflineMutationResult = Apollo.MutationResult<ForceChannelOfflineMutation>;
export type ForceChannelOfflineMutationOptions = Apollo.BaseMutationOptions<ForceChannelOfflineMutation, ForceChannelOfflineMutationVariables>;
export const ChannelUserRolesDocument = gql`
    query ChannelUserRoles($channelId: ID!, $cursor: APICursorInput) {
  channelPrivilegedUsers(channelId: $channelId, cursor: $cursor) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    users {
      roles
      userId
      user {
        account {
          email
        }
        userId
        userTag
        ...ProfileImageProfile
      }
    }
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useChannelUserRolesQuery__
 *
 * To run a query within a React component, call `useChannelUserRolesQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelUserRolesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelUserRolesQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useChannelUserRolesQuery(baseOptions: Apollo.QueryHookOptions<ChannelUserRolesQuery, ChannelUserRolesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelUserRolesQuery, ChannelUserRolesQueryVariables>(ChannelUserRolesDocument, options);
      }
export function useChannelUserRolesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelUserRolesQuery, ChannelUserRolesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelUserRolesQuery, ChannelUserRolesQueryVariables>(ChannelUserRolesDocument, options);
        }
export type ChannelUserRolesQueryHookResult = ReturnType<typeof useChannelUserRolesQuery>;
export type ChannelUserRolesLazyQueryHookResult = ReturnType<typeof useChannelUserRolesLazyQuery>;
export type ChannelUserRolesQueryResult = Apollo.QueryResult<ChannelUserRolesQuery, ChannelUserRolesQueryVariables>;
export const ChannelSettingsUpdateCrConfigDocument = gql`
    mutation ChannelSettingsUpdateCrConfig($id: ID!, $channelId: ID!, $containerImage: String, $controllerContainerImage: String, $arenaId: ID) {
  updateStreamBackendConfig(
    body: {id: $id, channelId: $channelId, crConfig: {containerImage: $containerImage, controllerContainerImage: $controllerContainerImage, arenaId: $arenaId}}
  ) {
    ...ArenaCrowdChannelStreamBackendConfig
  }
}
    ${ArenaCrowdChannelStreamBackendConfigFragmentDoc}`;
export type ChannelSettingsUpdateCrConfigMutationFn = Apollo.MutationFunction<ChannelSettingsUpdateCrConfigMutation, ChannelSettingsUpdateCrConfigMutationVariables>;

/**
 * __useChannelSettingsUpdateCrConfigMutation__
 *
 * To run a mutation, you first call `useChannelSettingsUpdateCrConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelSettingsUpdateCrConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelSettingsUpdateCrConfigMutation, { data, loading, error }] = useChannelSettingsUpdateCrConfigMutation({
 *   variables: {
 *      id: // value for 'id'
 *      channelId: // value for 'channelId'
 *      containerImage: // value for 'containerImage'
 *      controllerContainerImage: // value for 'controllerContainerImage'
 *      arenaId: // value for 'arenaId'
 *   },
 * });
 */
export function useChannelSettingsUpdateCrConfigMutation(baseOptions?: Apollo.MutationHookOptions<ChannelSettingsUpdateCrConfigMutation, ChannelSettingsUpdateCrConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelSettingsUpdateCrConfigMutation, ChannelSettingsUpdateCrConfigMutationVariables>(ChannelSettingsUpdateCrConfigDocument, options);
      }
export type ChannelSettingsUpdateCrConfigMutationHookResult = ReturnType<typeof useChannelSettingsUpdateCrConfigMutation>;
export type ChannelSettingsUpdateCrConfigMutationResult = Apollo.MutationResult<ChannelSettingsUpdateCrConfigMutation>;
export type ChannelSettingsUpdateCrConfigMutationOptions = Apollo.BaseMutationOptions<ChannelSettingsUpdateCrConfigMutation, ChannelSettingsUpdateCrConfigMutationVariables>;
export const ChannelUpdateMonetizationSettingsDocument = gql`
    mutation ChannelUpdateMonetizationSettings($body: ChannelMonetizationSettingsInput!) {
  updateChannelMonetizationSettings(body: $body) {
    channelId
    enabled
    eligible
  }
}
    `;
export type ChannelUpdateMonetizationSettingsMutationFn = Apollo.MutationFunction<ChannelUpdateMonetizationSettingsMutation, ChannelUpdateMonetizationSettingsMutationVariables>;

/**
 * __useChannelUpdateMonetizationSettingsMutation__
 *
 * To run a mutation, you first call `useChannelUpdateMonetizationSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelUpdateMonetizationSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelUpdateMonetizationSettingsMutation, { data, loading, error }] = useChannelUpdateMonetizationSettingsMutation({
 *   variables: {
 *      body: // value for 'body'
 *   },
 * });
 */
export function useChannelUpdateMonetizationSettingsMutation(baseOptions?: Apollo.MutationHookOptions<ChannelUpdateMonetizationSettingsMutation, ChannelUpdateMonetizationSettingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelUpdateMonetizationSettingsMutation, ChannelUpdateMonetizationSettingsMutationVariables>(ChannelUpdateMonetizationSettingsDocument, options);
      }
export type ChannelUpdateMonetizationSettingsMutationHookResult = ReturnType<typeof useChannelUpdateMonetizationSettingsMutation>;
export type ChannelUpdateMonetizationSettingsMutationResult = Apollo.MutationResult<ChannelUpdateMonetizationSettingsMutation>;
export type ChannelUpdateMonetizationSettingsMutationOptions = Apollo.BaseMutationOptions<ChannelUpdateMonetizationSettingsMutation, ChannelUpdateMonetizationSettingsMutationVariables>;
export const ChannelSettingsDocument = gql`
    query ChannelSettings($channelId: ID!, $skipConfigs: Boolean = false) {
  channel(id: $channelId) {
    id
    liveStatus
    ...ChannelVisibilityChannel
    ...ChannelMonetizationChannel
    priority
    riskTier
  }
  selectedStreamBackendConfig(channelId: $channelId) @skip(if: $skipConfigs) {
    ...PredictionGameChannelStreamBackendConfig
    ...ArenaCrowdChannelStreamBackendConfig
    ...RecordingChannelStreamBackendConfig
  }
  arenas(channelId: $channelId) {
    arenas {
      ...ArenaCrowdArena
    }
  }
}
    ${ChannelVisibilityChannelFragmentDoc}
${ChannelMonetizationChannelFragmentDoc}
${PredictionGameChannelStreamBackendConfigFragmentDoc}
${ArenaCrowdChannelStreamBackendConfigFragmentDoc}
${RecordingChannelStreamBackendConfigFragmentDoc}
${ArenaCrowdArenaFragmentDoc}`;

/**
 * __useChannelSettingsQuery__
 *
 * To run a query within a React component, call `useChannelSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelSettingsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      skipConfigs: // value for 'skipConfigs'
 *   },
 * });
 */
export function useChannelSettingsQuery(baseOptions: Apollo.QueryHookOptions<ChannelSettingsQuery, ChannelSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelSettingsQuery, ChannelSettingsQueryVariables>(ChannelSettingsDocument, options);
      }
export function useChannelSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelSettingsQuery, ChannelSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelSettingsQuery, ChannelSettingsQueryVariables>(ChannelSettingsDocument, options);
        }
export type ChannelSettingsQueryHookResult = ReturnType<typeof useChannelSettingsQuery>;
export type ChannelSettingsLazyQueryHookResult = ReturnType<typeof useChannelSettingsLazyQuery>;
export type ChannelSettingsQueryResult = Apollo.QueryResult<ChannelSettingsQuery, ChannelSettingsQueryVariables>;
export const ChannelUpdatePrivacyDocument = gql`
    mutation ChannelUpdatePrivacy($channelId: ID!, $isPublic: Boolean) {
  updateChannelDetails(body: {id: $channelId, isPublic: $isPublic}) {
    id
    isPublic
  }
}
    `;
export type ChannelUpdatePrivacyMutationFn = Apollo.MutationFunction<ChannelUpdatePrivacyMutation, ChannelUpdatePrivacyMutationVariables>;

/**
 * __useChannelUpdatePrivacyMutation__
 *
 * To run a mutation, you first call `useChannelUpdatePrivacyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelUpdatePrivacyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelUpdatePrivacyMutation, { data, loading, error }] = useChannelUpdatePrivacyMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      isPublic: // value for 'isPublic'
 *   },
 * });
 */
export function useChannelUpdatePrivacyMutation(baseOptions?: Apollo.MutationHookOptions<ChannelUpdatePrivacyMutation, ChannelUpdatePrivacyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelUpdatePrivacyMutation, ChannelUpdatePrivacyMutationVariables>(ChannelUpdatePrivacyDocument, options);
      }
export type ChannelUpdatePrivacyMutationHookResult = ReturnType<typeof useChannelUpdatePrivacyMutation>;
export type ChannelUpdatePrivacyMutationResult = Apollo.MutationResult<ChannelUpdatePrivacyMutation>;
export type ChannelUpdatePrivacyMutationOptions = Apollo.BaseMutationOptions<ChannelUpdatePrivacyMutation, ChannelUpdatePrivacyMutationVariables>;
export const ChannelSettingsUpdateMlConfigDocument = gql`
    mutation ChannelSettingsUpdateMlConfig($id: ID!, $channelId: ID!, $containerImage: String!) {
  updateStreamBackendConfig(
    body: {id: $id, channelId: $channelId, mlConfig: {containerImage: $containerImage}}
  ) {
    ...PredictionGameChannelStreamBackendConfig
  }
}
    ${PredictionGameChannelStreamBackendConfigFragmentDoc}`;
export type ChannelSettingsUpdateMlConfigMutationFn = Apollo.MutationFunction<ChannelSettingsUpdateMlConfigMutation, ChannelSettingsUpdateMlConfigMutationVariables>;

/**
 * __useChannelSettingsUpdateMlConfigMutation__
 *
 * To run a mutation, you first call `useChannelSettingsUpdateMlConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelSettingsUpdateMlConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelSettingsUpdateMlConfigMutation, { data, loading, error }] = useChannelSettingsUpdateMlConfigMutation({
 *   variables: {
 *      id: // value for 'id'
 *      channelId: // value for 'channelId'
 *      containerImage: // value for 'containerImage'
 *   },
 * });
 */
export function useChannelSettingsUpdateMlConfigMutation(baseOptions?: Apollo.MutationHookOptions<ChannelSettingsUpdateMlConfigMutation, ChannelSettingsUpdateMlConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelSettingsUpdateMlConfigMutation, ChannelSettingsUpdateMlConfigMutationVariables>(ChannelSettingsUpdateMlConfigDocument, options);
      }
export type ChannelSettingsUpdateMlConfigMutationHookResult = ReturnType<typeof useChannelSettingsUpdateMlConfigMutation>;
export type ChannelSettingsUpdateMlConfigMutationResult = Apollo.MutationResult<ChannelSettingsUpdateMlConfigMutation>;
export type ChannelSettingsUpdateMlConfigMutationOptions = Apollo.BaseMutationOptions<ChannelSettingsUpdateMlConfigMutation, ChannelSettingsUpdateMlConfigMutationVariables>;
export const ChannelUpdatePriorityDocument = gql`
    mutation ChannelUpdatePriority($channelId: ID!, $priority: Int) {
  updateChannelDetails(body: {id: $channelId, priority: $priority}) {
    id
    priority
  }
}
    `;
export type ChannelUpdatePriorityMutationFn = Apollo.MutationFunction<ChannelUpdatePriorityMutation, ChannelUpdatePriorityMutationVariables>;

/**
 * __useChannelUpdatePriorityMutation__
 *
 * To run a mutation, you first call `useChannelUpdatePriorityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelUpdatePriorityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelUpdatePriorityMutation, { data, loading, error }] = useChannelUpdatePriorityMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useChannelUpdatePriorityMutation(baseOptions?: Apollo.MutationHookOptions<ChannelUpdatePriorityMutation, ChannelUpdatePriorityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelUpdatePriorityMutation, ChannelUpdatePriorityMutationVariables>(ChannelUpdatePriorityDocument, options);
      }
export type ChannelUpdatePriorityMutationHookResult = ReturnType<typeof useChannelUpdatePriorityMutation>;
export type ChannelUpdatePriorityMutationResult = Apollo.MutationResult<ChannelUpdatePriorityMutation>;
export type ChannelUpdatePriorityMutationOptions = Apollo.BaseMutationOptions<ChannelUpdatePriorityMutation, ChannelUpdatePriorityMutationVariables>;
export const ChannelSettingsUpdateRecConfigDocument = gql`
    mutation ChannelSettingsUpdateRecConfig($id: ID!, $channelId: ID!, $containerImage: String!) {
  updateStreamBackendConfig(
    body: {id: $id, channelId: $channelId, recConfig: {containerImage: $containerImage}}
  ) {
    ...RecordingChannelStreamBackendConfig
  }
}
    ${RecordingChannelStreamBackendConfigFragmentDoc}`;
export type ChannelSettingsUpdateRecConfigMutationFn = Apollo.MutationFunction<ChannelSettingsUpdateRecConfigMutation, ChannelSettingsUpdateRecConfigMutationVariables>;

/**
 * __useChannelSettingsUpdateRecConfigMutation__
 *
 * To run a mutation, you first call `useChannelSettingsUpdateRecConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelSettingsUpdateRecConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelSettingsUpdateRecConfigMutation, { data, loading, error }] = useChannelSettingsUpdateRecConfigMutation({
 *   variables: {
 *      id: // value for 'id'
 *      channelId: // value for 'channelId'
 *      containerImage: // value for 'containerImage'
 *   },
 * });
 */
export function useChannelSettingsUpdateRecConfigMutation(baseOptions?: Apollo.MutationHookOptions<ChannelSettingsUpdateRecConfigMutation, ChannelSettingsUpdateRecConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelSettingsUpdateRecConfigMutation, ChannelSettingsUpdateRecConfigMutationVariables>(ChannelSettingsUpdateRecConfigDocument, options);
      }
export type ChannelSettingsUpdateRecConfigMutationHookResult = ReturnType<typeof useChannelSettingsUpdateRecConfigMutation>;
export type ChannelSettingsUpdateRecConfigMutationResult = Apollo.MutationResult<ChannelSettingsUpdateRecConfigMutation>;
export type ChannelSettingsUpdateRecConfigMutationOptions = Apollo.BaseMutationOptions<ChannelSettingsUpdateRecConfigMutation, ChannelSettingsUpdateRecConfigMutationVariables>;
export const ChannelUpdateRiskTierDocument = gql`
    mutation ChannelUpdateRiskTier($channelId: ID!, $riskTier: ChannelRiskTier!) {
  updateChannelDetails(body: {id: $channelId, riskTier: $riskTier}) {
    id
    riskTier
  }
}
    `;
export type ChannelUpdateRiskTierMutationFn = Apollo.MutationFunction<ChannelUpdateRiskTierMutation, ChannelUpdateRiskTierMutationVariables>;

/**
 * __useChannelUpdateRiskTierMutation__
 *
 * To run a mutation, you first call `useChannelUpdateRiskTierMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelUpdateRiskTierMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelUpdateRiskTierMutation, { data, loading, error }] = useChannelUpdateRiskTierMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      riskTier: // value for 'riskTier'
 *   },
 * });
 */
export function useChannelUpdateRiskTierMutation(baseOptions?: Apollo.MutationHookOptions<ChannelUpdateRiskTierMutation, ChannelUpdateRiskTierMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelUpdateRiskTierMutation, ChannelUpdateRiskTierMutationVariables>(ChannelUpdateRiskTierDocument, options);
      }
export type ChannelUpdateRiskTierMutationHookResult = ReturnType<typeof useChannelUpdateRiskTierMutation>;
export type ChannelUpdateRiskTierMutationResult = Apollo.MutationResult<ChannelUpdateRiskTierMutation>;
export type ChannelUpdateRiskTierMutationOptions = Apollo.BaseMutationOptions<ChannelUpdateRiskTierMutation, ChannelUpdateRiskTierMutationVariables>;
export const ChannelStreamsStreamDocument = gql`
    query ChannelStreamsStream($streamId: ID!) {
  stream(id: $streamId) {
    streamId
    matureRatedContent
    segments {
      startTime
      endTime
      gameId
      title
    }
  }
}
    `;

/**
 * __useChannelStreamsStreamQuery__
 *
 * To run a query within a React component, call `useChannelStreamsStreamQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelStreamsStreamQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelStreamsStreamQuery({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useChannelStreamsStreamQuery(baseOptions: Apollo.QueryHookOptions<ChannelStreamsStreamQuery, ChannelStreamsStreamQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelStreamsStreamQuery, ChannelStreamsStreamQueryVariables>(ChannelStreamsStreamDocument, options);
      }
export function useChannelStreamsStreamLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelStreamsStreamQuery, ChannelStreamsStreamQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelStreamsStreamQuery, ChannelStreamsStreamQueryVariables>(ChannelStreamsStreamDocument, options);
        }
export type ChannelStreamsStreamQueryHookResult = ReturnType<typeof useChannelStreamsStreamQuery>;
export type ChannelStreamsStreamLazyQueryHookResult = ReturnType<typeof useChannelStreamsStreamLazyQuery>;
export type ChannelStreamsStreamQueryResult = Apollo.QueryResult<ChannelStreamsStreamQuery, ChannelStreamsStreamQueryVariables>;
export const ChannelStreamsDocument = gql`
    query ChannelStreams($channelId: ID!, $cursor: APICursorInput) {
  streams(channelId: $channelId, cursor: $cursor) {
    streams {
      channelId
      streamId
      segments {
        startTime
        endTime
        gameId
      }
    }
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
  }
}
    `;

/**
 * __useChannelStreamsQuery__
 *
 * To run a query within a React component, call `useChannelStreamsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelStreamsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelStreamsQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useChannelStreamsQuery(baseOptions: Apollo.QueryHookOptions<ChannelStreamsQuery, ChannelStreamsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelStreamsQuery, ChannelStreamsQueryVariables>(ChannelStreamsDocument, options);
      }
export function useChannelStreamsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelStreamsQuery, ChannelStreamsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelStreamsQuery, ChannelStreamsQueryVariables>(ChannelStreamsDocument, options);
        }
export type ChannelStreamsQueryHookResult = ReturnType<typeof useChannelStreamsQuery>;
export type ChannelStreamsLazyQueryHookResult = ReturnType<typeof useChannelStreamsLazyQuery>;
export type ChannelStreamsQueryResult = Apollo.QueryResult<ChannelStreamsQuery, ChannelStreamsQueryVariables>;
export const ChannelListDocument = gql`
    query ChannelList($cursor: APICursorInput) {
  channels(cursor: $cursor) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    channels {
      id
      name
      subscriberCount
      followerCount
      isPublic
      liveStatus
      streamer {
        userId
        ...UsernameTableCellProfile
      }
    }
  }
}
    ${UsernameTableCellProfileFragmentDoc}`;

/**
 * __useChannelListQuery__
 *
 * To run a query within a React component, call `useChannelListQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelListQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useChannelListQuery(baseOptions?: Apollo.QueryHookOptions<ChannelListQuery, ChannelListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelListQuery, ChannelListQueryVariables>(ChannelListDocument, options);
      }
export function useChannelListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelListQuery, ChannelListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelListQuery, ChannelListQueryVariables>(ChannelListDocument, options);
        }
export type ChannelListQueryHookResult = ReturnType<typeof useChannelListQuery>;
export type ChannelListLazyQueryHookResult = ReturnType<typeof useChannelListLazyQuery>;
export type ChannelListQueryResult = Apollo.QueryResult<ChannelListQuery, ChannelListQueryVariables>;
export const CreateChannelDrawerUserCheckDocument = gql`
    query CreateChannelDrawerUserCheck($userId: ID!) {
  profile(userId: $userId) {
    userId
  }
  userPrivilegedChannels(userId: $userId) {
    channels {
      channelId
      roles
    }
  }
}
    `;

/**
 * __useCreateChannelDrawerUserCheckQuery__
 *
 * To run a query within a React component, call `useCreateChannelDrawerUserCheckQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateChannelDrawerUserCheckQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateChannelDrawerUserCheckQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useCreateChannelDrawerUserCheckQuery(baseOptions: Apollo.QueryHookOptions<CreateChannelDrawerUserCheckQuery, CreateChannelDrawerUserCheckQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreateChannelDrawerUserCheckQuery, CreateChannelDrawerUserCheckQueryVariables>(CreateChannelDrawerUserCheckDocument, options);
      }
export function useCreateChannelDrawerUserCheckLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateChannelDrawerUserCheckQuery, CreateChannelDrawerUserCheckQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreateChannelDrawerUserCheckQuery, CreateChannelDrawerUserCheckQueryVariables>(CreateChannelDrawerUserCheckDocument, options);
        }
export type CreateChannelDrawerUserCheckQueryHookResult = ReturnType<typeof useCreateChannelDrawerUserCheckQuery>;
export type CreateChannelDrawerUserCheckLazyQueryHookResult = ReturnType<typeof useCreateChannelDrawerUserCheckLazyQuery>;
export type CreateChannelDrawerUserCheckQueryResult = Apollo.QueryResult<CreateChannelDrawerUserCheckQuery, CreateChannelDrawerUserCheckQueryVariables>;
export const CreateChannelDocument = gql`
    mutation CreateChannel($name: String!, $streamerId: ID!) {
  createChannel(name: $name, streamerId: $streamerId) {
    name
    streamerId
  }
}
    `;
export type CreateChannelMutationFn = Apollo.MutationFunction<CreateChannelMutation, CreateChannelMutationVariables>;

/**
 * __useCreateChannelMutation__
 *
 * To run a mutation, you first call `useCreateChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createChannelMutation, { data, loading, error }] = useCreateChannelMutation({
 *   variables: {
 *      name: // value for 'name'
 *      streamerId: // value for 'streamerId'
 *   },
 * });
 */
export function useCreateChannelMutation(baseOptions?: Apollo.MutationHookOptions<CreateChannelMutation, CreateChannelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateChannelMutation, CreateChannelMutationVariables>(CreateChannelDocument, options);
      }
export type CreateChannelMutationHookResult = ReturnType<typeof useCreateChannelMutation>;
export type CreateChannelMutationResult = Apollo.MutationResult<CreateChannelMutation>;
export type CreateChannelMutationOptions = Apollo.BaseMutationOptions<CreateChannelMutation, CreateChannelMutationVariables>;
export const FtueDismissTooltipsDocument = gql`
    query FTUEDismissTooltips($userId: ID!) {
  dismissedTooltips(userId: $userId) {
    tooltipIds
  }
}
    `;

/**
 * __useFtueDismissTooltipsQuery__
 *
 * To run a query within a React component, call `useFtueDismissTooltipsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFtueDismissTooltipsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFtueDismissTooltipsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFtueDismissTooltipsQuery(baseOptions: Apollo.QueryHookOptions<FtueDismissTooltipsQuery, FtueDismissTooltipsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FtueDismissTooltipsQuery, FtueDismissTooltipsQueryVariables>(FtueDismissTooltipsDocument, options);
      }
export function useFtueDismissTooltipsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FtueDismissTooltipsQuery, FtueDismissTooltipsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FtueDismissTooltipsQuery, FtueDismissTooltipsQueryVariables>(FtueDismissTooltipsDocument, options);
        }
export type FtueDismissTooltipsQueryHookResult = ReturnType<typeof useFtueDismissTooltipsQuery>;
export type FtueDismissTooltipsLazyQueryHookResult = ReturnType<typeof useFtueDismissTooltipsLazyQuery>;
export type FtueDismissTooltipsQueryResult = Apollo.QueryResult<FtueDismissTooltipsQuery, FtueDismissTooltipsQueryVariables>;
export const FtueDismissTooltipDocument = gql`
    mutation FTUEDismissTooltip($tooltipId: ID!, $type: FtueDismissalType!) {
  dismissTooltip(tooltipId: $tooltipId, dismissalType: $type) {
    emptyTypeWorkaround
  }
}
    `;
export type FtueDismissTooltipMutationFn = Apollo.MutationFunction<FtueDismissTooltipMutation, FtueDismissTooltipMutationVariables>;

/**
 * __useFtueDismissTooltipMutation__
 *
 * To run a mutation, you first call `useFtueDismissTooltipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFtueDismissTooltipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [ftueDismissTooltipMutation, { data, loading, error }] = useFtueDismissTooltipMutation({
 *   variables: {
 *      tooltipId: // value for 'tooltipId'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useFtueDismissTooltipMutation(baseOptions?: Apollo.MutationHookOptions<FtueDismissTooltipMutation, FtueDismissTooltipMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FtueDismissTooltipMutation, FtueDismissTooltipMutationVariables>(FtueDismissTooltipDocument, options);
      }
export type FtueDismissTooltipMutationHookResult = ReturnType<typeof useFtueDismissTooltipMutation>;
export type FtueDismissTooltipMutationResult = Apollo.MutationResult<FtueDismissTooltipMutation>;
export type FtueDismissTooltipMutationOptions = Apollo.BaseMutationOptions<FtueDismissTooltipMutation, FtueDismissTooltipMutationVariables>;
export const FtueDeleteDismissTooltipDocument = gql`
    mutation FTUEDeleteDismissTooltip($tooltipId: ID!) {
  deleteDismissedTooltip(tooltipId: $tooltipId) {
    emptyTypeWorkaround
  }
}
    `;
export type FtueDeleteDismissTooltipMutationFn = Apollo.MutationFunction<FtueDeleteDismissTooltipMutation, FtueDeleteDismissTooltipMutationVariables>;

/**
 * __useFtueDeleteDismissTooltipMutation__
 *
 * To run a mutation, you first call `useFtueDeleteDismissTooltipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFtueDeleteDismissTooltipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [ftueDeleteDismissTooltipMutation, { data, loading, error }] = useFtueDeleteDismissTooltipMutation({
 *   variables: {
 *      tooltipId: // value for 'tooltipId'
 *   },
 * });
 */
export function useFtueDeleteDismissTooltipMutation(baseOptions?: Apollo.MutationHookOptions<FtueDeleteDismissTooltipMutation, FtueDeleteDismissTooltipMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FtueDeleteDismissTooltipMutation, FtueDeleteDismissTooltipMutationVariables>(FtueDeleteDismissTooltipDocument, options);
      }
export type FtueDeleteDismissTooltipMutationHookResult = ReturnType<typeof useFtueDeleteDismissTooltipMutation>;
export type FtueDeleteDismissTooltipMutationResult = Apollo.MutationResult<FtueDeleteDismissTooltipMutation>;
export type FtueDeleteDismissTooltipMutationOptions = Apollo.BaseMutationOptions<FtueDeleteDismissTooltipMutation, FtueDeleteDismissTooltipMutationVariables>;
export const ChannelSelectorListDocument = gql`
    query ChannelSelectorList($cursor: String, $pageSize: Int) {
  channels(cursor: {first: $pageSize, after: $cursor}) {
    pageInfo {
      endCursor
      hasNextPage
    }
    channels {
      ...ChannelSelectorChannel
    }
  }
}
    ${ChannelSelectorChannelFragmentDoc}`;

/**
 * __useChannelSelectorListQuery__
 *
 * To run a query within a React component, call `useChannelSelectorListQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelSelectorListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelSelectorListQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useChannelSelectorListQuery(baseOptions?: Apollo.QueryHookOptions<ChannelSelectorListQuery, ChannelSelectorListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelSelectorListQuery, ChannelSelectorListQueryVariables>(ChannelSelectorListDocument, options);
      }
export function useChannelSelectorListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelSelectorListQuery, ChannelSelectorListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelSelectorListQuery, ChannelSelectorListQueryVariables>(ChannelSelectorListDocument, options);
        }
export type ChannelSelectorListQueryHookResult = ReturnType<typeof useChannelSelectorListQuery>;
export type ChannelSelectorListLazyQueryHookResult = ReturnType<typeof useChannelSelectorListLazyQuery>;
export type ChannelSelectorListQueryResult = Apollo.QueryResult<ChannelSelectorListQuery, ChannelSelectorListQueryVariables>;
export const CreateAnnouncementDocument = gql`
    mutation CreateAnnouncement($category: AnnouncementAnnouncementCategory!, $title: String!, $text: String!, $published: Boolean!, $startTime: Timestamp, $endTime: Timestamp, $targets: AnnouncementTargetsInput) {
  createAnnouncement(
    category: $category
    title: $title
    text: $text
    published: $published
    startTime: $startTime
    endTime: $endTime
    targets: $targets
  ) {
    id
    status
  }
}
    `;
export type CreateAnnouncementMutationFn = Apollo.MutationFunction<CreateAnnouncementMutation, CreateAnnouncementMutationVariables>;

/**
 * __useCreateAnnouncementMutation__
 *
 * To run a mutation, you first call `useCreateAnnouncementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAnnouncementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAnnouncementMutation, { data, loading, error }] = useCreateAnnouncementMutation({
 *   variables: {
 *      category: // value for 'category'
 *      title: // value for 'title'
 *      text: // value for 'text'
 *      published: // value for 'published'
 *      startTime: // value for 'startTime'
 *      endTime: // value for 'endTime'
 *      targets: // value for 'targets'
 *   },
 * });
 */
export function useCreateAnnouncementMutation(baseOptions?: Apollo.MutationHookOptions<CreateAnnouncementMutation, CreateAnnouncementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAnnouncementMutation, CreateAnnouncementMutationVariables>(CreateAnnouncementDocument, options);
      }
export type CreateAnnouncementMutationHookResult = ReturnType<typeof useCreateAnnouncementMutation>;
export type CreateAnnouncementMutationResult = Apollo.MutationResult<CreateAnnouncementMutation>;
export type CreateAnnouncementMutationOptions = Apollo.BaseMutationOptions<CreateAnnouncementMutation, CreateAnnouncementMutationVariables>;
export const DeleteAnnouncementDocument = gql`
    mutation DeleteAnnouncement($id: ID!) {
  deleteAnnouncement(id: $id) {
    emptyTypeWorkaround
  }
}
    `;
export type DeleteAnnouncementMutationFn = Apollo.MutationFunction<DeleteAnnouncementMutation, DeleteAnnouncementMutationVariables>;

/**
 * __useDeleteAnnouncementMutation__
 *
 * To run a mutation, you first call `useDeleteAnnouncementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAnnouncementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAnnouncementMutation, { data, loading, error }] = useDeleteAnnouncementMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteAnnouncementMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAnnouncementMutation, DeleteAnnouncementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAnnouncementMutation, DeleteAnnouncementMutationVariables>(DeleteAnnouncementDocument, options);
      }
export type DeleteAnnouncementMutationHookResult = ReturnType<typeof useDeleteAnnouncementMutation>;
export type DeleteAnnouncementMutationResult = Apollo.MutationResult<DeleteAnnouncementMutation>;
export type DeleteAnnouncementMutationOptions = Apollo.BaseMutationOptions<DeleteAnnouncementMutation, DeleteAnnouncementMutationVariables>;
export const EditAnnouncementDocument = gql`
    mutation EditAnnouncement($id: ID!, $category: AnnouncementAnnouncementCategory!, $title: String!, $text: String!, $published: Boolean!, $startTime: InputTimestamp, $endTime: InputTimestamp, $targets: AnnouncementTargetsInput!) {
  updateAnnouncement(
    body: {id: $id, category: $category, title: $title, text: $text, published: $published, startTime: $startTime, endTime: $endTime, targets: $targets}
  ) {
    ...AnnouncementEditFormCacheAnnouncement
  }
}
    ${AnnouncementEditFormCacheAnnouncementFragmentDoc}`;
export type EditAnnouncementMutationFn = Apollo.MutationFunction<EditAnnouncementMutation, EditAnnouncementMutationVariables>;

/**
 * __useEditAnnouncementMutation__
 *
 * To run a mutation, you first call `useEditAnnouncementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditAnnouncementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editAnnouncementMutation, { data, loading, error }] = useEditAnnouncementMutation({
 *   variables: {
 *      id: // value for 'id'
 *      category: // value for 'category'
 *      title: // value for 'title'
 *      text: // value for 'text'
 *      published: // value for 'published'
 *      startTime: // value for 'startTime'
 *      endTime: // value for 'endTime'
 *      targets: // value for 'targets'
 *   },
 * });
 */
export function useEditAnnouncementMutation(baseOptions?: Apollo.MutationHookOptions<EditAnnouncementMutation, EditAnnouncementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditAnnouncementMutation, EditAnnouncementMutationVariables>(EditAnnouncementDocument, options);
      }
export type EditAnnouncementMutationHookResult = ReturnType<typeof useEditAnnouncementMutation>;
export type EditAnnouncementMutationResult = Apollo.MutationResult<EditAnnouncementMutation>;
export type EditAnnouncementMutationOptions = Apollo.BaseMutationOptions<EditAnnouncementMutation, EditAnnouncementMutationVariables>;
export const AnnouncementAssetDeleteImageDocument = gql`
    mutation AnnouncementAssetDeleteImage($announcementId: ID!) {
  deleteAnnouncementImage(announcementId: $announcementId) {
    emptyTypeWorkaround
  }
}
    `;
export type AnnouncementAssetDeleteImageMutationFn = Apollo.MutationFunction<AnnouncementAssetDeleteImageMutation, AnnouncementAssetDeleteImageMutationVariables>;

/**
 * __useAnnouncementAssetDeleteImageMutation__
 *
 * To run a mutation, you first call `useAnnouncementAssetDeleteImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAnnouncementAssetDeleteImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [announcementAssetDeleteImageMutation, { data, loading, error }] = useAnnouncementAssetDeleteImageMutation({
 *   variables: {
 *      announcementId: // value for 'announcementId'
 *   },
 * });
 */
export function useAnnouncementAssetDeleteImageMutation(baseOptions?: Apollo.MutationHookOptions<AnnouncementAssetDeleteImageMutation, AnnouncementAssetDeleteImageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AnnouncementAssetDeleteImageMutation, AnnouncementAssetDeleteImageMutationVariables>(AnnouncementAssetDeleteImageDocument, options);
      }
export type AnnouncementAssetDeleteImageMutationHookResult = ReturnType<typeof useAnnouncementAssetDeleteImageMutation>;
export type AnnouncementAssetDeleteImageMutationResult = Apollo.MutationResult<AnnouncementAssetDeleteImageMutation>;
export type AnnouncementAssetDeleteImageMutationOptions = Apollo.BaseMutationOptions<AnnouncementAssetDeleteImageMutation, AnnouncementAssetDeleteImageMutationVariables>;
export const AnnouncementAmountsDocument = gql`
    query AnnouncementAmounts {
  active: announcements(filter: {statuses: [ANNOUNCEMENT_STATUS_ACTIVE]}) {
    totalCount
  }
  scheduled: announcements(filter: {statuses: [ANNOUNCEMENT_STATUS_SCHEDULED]}) {
    totalCount
  }
  draft: announcements(filter: {statuses: [ANNOUNCEMENT_STATUS_DRAFT]}) {
    totalCount
  }
  past: announcements(filter: {statuses: [ANNOUNCEMENT_STATUS_PAST]}) {
    totalCount
  }
}
    `;

/**
 * __useAnnouncementAmountsQuery__
 *
 * To run a query within a React component, call `useAnnouncementAmountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAnnouncementAmountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAnnouncementAmountsQuery({
 *   variables: {
 *   },
 * });
 */
export function useAnnouncementAmountsQuery(baseOptions?: Apollo.QueryHookOptions<AnnouncementAmountsQuery, AnnouncementAmountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AnnouncementAmountsQuery, AnnouncementAmountsQueryVariables>(AnnouncementAmountsDocument, options);
      }
export function useAnnouncementAmountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AnnouncementAmountsQuery, AnnouncementAmountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AnnouncementAmountsQuery, AnnouncementAmountsQueryVariables>(AnnouncementAmountsDocument, options);
        }
export type AnnouncementAmountsQueryHookResult = ReturnType<typeof useAnnouncementAmountsQuery>;
export type AnnouncementAmountsLazyQueryHookResult = ReturnType<typeof useAnnouncementAmountsLazyQuery>;
export type AnnouncementAmountsQueryResult = Apollo.QueryResult<AnnouncementAmountsQuery, AnnouncementAmountsQueryVariables>;
export const AnnouncementAssetCreateTokenDocument = gql`
    mutation AnnouncementAssetCreateToken($announcementId: ID!) {
  createAnnouncementImageUploadToken(announcementId: $announcementId) {
    token
  }
}
    `;
export type AnnouncementAssetCreateTokenMutationFn = Apollo.MutationFunction<AnnouncementAssetCreateTokenMutation, AnnouncementAssetCreateTokenMutationVariables>;

/**
 * __useAnnouncementAssetCreateTokenMutation__
 *
 * To run a mutation, you first call `useAnnouncementAssetCreateTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAnnouncementAssetCreateTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [announcementAssetCreateTokenMutation, { data, loading, error }] = useAnnouncementAssetCreateTokenMutation({
 *   variables: {
 *      announcementId: // value for 'announcementId'
 *   },
 * });
 */
export function useAnnouncementAssetCreateTokenMutation(baseOptions?: Apollo.MutationHookOptions<AnnouncementAssetCreateTokenMutation, AnnouncementAssetCreateTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AnnouncementAssetCreateTokenMutation, AnnouncementAssetCreateTokenMutationVariables>(AnnouncementAssetCreateTokenDocument, options);
      }
export type AnnouncementAssetCreateTokenMutationHookResult = ReturnType<typeof useAnnouncementAssetCreateTokenMutation>;
export type AnnouncementAssetCreateTokenMutationResult = Apollo.MutationResult<AnnouncementAssetCreateTokenMutation>;
export type AnnouncementAssetCreateTokenMutationOptions = Apollo.BaseMutationOptions<AnnouncementAssetCreateTokenMutation, AnnouncementAssetCreateTokenMutationVariables>;
export const ActiveAnnouncementsDocument = gql`
    query ActiveAnnouncements($cursor: APICursorInput) {
  announcements(cursor: $cursor, filter: {statuses: [ANNOUNCEMENT_STATUS_ACTIVE]}) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    announcements {
      id
      ...AnnouncementTableAnnouncement
      ...AnnouncementDrawerAnnouncement
    }
  }
}
    ${AnnouncementTableAnnouncementFragmentDoc}
${AnnouncementDrawerAnnouncementFragmentDoc}`;

/**
 * __useActiveAnnouncementsQuery__
 *
 * To run a query within a React component, call `useActiveAnnouncementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useActiveAnnouncementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActiveAnnouncementsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useActiveAnnouncementsQuery(baseOptions?: Apollo.QueryHookOptions<ActiveAnnouncementsQuery, ActiveAnnouncementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ActiveAnnouncementsQuery, ActiveAnnouncementsQueryVariables>(ActiveAnnouncementsDocument, options);
      }
export function useActiveAnnouncementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActiveAnnouncementsQuery, ActiveAnnouncementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ActiveAnnouncementsQuery, ActiveAnnouncementsQueryVariables>(ActiveAnnouncementsDocument, options);
        }
export type ActiveAnnouncementsQueryHookResult = ReturnType<typeof useActiveAnnouncementsQuery>;
export type ActiveAnnouncementsLazyQueryHookResult = ReturnType<typeof useActiveAnnouncementsLazyQuery>;
export type ActiveAnnouncementsQueryResult = Apollo.QueryResult<ActiveAnnouncementsQuery, ActiveAnnouncementsQueryVariables>;
export const DraftAnnouncementsDocument = gql`
    query DraftAnnouncements($cursor: APICursorInput) {
  announcements(cursor: $cursor, filter: {statuses: [ANNOUNCEMENT_STATUS_DRAFT]}) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    announcements {
      id
      ...AnnouncementTableAnnouncement
      ...AnnouncementDrawerAnnouncement
    }
  }
}
    ${AnnouncementTableAnnouncementFragmentDoc}
${AnnouncementDrawerAnnouncementFragmentDoc}`;

/**
 * __useDraftAnnouncementsQuery__
 *
 * To run a query within a React component, call `useDraftAnnouncementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useDraftAnnouncementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDraftAnnouncementsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useDraftAnnouncementsQuery(baseOptions?: Apollo.QueryHookOptions<DraftAnnouncementsQuery, DraftAnnouncementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DraftAnnouncementsQuery, DraftAnnouncementsQueryVariables>(DraftAnnouncementsDocument, options);
      }
export function useDraftAnnouncementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DraftAnnouncementsQuery, DraftAnnouncementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DraftAnnouncementsQuery, DraftAnnouncementsQueryVariables>(DraftAnnouncementsDocument, options);
        }
export type DraftAnnouncementsQueryHookResult = ReturnType<typeof useDraftAnnouncementsQuery>;
export type DraftAnnouncementsLazyQueryHookResult = ReturnType<typeof useDraftAnnouncementsLazyQuery>;
export type DraftAnnouncementsQueryResult = Apollo.QueryResult<DraftAnnouncementsQuery, DraftAnnouncementsQueryVariables>;
export const PastAnnouncementsDocument = gql`
    query PastAnnouncements($cursor: APICursorInput) {
  announcements(cursor: $cursor, filter: {statuses: [ANNOUNCEMENT_STATUS_PAST]}) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    announcements {
      id
      ...AnnouncementTableAnnouncement
      ...AnnouncementDrawerAnnouncement
    }
  }
}
    ${AnnouncementTableAnnouncementFragmentDoc}
${AnnouncementDrawerAnnouncementFragmentDoc}`;

/**
 * __usePastAnnouncementsQuery__
 *
 * To run a query within a React component, call `usePastAnnouncementsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePastAnnouncementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePastAnnouncementsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function usePastAnnouncementsQuery(baseOptions?: Apollo.QueryHookOptions<PastAnnouncementsQuery, PastAnnouncementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PastAnnouncementsQuery, PastAnnouncementsQueryVariables>(PastAnnouncementsDocument, options);
      }
export function usePastAnnouncementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PastAnnouncementsQuery, PastAnnouncementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PastAnnouncementsQuery, PastAnnouncementsQueryVariables>(PastAnnouncementsDocument, options);
        }
export type PastAnnouncementsQueryHookResult = ReturnType<typeof usePastAnnouncementsQuery>;
export type PastAnnouncementsLazyQueryHookResult = ReturnType<typeof usePastAnnouncementsLazyQuery>;
export type PastAnnouncementsQueryResult = Apollo.QueryResult<PastAnnouncementsQuery, PastAnnouncementsQueryVariables>;
export const ScheduledAnnouncementsDocument = gql`
    query ScheduledAnnouncements($cursor: APICursorInput) {
  announcements(
    cursor: $cursor
    filter: {statuses: [ANNOUNCEMENT_STATUS_SCHEDULED]}
  ) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    announcements {
      id
      ...AnnouncementTableAnnouncement
      ...AnnouncementDrawerAnnouncement
    }
  }
}
    ${AnnouncementTableAnnouncementFragmentDoc}
${AnnouncementDrawerAnnouncementFragmentDoc}`;

/**
 * __useScheduledAnnouncementsQuery__
 *
 * To run a query within a React component, call `useScheduledAnnouncementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useScheduledAnnouncementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScheduledAnnouncementsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useScheduledAnnouncementsQuery(baseOptions?: Apollo.QueryHookOptions<ScheduledAnnouncementsQuery, ScheduledAnnouncementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ScheduledAnnouncementsQuery, ScheduledAnnouncementsQueryVariables>(ScheduledAnnouncementsDocument, options);
      }
export function useScheduledAnnouncementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ScheduledAnnouncementsQuery, ScheduledAnnouncementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ScheduledAnnouncementsQuery, ScheduledAnnouncementsQueryVariables>(ScheduledAnnouncementsDocument, options);
        }
export type ScheduledAnnouncementsQueryHookResult = ReturnType<typeof useScheduledAnnouncementsQuery>;
export type ScheduledAnnouncementsLazyQueryHookResult = ReturnType<typeof useScheduledAnnouncementsLazyQuery>;
export type ScheduledAnnouncementsQueryResult = Apollo.QueryResult<ScheduledAnnouncementsQuery, ScheduledAnnouncementsQueryVariables>;
export const PlatformEmojisDocument = gql`
    query PlatformEmojis($cursor: APICursorInput, $includeDisabled: Boolean) {
  platformEmojis(
    cursor: $cursor
    includeCount: true
    includeDisabled: $includeDisabled
  ) {
    pageInfo {
      endCursor
      hasNextPage
      hasPreviousPage
      startCursor
    }
    emojis {
      id
      ...EmojiTableEmoji
    }
    count {
      disabled
      total
    }
  }
}
    ${EmojiTableEmojiFragmentDoc}`;

/**
 * __usePlatformEmojisQuery__
 *
 * To run a query within a React component, call `usePlatformEmojisQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlatformEmojisQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlatformEmojisQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      includeDisabled: // value for 'includeDisabled'
 *   },
 * });
 */
export function usePlatformEmojisQuery(baseOptions?: Apollo.QueryHookOptions<PlatformEmojisQuery, PlatformEmojisQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlatformEmojisQuery, PlatformEmojisQueryVariables>(PlatformEmojisDocument, options);
      }
export function usePlatformEmojisLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlatformEmojisQuery, PlatformEmojisQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlatformEmojisQuery, PlatformEmojisQueryVariables>(PlatformEmojisDocument, options);
        }
export type PlatformEmojisQueryHookResult = ReturnType<typeof usePlatformEmojisQuery>;
export type PlatformEmojisLazyQueryHookResult = ReturnType<typeof usePlatformEmojisLazyQuery>;
export type PlatformEmojisQueryResult = Apollo.QueryResult<PlatformEmojisQuery, PlatformEmojisQueryVariables>;
export const AddPlatformEmojiDocument = gql`
    mutation AddPlatformEmoji($label: String!) {
  createPlatformEmoji(label: $label) {
    id
    label
    disabled
  }
}
    `;
export type AddPlatformEmojiMutationFn = Apollo.MutationFunction<AddPlatformEmojiMutation, AddPlatformEmojiMutationVariables>;

/**
 * __useAddPlatformEmojiMutation__
 *
 * To run a mutation, you first call `useAddPlatformEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddPlatformEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addPlatformEmojiMutation, { data, loading, error }] = useAddPlatformEmojiMutation({
 *   variables: {
 *      label: // value for 'label'
 *   },
 * });
 */
export function useAddPlatformEmojiMutation(baseOptions?: Apollo.MutationHookOptions<AddPlatformEmojiMutation, AddPlatformEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddPlatformEmojiMutation, AddPlatformEmojiMutationVariables>(AddPlatformEmojiDocument, options);
      }
export type AddPlatformEmojiMutationHookResult = ReturnType<typeof useAddPlatformEmojiMutation>;
export type AddPlatformEmojiMutationResult = Apollo.MutationResult<AddPlatformEmojiMutation>;
export type AddPlatformEmojiMutationOptions = Apollo.BaseMutationOptions<AddPlatformEmojiMutation, AddPlatformEmojiMutationVariables>;
export const EnableCreatedPlatformEmojiDocument = gql`
    mutation EnableCreatedPlatformEmoji($id: ID!) {
  updatePlatformEmoji(body: {id: $id, disabled: false}) {
    id
    disabled
  }
}
    `;
export type EnableCreatedPlatformEmojiMutationFn = Apollo.MutationFunction<EnableCreatedPlatformEmojiMutation, EnableCreatedPlatformEmojiMutationVariables>;

/**
 * __useEnableCreatedPlatformEmojiMutation__
 *
 * To run a mutation, you first call `useEnableCreatedPlatformEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEnableCreatedPlatformEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [enableCreatedPlatformEmojiMutation, { data, loading, error }] = useEnableCreatedPlatformEmojiMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEnableCreatedPlatformEmojiMutation(baseOptions?: Apollo.MutationHookOptions<EnableCreatedPlatformEmojiMutation, EnableCreatedPlatformEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EnableCreatedPlatformEmojiMutation, EnableCreatedPlatformEmojiMutationVariables>(EnableCreatedPlatformEmojiDocument, options);
      }
export type EnableCreatedPlatformEmojiMutationHookResult = ReturnType<typeof useEnableCreatedPlatformEmojiMutation>;
export type EnableCreatedPlatformEmojiMutationResult = Apollo.MutationResult<EnableCreatedPlatformEmojiMutation>;
export type EnableCreatedPlatformEmojiMutationOptions = Apollo.BaseMutationOptions<EnableCreatedPlatformEmojiMutation, EnableCreatedPlatformEmojiMutationVariables>;
export const PlatformEmojiDrawerEmojiDocument = gql`
    query PlatformEmojiDrawerEmoji($emojiId: ID!) {
  emoji(id: $emojiId) {
    id
    ...PlatformEmojiEditDrawerEmoji
  }
}
    ${PlatformEmojiEditDrawerEmojiFragmentDoc}`;

/**
 * __usePlatformEmojiDrawerEmojiQuery__
 *
 * To run a query within a React component, call `usePlatformEmojiDrawerEmojiQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlatformEmojiDrawerEmojiQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlatformEmojiDrawerEmojiQuery({
 *   variables: {
 *      emojiId: // value for 'emojiId'
 *   },
 * });
 */
export function usePlatformEmojiDrawerEmojiQuery(baseOptions: Apollo.QueryHookOptions<PlatformEmojiDrawerEmojiQuery, PlatformEmojiDrawerEmojiQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlatformEmojiDrawerEmojiQuery, PlatformEmojiDrawerEmojiQueryVariables>(PlatformEmojiDrawerEmojiDocument, options);
      }
export function usePlatformEmojiDrawerEmojiLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlatformEmojiDrawerEmojiQuery, PlatformEmojiDrawerEmojiQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlatformEmojiDrawerEmojiQuery, PlatformEmojiDrawerEmojiQueryVariables>(PlatformEmojiDrawerEmojiDocument, options);
        }
export type PlatformEmojiDrawerEmojiQueryHookResult = ReturnType<typeof usePlatformEmojiDrawerEmojiQuery>;
export type PlatformEmojiDrawerEmojiLazyQueryHookResult = ReturnType<typeof usePlatformEmojiDrawerEmojiLazyQuery>;
export type PlatformEmojiDrawerEmojiQueryResult = Apollo.QueryResult<PlatformEmojiDrawerEmojiQuery, PlatformEmojiDrawerEmojiQueryVariables>;
export const EditPlatformEmojiDocument = gql`
    mutation EditPlatformEmoji($id: ID!, $label: String!, $disabled: Boolean) {
  updatePlatformEmoji(body: {id: $id, label: $label, disabled: $disabled}) {
    id
    disabled
    label
  }
}
    `;
export type EditPlatformEmojiMutationFn = Apollo.MutationFunction<EditPlatformEmojiMutation, EditPlatformEmojiMutationVariables>;

/**
 * __useEditPlatformEmojiMutation__
 *
 * To run a mutation, you first call `useEditPlatformEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditPlatformEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editPlatformEmojiMutation, { data, loading, error }] = useEditPlatformEmojiMutation({
 *   variables: {
 *      id: // value for 'id'
 *      label: // value for 'label'
 *      disabled: // value for 'disabled'
 *   },
 * });
 */
export function useEditPlatformEmojiMutation(baseOptions?: Apollo.MutationHookOptions<EditPlatformEmojiMutation, EditPlatformEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditPlatformEmojiMutation, EditPlatformEmojiMutationVariables>(EditPlatformEmojiDocument, options);
      }
export type EditPlatformEmojiMutationHookResult = ReturnType<typeof useEditPlatformEmojiMutation>;
export type EditPlatformEmojiMutationResult = Apollo.MutationResult<EditPlatformEmojiMutation>;
export type EditPlatformEmojiMutationOptions = Apollo.BaseMutationOptions<EditPlatformEmojiMutation, EditPlatformEmojiMutationVariables>;
export const DeletePlatformEmojiDocument = gql`
    mutation DeletePlatformEmoji($id: ID!) {
  deletePlatformEmoji(id: $id) {
    emptyTypeWorkaround
  }
}
    `;
export type DeletePlatformEmojiMutationFn = Apollo.MutationFunction<DeletePlatformEmojiMutation, DeletePlatformEmojiMutationVariables>;

/**
 * __useDeletePlatformEmojiMutation__
 *
 * To run a mutation, you first call `useDeletePlatformEmojiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePlatformEmojiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePlatformEmojiMutation, { data, loading, error }] = useDeletePlatformEmojiMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePlatformEmojiMutation(baseOptions?: Apollo.MutationHookOptions<DeletePlatformEmojiMutation, DeletePlatformEmojiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePlatformEmojiMutation, DeletePlatformEmojiMutationVariables>(DeletePlatformEmojiDocument, options);
      }
export type DeletePlatformEmojiMutationHookResult = ReturnType<typeof useDeletePlatformEmojiMutation>;
export type DeletePlatformEmojiMutationResult = Apollo.MutationResult<DeletePlatformEmojiMutation>;
export type DeletePlatformEmojiMutationOptions = Apollo.BaseMutationOptions<DeletePlatformEmojiMutation, DeletePlatformEmojiMutationVariables>;
export const GameConditionGameListDocument = gql`
    query GameConditionGameList {
  listGames {
    games {
      id
      name
    }
  }
}
    `;

/**
 * __useGameConditionGameListQuery__
 *
 * To run a query within a React component, call `useGameConditionGameListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGameConditionGameListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGameConditionGameListQuery({
 *   variables: {
 *   },
 * });
 */
export function useGameConditionGameListQuery(baseOptions?: Apollo.QueryHookOptions<GameConditionGameListQuery, GameConditionGameListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GameConditionGameListQuery, GameConditionGameListQueryVariables>(GameConditionGameListDocument, options);
      }
export function useGameConditionGameListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GameConditionGameListQuery, GameConditionGameListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GameConditionGameListQuery, GameConditionGameListQueryVariables>(GameConditionGameListDocument, options);
        }
export type GameConditionGameListQueryHookResult = ReturnType<typeof useGameConditionGameListQuery>;
export type GameConditionGameListLazyQueryHookResult = ReturnType<typeof useGameConditionGameListLazyQuery>;
export type GameConditionGameListQueryResult = Apollo.QueryResult<GameConditionGameListQuery, GameConditionGameListQueryVariables>;
export const FeatureFlagChannelConditionChannelDocument = gql`
    query FeatureFlagChannelConditionChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
    ...ChannelLogoChannel
  }
}
    ${ChannelLogoChannelFragmentDoc}`;

/**
 * __useFeatureFlagChannelConditionChannelQuery__
 *
 * To run a query within a React component, call `useFeatureFlagChannelConditionChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useFeatureFlagChannelConditionChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFeatureFlagChannelConditionChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useFeatureFlagChannelConditionChannelQuery(baseOptions: Apollo.QueryHookOptions<FeatureFlagChannelConditionChannelQuery, FeatureFlagChannelConditionChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FeatureFlagChannelConditionChannelQuery, FeatureFlagChannelConditionChannelQueryVariables>(FeatureFlagChannelConditionChannelDocument, options);
      }
export function useFeatureFlagChannelConditionChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FeatureFlagChannelConditionChannelQuery, FeatureFlagChannelConditionChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FeatureFlagChannelConditionChannelQuery, FeatureFlagChannelConditionChannelQueryVariables>(FeatureFlagChannelConditionChannelDocument, options);
        }
export type FeatureFlagChannelConditionChannelQueryHookResult = ReturnType<typeof useFeatureFlagChannelConditionChannelQuery>;
export type FeatureFlagChannelConditionChannelLazyQueryHookResult = ReturnType<typeof useFeatureFlagChannelConditionChannelLazyQuery>;
export type FeatureFlagChannelConditionChannelQueryResult = Apollo.QueryResult<FeatureFlagChannelConditionChannelQuery, FeatureFlagChannelConditionChannelQueryVariables>;
export const FeatureFlagGameConditionGameDocument = gql`
    query FeatureFlagGameConditionGame($gameId: ID!) {
  game(id: $gameId) {
    id
    name
  }
}
    `;

/**
 * __useFeatureFlagGameConditionGameQuery__
 *
 * To run a query within a React component, call `useFeatureFlagGameConditionGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useFeatureFlagGameConditionGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFeatureFlagGameConditionGameQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useFeatureFlagGameConditionGameQuery(baseOptions: Apollo.QueryHookOptions<FeatureFlagGameConditionGameQuery, FeatureFlagGameConditionGameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FeatureFlagGameConditionGameQuery, FeatureFlagGameConditionGameQueryVariables>(FeatureFlagGameConditionGameDocument, options);
      }
export function useFeatureFlagGameConditionGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FeatureFlagGameConditionGameQuery, FeatureFlagGameConditionGameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FeatureFlagGameConditionGameQuery, FeatureFlagGameConditionGameQueryVariables>(FeatureFlagGameConditionGameDocument, options);
        }
export type FeatureFlagGameConditionGameQueryHookResult = ReturnType<typeof useFeatureFlagGameConditionGameQuery>;
export type FeatureFlagGameConditionGameLazyQueryHookResult = ReturnType<typeof useFeatureFlagGameConditionGameLazyQuery>;
export type FeatureFlagGameConditionGameQueryResult = Apollo.QueryResult<FeatureFlagGameConditionGameQuery, FeatureFlagGameConditionGameQueryVariables>;
export const FeatureFlagSchemaDocument = gql`
    query FeatureFlagSchema {
  featureFlagSchema {
    flags {
      ...FeatureFlagListSchemaFlag
      ...FeatureFlagDrawerSchemaFlag
    }
  }
}
    ${FeatureFlagListSchemaFlagFragmentDoc}
${FeatureFlagDrawerSchemaFlagFragmentDoc}`;

/**
 * __useFeatureFlagSchemaQuery__
 *
 * To run a query within a React component, call `useFeatureFlagSchemaQuery` and pass it any options that fit your needs.
 * When your component renders, `useFeatureFlagSchemaQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFeatureFlagSchemaQuery({
 *   variables: {
 *   },
 * });
 */
export function useFeatureFlagSchemaQuery(baseOptions?: Apollo.QueryHookOptions<FeatureFlagSchemaQuery, FeatureFlagSchemaQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FeatureFlagSchemaQuery, FeatureFlagSchemaQueryVariables>(FeatureFlagSchemaDocument, options);
      }
export function useFeatureFlagSchemaLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FeatureFlagSchemaQuery, FeatureFlagSchemaQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FeatureFlagSchemaQuery, FeatureFlagSchemaQueryVariables>(FeatureFlagSchemaDocument, options);
        }
export type FeatureFlagSchemaQueryHookResult = ReturnType<typeof useFeatureFlagSchemaQuery>;
export type FeatureFlagSchemaLazyQueryHookResult = ReturnType<typeof useFeatureFlagSchemaLazyQuery>;
export type FeatureFlagSchemaQueryResult = Apollo.QueryResult<FeatureFlagSchemaQuery, FeatureFlagSchemaQueryVariables>;
export const FeatureFlagUserConditionProfileDocument = gql`
    query FeatureFlagUserConditionProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    ...ProfileImageProfile
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useFeatureFlagUserConditionProfileQuery__
 *
 * To run a query within a React component, call `useFeatureFlagUserConditionProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useFeatureFlagUserConditionProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFeatureFlagUserConditionProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useFeatureFlagUserConditionProfileQuery(baseOptions: Apollo.QueryHookOptions<FeatureFlagUserConditionProfileQuery, FeatureFlagUserConditionProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FeatureFlagUserConditionProfileQuery, FeatureFlagUserConditionProfileQueryVariables>(FeatureFlagUserConditionProfileDocument, options);
      }
export function useFeatureFlagUserConditionProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FeatureFlagUserConditionProfileQuery, FeatureFlagUserConditionProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FeatureFlagUserConditionProfileQuery, FeatureFlagUserConditionProfileQueryVariables>(FeatureFlagUserConditionProfileDocument, options);
        }
export type FeatureFlagUserConditionProfileQueryHookResult = ReturnType<typeof useFeatureFlagUserConditionProfileQuery>;
export type FeatureFlagUserConditionProfileLazyQueryHookResult = ReturnType<typeof useFeatureFlagUserConditionProfileLazyQuery>;
export type FeatureFlagUserConditionProfileQueryResult = Apollo.QueryResult<FeatureFlagUserConditionProfileQuery, FeatureFlagUserConditionProfileQueryVariables>;
export const FeatureFlagConfigSubscriptionDocument = gql`
    subscription FeatureFlagConfigSubscription {
  updates: subscribeFeatureFlagConfigUpdates {
    revision
    userFlags {
      ...FeatureFlagList
    }
    channelFlags {
      ...FeatureFlagList
    }
  }
}
    ${FeatureFlagListFragmentDoc}`;

/**
 * __useFeatureFlagConfigSubscriptionSubscription__
 *
 * To run a query within a React component, call `useFeatureFlagConfigSubscriptionSubscription` and pass it any options that fit your needs.
 * When your component renders, `useFeatureFlagConfigSubscriptionSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFeatureFlagConfigSubscriptionSubscription({
 *   variables: {
 *   },
 * });
 */
export function useFeatureFlagConfigSubscriptionSubscription(baseOptions?: Apollo.SubscriptionHookOptions<FeatureFlagConfigSubscriptionSubscription, FeatureFlagConfigSubscriptionSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<FeatureFlagConfigSubscriptionSubscription, FeatureFlagConfigSubscriptionSubscriptionVariables>(FeatureFlagConfigSubscriptionDocument, options);
      }
export type FeatureFlagConfigSubscriptionSubscriptionHookResult = ReturnType<typeof useFeatureFlagConfigSubscriptionSubscription>;
export type FeatureFlagConfigSubscriptionSubscriptionResult = Apollo.SubscriptionResult<FeatureFlagConfigSubscriptionSubscription>;
export const SetFeatureFlagConfigDocument = gql`
    mutation SetFeatureFlagConfig($previousRevision: String!, $newConfig: FlagFeatureFlagConfigInput!) {
  setFeatureFlagConfig(
    previousRevision: $previousRevision
    config: $newConfig
    validateSchema: true
  ) {
    revision
  }
}
    `;
export type SetFeatureFlagConfigMutationFn = Apollo.MutationFunction<SetFeatureFlagConfigMutation, SetFeatureFlagConfigMutationVariables>;

/**
 * __useSetFeatureFlagConfigMutation__
 *
 * To run a mutation, you first call `useSetFeatureFlagConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetFeatureFlagConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setFeatureFlagConfigMutation, { data, loading, error }] = useSetFeatureFlagConfigMutation({
 *   variables: {
 *      previousRevision: // value for 'previousRevision'
 *      newConfig: // value for 'newConfig'
 *   },
 * });
 */
export function useSetFeatureFlagConfigMutation(baseOptions?: Apollo.MutationHookOptions<SetFeatureFlagConfigMutation, SetFeatureFlagConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetFeatureFlagConfigMutation, SetFeatureFlagConfigMutationVariables>(SetFeatureFlagConfigDocument, options);
      }
export type SetFeatureFlagConfigMutationHookResult = ReturnType<typeof useSetFeatureFlagConfigMutation>;
export type SetFeatureFlagConfigMutationResult = Apollo.MutationResult<SetFeatureFlagConfigMutation>;
export type SetFeatureFlagConfigMutationOptions = Apollo.BaseMutationOptions<SetFeatureFlagConfigMutation, SetFeatureFlagConfigMutationVariables>;
export const VideoReportCaseDocument = gql`
    query VideoReportCase($caseId: ID!) {
  reportCase(id: $caseId) {
    id
    status
    resolution
    context {
      value {
        ... on SupportReportContextStream {
          streamId
          startAt
        }
      }
    }
  }
  reports(filter: {caseId: $caseId}, cursor: {first: 20}) {
    reports {
      ...VideoReport
    }
  }
}
    ${VideoReportFragmentDoc}`;

/**
 * __useVideoReportCaseQuery__
 *
 * To run a query within a React component, call `useVideoReportCaseQuery` and pass it any options that fit your needs.
 * When your component renders, `useVideoReportCaseQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVideoReportCaseQuery({
 *   variables: {
 *      caseId: // value for 'caseId'
 *   },
 * });
 */
export function useVideoReportCaseQuery(baseOptions: Apollo.QueryHookOptions<VideoReportCaseQuery, VideoReportCaseQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VideoReportCaseQuery, VideoReportCaseQueryVariables>(VideoReportCaseDocument, options);
      }
export function useVideoReportCaseLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VideoReportCaseQuery, VideoReportCaseQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VideoReportCaseQuery, VideoReportCaseQueryVariables>(VideoReportCaseDocument, options);
        }
export type VideoReportCaseQueryHookResult = ReturnType<typeof useVideoReportCaseQuery>;
export type VideoReportCaseLazyQueryHookResult = ReturnType<typeof useVideoReportCaseLazyQuery>;
export type VideoReportCaseQueryResult = Apollo.QueryResult<VideoReportCaseQuery, VideoReportCaseQueryVariables>;
export const VideoReportStreamDocument = gql`
    query VideoReportStream($streamId: ID!) {
  stream(id: $streamId) {
    channelId
    streamId
  }
}
    `;

/**
 * __useVideoReportStreamQuery__
 *
 * To run a query within a React component, call `useVideoReportStreamQuery` and pass it any options that fit your needs.
 * When your component renders, `useVideoReportStreamQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVideoReportStreamQuery({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useVideoReportStreamQuery(baseOptions: Apollo.QueryHookOptions<VideoReportStreamQuery, VideoReportStreamQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VideoReportStreamQuery, VideoReportStreamQueryVariables>(VideoReportStreamDocument, options);
      }
export function useVideoReportStreamLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VideoReportStreamQuery, VideoReportStreamQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VideoReportStreamQuery, VideoReportStreamQueryVariables>(VideoReportStreamDocument, options);
        }
export type VideoReportStreamQueryHookResult = ReturnType<typeof useVideoReportStreamQuery>;
export type VideoReportStreamLazyQueryHookResult = ReturnType<typeof useVideoReportStreamLazyQuery>;
export type VideoReportStreamQueryResult = Apollo.QueryResult<VideoReportStreamQuery, VideoReportStreamQueryVariables>;
export const VideoReportChannelDocument = gql`
    query VideoReportChannel($channelId: ID!) {
  channel(id: $channelId) {
    ...VideoReportChannel
  }
}
    ${VideoReportChannelFragmentDoc}`;

/**
 * __useVideoReportChannelQuery__
 *
 * To run a query within a React component, call `useVideoReportChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useVideoReportChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVideoReportChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useVideoReportChannelQuery(baseOptions: Apollo.QueryHookOptions<VideoReportChannelQuery, VideoReportChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VideoReportChannelQuery, VideoReportChannelQueryVariables>(VideoReportChannelDocument, options);
      }
export function useVideoReportChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VideoReportChannelQuery, VideoReportChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VideoReportChannelQuery, VideoReportChannelQueryVariables>(VideoReportChannelDocument, options);
        }
export type VideoReportChannelQueryHookResult = ReturnType<typeof useVideoReportChannelQuery>;
export type VideoReportChannelLazyQueryHookResult = ReturnType<typeof useVideoReportChannelLazyQuery>;
export type VideoReportChannelQueryResult = Apollo.QueryResult<VideoReportChannelQuery, VideoReportChannelQueryVariables>;
export const ChannelSearchDocument = gql`
    query ChannelSearch($query: String, $cursor: APICursorInput) {
  search(query: $query, entityTypes: [ENTITY_TYPE_CHANNEL], cursor: $cursor) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    resultItems {
      entityId
      entity {
        ... on ChannelChannel {
          id
          name
          followerCount
          isPublic
          liveStatus
          streamer {
            userId
            ...UsernameTableCellProfile
          }
        }
      }
    }
  }
}
    ${UsernameTableCellProfileFragmentDoc}`;

/**
 * __useChannelSearchQuery__
 *
 * To run a query within a React component, call `useChannelSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useChannelSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChannelSearchQuery({
 *   variables: {
 *      query: // value for 'query'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useChannelSearchQuery(baseOptions?: Apollo.QueryHookOptions<ChannelSearchQuery, ChannelSearchQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChannelSearchQuery, ChannelSearchQueryVariables>(ChannelSearchDocument, options);
      }
export function useChannelSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChannelSearchQuery, ChannelSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChannelSearchQuery, ChannelSearchQueryVariables>(ChannelSearchDocument, options);
        }
export type ChannelSearchQueryHookResult = ReturnType<typeof useChannelSearchQuery>;
export type ChannelSearchLazyQueryHookResult = ReturnType<typeof useChannelSearchLazyQuery>;
export type ChannelSearchQueryResult = Apollo.QueryResult<ChannelSearchQuery, ChannelSearchQueryVariables>;
export const UserSearchDocument = gql`
    query UserSearch($query: String, $cursor: APICursorInput) {
  search(query: $query, entityTypes: [ENTITY_TYPE_USER], cursor: $cursor) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    resultItems {
      entityId
      entity {
        ... on ProfileProfile {
          userId
          account {
            email
          }
          ...UsernameTableCellProfile
        }
      }
    }
  }
}
    ${UsernameTableCellProfileFragmentDoc}`;

/**
 * __useUserSearchQuery__
 *
 * To run a query within a React component, call `useUserSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserSearchQuery({
 *   variables: {
 *      query: // value for 'query'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useUserSearchQuery(baseOptions?: Apollo.QueryHookOptions<UserSearchQuery, UserSearchQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserSearchQuery, UserSearchQueryVariables>(UserSearchDocument, options);
      }
export function useUserSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserSearchQuery, UserSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserSearchQuery, UserSearchQueryVariables>(UserSearchDocument, options);
        }
export type UserSearchQueryHookResult = ReturnType<typeof useUserSearchQuery>;
export type UserSearchLazyQueryHookResult = ReturnType<typeof useUserSearchLazyQuery>;
export type UserSearchQueryResult = Apollo.QueryResult<UserSearchQuery, UserSearchQueryVariables>;
export const PlatformSuspensionAppealDrawerDocument = gql`
    query PlatformSuspensionAppealDrawer($userId: ID!) {
  platformBan(userId: $userId) {
    banId
    ...PlatformSuspensionAppealFormSuspension
  }
  profile(userId: $userId) {
    userId
    ...PlatformSuspensionAppealFormProfile
  }
}
    ${PlatformSuspensionAppealFormSuspensionFragmentDoc}
${PlatformSuspensionAppealFormProfileFragmentDoc}`;

/**
 * __usePlatformSuspensionAppealDrawerQuery__
 *
 * To run a query within a React component, call `usePlatformSuspensionAppealDrawerQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlatformSuspensionAppealDrawerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlatformSuspensionAppealDrawerQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function usePlatformSuspensionAppealDrawerQuery(baseOptions: Apollo.QueryHookOptions<PlatformSuspensionAppealDrawerQuery, PlatformSuspensionAppealDrawerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlatformSuspensionAppealDrawerQuery, PlatformSuspensionAppealDrawerQueryVariables>(PlatformSuspensionAppealDrawerDocument, options);
      }
export function usePlatformSuspensionAppealDrawerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlatformSuspensionAppealDrawerQuery, PlatformSuspensionAppealDrawerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlatformSuspensionAppealDrawerQuery, PlatformSuspensionAppealDrawerQueryVariables>(PlatformSuspensionAppealDrawerDocument, options);
        }
export type PlatformSuspensionAppealDrawerQueryHookResult = ReturnType<typeof usePlatformSuspensionAppealDrawerQuery>;
export type PlatformSuspensionAppealDrawerLazyQueryHookResult = ReturnType<typeof usePlatformSuspensionAppealDrawerLazyQuery>;
export type PlatformSuspensionAppealDrawerQueryResult = Apollo.QueryResult<PlatformSuspensionAppealDrawerQuery, PlatformSuspensionAppealDrawerQueryVariables>;
export const PlatformSuspensionAppealsDocument = gql`
    query PlatformSuspensionAppeals($cursor: APICursorInput) {
  platformBanAppeals(cursor: $cursor) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    appeals {
      banId
      ban {
        banId
        bannedAt
        moderator {
          userId
          ...UsernameTableCellProfile
        }
      }
      createdAt
      user {
        userId
        ...UsernameTableCellProfile
      }
    }
  }
}
    ${UsernameTableCellProfileFragmentDoc}`;

/**
 * __usePlatformSuspensionAppealsQuery__
 *
 * To run a query within a React component, call `usePlatformSuspensionAppealsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlatformSuspensionAppealsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlatformSuspensionAppealsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function usePlatformSuspensionAppealsQuery(baseOptions?: Apollo.QueryHookOptions<PlatformSuspensionAppealsQuery, PlatformSuspensionAppealsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlatformSuspensionAppealsQuery, PlatformSuspensionAppealsQueryVariables>(PlatformSuspensionAppealsDocument, options);
      }
export function usePlatformSuspensionAppealsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlatformSuspensionAppealsQuery, PlatformSuspensionAppealsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlatformSuspensionAppealsQuery, PlatformSuspensionAppealsQueryVariables>(PlatformSuspensionAppealsDocument, options);
        }
export type PlatformSuspensionAppealsQueryHookResult = ReturnType<typeof usePlatformSuspensionAppealsQuery>;
export type PlatformSuspensionAppealsLazyQueryHookResult = ReturnType<typeof usePlatformSuspensionAppealsLazyQuery>;
export type PlatformSuspensionAppealsQueryResult = Apollo.QueryResult<PlatformSuspensionAppealsQuery, PlatformSuspensionAppealsQueryVariables>;
export const SidebarUserDocument = gql`
    query SidebarUser($userId: ID!, $skipBan: Boolean = false) {
  profile(userId: $userId) {
    userId
    userTag
    isNewUsername
    account {
      state
    }
    ...ProfileImageProfile
  }
  platformBan(userId: $userId) @skip(if: $skipBan) {
    banId
  }
}
    ${ProfileImageProfileFragmentDoc}`;

/**
 * __useSidebarUserQuery__
 *
 * To run a query within a React component, call `useSidebarUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useSidebarUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSidebarUserQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      skipBan: // value for 'skipBan'
 *   },
 * });
 */
export function useSidebarUserQuery(baseOptions: Apollo.QueryHookOptions<SidebarUserQuery, SidebarUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SidebarUserQuery, SidebarUserQueryVariables>(SidebarUserDocument, options);
      }
export function useSidebarUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SidebarUserQuery, SidebarUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SidebarUserQuery, SidebarUserQueryVariables>(SidebarUserDocument, options);
        }
export type SidebarUserQueryHookResult = ReturnType<typeof useSidebarUserQuery>;
export type SidebarUserLazyQueryHookResult = ReturnType<typeof useSidebarUserLazyQuery>;
export type SidebarUserQueryResult = Apollo.QueryResult<SidebarUserQuery, SidebarUserQueryVariables>;
export const CancelUserDeletionDocument = gql`
    mutation CancelUserDeletion($userId: ID!) {
  cancelDataDeletion(userId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type CancelUserDeletionMutationFn = Apollo.MutationFunction<CancelUserDeletionMutation, CancelUserDeletionMutationVariables>;

/**
 * __useCancelUserDeletionMutation__
 *
 * To run a mutation, you first call `useCancelUserDeletionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCancelUserDeletionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cancelUserDeletionMutation, { data, loading, error }] = useCancelUserDeletionMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useCancelUserDeletionMutation(baseOptions?: Apollo.MutationHookOptions<CancelUserDeletionMutation, CancelUserDeletionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CancelUserDeletionMutation, CancelUserDeletionMutationVariables>(CancelUserDeletionDocument, options);
      }
export type CancelUserDeletionMutationHookResult = ReturnType<typeof useCancelUserDeletionMutation>;
export type CancelUserDeletionMutationResult = Apollo.MutationResult<CancelUserDeletionMutation>;
export type CancelUserDeletionMutationOptions = Apollo.BaseMutationOptions<CancelUserDeletionMutation, CancelUserDeletionMutationVariables>;
export const DeleteUserDocument = gql`
    mutation DeleteUser($userId: ID!) {
  deleteUserData(userId: $userId) {
    taskId
  }
}
    `;
export type DeleteUserMutationFn = Apollo.MutationFunction<DeleteUserMutation, DeleteUserMutationVariables>;

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useDeleteUserMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserMutation, DeleteUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(DeleteUserDocument, options);
      }
export type DeleteUserMutationHookResult = ReturnType<typeof useDeleteUserMutation>;
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>;
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<DeleteUserMutation, DeleteUserMutationVariables>;
export const EditUsernameDocument = gql`
    mutation EditUsername($userId: ID!, $username: String!) {
  updateProfile(
    body: {userId: $userId, userTag: $username}
    options: {omitNameValidation: true, omitRankValidation: true}
  ) {
    userId
    userTag
  }
}
    `;
export type EditUsernameMutationFn = Apollo.MutationFunction<EditUsernameMutation, EditUsernameMutationVariables>;

/**
 * __useEditUsernameMutation__
 *
 * To run a mutation, you first call `useEditUsernameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditUsernameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editUsernameMutation, { data, loading, error }] = useEditUsernameMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      username: // value for 'username'
 *   },
 * });
 */
export function useEditUsernameMutation(baseOptions?: Apollo.MutationHookOptions<EditUsernameMutation, EditUsernameMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditUsernameMutation, EditUsernameMutationVariables>(EditUsernameDocument, options);
      }
export type EditUsernameMutationHookResult = ReturnType<typeof useEditUsernameMutation>;
export type EditUsernameMutationResult = Apollo.MutationResult<EditUsernameMutation>;
export type EditUsernameMutationOptions = Apollo.BaseMutationOptions<EditUsernameMutation, EditUsernameMutationVariables>;
export const UserDocument = gql`
    query User($userId: ID!, $isAdmin: Boolean = false) {
  profile(userId: $userId) {
    userId
    userTag
    bio
    account {
      signupLocation
      createdAt
      uid
      matureRatedContentAllowed
      externalIds {
        type
        id
      }
      ...TermsAndAgreementsAuthAccount
    }
    stats {
      ...UserStats
    }
    ...UserRoleProfile
    ...UserAccountState
    ...DeleteUserProfile
    ...EditUsernameModalProfile
    ...HiddenEmailTextFieldProfile
  }
  userPrivilegedChannels(userId: $userId) @include(if: $isAdmin) {
    channels {
      channelId
      ...UserChannelRoles
    }
  }
}
    ${TermsAndAgreementsAuthAccountFragmentDoc}
${UserStatsFragmentDoc}
${UserRoleProfileFragmentDoc}
${UserAccountStateFragmentDoc}
${DeleteUserProfileFragmentDoc}
${EditUsernameModalProfileFragmentDoc}
${HiddenEmailTextFieldProfileFragmentDoc}
${UserChannelRolesFragmentDoc}`;

/**
 * __useUserQuery__
 *
 * To run a query within a React component, call `useUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      isAdmin: // value for 'isAdmin'
 *   },
 * });
 */
export function useUserQuery(baseOptions: Apollo.QueryHookOptions<UserQuery, UserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserQuery, UserQueryVariables>(UserDocument, options);
      }
export function useUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserQuery, UserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserQuery, UserQueryVariables>(UserDocument, options);
        }
export type UserQueryHookResult = ReturnType<typeof useUserQuery>;
export type UserLazyQueryHookResult = ReturnType<typeof useUserLazyQuery>;
export type UserQueryResult = Apollo.QueryResult<UserQuery, UserQueryVariables>;
export const UserRolesUpdateAccountDocument = gql`
    mutation UserRolesUpdateAccount($userId: ID!, $roles: [AuthPlatformRole!]!) {
  updateAccount(body: {userId: $userId, roles: $roles}) {
    uid
    roles
  }
}
    `;
export type UserRolesUpdateAccountMutationFn = Apollo.MutationFunction<UserRolesUpdateAccountMutation, UserRolesUpdateAccountMutationVariables>;

/**
 * __useUserRolesUpdateAccountMutation__
 *
 * To run a mutation, you first call `useUserRolesUpdateAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserRolesUpdateAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userRolesUpdateAccountMutation, { data, loading, error }] = useUserRolesUpdateAccountMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      roles: // value for 'roles'
 *   },
 * });
 */
export function useUserRolesUpdateAccountMutation(baseOptions?: Apollo.MutationHookOptions<UserRolesUpdateAccountMutation, UserRolesUpdateAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserRolesUpdateAccountMutation, UserRolesUpdateAccountMutationVariables>(UserRolesUpdateAccountDocument, options);
      }
export type UserRolesUpdateAccountMutationHookResult = ReturnType<typeof useUserRolesUpdateAccountMutation>;
export type UserRolesUpdateAccountMutationResult = Apollo.MutationResult<UserRolesUpdateAccountMutation>;
export type UserRolesUpdateAccountMutationOptions = Apollo.BaseMutationOptions<UserRolesUpdateAccountMutation, UserRolesUpdateAccountMutationVariables>;
export const UserSubscriptionsDocument = gql`
    query UserSubscriptions($userId: ID!, $cursor: APICursorInput, $filters: [SubscriptionListUserChannelSubscriptionsRequestFilterInput!]) {
  userChannelSubscriptions(userId: $userId, cursor: $cursor, filters: $filters) {
    subscriptions {
      cancelledAt
      channel {
        id
        name
      }
      createdAt
      expiresAt
      id
      paymentFailedAt
      renewedAt
      state
      tier
    }
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
  }
}
    `;

/**
 * __useUserSubscriptionsQuery__
 *
 * To run a query within a React component, call `useUserSubscriptionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserSubscriptionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserSubscriptionsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *      filters: // value for 'filters'
 *   },
 * });
 */
export function useUserSubscriptionsQuery(baseOptions: Apollo.QueryHookOptions<UserSubscriptionsQuery, UserSubscriptionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserSubscriptionsQuery, UserSubscriptionsQueryVariables>(UserSubscriptionsDocument, options);
      }
export function useUserSubscriptionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserSubscriptionsQuery, UserSubscriptionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserSubscriptionsQuery, UserSubscriptionsQueryVariables>(UserSubscriptionsDocument, options);
        }
export type UserSubscriptionsQueryHookResult = ReturnType<typeof useUserSubscriptionsQuery>;
export type UserSubscriptionsLazyQueryHookResult = ReturnType<typeof useUserSubscriptionsLazyQuery>;
export type UserSubscriptionsQueryResult = Apollo.QueryResult<UserSubscriptionsQuery, UserSubscriptionsQueryVariables>;
export const UserFeatureFlagsDocument = gql`
    query UserFeatureFlags($userId: ID!) {
  userFeatureFlags(userId: $userId) {
    flags {
      name
      value
    }
  }
}
    `;

/**
 * __useUserFeatureFlagsQuery__
 *
 * To run a query within a React component, call `useUserFeatureFlagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserFeatureFlagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserFeatureFlagsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserFeatureFlagsQuery(baseOptions: Apollo.QueryHookOptions<UserFeatureFlagsQuery, UserFeatureFlagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserFeatureFlagsQuery, UserFeatureFlagsQueryVariables>(UserFeatureFlagsDocument, options);
      }
export function useUserFeatureFlagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserFeatureFlagsQuery, UserFeatureFlagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserFeatureFlagsQuery, UserFeatureFlagsQueryVariables>(UserFeatureFlagsDocument, options);
        }
export type UserFeatureFlagsQueryHookResult = ReturnType<typeof useUserFeatureFlagsQuery>;
export type UserFeatureFlagsLazyQueryHookResult = ReturnType<typeof useUserFeatureFlagsLazyQuery>;
export type UserFeatureFlagsQueryResult = Apollo.QueryResult<UserFeatureFlagsQuery, UserFeatureFlagsQueryVariables>;
export const UserFriendsDocument = gql`
    query UserFriends($userId: ID) {
  friends(userId: $userId) {
    users {
      userId
      profile {
        userId
        ...UsernameTableCellProfile
        account {
          email
        }
      }
    }
  }
}
    ${UsernameTableCellProfileFragmentDoc}`;

/**
 * __useUserFriendsQuery__
 *
 * To run a query within a React component, call `useUserFriendsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserFriendsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserFriendsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserFriendsQuery(baseOptions?: Apollo.QueryHookOptions<UserFriendsQuery, UserFriendsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserFriendsQuery, UserFriendsQueryVariables>(UserFriendsDocument, options);
      }
export function useUserFriendsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserFriendsQuery, UserFriendsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserFriendsQuery, UserFriendsQueryVariables>(UserFriendsDocument, options);
        }
export type UserFriendsQueryHookResult = ReturnType<typeof useUserFriendsQuery>;
export type UserFriendsLazyQueryHookResult = ReturnType<typeof useUserFriendsLazyQuery>;
export type UserFriendsQueryResult = Apollo.QueryResult<UserFriendsQuery, UserFriendsQueryVariables>;
export const UserProgressionsDocument = gql`
    query UserProgressions($userId: ID) {
  profile(userId: $userId) {
    userTag
    userId
    playedGames {
      id
      userId
      progression {
        level
      }
      season {
        id
        name
      }
      game {
        id
        name
      }
    }
  }
}
    `;

/**
 * __useUserProgressionsQuery__
 *
 * To run a query within a React component, call `useUserProgressionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserProgressionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserProgressionsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserProgressionsQuery(baseOptions?: Apollo.QueryHookOptions<UserProgressionsQuery, UserProgressionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserProgressionsQuery, UserProgressionsQueryVariables>(UserProgressionsDocument, options);
      }
export function useUserProgressionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserProgressionsQuery, UserProgressionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserProgressionsQuery, UserProgressionsQueryVariables>(UserProgressionsDocument, options);
        }
export type UserProgressionsQueryHookResult = ReturnType<typeof useUserProgressionsQuery>;
export type UserProgressionsLazyQueryHookResult = ReturnType<typeof useUserProgressionsLazyQuery>;
export type UserProgressionsQueryResult = Apollo.QueryResult<UserProgressionsQuery, UserProgressionsQueryVariables>;
export const UserWalletDocument = gql`
    query UserWallet($userId: ID) {
  wallet(userId: $userId) {
    wallet {
      userId
      currencies {
        currencyId
        currencyAmount
      }
    }
  }
}
    `;

/**
 * __useUserWalletQuery__
 *
 * To run a query within a React component, call `useUserWalletQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserWalletQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserWalletQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserWalletQuery(baseOptions?: Apollo.QueryHookOptions<UserWalletQuery, UserWalletQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserWalletQuery, UserWalletQueryVariables>(UserWalletDocument, options);
      }
export function useUserWalletLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserWalletQuery, UserWalletQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserWalletQuery, UserWalletQueryVariables>(UserWalletDocument, options);
        }
export type UserWalletQueryHookResult = ReturnType<typeof useUserWalletQuery>;
export type UserWalletLazyQueryHookResult = ReturnType<typeof useUserWalletLazyQuery>;
export type UserWalletQueryResult = Apollo.QueryResult<UserWalletQuery, UserWalletQueryVariables>;
export const UserWalletAddCurrencyDocument = gql`
    mutation UserWalletAddCurrency($userId: ID, $currencies: [WalletWalletCurrencyInput!], $reason: ReasonReasonInput!) {
  addWalletCurrencies(userId: $userId, currencies: $currencies, reason: $reason) {
    emptyTypeWorkaround
  }
}
    `;
export type UserWalletAddCurrencyMutationFn = Apollo.MutationFunction<UserWalletAddCurrencyMutation, UserWalletAddCurrencyMutationVariables>;

/**
 * __useUserWalletAddCurrencyMutation__
 *
 * To run a mutation, you first call `useUserWalletAddCurrencyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserWalletAddCurrencyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userWalletAddCurrencyMutation, { data, loading, error }] = useUserWalletAddCurrencyMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      currencies: // value for 'currencies'
 *      reason: // value for 'reason'
 *   },
 * });
 */
export function useUserWalletAddCurrencyMutation(baseOptions?: Apollo.MutationHookOptions<UserWalletAddCurrencyMutation, UserWalletAddCurrencyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserWalletAddCurrencyMutation, UserWalletAddCurrencyMutationVariables>(UserWalletAddCurrencyDocument, options);
      }
export type UserWalletAddCurrencyMutationHookResult = ReturnType<typeof useUserWalletAddCurrencyMutation>;
export type UserWalletAddCurrencyMutationResult = Apollo.MutationResult<UserWalletAddCurrencyMutation>;
export type UserWalletAddCurrencyMutationOptions = Apollo.BaseMutationOptions<UserWalletAddCurrencyMutation, UserWalletAddCurrencyMutationVariables>;
export const UserWalletSubtractCurrencyDocument = gql`
    mutation UserWalletSubtractCurrency($userId: ID, $currencies: [WalletWalletCurrencyInput!], $reason: ReasonReasonInput!) {
  subtractWalletCurrencies(
    userId: $userId
    currencies: $currencies
    reason: $reason
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type UserWalletSubtractCurrencyMutationFn = Apollo.MutationFunction<UserWalletSubtractCurrencyMutation, UserWalletSubtractCurrencyMutationVariables>;

/**
 * __useUserWalletSubtractCurrencyMutation__
 *
 * To run a mutation, you first call `useUserWalletSubtractCurrencyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserWalletSubtractCurrencyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userWalletSubtractCurrencyMutation, { data, loading, error }] = useUserWalletSubtractCurrencyMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      currencies: // value for 'currencies'
 *      reason: // value for 'reason'
 *   },
 * });
 */
export function useUserWalletSubtractCurrencyMutation(baseOptions?: Apollo.MutationHookOptions<UserWalletSubtractCurrencyMutation, UserWalletSubtractCurrencyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserWalletSubtractCurrencyMutation, UserWalletSubtractCurrencyMutationVariables>(UserWalletSubtractCurrencyDocument, options);
      }
export type UserWalletSubtractCurrencyMutationHookResult = ReturnType<typeof useUserWalletSubtractCurrencyMutation>;
export type UserWalletSubtractCurrencyMutationResult = Apollo.MutationResult<UserWalletSubtractCurrencyMutation>;
export type UserWalletSubtractCurrencyMutationOptions = Apollo.BaseMutationOptions<UserWalletSubtractCurrencyMutation, UserWalletSubtractCurrencyMutationVariables>;
export const UserDrawerDocument = gql`
    query UserDrawer($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    lastSeen
    account {
      acceptedTerms {
        revision
        name
        signature
      }
      pendingAgreements {
        name
        revision
      }
    }
    ...ProfileImageProfile
    ...HiddenEmailTextFieldProfile
  }
}
    ${ProfileImageProfileFragmentDoc}
${HiddenEmailTextFieldProfileFragmentDoc}`;

/**
 * __useUserDrawerQuery__
 *
 * To run a query within a React component, call `useUserDrawerQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserDrawerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserDrawerQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserDrawerQuery(baseOptions: Apollo.QueryHookOptions<UserDrawerQuery, UserDrawerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserDrawerQuery, UserDrawerQueryVariables>(UserDrawerDocument, options);
      }
export function useUserDrawerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserDrawerQuery, UserDrawerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserDrawerQuery, UserDrawerQueryVariables>(UserDrawerDocument, options);
        }
export type UserDrawerQueryHookResult = ReturnType<typeof useUserDrawerQuery>;
export type UserDrawerLazyQueryHookResult = ReturnType<typeof useUserDrawerLazyQuery>;
export type UserDrawerQueryResult = Apollo.QueryResult<UserDrawerQuery, UserDrawerQueryVariables>;
export const UsersDocument = gql`
    query Users($cursor: APICursorInput) {
  profiles(cursor: $cursor) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    profiles {
      userId
      userTag
      lastSeen
      account {
        email
        roles
      }
    }
  }
}
    `;

/**
 * __useUsersQuery__
 *
 * To run a query within a React component, call `useUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsersQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useUsersQuery(baseOptions?: Apollo.QueryHookOptions<UsersQuery, UsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
      }
export function useUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export type UsersQueryHookResult = ReturnType<typeof useUsersQuery>;
export type UsersLazyQueryHookResult = ReturnType<typeof useUsersLazyQuery>;
export type UsersQueryResult = Apollo.QueryResult<UsersQuery, UsersQueryVariables>;
export const UpdateSuspensionAppealDocument = gql`
    mutation UpdateSuspensionAppeal($banId: ID!, $status: ModerationAppealStatus!) {
  updatePlatformBanAppeal(banId: $banId, status: $status) {
    emptyTypeWorkaround
  }
}
    `;
export type UpdateSuspensionAppealMutationFn = Apollo.MutationFunction<UpdateSuspensionAppealMutation, UpdateSuspensionAppealMutationVariables>;

/**
 * __useUpdateSuspensionAppealMutation__
 *
 * To run a mutation, you first call `useUpdateSuspensionAppealMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSuspensionAppealMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSuspensionAppealMutation, { data, loading, error }] = useUpdateSuspensionAppealMutation({
 *   variables: {
 *      banId: // value for 'banId'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useUpdateSuspensionAppealMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSuspensionAppealMutation, UpdateSuspensionAppealMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSuspensionAppealMutation, UpdateSuspensionAppealMutationVariables>(UpdateSuspensionAppealDocument, options);
      }
export type UpdateSuspensionAppealMutationHookResult = ReturnType<typeof useUpdateSuspensionAppealMutation>;
export type UpdateSuspensionAppealMutationResult = Apollo.MutationResult<UpdateSuspensionAppealMutation>;
export type UpdateSuspensionAppealMutationOptions = Apollo.BaseMutationOptions<UpdateSuspensionAppealMutation, UpdateSuspensionAppealMutationVariables>;
export const UserWalletPaymentsDocument = gql`
    query UserWalletPayments($userId: ID!, $cursor: APICursorInput) {
  successfulPayments(userId: $userId, cursor: $cursor) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    payments {
      ...UserWalletPayment
    }
  }
}
    ${UserWalletPaymentFragmentDoc}`;

/**
 * __useUserWalletPaymentsQuery__
 *
 * To run a query within a React component, call `useUserWalletPaymentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserWalletPaymentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserWalletPaymentsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useUserWalletPaymentsQuery(baseOptions: Apollo.QueryHookOptions<UserWalletPaymentsQuery, UserWalletPaymentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserWalletPaymentsQuery, UserWalletPaymentsQueryVariables>(UserWalletPaymentsDocument, options);
      }
export function useUserWalletPaymentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserWalletPaymentsQuery, UserWalletPaymentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserWalletPaymentsQuery, UserWalletPaymentsQueryVariables>(UserWalletPaymentsDocument, options);
        }
export type UserWalletPaymentsQueryHookResult = ReturnType<typeof useUserWalletPaymentsQuery>;
export type UserWalletPaymentsLazyQueryHookResult = ReturnType<typeof useUserWalletPaymentsLazyQuery>;
export type UserWalletPaymentsQueryResult = Apollo.QueryResult<UserWalletPaymentsQuery, UserWalletPaymentsQueryVariables>;
export const UserWallerTransactionsDocument = gql`
    query UserWallerTransactions($userId: ID!, $cursor: APICursorInput) {
  walletTransactions(
    userId: $userId
    cursor: $cursor
    filter: {reasons: [TRANSACTION_REASON_ADMINISTRATIVE, TRANSACTION_REASON_PROVISION, TRANSACTION_REASON_PURCHASE_WITH_PAYMENT, TRANSACTION_REASON_PURCHASE_WITH_IN_GAME_CURRENCY, TRANSACTION_REASON_STORE_ORDER_PAYMENT, TRANSACTION_REASON_CHANNEL_SUBSCRIPTION]}
  ) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    transactions {
      ...UserWalletTransaction
    }
  }
}
    ${UserWalletTransactionFragmentDoc}`;

/**
 * __useUserWallerTransactionsQuery__
 *
 * To run a query within a React component, call `useUserWallerTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserWallerTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserWallerTransactionsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useUserWallerTransactionsQuery(baseOptions: Apollo.QueryHookOptions<UserWallerTransactionsQuery, UserWallerTransactionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserWallerTransactionsQuery, UserWallerTransactionsQueryVariables>(UserWallerTransactionsDocument, options);
      }
export function useUserWallerTransactionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserWallerTransactionsQuery, UserWallerTransactionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserWallerTransactionsQuery, UserWallerTransactionsQueryVariables>(UserWallerTransactionsDocument, options);
        }
export type UserWallerTransactionsQueryHookResult = ReturnType<typeof useUserWallerTransactionsQuery>;
export type UserWallerTransactionsLazyQueryHookResult = ReturnType<typeof useUserWallerTransactionsLazyQuery>;
export type UserWallerTransactionsQueryResult = Apollo.QueryResult<UserWallerTransactionsQuery, UserWallerTransactionsQueryVariables>;
export const AddNewUserDocument = gql`
    mutation AddNewUser($email: String!, $username: String!, $isBot: Boolean) {
  createAccount(email: $email, username: $username, isBot: $isBot) {
    uid
  }
}
    `;
export type AddNewUserMutationFn = Apollo.MutationFunction<AddNewUserMutation, AddNewUserMutationVariables>;

/**
 * __useAddNewUserMutation__
 *
 * To run a mutation, you first call `useAddNewUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddNewUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addNewUserMutation, { data, loading, error }] = useAddNewUserMutation({
 *   variables: {
 *      email: // value for 'email'
 *      username: // value for 'username'
 *      isBot: // value for 'isBot'
 *   },
 * });
 */
export function useAddNewUserMutation(baseOptions?: Apollo.MutationHookOptions<AddNewUserMutation, AddNewUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddNewUserMutation, AddNewUserMutationVariables>(AddNewUserDocument, options);
      }
export type AddNewUserMutationHookResult = ReturnType<typeof useAddNewUserMutation>;
export type AddNewUserMutationResult = Apollo.MutationResult<AddNewUserMutation>;
export type AddNewUserMutationOptions = Apollo.BaseMutationOptions<AddNewUserMutation, AddNewUserMutationVariables>;
export const IncreaseInventoryItemCountDocument = gql`
    mutation IncreaseInventoryItemCount($userId: ID!, $itemId: ID!, $itemCount: Int!, $reason: ReasonReasonInput!) {
  addUserEntitlements(
    userId: $userId
    entitlements: [{itemId: $itemId, itemCount: $itemCount}]
    reason: $reason
  ) {
    items {
      itemCount
      itemId
    }
  }
}
    `;
export type IncreaseInventoryItemCountMutationFn = Apollo.MutationFunction<IncreaseInventoryItemCountMutation, IncreaseInventoryItemCountMutationVariables>;

/**
 * __useIncreaseInventoryItemCountMutation__
 *
 * To run a mutation, you first call `useIncreaseInventoryItemCountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useIncreaseInventoryItemCountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [increaseInventoryItemCountMutation, { data, loading, error }] = useIncreaseInventoryItemCountMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      itemId: // value for 'itemId'
 *      itemCount: // value for 'itemCount'
 *      reason: // value for 'reason'
 *   },
 * });
 */
export function useIncreaseInventoryItemCountMutation(baseOptions?: Apollo.MutationHookOptions<IncreaseInventoryItemCountMutation, IncreaseInventoryItemCountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<IncreaseInventoryItemCountMutation, IncreaseInventoryItemCountMutationVariables>(IncreaseInventoryItemCountDocument, options);
      }
export type IncreaseInventoryItemCountMutationHookResult = ReturnType<typeof useIncreaseInventoryItemCountMutation>;
export type IncreaseInventoryItemCountMutationResult = Apollo.MutationResult<IncreaseInventoryItemCountMutation>;
export type IncreaseInventoryItemCountMutationOptions = Apollo.BaseMutationOptions<IncreaseInventoryItemCountMutation, IncreaseInventoryItemCountMutationVariables>;
export const DecreaseInventoryItemCountDocument = gql`
    mutation DecreaseInventoryItemCount($userId: ID!, $itemId: ID!, $itemCount: Int!, $reason: ReasonReasonInput!) {
  consumeUserItem(
    userId: $userId
    reason: $reason
    consumptions: [{itemId: $itemId, itemCount: $itemCount}]
  ) {
    items {
      itemCount
      itemId
    }
  }
}
    `;
export type DecreaseInventoryItemCountMutationFn = Apollo.MutationFunction<DecreaseInventoryItemCountMutation, DecreaseInventoryItemCountMutationVariables>;

/**
 * __useDecreaseInventoryItemCountMutation__
 *
 * To run a mutation, you first call `useDecreaseInventoryItemCountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDecreaseInventoryItemCountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [decreaseInventoryItemCountMutation, { data, loading, error }] = useDecreaseInventoryItemCountMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      itemId: // value for 'itemId'
 *      itemCount: // value for 'itemCount'
 *      reason: // value for 'reason'
 *   },
 * });
 */
export function useDecreaseInventoryItemCountMutation(baseOptions?: Apollo.MutationHookOptions<DecreaseInventoryItemCountMutation, DecreaseInventoryItemCountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DecreaseInventoryItemCountMutation, DecreaseInventoryItemCountMutationVariables>(DecreaseInventoryItemCountDocument, options);
      }
export type DecreaseInventoryItemCountMutationHookResult = ReturnType<typeof useDecreaseInventoryItemCountMutation>;
export type DecreaseInventoryItemCountMutationResult = Apollo.MutationResult<DecreaseInventoryItemCountMutation>;
export type DecreaseInventoryItemCountMutationOptions = Apollo.BaseMutationOptions<DecreaseInventoryItemCountMutation, DecreaseInventoryItemCountMutationVariables>;
export const InventoryAvatarPartsDocument = gql`
    query InventoryAvatarParts($userId: ID!, $cursor: APICursorInput) {
  items(filters: [{itemType: TYPE_AVATAR_ITEM}], cursor: $cursor) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    items {
      id
      name
      inventoryItem(user_id: $userId) {
        ...InventoryItemToggleInventoryItem
      }
      ...InventoryItemToggleItem
    }
  }
}
    ${InventoryItemToggleInventoryItemFragmentDoc}
${InventoryItemToggleItemFragmentDoc}`;

/**
 * __useInventoryAvatarPartsQuery__
 *
 * To run a query within a React component, call `useInventoryAvatarPartsQuery` and pass it any options that fit your needs.
 * When your component renders, `useInventoryAvatarPartsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInventoryAvatarPartsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useInventoryAvatarPartsQuery(baseOptions: Apollo.QueryHookOptions<InventoryAvatarPartsQuery, InventoryAvatarPartsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InventoryAvatarPartsQuery, InventoryAvatarPartsQueryVariables>(InventoryAvatarPartsDocument, options);
      }
export function useInventoryAvatarPartsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InventoryAvatarPartsQuery, InventoryAvatarPartsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InventoryAvatarPartsQuery, InventoryAvatarPartsQueryVariables>(InventoryAvatarPartsDocument, options);
        }
export type InventoryAvatarPartsQueryHookResult = ReturnType<typeof useInventoryAvatarPartsQuery>;
export type InventoryAvatarPartsLazyQueryHookResult = ReturnType<typeof useInventoryAvatarPartsLazyQuery>;
export type InventoryAvatarPartsQueryResult = Apollo.QueryResult<InventoryAvatarPartsQuery, InventoryAvatarPartsQueryVariables>;
export const InventoryCardsDocument = gql`
    query InventoryCards($userId: ID!, $filters: [ItemListItemsRequestFilterInput!], $cursor: APICursorInput) {
  items(filters: $filters, cursor: $cursor) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    items {
      id
      name
      type
      game {
        id
        name
      }
      season {
        id
        name
      }
      name
      details {
        ... on GameLogicCard {
          id
          name
          leveling {
            currentLevel
          }
        }
        ... on GameLogicStreamerCard {
          baseCard {
            id
            name
            leveling {
              currentLevel
            }
          }
        }
      }
      inventoryItem(user_id: $userId) {
        ...InventoryCardsEditPopoverInventoryItem
      }
      ...InventoryCardsEditPopoverItem
    }
  }
}
    ${InventoryCardsEditPopoverInventoryItemFragmentDoc}
${InventoryCardsEditPopoverItemFragmentDoc}`;

/**
 * __useInventoryCardsQuery__
 *
 * To run a query within a React component, call `useInventoryCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useInventoryCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInventoryCardsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      filters: // value for 'filters'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useInventoryCardsQuery(baseOptions: Apollo.QueryHookOptions<InventoryCardsQuery, InventoryCardsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InventoryCardsQuery, InventoryCardsQueryVariables>(InventoryCardsDocument, options);
      }
export function useInventoryCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InventoryCardsQuery, InventoryCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InventoryCardsQuery, InventoryCardsQueryVariables>(InventoryCardsDocument, options);
        }
export type InventoryCardsQueryHookResult = ReturnType<typeof useInventoryCardsQuery>;
export type InventoryCardsLazyQueryHookResult = ReturnType<typeof useInventoryCardsLazyQuery>;
export type InventoryCardsQueryResult = Apollo.QueryResult<InventoryCardsQuery, InventoryCardsQueryVariables>;
export const CardFilterGamesDocument = gql`
    query CardFilterGames {
  listGames {
    games {
      id
      name
    }
  }
}
    `;

/**
 * __useCardFilterGamesQuery__
 *
 * To run a query within a React component, call `useCardFilterGamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardFilterGamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardFilterGamesQuery({
 *   variables: {
 *   },
 * });
 */
export function useCardFilterGamesQuery(baseOptions?: Apollo.QueryHookOptions<CardFilterGamesQuery, CardFilterGamesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardFilterGamesQuery, CardFilterGamesQueryVariables>(CardFilterGamesDocument, options);
      }
export function useCardFilterGamesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardFilterGamesQuery, CardFilterGamesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardFilterGamesQuery, CardFilterGamesQueryVariables>(CardFilterGamesDocument, options);
        }
export type CardFilterGamesQueryHookResult = ReturnType<typeof useCardFilterGamesQuery>;
export type CardFilterGamesLazyQueryHookResult = ReturnType<typeof useCardFilterGamesLazyQuery>;
export type CardFilterGamesQueryResult = Apollo.QueryResult<CardFilterGamesQuery, CardFilterGamesQueryVariables>;
export const CardFilterGameSeasonsDocument = gql`
    query CardFilterGameSeasons($gameId: ID!) {
  listSeasons(gameId: $gameId) {
    seasons {
      id
      name
    }
  }
}
    `;

/**
 * __useCardFilterGameSeasonsQuery__
 *
 * To run a query within a React component, call `useCardFilterGameSeasonsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCardFilterGameSeasonsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCardFilterGameSeasonsQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useCardFilterGameSeasonsQuery(baseOptions: Apollo.QueryHookOptions<CardFilterGameSeasonsQuery, CardFilterGameSeasonsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CardFilterGameSeasonsQuery, CardFilterGameSeasonsQueryVariables>(CardFilterGameSeasonsDocument, options);
      }
export function useCardFilterGameSeasonsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CardFilterGameSeasonsQuery, CardFilterGameSeasonsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CardFilterGameSeasonsQuery, CardFilterGameSeasonsQueryVariables>(CardFilterGameSeasonsDocument, options);
        }
export type CardFilterGameSeasonsQueryHookResult = ReturnType<typeof useCardFilterGameSeasonsQuery>;
export type CardFilterGameSeasonsLazyQueryHookResult = ReturnType<typeof useCardFilterGameSeasonsLazyQuery>;
export type CardFilterGameSeasonsQueryResult = Apollo.QueryResult<CardFilterGameSeasonsQuery, CardFilterGameSeasonsQueryVariables>;
export const InventoryEmojisDocument = gql`
    query InventoryEmojis($userId: ID!, $cursor: APICursorInput) {
  items(filters: [{itemType: TYPE_EMOJI}], cursor: $cursor) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    items {
      id
      name
      inventoryItem(user_id: $userId) {
        ...InventoryItemToggleInventoryItem
      }
      ...InventoryItemToggleItem
    }
  }
}
    ${InventoryItemToggleInventoryItemFragmentDoc}
${InventoryItemToggleItemFragmentDoc}`;

/**
 * __useInventoryEmojisQuery__
 *
 * To run a query within a React component, call `useInventoryEmojisQuery` and pass it any options that fit your needs.
 * When your component renders, `useInventoryEmojisQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInventoryEmojisQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useInventoryEmojisQuery(baseOptions: Apollo.QueryHookOptions<InventoryEmojisQuery, InventoryEmojisQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InventoryEmojisQuery, InventoryEmojisQueryVariables>(InventoryEmojisDocument, options);
      }
export function useInventoryEmojisLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InventoryEmojisQuery, InventoryEmojisQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InventoryEmojisQuery, InventoryEmojisQueryVariables>(InventoryEmojisDocument, options);
        }
export type InventoryEmojisQueryHookResult = ReturnType<typeof useInventoryEmojisQuery>;
export type InventoryEmojisLazyQueryHookResult = ReturnType<typeof useInventoryEmojisLazyQuery>;
export type InventoryEmojisQueryResult = Apollo.QueryResult<InventoryEmojisQuery, InventoryEmojisQueryVariables>;
export const InventoryEmotesDocument = gql`
    query InventoryEmotes($userId: ID!, $cursor: APICursorInput) {
  items(filters: [{itemType: TYPE_EMOTE}], cursor: $cursor) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    items {
      id
      name
      inventoryItem(user_id: $userId) {
        ...InventoryItemToggleInventoryItem
      }
      ...InventoryItemToggleItem
    }
  }
}
    ${InventoryItemToggleInventoryItemFragmentDoc}
${InventoryItemToggleItemFragmentDoc}`;

/**
 * __useInventoryEmotesQuery__
 *
 * To run a query within a React component, call `useInventoryEmotesQuery` and pass it any options that fit your needs.
 * When your component renders, `useInventoryEmotesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInventoryEmotesQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useInventoryEmotesQuery(baseOptions: Apollo.QueryHookOptions<InventoryEmotesQuery, InventoryEmotesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InventoryEmotesQuery, InventoryEmotesQueryVariables>(InventoryEmotesDocument, options);
      }
export function useInventoryEmotesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InventoryEmotesQuery, InventoryEmotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InventoryEmotesQuery, InventoryEmotesQueryVariables>(InventoryEmotesDocument, options);
        }
export type InventoryEmotesQueryHookResult = ReturnType<typeof useInventoryEmotesQuery>;
export type InventoryEmotesLazyQueryHookResult = ReturnType<typeof useInventoryEmotesLazyQuery>;
export type InventoryEmotesQueryResult = Apollo.QueryResult<InventoryEmotesQuery, InventoryEmotesQueryVariables>;
export const UserModerationDocument = gql`
    query UserModeration($userId: ID!) {
  platformBan(userId: $userId) {
    banId
    violation
    description
    bannedAt
    ...SuspensionStatusPlatformSuspension
    ...PlatformSuspensionAppealFormSuspension
  }
  profile(userId: $userId) {
    userId
    ...PlatformSuspensionModerationModalProfile
    ...PlatformSuspensionAppealFormProfile
    ...UsernameRejectionProfile
    moderationEvents: usernameHistory {
      ...ModerationEventsProfileUsernameChange
    }
  }
  userChannelBans(userId: $userId, cursor: {first: 5}) {
    bans {
      userId
      channelId
      ...ModerationChannelBan
    }
  }
}
    ${SuspensionStatusPlatformSuspensionFragmentDoc}
${PlatformSuspensionAppealFormSuspensionFragmentDoc}
${PlatformSuspensionModerationModalProfileFragmentDoc}
${PlatformSuspensionAppealFormProfileFragmentDoc}
${UsernameRejectionProfileFragmentDoc}
${ModerationEventsProfileUsernameChangeFragmentDoc}
${ModerationChannelBanFragmentDoc}`;

/**
 * __useUserModerationQuery__
 *
 * To run a query within a React component, call `useUserModerationQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserModerationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserModerationQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserModerationQuery(baseOptions: Apollo.QueryHookOptions<UserModerationQuery, UserModerationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserModerationQuery, UserModerationQueryVariables>(UserModerationDocument, options);
      }
export function useUserModerationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserModerationQuery, UserModerationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserModerationQuery, UserModerationQueryVariables>(UserModerationDocument, options);
        }
export type UserModerationQueryHookResult = ReturnType<typeof useUserModerationQuery>;
export type UserModerationLazyQueryHookResult = ReturnType<typeof useUserModerationLazyQuery>;
export type UserModerationQueryResult = Apollo.QueryResult<UserModerationQuery, UserModerationQueryVariables>;
export const ModerationUnsuspendPlatformUserDocument = gql`
    mutation ModerationUnsuspendPlatformUser($userId: ID!) {
  unbanPlatformUser(userId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type ModerationUnsuspendPlatformUserMutationFn = Apollo.MutationFunction<ModerationUnsuspendPlatformUserMutation, ModerationUnsuspendPlatformUserMutationVariables>;

/**
 * __useModerationUnsuspendPlatformUserMutation__
 *
 * To run a mutation, you first call `useModerationUnsuspendPlatformUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useModerationUnsuspendPlatformUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [moderationUnsuspendPlatformUserMutation, { data, loading, error }] = useModerationUnsuspendPlatformUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useModerationUnsuspendPlatformUserMutation(baseOptions?: Apollo.MutationHookOptions<ModerationUnsuspendPlatformUserMutation, ModerationUnsuspendPlatformUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ModerationUnsuspendPlatformUserMutation, ModerationUnsuspendPlatformUserMutationVariables>(ModerationUnsuspendPlatformUserDocument, options);
      }
export type ModerationUnsuspendPlatformUserMutationHookResult = ReturnType<typeof useModerationUnsuspendPlatformUserMutation>;
export type ModerationUnsuspendPlatformUserMutationResult = Apollo.MutationResult<ModerationUnsuspendPlatformUserMutation>;
export type ModerationUnsuspendPlatformUserMutationOptions = Apollo.BaseMutationOptions<ModerationUnsuspendPlatformUserMutation, ModerationUnsuspendPlatformUserMutationVariables>;
export const UnsuspendPlatformUserDocument = gql`
    mutation UnsuspendPlatformUser($userId: ID!) {
  unbanPlatformUser(userId: $userId) {
    emptyTypeWorkaround
  }
}
    `;
export type UnsuspendPlatformUserMutationFn = Apollo.MutationFunction<UnsuspendPlatformUserMutation, UnsuspendPlatformUserMutationVariables>;

/**
 * __useUnsuspendPlatformUserMutation__
 *
 * To run a mutation, you first call `useUnsuspendPlatformUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnsuspendPlatformUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unsuspendPlatformUserMutation, { data, loading, error }] = useUnsuspendPlatformUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUnsuspendPlatformUserMutation(baseOptions?: Apollo.MutationHookOptions<UnsuspendPlatformUserMutation, UnsuspendPlatformUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnsuspendPlatformUserMutation, UnsuspendPlatformUserMutationVariables>(UnsuspendPlatformUserDocument, options);
      }
export type UnsuspendPlatformUserMutationHookResult = ReturnType<typeof useUnsuspendPlatformUserMutation>;
export type UnsuspendPlatformUserMutationResult = Apollo.MutationResult<UnsuspendPlatformUserMutation>;
export type UnsuspendPlatformUserMutationOptions = Apollo.BaseMutationOptions<UnsuspendPlatformUserMutation, UnsuspendPlatformUserMutationVariables>;
export const SuspendPlatformUserDocument = gql`
    mutation SuspendPlatformUser($userId: ID!, $violation: ModerationViolation!, $description: String!, $duration: Duration) {
  banPlatformUser(
    userId: $userId
    violation: $violation
    description: $description
    duration: $duration
  ) {
    emptyTypeWorkaround
  }
}
    `;
export type SuspendPlatformUserMutationFn = Apollo.MutationFunction<SuspendPlatformUserMutation, SuspendPlatformUserMutationVariables>;

/**
 * __useSuspendPlatformUserMutation__
 *
 * To run a mutation, you first call `useSuspendPlatformUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSuspendPlatformUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [suspendPlatformUserMutation, { data, loading, error }] = useSuspendPlatformUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      violation: // value for 'violation'
 *      description: // value for 'description'
 *      duration: // value for 'duration'
 *   },
 * });
 */
export function useSuspendPlatformUserMutation(baseOptions?: Apollo.MutationHookOptions<SuspendPlatformUserMutation, SuspendPlatformUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SuspendPlatformUserMutation, SuspendPlatformUserMutationVariables>(SuspendPlatformUserDocument, options);
      }
export type SuspendPlatformUserMutationHookResult = ReturnType<typeof useSuspendPlatformUserMutation>;
export type SuspendPlatformUserMutationResult = Apollo.MutationResult<SuspendPlatformUserMutation>;
export type SuspendPlatformUserMutationOptions = Apollo.BaseMutationOptions<SuspendPlatformUserMutation, SuspendPlatformUserMutationVariables>;
export const RejectUsernameDocument = gql`
    mutation RejectUsername($userId: ID!, $reason: ModerationViolation!) {
  rejectUsername(userId: $userId, reason: $reason) {
    emptyTypeWorkaround
  }
}
    `;
export type RejectUsernameMutationFn = Apollo.MutationFunction<RejectUsernameMutation, RejectUsernameMutationVariables>;

/**
 * __useRejectUsernameMutation__
 *
 * To run a mutation, you first call `useRejectUsernameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRejectUsernameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [rejectUsernameMutation, { data, loading, error }] = useRejectUsernameMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      reason: // value for 'reason'
 *   },
 * });
 */
export function useRejectUsernameMutation(baseOptions?: Apollo.MutationHookOptions<RejectUsernameMutation, RejectUsernameMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RejectUsernameMutation, RejectUsernameMutationVariables>(RejectUsernameDocument, options);
      }
export type RejectUsernameMutationHookResult = ReturnType<typeof useRejectUsernameMutation>;
export type RejectUsernameMutationResult = Apollo.MutationResult<RejectUsernameMutation>;
export type RejectUsernameMutationOptions = Apollo.BaseMutationOptions<RejectUsernameMutation, RejectUsernameMutationVariables>;
export const UsernameRejectionUpdateDocument = gql`
    query UsernameRejectionUpdate($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    usernameHistory {
      newUsername
      oldUsername
      reason
    }
  }
}
    `;

/**
 * __useUsernameRejectionUpdateQuery__
 *
 * To run a query within a React component, call `useUsernameRejectionUpdateQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsernameRejectionUpdateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsernameRejectionUpdateQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUsernameRejectionUpdateQuery(baseOptions: Apollo.QueryHookOptions<UsernameRejectionUpdateQuery, UsernameRejectionUpdateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsernameRejectionUpdateQuery, UsernameRejectionUpdateQueryVariables>(UsernameRejectionUpdateDocument, options);
      }
export function useUsernameRejectionUpdateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsernameRejectionUpdateQuery, UsernameRejectionUpdateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsernameRejectionUpdateQuery, UsernameRejectionUpdateQueryVariables>(UsernameRejectionUpdateDocument, options);
        }
export type UsernameRejectionUpdateQueryHookResult = ReturnType<typeof useUsernameRejectionUpdateQuery>;
export type UsernameRejectionUpdateLazyQueryHookResult = ReturnType<typeof useUsernameRejectionUpdateLazyQuery>;
export type UsernameRejectionUpdateQueryResult = Apollo.QueryResult<UsernameRejectionUpdateQuery, UsernameRejectionUpdateQueryVariables>;
export const UserChannelBansDocument = gql`
    query UserChannelBans($userId: ID!, $cursor: APICursorInput) {
  userChannelBans(userId: $userId, cursor: $cursor) {
    bans {
      userId
      channelId
      channel {
        id
        name
      }
      bannedAt
      violation
      description
      moderator {
        userId
        userTag
      }
    }
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
  }
}
    `;

/**
 * __useUserChannelBansQuery__
 *
 * To run a query within a React component, call `useUserChannelBansQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserChannelBansQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserChannelBansQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useUserChannelBansQuery(baseOptions: Apollo.QueryHookOptions<UserChannelBansQuery, UserChannelBansQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserChannelBansQuery, UserChannelBansQueryVariables>(UserChannelBansDocument, options);
      }
export function useUserChannelBansLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserChannelBansQuery, UserChannelBansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserChannelBansQuery, UserChannelBansQueryVariables>(UserChannelBansDocument, options);
        }
export type UserChannelBansQueryHookResult = ReturnType<typeof useUserChannelBansQuery>;
export type UserChannelBansLazyQueryHookResult = ReturnType<typeof useUserChannelBansLazyQuery>;
export type UserChannelBansQueryResult = Apollo.QueryResult<UserChannelBansQuery, UserChannelBansQueryVariables>;
export const BreadcrumbsUserDocument = gql`
    query BreadcrumbsUser($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
  }
}
    `;

/**
 * __useBreadcrumbsUserQuery__
 *
 * To run a query within a React component, call `useBreadcrumbsUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useBreadcrumbsUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBreadcrumbsUserQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useBreadcrumbsUserQuery(baseOptions: Apollo.QueryHookOptions<BreadcrumbsUserQuery, BreadcrumbsUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BreadcrumbsUserQuery, BreadcrumbsUserQueryVariables>(BreadcrumbsUserDocument, options);
      }
export function useBreadcrumbsUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BreadcrumbsUserQuery, BreadcrumbsUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BreadcrumbsUserQuery, BreadcrumbsUserQueryVariables>(BreadcrumbsUserDocument, options);
        }
export type BreadcrumbsUserQueryHookResult = ReturnType<typeof useBreadcrumbsUserQuery>;
export type BreadcrumbsUserLazyQueryHookResult = ReturnType<typeof useBreadcrumbsUserLazyQuery>;
export type BreadcrumbsUserQueryResult = Apollo.QueryResult<BreadcrumbsUserQuery, BreadcrumbsUserQueryVariables>;
export const BreadcrumbsChannelDocument = gql`
    query BreadcrumbsChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    name
  }
}
    `;

/**
 * __useBreadcrumbsChannelQuery__
 *
 * To run a query within a React component, call `useBreadcrumbsChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useBreadcrumbsChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBreadcrumbsChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useBreadcrumbsChannelQuery(baseOptions: Apollo.QueryHookOptions<BreadcrumbsChannelQuery, BreadcrumbsChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BreadcrumbsChannelQuery, BreadcrumbsChannelQueryVariables>(BreadcrumbsChannelDocument, options);
      }
export function useBreadcrumbsChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BreadcrumbsChannelQuery, BreadcrumbsChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BreadcrumbsChannelQuery, BreadcrumbsChannelQueryVariables>(BreadcrumbsChannelDocument, options);
        }
export type BreadcrumbsChannelQueryHookResult = ReturnType<typeof useBreadcrumbsChannelQuery>;
export type BreadcrumbsChannelLazyQueryHookResult = ReturnType<typeof useBreadcrumbsChannelLazyQuery>;
export type BreadcrumbsChannelQueryResult = Apollo.QueryResult<BreadcrumbsChannelQuery, BreadcrumbsChannelQueryVariables>;
export const SearchBoxSearchDocument = gql`
    query SearchBoxSearch($query: String) {
  userSearch: search(
    query: $query
    entityTypes: [ENTITY_TYPE_USER]
    cursor: {first: 5}
  ) {
    resultItems {
      entityId
      ...SearchBoxProfileResultItem
    }
  }
  channelSearch: search(
    query: $query
    entityTypes: [ENTITY_TYPE_CHANNEL]
    cursor: {first: 5}
  ) {
    resultItems {
      entityId
      ...SearchBoxChannelResultItem
    }
  }
}
    ${SearchBoxProfileResultItemFragmentDoc}
${SearchBoxChannelResultItemFragmentDoc}`;

/**
 * __useSearchBoxSearchQuery__
 *
 * To run a query within a React component, call `useSearchBoxSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchBoxSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchBoxSearchQuery({
 *   variables: {
 *      query: // value for 'query'
 *   },
 * });
 */
export function useSearchBoxSearchQuery(baseOptions?: Apollo.QueryHookOptions<SearchBoxSearchQuery, SearchBoxSearchQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchBoxSearchQuery, SearchBoxSearchQueryVariables>(SearchBoxSearchDocument, options);
      }
export function useSearchBoxSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchBoxSearchQuery, SearchBoxSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchBoxSearchQuery, SearchBoxSearchQueryVariables>(SearchBoxSearchDocument, options);
        }
export type SearchBoxSearchQueryHookResult = ReturnType<typeof useSearchBoxSearchQuery>;
export type SearchBoxSearchLazyQueryHookResult = ReturnType<typeof useSearchBoxSearchLazyQuery>;
export type SearchBoxSearchQueryResult = Apollo.QueryResult<SearchBoxSearchQuery, SearchBoxSearchQueryVariables>;
export const NoAccessPermissionDocument = gql`
    query NoAccessPermission($userId: ID!) {
  profile(userId: $userId) {
    userId
    userTag
    account {
      uid
      roles
    }
  }
}
    `;

/**
 * __useNoAccessPermissionQuery__
 *
 * To run a query within a React component, call `useNoAccessPermissionQuery` and pass it any options that fit your needs.
 * When your component renders, `useNoAccessPermissionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNoAccessPermissionQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useNoAccessPermissionQuery(baseOptions: Apollo.QueryHookOptions<NoAccessPermissionQuery, NoAccessPermissionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NoAccessPermissionQuery, NoAccessPermissionQueryVariables>(NoAccessPermissionDocument, options);
      }
export function useNoAccessPermissionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NoAccessPermissionQuery, NoAccessPermissionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NoAccessPermissionQuery, NoAccessPermissionQueryVariables>(NoAccessPermissionDocument, options);
        }
export type NoAccessPermissionQueryHookResult = ReturnType<typeof useNoAccessPermissionQuery>;
export type NoAccessPermissionLazyQueryHookResult = ReturnType<typeof useNoAccessPermissionLazyQuery>;
export type NoAccessPermissionQueryResult = Apollo.QueryResult<NoAccessPermissionQuery, NoAccessPermissionQueryVariables>;
export const ReportUserDocument = gql`
    mutation ReportUser($reason: SupportReportReason!, $description: String, $context: SupportReportContextInput!) {
  createReport(reason: $reason, description: $description, context: $context) {
    createdAt
  }
}
    `;
export type ReportUserMutationFn = Apollo.MutationFunction<ReportUserMutation, ReportUserMutationVariables>;

/**
 * __useReportUserMutation__
 *
 * To run a mutation, you first call `useReportUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReportUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [reportUserMutation, { data, loading, error }] = useReportUserMutation({
 *   variables: {
 *      reason: // value for 'reason'
 *      description: // value for 'description'
 *      context: // value for 'context'
 *   },
 * });
 */
export function useReportUserMutation(baseOptions?: Apollo.MutationHookOptions<ReportUserMutation, ReportUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReportUserMutation, ReportUserMutationVariables>(ReportUserDocument, options);
      }
export type ReportUserMutationHookResult = ReturnType<typeof useReportUserMutation>;
export type ReportUserMutationResult = Apollo.MutationResult<ReportUserMutation>;
export type ReportUserMutationOptions = Apollo.BaseMutationOptions<ReportUserMutation, ReportUserMutationVariables>;
export const ReportedUserProfileDocument = gql`
    query ReportedUserProfile($userId: ID!) {
  profile(userId: $userId) {
    userId
    ...ReportedUserProfile
    ...ReasonSelectProfile
  }
}
    ${ReportedUserProfileFragmentDoc}
${ReasonSelectProfileFragmentDoc}`;

/**
 * __useReportedUserProfileQuery__
 *
 * To run a query within a React component, call `useReportedUserProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportedUserProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportedUserProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useReportedUserProfileQuery(baseOptions: Apollo.QueryHookOptions<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>(ReportedUserProfileDocument, options);
      }
export function useReportedUserProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>(ReportedUserProfileDocument, options);
        }
export type ReportedUserProfileQueryHookResult = ReturnType<typeof useReportedUserProfileQuery>;
export type ReportedUserProfileLazyQueryHookResult = ReturnType<typeof useReportedUserProfileLazyQuery>;
export type ReportedUserProfileQueryResult = Apollo.QueryResult<ReportedUserProfileQuery, ReportedUserProfileQueryVariables>;
export const ReportedChannelDocument = gql`
    query ReportedChannel($channelId: ID!) {
  channel(id: $channelId) {
    id
    ...ReasonSelectChannel
    ...ReportedChannel
  }
}
    ${ReasonSelectChannelFragmentDoc}
${ReportedChannelFragmentDoc}`;

/**
 * __useReportedChannelQuery__
 *
 * To run a query within a React component, call `useReportedChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportedChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportedChannelQuery({
 *   variables: {
 *      channelId: // value for 'channelId'
 *   },
 * });
 */
export function useReportedChannelQuery(baseOptions: Apollo.QueryHookOptions<ReportedChannelQuery, ReportedChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportedChannelQuery, ReportedChannelQueryVariables>(ReportedChannelDocument, options);
      }
export function useReportedChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportedChannelQuery, ReportedChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportedChannelQuery, ReportedChannelQueryVariables>(ReportedChannelDocument, options);
        }
export type ReportedChannelQueryHookResult = ReturnType<typeof useReportedChannelQuery>;
export type ReportedChannelLazyQueryHookResult = ReturnType<typeof useReportedChannelLazyQuery>;
export type ReportedChannelQueryResult = Apollo.QueryResult<ReportedChannelQuery, ReportedChannelQueryVariables>;
export const ReportStreamTimestampDocument = gql`
    query ReportStreamTimestamp($streamId: ID!) {
  stream(id: $streamId) {
    streamId
    segments {
      startTime
    }
  }
}
    `;

/**
 * __useReportStreamTimestampQuery__
 *
 * To run a query within a React component, call `useReportStreamTimestampQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportStreamTimestampQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportStreamTimestampQuery({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useReportStreamTimestampQuery(baseOptions: Apollo.QueryHookOptions<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>(ReportStreamTimestampDocument, options);
      }
export function useReportStreamTimestampLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>(ReportStreamTimestampDocument, options);
        }
export type ReportStreamTimestampQueryHookResult = ReturnType<typeof useReportStreamTimestampQuery>;
export type ReportStreamTimestampLazyQueryHookResult = ReturnType<typeof useReportStreamTimestampLazyQuery>;
export type ReportStreamTimestampQueryResult = Apollo.QueryResult<ReportStreamTimestampQuery, ReportStreamTimestampQueryVariables>;
export const SignupFlowChannelDocument = gql`
    query SignupFlowChannel($channelName: String!) {
  channelByName(name: $channelName) {
    id
    ...SignupFlowChannel
  }
}
    ${SignupFlowChannelFragmentDoc}`;

/**
 * __useSignupFlowChannelQuery__
 *
 * To run a query within a React component, call `useSignupFlowChannelQuery` and pass it any options that fit your needs.
 * When your component renders, `useSignupFlowChannelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSignupFlowChannelQuery({
 *   variables: {
 *      channelName: // value for 'channelName'
 *   },
 * });
 */
export function useSignupFlowChannelQuery(baseOptions: Apollo.QueryHookOptions<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>(SignupFlowChannelDocument, options);
      }
export function useSignupFlowChannelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>(SignupFlowChannelDocument, options);
        }
export type SignupFlowChannelQueryHookResult = ReturnType<typeof useSignupFlowChannelQuery>;
export type SignupFlowChannelLazyQueryHookResult = ReturnType<typeof useSignupFlowChannelLazyQuery>;
export type SignupFlowChannelQueryResult = Apollo.QueryResult<SignupFlowChannelQuery, SignupFlowChannelQueryVariables>;
export const ChannelAssetCreateTokenDocument = gql`
    mutation ChannelAssetCreateToken($channelId: ID, $assetType: ChannelAssetType) {
  createChannelAssetUploadToken(channelId: $channelId, assetType: $assetType) {
    token
  }
}
    `;
export type ChannelAssetCreateTokenMutationFn = Apollo.MutationFunction<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>;

/**
 * __useChannelAssetCreateTokenMutation__
 *
 * To run a mutation, you first call `useChannelAssetCreateTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChannelAssetCreateTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [channelAssetCreateTokenMutation, { data, loading, error }] = useChannelAssetCreateTokenMutation({
 *   variables: {
 *      channelId: // value for 'channelId'
 *      assetType: // value for 'assetType'
 *   },
 * });
 */
export function useChannelAssetCreateTokenMutation(baseOptions?: Apollo.MutationHookOptions<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>(ChannelAssetCreateTokenDocument, options);
      }
export type ChannelAssetCreateTokenMutationHookResult = ReturnType<typeof useChannelAssetCreateTokenMutation>;
export type ChannelAssetCreateTokenMutationResult = Apollo.MutationResult<ChannelAssetCreateTokenMutation>;
export type ChannelAssetCreateTokenMutationOptions = Apollo.BaseMutationOptions<ChannelAssetCreateTokenMutation, ChannelAssetCreateTokenMutationVariables>;
export const EmojiAssetCreateTokenDocument = gql`
    mutation EmojiAssetCreateToken($itemId: ID!) {
  createEmojiUploadToken(itemId: $itemId) {
    token
  }
}
    `;
export type EmojiAssetCreateTokenMutationFn = Apollo.MutationFunction<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>;

/**
 * __useEmojiAssetCreateTokenMutation__
 *
 * To run a mutation, you first call `useEmojiAssetCreateTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEmojiAssetCreateTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [emojiAssetCreateTokenMutation, { data, loading, error }] = useEmojiAssetCreateTokenMutation({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useEmojiAssetCreateTokenMutation(baseOptions?: Apollo.MutationHookOptions<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>(EmojiAssetCreateTokenDocument, options);
      }
export type EmojiAssetCreateTokenMutationHookResult = ReturnType<typeof useEmojiAssetCreateTokenMutation>;
export type EmojiAssetCreateTokenMutationResult = Apollo.MutationResult<EmojiAssetCreateTokenMutation>;
export type EmojiAssetCreateTokenMutationOptions = Apollo.BaseMutationOptions<EmojiAssetCreateTokenMutation, EmojiAssetCreateTokenMutationVariables>;
export const WalletDocument = gql`
    query Wallet($userId: ID!) {
  wallet(userId: $userId) {
    wallet {
      currencies {
        ...WalletCurrency
      }
    }
  }
}
    ${WalletCurrencyFragmentDoc}`;

/**
 * __useWalletQuery__
 *
 * To run a query within a React component, call `useWalletQuery` and pass it any options that fit your needs.
 * When your component renders, `useWalletQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useWalletQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useWalletQuery(baseOptions: Apollo.QueryHookOptions<WalletQuery, WalletQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<WalletQuery, WalletQueryVariables>(WalletDocument, options);
      }
export function useWalletLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<WalletQuery, WalletQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<WalletQuery, WalletQueryVariables>(WalletDocument, options);
        }
export type WalletQueryHookResult = ReturnType<typeof useWalletQuery>;
export type WalletLazyQueryHookResult = ReturnType<typeof useWalletLazyQuery>;
export type WalletQueryResult = Apollo.QueryResult<WalletQuery, WalletQueryVariables>;
export const StreamSpectatorCoordinationSubscribeDocument = gql`
    subscription StreamSpectatorCoordinationSubscribe($streamId: ID!) {
  streamSpectatorCoordinationEventsSubscribe(streamId: $streamId) {
    event {
      ... on MatchStreamSpectatorChangeGroupEvent {
        groupId
      }
    }
  }
}
    `;

/**
 * __useStreamSpectatorCoordinationSubscribeSubscription__
 *
 * To run a query within a React component, call `useStreamSpectatorCoordinationSubscribeSubscription` and pass it any options that fit your needs.
 * When your component renders, `useStreamSpectatorCoordinationSubscribeSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStreamSpectatorCoordinationSubscribeSubscription({
 *   variables: {
 *      streamId: // value for 'streamId'
 *   },
 * });
 */
export function useStreamSpectatorCoordinationSubscribeSubscription(baseOptions: Apollo.SubscriptionHookOptions<StreamSpectatorCoordinationSubscribeSubscription, StreamSpectatorCoordinationSubscribeSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<StreamSpectatorCoordinationSubscribeSubscription, StreamSpectatorCoordinationSubscribeSubscriptionVariables>(StreamSpectatorCoordinationSubscribeDocument, options);
      }
export type StreamSpectatorCoordinationSubscribeSubscriptionHookResult = ReturnType<typeof useStreamSpectatorCoordinationSubscribeSubscription>;
export type StreamSpectatorCoordinationSubscribeSubscriptionResult = Apollo.SubscriptionResult<StreamSpectatorCoordinationSubscribeSubscription>;
export const UpdateAvatarDocument = gql`
    mutation UpdateAvatar($avatarId: ID!) {
  updateProfileAvatar(modelId: $avatarId) {
    emptyTypeWorkaround
  }
}
    `;
export type UpdateAvatarMutationFn = Apollo.MutationFunction<UpdateAvatarMutation, UpdateAvatarMutationVariables>;

/**
 * __useUpdateAvatarMutation__
 *
 * To run a mutation, you first call `useUpdateAvatarMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAvatarMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAvatarMutation, { data, loading, error }] = useUpdateAvatarMutation({
 *   variables: {
 *      avatarId: // value for 'avatarId'
 *   },
 * });
 */
export function useUpdateAvatarMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAvatarMutation, UpdateAvatarMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAvatarMutation, UpdateAvatarMutationVariables>(UpdateAvatarDocument, options);
      }
export type UpdateAvatarMutationHookResult = ReturnType<typeof useUpdateAvatarMutation>;
export type UpdateAvatarMutationResult = Apollo.MutationResult<UpdateAvatarMutation>;
export type UpdateAvatarMutationOptions = Apollo.BaseMutationOptions<UpdateAvatarMutation, UpdateAvatarMutationVariables>;